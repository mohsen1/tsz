#!/bin/bash
#
# Pre-commit hook for tsz — workspace-aware
#
# Only tests crates affected by your changes. If you change files in
# crates/tsz-scanner, it tests tsz-scanner + all dependents (parser,
# binder, solver, checker, emitter, lsp) but NOT tsz-common.
#
# Steps:
#   0. Reset TypeScript submodule to pinned SHA
#   0b. Block TypeScript submodule changes
#   1. Detect changed crates
#   3. cargo fmt -- check & auto-fix
#   4. cargo clippy -- deny warnings (only affected crates)
#   5. Run unit tests (only affected crates)
#   6. Microbenchmark regression check (if solver/checker changed)
#   7. Conformance regression check (if solver/checker changed)
#
# Env vars:
#   TSZ_SKIP_HOOKS=1         Skip the entire hook
#   TSZ_SKIP_CONFORMANCE=1   Skip the conformance regression check
#   TSZ_SKIP_BENCH=1         Skip microbenchmark regression check
#   TSZ_SKIP_CLEAN=1         Skip the target cleanup step
#   TSZ_CLEAN_STALE_DAYS=7   Remove build artifacts older than N days
#   TSZ_BENCH_UPDATE_BASELINE=1  Refresh local microbenchmark baseline
#   TSZ_TEST_ALL=1           Force testing all crates

set -e

# Skip hook entirely if requested
if [ "${TSZ_SKIP_HOOKS:-}" = "1" ]; then exit 0; fi

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../" && pwd)"
cd "$ROOT_DIR"

SKIP_CONFORMANCE="${TSZ_SKIP_CONFORMANCE:-}"
SKIP_BENCH="${TSZ_SKIP_BENCH:-}"
SKIP_CLEAN="${TSZ_SKIP_CLEAN:-}"
CLEAN_STALE_DAYS="${TSZ_CLEAN_STALE_DAYS:-7}"

echo "Pre-commit checks..."

# ─── 0. Reset TypeScript submodule to pinned SHA ─────────────────────────────

"$ROOT_DIR/scripts/reset-ts-submodule.sh"

# ─── 0b. Block TypeScript submodule changes ──────────────────────────────────

SUBMODULE_CHANGES=$(git diff --cached --name-only | grep '^TypeScript/' || true)
if [ -n "$SUBMODULE_CHANGES" ]; then
    echo ""
    echo "ERROR: Attempting to commit changes to TypeScript submodule!"
    echo ""
    echo "The TypeScript/ directory is a READ-ONLY git submodule."
    echo "You must NOT modify, add, or commit any files in this directory."
    echo ""
    echo "Blocked files:"
    echo "$SUBMODULE_CHANGES" | head -20
    if [ "$(echo "$SUBMODULE_CHANGES" | wc -l)" -gt 20 ]; then
        echo "... and more"
    fi
    echo ""
    echo "To unstage these changes:"
    echo "  git reset HEAD TypeScript/"
    exit 1
fi

SUBMODULE_POINTER=$(git diff --cached --name-only | grep '^TypeScript$' || true)
if [ -n "$SUBMODULE_POINTER" ]; then
    echo ""
    echo "ERROR: Attempting to change TypeScript submodule pointer!"
    echo "To unstage: git reset HEAD TypeScript"
    exit 1
fi

# ─── Prerequisites ───────────────────────────────────────────────────────────

if ! command -v cargo >/dev/null 2>&1; then
    echo "ERROR: cargo not found"
    exit 1
fi

# Get changed files
CHANGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)
CHANGED_RS=$(echo "$CHANGED_FILES" | grep '\.rs$' || true)

# Nothing to do if no Rust files changed
if [ -z "$CHANGED_RS" ]; then
    echo "No Rust files changed, skipping checks."
    exit 0
fi

# ─── 1. Detect affected workspace crates ─────────────────────────────────────
#
# Dependency graph (linear pipeline):
#   common -> scanner -> parser -> binder -> solver -> checker -> emitter, lsp
#
# If crate X changed, all crates that depend on X (transitively) need retesting.
# Uses simple string variable as a set (bash 3.2 compatible, no associative arrays).

AFFECTED=""  # space-separated list of affected crate names

has_crate() { echo " $AFFECTED " | grep -q " $1 "; }
add_crate() {
    if has_crate "$1"; then
        : # already present
    else
        AFFECTED="$AFFECTED $1"
    fi
}

# Add a crate and all its transitive dependents
add_with_dependents() {
    case "$1" in
        tsz-common)
            add_crate tsz-common; add_crate tsz-scanner; add_crate tsz-parser
            add_crate tsz-binder; add_crate tsz-solver; add_crate tsz-checker
            add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-scanner)
            add_crate tsz-scanner; add_crate tsz-parser
            add_crate tsz-binder; add_crate tsz-solver; add_crate tsz-checker
            add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-parser)
            add_crate tsz-parser
            add_crate tsz-binder; add_crate tsz-solver; add_crate tsz-checker
            add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-binder)
            add_crate tsz-binder; add_crate tsz-solver; add_crate tsz-checker
            add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-solver)
            add_crate tsz-solver; add_crate tsz-checker
            add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-checker)
            add_crate tsz-checker; add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-emitter)
            add_crate tsz-emitter ;;
        tsz-lsp)
            add_crate tsz-lsp ;;
    esac
}

ROOT_CHANGED=false

for file in $CHANGED_RS; do
    case "$file" in
        crates/tsz-common/*)  add_with_dependents tsz-common ;;
        crates/tsz-scanner/*) add_with_dependents tsz-scanner ;;
        crates/tsz-parser/*)  add_with_dependents tsz-parser ;;
        crates/tsz-binder/*)  add_with_dependents tsz-binder ;;
        crates/tsz-solver/*)  add_with_dependents tsz-solver ;;
        crates/tsz-checker/*) add_with_dependents tsz-checker ;;
        crates/tsz-emitter/*) add_with_dependents tsz-emitter ;;
        crates/tsz-lsp/*)     add_with_dependents tsz-lsp ;;
        src/*)                 ROOT_CHANGED=true ;;
    esac
done

# Cargo.toml changes affect everything
CHANGED_TOML=$(echo "$CHANGED_FILES" | grep 'Cargo\.toml$' || true)
if [ -n "$CHANGED_TOML" ]; then
    ROOT_CHANGED=true
fi

# Root or force-all: test everything
if [ "$ROOT_CHANGED" = "true" ] || [ "${TSZ_TEST_ALL:-}" = "1" ]; then
    AFFECTED="tsz-common tsz-scanner tsz-parser tsz-binder tsz-solver tsz-checker tsz-emitter tsz-lsp"
fi

# Normalize: trim leading/trailing whitespace
AFFECTED=$(echo $AFFECTED | xargs)

if [ -z "$AFFECTED" ]; then
    echo "No workspace crates affected, skipping tests."
    exit 0
fi

NUM_AFFECTED=$(echo $AFFECTED | wc -w | xargs)
echo "  Affected crates: $AFFECTED ($NUM_AFFECTED/8)"

# Check if solver/checker changed (needed for bench/conformance)
SOLVER_OR_CHECKER_CHANGED=false
if has_crate tsz-solver || has_crate tsz-checker; then
    SOLVER_OR_CHECKER_CHANGED=true
fi

# ─── 2. Clean stale target artifacts ─────────────────────────────────────────

if [ "$SKIP_CLEAN" != "1" ]; then
    echo "1/6 Cleaning stale target artifacts..."
    TARGET_DIR="$ROOT_DIR/.target"

    # Always-safe removals that tend to accumulate quickly.
    if [ -d "$TARGET_DIR" ]; then
        [ -d "$TARGET_DIR/doc" ] && rm -rf "$TARGET_DIR/doc"
        [ -d "$TARGET_DIR/nextest" ] && rm -rf "$TARGET_DIR/nextest"
    fi

    # Keep recent caches for speed, prune only stale heavyweight artifacts.
    cleanup_stale_artifacts() {
        local base_dir="$1"
        local stale_days="$2"

        [ -d "$base_dir" ] || return 0

        # Remove stale profiles and cache dirs that can grow very large.
        find "$base_dir" -mindepth 1 -maxdepth 1 -type d \( \
            -name "debug" -o \
            -name "release" -o \
            -name "dist" -o \
            -name "dist-fast" -o \
            -name "dist-quick" -o \
            -name "tmp" -o \
            -name "incremental" -o \
            -name ".fingerprint" \
        \) -mtime +"$stale_days" -prune -exec rm -rf {} + 2>/dev/null || true

        # Remove stale nested incremental/fingerprint caches.
        find "$base_dir" -type d \( -name "incremental" -o -name ".fingerprint" \) \
            -mtime +"$stale_days" -prune -exec rm -rf {} + 2>/dev/null || true
    }

    cleanup_stale_artifacts "$ROOT_DIR/.target" "$CLEAN_STALE_DAYS"
    cleanup_stale_artifacts "$ROOT_DIR/.target-bench" "$CLEAN_STALE_DAYS"

    # Clean additional isolated build targets used by local scripts.
    find "$ROOT_DIR" -mindepth 1 -maxdepth 1 -type d -name ".target-*" \
        ! -name ".target" ! -name ".target-bench" \
        -mtime +"$CLEAN_STALE_DAYS" -prune -exec rm -rf {} + 2>/dev/null || true
else
    echo "1/6 Target cleanup skipped (TSZ_SKIP_CLEAN=1)"
fi

# ─── 3. cargo fmt ────────────────────────────────────────────────────────────

echo "2/6 Formatting (cargo fmt)..."

if ! cargo fmt -- --check >/dev/null 2>&1; then
    cargo fmt
    echo "  Formatted files — auto-fixed."
else
    echo "  Already formatted."
fi

# ─── 4. Clippy — deny all warnings (affected crates only) ────────────────────

echo "3/6 Clippy (affected crates)..."

# Build clippy args: -p crate1 -p crate2 ...
CLIPPY_PKGS=""
for crate in $AFFECTED; do
    CLIPPY_PKGS="$CLIPPY_PKGS -p $crate"
done

# Also include root crate if root files changed
if [ "$ROOT_CHANGED" = "true" ]; then
    CLIPPY_PKGS="$CLIPPY_PKGS -p tsz"
fi

# Try auto-fix first, then verify
if ! cargo clippy $CLIPPY_PKGS --lib --fix --allow-dirty --allow-staged -- -D warnings 2>/dev/null; then
    echo ""
    echo "ERROR: Clippy found warnings/errors that could not be auto-fixed:"
    echo ""
    cargo clippy $CLIPPY_PKGS --lib -- -D warnings 2>&1 | tail -50
    exit 1
fi

CLIPPY_OUTPUT=$(cargo clippy $CLIPPY_PKGS --lib -- -D warnings 2>&1) || {
    echo ""
    echo "ERROR: Clippy warnings remain after auto-fix. Please fix manually:"
    echo "$CLIPPY_OUTPUT" | tail -20
    exit 1
}
echo "  Clippy passed (zero warnings)"

# ─── 4.5. Architecture guardrail (checker boundary) ──────────────────────────
echo "3.5/6 Checker boundary guardrail..."
./scripts/check-checker-boundaries.sh

# ─── Re-stage files modified by fmt / clippy auto-fix ─────────────────────────

git add -u

# ─── 5. Tests — only affected crates ─────────────────────────────────────────

echo "4/6 Running tests ($NUM_AFFECTED crate(s))..."

# Build nextest filter expression: -E 'package(crate1) | package(crate2) ...'
NEXTEST_FILTER=""
for crate in $AFFECTED; do
    if [ -z "$NEXTEST_FILTER" ]; then
        NEXTEST_FILTER="package($crate)"
    else
        NEXTEST_FILTER="$NEXTEST_FILTER | package($crate)"
    fi
done

# Also test root crate if root changed
if [ "$ROOT_CHANGED" = "true" ]; then
    if [ -z "$NEXTEST_FILTER" ]; then
        NEXTEST_FILTER="package(tsz)"
    else
        NEXTEST_FILTER="$NEXTEST_FILTER | package(tsz)"
    fi
fi

# Only include root tsz crate if root files or solver/checker changed.
# Previously this was unconditional, forcing slow integration tests on every commit.
if [ "$ROOT_CHANGED" = "true" ] || [ "$SOLVER_OR_CHECKER_CHANGED" = "true" ]; then
    if ! echo "$NEXTEST_FILTER" | grep -q "package(tsz)"; then
        NEXTEST_FILTER="$NEXTEST_FILTER | package(tsz)"
    fi
fi

if cargo nextest --version >/dev/null 2>&1; then
    TEST_OUTPUT=$(cargo nextest run --profile precommit --no-tests=pass -E "$NEXTEST_FILTER" 2>&1) || {
        echo "$TEST_OUTPUT" | tail -20
        echo "ERROR: Tests failed. Run 'cargo nextest run' for details."
        exit 1
    }
    echo "$TEST_OUTPUT" | tail -5
else
    # Fallback to cargo test with package filters
    TEST_PKGS=""
    for crate in $AFFECTED; do
        TEST_PKGS="$TEST_PKGS -p $crate"
    done
    if [ "$ROOT_CHANGED" = "true" ]; then
        TEST_PKGS="$TEST_PKGS -p tsz"
    fi
    TEST_OUTPUT=$(cargo test $TEST_PKGS 2>&1) || {
        echo "$TEST_OUTPUT" | tail -20
        echo "ERROR: Tests failed."
        exit 1
    }
fi
echo "  Tests passed"

# ─── 6. Microbenchmark regression check ──────────────────────────────────────
# DISABLED: Microbenchmark checks are too noisy and cause false positives
# Uncomment to re-enable if needed

# if [ "$SKIP_BENCH" = "1" ]; then
#     echo "5/6 Microbenchmark check skipped (TSZ_SKIP_BENCH=1)"
# elif [ "$SOLVER_OR_CHECKER_CHANGED" = "false" ]; then
#     echo "5/6 Microbenchmark check skipped (solver/checker unchanged)"
# else
#     echo "5/6 Microbenchmark regression check..."
#     BENCH_CMD="$ROOT_DIR/scripts/precommit-microbench.sh"
#     BENCH_ARGS=""
#     if [ "${TSZ_BENCH_UPDATE_BASELINE:-}" = "1" ]; then
#         BENCH_ARGS="--update-baseline"
#     fi
#
#     BENCH_OUTPUT=$("$BENCH_CMD" $BENCH_ARGS 2>&1) || {
#         echo "$BENCH_OUTPUT" | tail -30
#         echo ""
#         echo "ERROR: Microbenchmark regression gate failed."
#         echo "  To bypass: TSZ_SKIP_BENCH=1 git commit ..."
#         echo "  To refresh baseline: TSZ_BENCH_UPDATE_BASELINE=1 git commit ..."
#         exit 1
#     }
#     echo "$BENCH_OUTPUT" | tail -12
#     echo "  Microbenchmark gate passed"
# fi

echo "5/6 Microbenchmark check disabled"

# ─── 7. Conformance regression check ─────────────────────────────────────────

if [ "$SKIP_CONFORMANCE" = "1" ]; then
    echo "6/6 Conformance check skipped (TSZ_SKIP_CONFORMANCE=1)"
elif [ "$SOLVER_OR_CHECKER_CHANGED" = "false" ]; then
    echo "6/6 Conformance check skipped (solver/checker unchanged)"
else
    echo "6/6 Conformance regression check..."

    LAST_CONFORMANCE=""
    if LAST_CONFORMANCE=$("$ROOT_DIR/scripts/get-last-conformance.sh" 2>/dev/null); then
        echo "  Last recorded: ${LAST_CONFORMANCE}%"
    else
        echo "  No previous conformance found — skipping regression check."
        SKIP_CONFORMANCE=1
    fi

    if [ "$SKIP_CONFORMANCE" != "1" ]; then
        TEMP_OUTPUT=$(mktemp)
        trap 'rm -f "$TEMP_OUTPUT"' EXIT

        echo "  Running conformance pass rate check..."
        # Use conformance.sh (the run.sh was replaced by Rust implementation)
        CONFORMANCE_SCRIPT="$ROOT_DIR/scripts/conformance.sh"
        if [ ! -x "$CONFORMANCE_SCRIPT" ]; then
            echo "  Conformance script not found — skipping."
            SKIP_CONFORMANCE=1
        fi

        if [ "$SKIP_CONFORMANCE" != "1" ]; then
            "$CONFORMANCE_SCRIPT" run > "$TEMP_OUTPUT" 2>&1 || true

            # Extract current pass rate from "FINAL RESULTS: N/M passed (XX.X%)"
            CURRENT_CONFORMANCE=$(grep -oE 'passed \([0-9]+\.[0-9]+%\)' "$TEMP_OUTPUT" | grep -oE '[0-9]+\.[0-9]+' | head -1)
            if [ -z "$CURRENT_CONFORMANCE" ]; then
                PASS_LINE=$(grep -E "FINAL RESULTS" "$TEMP_OUTPUT" | tail -1)
                CURRENT_CONFORMANCE=$(echo "$PASS_LINE" | grep -oE '[0-9]+\.[0-9]+' | head -1)
            fi
        fi

        if [ "$SKIP_CONFORMANCE" != "1" ] && [ -z "$CURRENT_CONFORMANCE" ]; then
            echo "  Warning: Could not extract pass rate from conformance output — skipping regression check."
        elif [ "$SKIP_CONFORMANCE" != "1" ]; then
            echo "  Current: ${CURRENT_CONFORMANCE}%"

            # Float comparison
            if command -v bc >/dev/null 2>&1; then
                IS_REGRESSION=$(echo "$CURRENT_CONFORMANCE < $LAST_CONFORMANCE" | bc -l)
            else
                CURRENT_INT=$(echo "$CURRENT_CONFORMANCE" | tr -d '.' | sed 's/^0*//')
                LAST_INT=$(echo "$LAST_CONFORMANCE" | tr -d '.' | sed 's/^0*//')
                [ -z "$CURRENT_INT" ] && CURRENT_INT=0
                [ -z "$LAST_INT" ] && LAST_INT=0
                if [ "$CURRENT_INT" -lt "$LAST_INT" ]; then
                    IS_REGRESSION=1
                else
                    IS_REGRESSION=0
                fi
            fi

            if [ "$IS_REGRESSION" = "1" ]; then
                echo ""
                echo "CONFORMANCE REGRESSION DETECTED!"
                echo ""
                echo "  Previous: ${LAST_CONFORMANCE}%"
                echo "  Current:  ${CURRENT_CONFORMANCE}%"
                echo "  Delta:    -$(echo "$LAST_CONFORMANCE - $CURRENT_CONFORMANCE" | bc -l 2>/dev/null || echo "?")%"
                echo ""
                echo "  Your changes caused a drop in conformance test pass rate."
                echo "  Please fix the regression before committing."
                echo ""
                echo "  To investigate:"
                echo "    ./scripts/conformance.sh analyze"
                echo ""
                echo "  To bypass (not recommended):"
                echo "    TSZ_SKIP_CONFORMANCE=1 git commit ..."
                echo ""
                exit 1
            fi

            echo "  Conformance: ${CURRENT_CONFORMANCE}% (no regression from ${LAST_CONFORMANCE}%)"
        fi

        # Store for prepare-commit-msg hook
        echo "$CURRENT_CONFORMANCE" > "$ROOT_DIR/.conformance-value"
    fi
fi

echo ""
echo "All pre-commit checks passed!"
