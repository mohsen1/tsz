#!/bin/bash
#
# Pre-commit hook for tsz — workspace-aware
#
# Only tests crates affected by your changes. If you change files in
# crates/tsz-scanner, it tests tsz-scanner + all dependents (parser,
# binder, solver, checker, lowering, emitter, lsp) but NOT tsz-common.
#
# Steps:
#   0. Reset TypeScript submodule to pinned SHA
#   0b. Block TypeScript submodule changes
#   1. Detect changed crates
#   3. cargo fmt -- check & auto-fix
#   4. cargo clippy -- deny warnings (affected crates + CI parity commands)
#   5. Run unit tests (only affected crates)
#   6. Microbenchmark regression check (if solver/checker changed)
#
# Env vars:
#   TSZ_SKIP_HOOKS=1         Skip the entire hook
#   TSZ_SKIP_BENCH=1         Skip microbenchmark regression check
#   TSZ_SKIP_CLEAN=1         Skip the target cleanup step
#   TSZ_SKIP_LINT_PARITY=1   Skip CI parity lint commands
#   TSZ_CLEAN_STALE_DAYS=7   Remove build artifacts older than N days
#   TSZ_BENCH_UPDATE_BASELINE=1  Refresh local microbenchmark baseline
#   TSZ_TEST_ALL=1           Force testing all crates

set -e

# Skip hook entirely if requested
if [ "${TSZ_SKIP_HOOKS:-}" = "1" ]; then exit 0; fi

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../" && pwd)"
cd "$ROOT_DIR"

SKIP_BENCH="${TSZ_SKIP_BENCH:-}"
SKIP_CLEAN="${TSZ_SKIP_CLEAN:-}"
SKIP_LINT_PARITY="${TSZ_SKIP_LINT_PARITY:-}"
CLEAN_STALE_DAYS="${TSZ_CLEAN_STALE_DAYS:-7}"

echo "Pre-commit checks..."

# ─── 0. Reset TypeScript submodule to pinned SHA ─────────────────────────────

"$ROOT_DIR/scripts/reset-ts-submodule.sh"

# ─── 0b. Block TypeScript submodule changes ──────────────────────────────────

SUBMODULE_CHANGES=$(git diff --cached --name-only | grep '^TypeScript/' || true)
if [ -n "$SUBMODULE_CHANGES" ]; then
    echo ""
    echo "ERROR: Attempting to commit changes to TypeScript submodule!"
    echo ""
    echo "The TypeScript/ directory is a READ-ONLY git submodule."
    echo "You must NOT modify, add, or commit any files in this directory."
    echo ""
    echo "Blocked files:"
    echo "$SUBMODULE_CHANGES" | head -20
    if [ "$(echo "$SUBMODULE_CHANGES" | wc -l)" -gt 20 ]; then
        echo "... and more"
    fi
    echo ""
    echo "To unstage these changes:"
    echo "  git reset HEAD TypeScript/"
    exit 1
fi

SUBMODULE_POINTER=$(git diff --cached --name-only | grep '^TypeScript$' || true)
if [ -n "$SUBMODULE_POINTER" ]; then
    echo ""
    echo "ERROR: Attempting to change TypeScript submodule pointer!"
    echo "To unstage: git reset HEAD TypeScript"
    exit 1
fi

# ─── Prerequisites ───────────────────────────────────────────────────────────

if ! command -v cargo >/dev/null 2>&1; then
    echo "ERROR: cargo not found"
    exit 1
fi

# Get changed files (include deletions/renames so removed Rust files still trigger checks)
CHANGED_FILES=$(git diff --cached --name-only --diff-filter=ACMRD)
CHANGED_RS=$(echo "$CHANGED_FILES" | grep '\.rs$' || true)

# Nothing to do if no Rust files changed
if [ -z "$CHANGED_RS" ]; then
    echo "No Rust files changed, skipping checks."
    exit 0
fi

# ─── 1. Detect affected workspace crates ─────────────────────────────────────
#
# Dependency graph (linear pipeline):
#   common -> scanner -> parser -> binder -> solver -> checker -> lowering -> emitter, lsp
#
# If crate X changed, all crates that depend on X (transitively) need retesting.
# Uses simple string variable as a set (bash 3.2 compatible, no associative arrays).

AFFECTED=""  # space-separated list of affected crate names

has_crate() { echo " $AFFECTED " | grep -q " $1 "; }
add_crate() {
    if has_crate "$1"; then
        : # already present
    else
        AFFECTED="$AFFECTED $1"
    fi
}

# Add a crate and all its transitive dependents
add_with_dependents() {
    case "$1" in
        tsz-common)
            add_crate tsz-common; add_crate tsz-scanner; add_crate tsz-parser
            add_crate tsz-binder; add_crate tsz-solver; add_crate tsz-checker; add_crate tsz-lowering
            add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-scanner)
            add_crate tsz-scanner; add_crate tsz-parser
            add_crate tsz-binder; add_crate tsz-solver; add_crate tsz-checker; add_crate tsz-lowering
            add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-parser)
            add_crate tsz-parser
            add_crate tsz-binder; add_crate tsz-solver; add_crate tsz-checker; add_crate tsz-lowering
            add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-binder)
            add_crate tsz-binder; add_crate tsz-solver; add_crate tsz-checker; add_crate tsz-lowering
            add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-solver)
            add_crate tsz-solver; add_crate tsz-checker; add_crate tsz-lowering
            add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-checker)
            add_crate tsz-checker; add_crate tsz-emitter; add_crate tsz-lsp ;;
        tsz-lowering)
            add_crate tsz-lowering ;;
        tsz-emitter)
            add_crate tsz-emitter ;;
        tsz-lsp)
            add_crate tsz-lsp ;;
    esac
}

ROOT_CHANGED=false

for file in $CHANGED_RS; do
    case "$file" in
        crates/tsz-common/*)  add_with_dependents tsz-common ;;
        crates/tsz-scanner/*) add_with_dependents tsz-scanner ;;
        crates/tsz-parser/*)  add_with_dependents tsz-parser ;;
        crates/tsz-binder/*)  add_with_dependents tsz-binder ;;
        crates/tsz-solver/*)  add_with_dependents tsz-solver ;;
        crates/tsz-checker/*) add_with_dependents tsz-checker ;;
        crates/tsz-lowering/*) add_with_dependents tsz-lowering ;;
        crates/tsz-emitter/*) add_with_dependents tsz-emitter ;;
        crates/tsz-lsp/*)     add_with_dependents tsz-lsp ;;
        src/*)                 ROOT_CHANGED=true ;;
    esac
done

# Cargo.toml changes affect everything
CHANGED_TOML=$(echo "$CHANGED_FILES" | grep 'Cargo\.toml$' || true)
if [ -n "$CHANGED_TOML" ]; then
    ROOT_CHANGED=true
fi

# Root or force-all: test everything
if [ "$ROOT_CHANGED" = "true" ] || [ "${TSZ_TEST_ALL:-}" = "1" ]; then
    AFFECTED="tsz-common tsz-scanner tsz-parser tsz-binder tsz-solver tsz-checker tsz-lowering tsz-emitter tsz-lsp"
fi

# Normalize: trim leading/trailing whitespace
AFFECTED=$(echo $AFFECTED | xargs)

if [ -z "$AFFECTED" ]; then
    echo "No workspace crates affected, skipping tests."
    exit 0
fi

NUM_AFFECTED=$(echo $AFFECTED | wc -w | xargs)
echo "  Affected crates: $AFFECTED ($NUM_AFFECTED/9)"

# Root tests cover integration behavior across the core pipeline crates.
ROOT_TEST_RELEVANT_CHANGED=false
if has_crate tsz-common || has_crate tsz-scanner || has_crate tsz-parser || has_crate tsz-binder || has_crate tsz-solver || has_crate tsz-checker || has_crate tsz-lowering || has_crate tsz-emitter; then
    ROOT_TEST_RELEVANT_CHANGED=true
fi


# ─── 2. Clean stale target artifacts ─────────────────────────────────────────

if [ "$SKIP_CLEAN" != "1" ]; then
    echo "1/5 Cleaning stale target artifacts..."
    TARGET_DIR="$ROOT_DIR/.target"

    # Always-safe removals that tend to accumulate quickly.
    if [ -d "$TARGET_DIR" ]; then
        [ -d "$TARGET_DIR/doc" ] && rm -rf "$TARGET_DIR/doc"
        [ -d "$TARGET_DIR/nextest" ] && rm -rf "$TARGET_DIR/nextest"
    fi

    # Keep recent caches for speed, prune only stale heavyweight artifacts.
    cleanup_stale_artifacts() {
        local base_dir="$1"
        local stale_days="$2"

        [ -d "$base_dir" ] || return 0

        # Remove stale profiles and cache dirs that can grow very large.
        find "$base_dir" -mindepth 1 -maxdepth 1 -type d \( \
            -name "debug" -o \
            -name "release" -o \
            -name "dist" -o \
            -name "dist-fast" -o \
            -name "dist-quick" -o \
            -name "tmp" -o \
            -name "incremental" -o \
            -name ".fingerprint" \
        \) -mtime +"$stale_days" -prune -exec rm -rf {} + 2>/dev/null || true

        # Remove stale nested incremental/fingerprint caches.
        find "$base_dir" -type d \( -name "incremental" -o -name ".fingerprint" \) \
            -mtime +"$stale_days" -prune -exec rm -rf {} + 2>/dev/null || true
    }

    cleanup_stale_artifacts "$ROOT_DIR/.target" "$CLEAN_STALE_DAYS"
    cleanup_stale_artifacts "$ROOT_DIR/.target-bench" "$CLEAN_STALE_DAYS"

    # Clean additional isolated build targets used by local scripts.
    find "$ROOT_DIR" -mindepth 1 -maxdepth 1 -type d -name ".target-*" \
        ! -name ".target" ! -name ".target-bench" \
        -mtime +"$CLEAN_STALE_DAYS" -prune -exec rm -rf {} + 2>/dev/null || true
else
    echo "1/5 Target cleanup skipped (TSZ_SKIP_CLEAN=1)"
fi

# ─── 3. cargo fmt ────────────────────────────────────────────────────────────

echo "2/5 Formatting (cargo fmt)..."

if ! cargo fmt -- --check >/dev/null 2>&1; then
    cargo fmt
    echo "  Formatted files — auto-fixed."
else
    echo "  Already formatted."
fi

# ─── 4. Clippy — deny all warnings (affected crates only) ────────────────────

echo "3/5 Clippy (affected crates)..."

# Build clippy args: -p crate1 -p crate2 ...
CLIPPY_PKGS=""
for crate in $AFFECTED; do
    CLIPPY_PKGS="$CLIPPY_PKGS -p $crate"
done

# Match CI: check all targets (lib + tests + benches), not just --lib.
# This catches lint errors that only appear in test code.
# Note: root crate (tsz) is checked separately with --lib only because its
# integration tests have many format-string warnings that are not actionable.
CLIPPY_TARGETS="--all-targets"

# Try auto-fix first, then verify
if ! cargo clippy $CLIPPY_PKGS $CLIPPY_TARGETS --fix --allow-dirty --allow-staged -- -D warnings 2>/dev/null; then
    echo ""
    echo "ERROR: Clippy found warnings/errors that could not be auto-fixed:"
    echo ""
    cargo clippy $CLIPPY_PKGS $CLIPPY_TARGETS -- -D warnings 2>&1 | tail -50
    exit 1
fi

CLIPPY_OUTPUT=$(cargo clippy $CLIPPY_PKGS $CLIPPY_TARGETS -- -D warnings 2>&1) || {
    echo ""
    echo "ERROR: Clippy warnings remain after auto-fix. Please fix manually:"
    echo "$CLIPPY_OUTPUT" | tail -20
    exit 1
}

# Also lint root crate lib if root files changed (--lib only to avoid test fixture noise)
if [ "$ROOT_CHANGED" = "true" ]; then
    ROOT_OUTPUT=$(cargo clippy -p tsz --lib -- -D warnings 2>&1) || {
        echo ""
        echo "ERROR: Clippy warnings in root crate. Please fix manually:"
        echo "$ROOT_OUTPUT" | tail -20
        exit 1
    }
fi

if [ "$SKIP_LINT_PARITY" = "1" ]; then
    echo "  CI lint parity checks skipped (TSZ_SKIP_LINT_PARITY=1)"
else
    # Match CI lint commands exactly to prevent local-vs-CI drift.
    CI_CLIPPY_PKGS="-p tsz-common -p tsz-scanner -p tsz-parser -p tsz-binder -p tsz-solver -p tsz-checker -p tsz-emitter -p tsz-lowering -p tsz-lsp"
    CI_CLIPPY_OUTPUT=$(cargo clippy $CI_CLIPPY_PKGS --all-targets -- -D warnings 2>&1) || {
        echo ""
        echo "ERROR: CI parity lint failed (workspace crates deny warnings):"
        echo "$CI_CLIPPY_OUTPUT" | tail -30
        exit 1
    }

    FULL_WS_CLIPPY_OUTPUT=$(cargo clippy --all-targets --all-features 2>&1) || {
        echo ""
        echo "ERROR: CI parity lint failed (full workspace):"
        echo "$FULL_WS_CLIPPY_OUTPUT" | tail -30
        exit 1
    }
fi
echo "  Clippy passed (zero warnings)"

# ─── 4.5. Architecture guardrail (checker boundary) ──────────────────────────
echo "3.5/5 Checker boundary guardrail..."
./scripts/check-checker-boundaries.sh

# ─── Re-stage files modified by fmt / clippy auto-fix ─────────────────────────

git add -u

# ─── 5. Tests — only affected crates ─────────────────────────────────────────

echo "4/5 Running tests ($NUM_AFFECTED crate(s))..."

# Build nextest filter expression: -E 'package(crate1) | package(crate2) ...'
NEXTEST_FILTER=""
for crate in $AFFECTED; do
    if [ -z "$NEXTEST_FILTER" ]; then
        NEXTEST_FILTER="package($crate)"
    else
        NEXTEST_FILTER="$NEXTEST_FILTER | package($crate)"
    fi
done

# Also test root crate if root changed
if [ "$ROOT_CHANGED" = "true" ]; then
    if [ -z "$NEXTEST_FILTER" ]; then
        NEXTEST_FILTER="package(tsz)"
    else
        NEXTEST_FILTER="$NEXTEST_FILTER | package(tsz)"
    fi
fi

# Only include root tsz crate if root files or core crates changed.
if [ "$ROOT_CHANGED" = "true" ] || [ "$ROOT_TEST_RELEVANT_CHANGED" = "true" ]; then
    if ! echo "$NEXTEST_FILTER" | grep -q "package(tsz)"; then
        NEXTEST_FILTER="$NEXTEST_FILTER | package(tsz)"
    fi
fi

if cargo nextest --version >/dev/null 2>&1; then
    TEST_OUTPUT=$(cargo nextest run --profile precommit --no-tests=pass -E "$NEXTEST_FILTER" 2>&1) || {
        echo "$TEST_OUTPUT" | tail -20
        echo "ERROR: Tests failed. Run 'cargo nextest run' for details."
        exit 1
    }
    echo "$TEST_OUTPUT" | tail -5
else
    # Fallback to cargo test with package filters
    TEST_PKGS=""
    for crate in $AFFECTED; do
        TEST_PKGS="$TEST_PKGS -p $crate"
    done
    if [ "$ROOT_CHANGED" = "true" ] || [ "$ROOT_TEST_RELEVANT_CHANGED" = "true" ]; then
        TEST_PKGS="$TEST_PKGS -p tsz"
    fi
    TEST_OUTPUT=$(cargo test $TEST_PKGS 2>&1) || {
        echo "$TEST_OUTPUT" | tail -20
        echo "ERROR: Tests failed."
        exit 1
    }
fi
echo "  Tests passed"

# ─── 6. Microbenchmark regression check ──────────────────────────────────────
# DISABLED: Microbenchmark checks are too noisy and cause false positives
# Uncomment to re-enable if needed

# if [ "$SKIP_BENCH" = "1" ]; then
#     echo "5/5 Microbenchmark check skipped (TSZ_SKIP_BENCH=1)"
# elif [ "$CONFORMANCE_RELEVANT_CHANGED" = "false" ]; then
#     echo "5/5 Microbenchmark check skipped (conformance-relevant crates unchanged)"
# else
#     echo "5/5 Microbenchmark regression check..."
#     BENCH_CMD="$ROOT_DIR/scripts/precommit-microbench.sh"
#     BENCH_ARGS=""
#     if [ "${TSZ_BENCH_UPDATE_BASELINE:-}" = "1" ]; then
#         BENCH_ARGS="--update-baseline"
#     fi
#
#     BENCH_OUTPUT=$("$BENCH_CMD" $BENCH_ARGS 2>&1) || {
#         echo "$BENCH_OUTPUT" | tail -30
#         echo ""
#         echo "ERROR: Microbenchmark regression gate failed."
#         echo "  To bypass: TSZ_SKIP_BENCH=1 git commit ..."
#         echo "  To refresh baseline: TSZ_BENCH_UPDATE_BASELINE=1 git commit ..."
#         exit 1
#     }
#     echo "$BENCH_OUTPUT" | tail -12
#     echo "  Microbenchmark gate passed"
# fi

echo "5/5 Microbenchmark check disabled"

echo ""
echo "All pre-commit checks passed!"

# NOTE: Conformance regression check was removed from pre-commit (too slow).
# Run manually when needed: ./scripts/conformance.sh run
