# TS2769 Fix Ready: DefId Collision Bug - Complete Analysis

**Date**: 2026-02-13
**Session Duration**: 6 hours
**Status**: âœ… **ROOT CAUSE IDENTIFIED - Fix Ready**
**Priority**: CRITICAL (affects 20-30+ conformance tests)

## Executive Summary

**CRITICAL BUG FOUND AND DIAGNOSED:**
Multiple `DefinitionStore` instances creating overlapping DefId sequences, causing ConcatArray to display as "Node" in error messages.

### Root Cause
Each `CheckerContext` creates its own `DefinitionStore::new()`, starting DefId allocation from 1. When lib contexts and main context are used together, they generate colliding DefIds.

**Evidence:**
```
TRACE: Mapping symbol to DefId, symbol_name=ThisParameterType, symbol_id=2417, def_id=14, kind=TypeAlias
TRACE: Mapping symbol to DefId, symbol_name=Node, symbol_id=392, def_id=14, kind=Interface
```

Two different symbols mapped to **same DefId(14)**!

## The Bug in Action

### Expected (TSC)
```
Argument of type 'string' is not assignable to parameter of type 'ConcatArray<number>'.
```

### Actual (tsz)
```
Argument of type 'string' is not assignable to parameter of type 'Node<number>'.
                                                                        ^^^^
```

When formatting `Application(base=Lazy(DefId(14)), args=[number])`:
- DefId(14) resolves to "Node" (from one DefinitionStore)
- Should resolve to "ConcatArray" (from another DefinitionStore)

## Investigation Timeline

### Phase 1: Symptom Identification (1.5h)
- Observed "Node<T>" instead of "ConcatArray<T>"
- Added tracing to format.rs and operations.rs
- Discovered DefId(14) = "Node" interface (0 type params)

### Phase 2: Type System Trace (2h)
- Traced rest parameter extraction (works correctly)
- Traced array element type extraction (works correctly)
- Found TypeId(287) = Lazy(DefId(14)) as Application base

### Phase 3: Symbol Resolution (1.5h)
- Added tracing to symbolâ†’DefId mapping
- Discovered **COLLISION**: Two symbols â†’ DefId(14)
- Identified multiple `DefinitionStore::new()` calls

### Phase 4: Root Cause Confirmation (1h)
- Located 4 places creating new DefinitionStores
- Confirmed atomic counter starts at 1 in each store
- Verified collision mechanism

**Total Time**: 6 hours from symptom to root cause

## Code Locations

### Problem: Multiple DefinitionStore Creation
```rust
// crates/tsz-checker/src/context.rs
Line 705:  definition_store: Rc::new(DefinitionStore::new()),  // CheckerContext::new()
Line 820:  definition_store: Rc::new(DefinitionStore::new()),  // CheckerContext::with_options()
Line 938:  definition_store: Rc::new(DefinitionStore::new()),  // (another constructor)
Line 1055: definition_store: Rc::new(DefinitionStore::new()),  // (another constructor)
```

### Allocator (Correct - Not the Bug)
```rust
// crates/tsz-solver/src/def.rs:373-376
fn allocate(&self) -> DefId {
    let id = self.next_id.fetch_add(1, Ordering::SeqCst);  // Atomic, correct
    DefId(id)
}
```

The allocator is correct. The bug is creating **multiple independent allocators**.

## The Fix

### Solution: Share Single DefinitionStore

All `CheckerContext` instances (main + lib contexts) must share the **same** `DefinitionStore` instance.

### Implementation Strategy

1. **Add new constructor parameter:**
```rust
pub fn new_with_def_store(
    arena: &'a NodeArena,
    binder: &'a BinderState,
    types: &'a dyn QueryDatabase,
    file_name: String,
    compiler_options: CheckerOptions,
    definition_store: Rc<DefinitionStore>,  // â† Shared store
) -> Self {
    // ... same body, but use passed definition_store
}
```

2. **Update existing `new()` to delegate:**
```rust
pub fn new(...) -> Self {
    Self::new_with_def_store(..., Rc::new(DefinitionStore::new()))
}
```

3. **Update all 4 constructors** (lines 705, 820, 938, 1055)

4. **Find where lib contexts are created** and pass shared store:
```rust
// Instead of each context creating its own:
let main_ctx = CheckerContext::new(...);
let lib_ctx1 = CheckerContext::new(...);  // â† Creates new store!

// Do this:
let shared_store = Rc::new(DefinitionStore::new());
let main_ctx = CheckerContext::new_with_def_store(..., shared_store.clone());
let lib_ctx1 = CheckerContext::new_with_def_store(..., shared_store.clone());
```

5. **Update call sites** (6 files):
   - `crates/tsz-checker/src/state.rs`
   - `crates/tsz-checker/src/declarations.rs`
   - `crates/tsz-checker/src/type_node.rs`
   - `crates/tsz-checker/src/iterators.rs`
   - `crates/tsz-checker/src/generators.rs`
   - `crates/tsz-checker/src/expr.rs`

### Verification

After fix:
```bash
# Should show ConcatArray, not Node:
.target/dist-fast/tsz tmp/check-concat-type.ts 2>&1

# Run tests:
cargo nextest run

# Check conformance improvement:
./scripts/conformance.sh run --max=300
# Expected: 90.3% â†’ 92-93% (20-30+ tests fixed)
```

## Impact

### Tests Affected (Sample)
- arrayConcat3.ts
- arrayFromAsync.ts
- arrayToLocaleStringES2015.ts
- arrayToLocaleStringES2020.ts
- 16+ more with array/concat operations

### Pass Rate Improvement
**Before**: 90.3% (270/299 in sample)
**After**: 92-93% estimated (290+/299)
**Tests fixed**: 20-30+ in full suite

## Commits

1. `eef1aa0f1` - Added tracing to format.rs and operations.rs
2. `d88348f53` - Comprehensive TS2769 analysis document
3. `51c3c6bdf` - **Identified DefId collision root cause**

## Files Modified (Tracing)

- `crates/tsz-solver/src/format.rs` - Application formatting tracing
- `crates/tsz-solver/src/operations.rs` - Rest parameter tracing
- `crates/tsz-checker/src/context.rs` - Symbolâ†’DefId mapping tracing
- `crates/tsz-solver/src/def.rs` - Import tracing

## Test Files Created

- `tmp/no-concat-name.ts` - Original reproduction
- `tmp/check-concat-type.ts` - Simplified reproduction
- `tmp/fresh-rest-test.ts` - Isolation test
- `tmp/union-rest-test.ts` - Union parameter test
- `tmp/function-union-rest.ts` - Generic function test

## Next Steps (2-3 hours)

### Step 1: Implement Fix (1h)
1. Create `new_with_def_store()` method
2. Update 4 constructor call sites
3. Find lib context creation code
4. Pass shared DefinitionStore

### Step 2: Update Call Sites (0.5h)
Update 6 files that call `CheckerContext::new()`

### Step 3: Verify (0.5h)
```bash
cargo nextest run
.target/dist-fast/tsz tmp/check-concat-type.ts
./scripts/conformance.sh run --max=300
```

### Step 4: Clean Up (0.5h)
- Remove tracing code (optional - can leave for future debugging)
- Update documentation
- Commit and sync

### Step 5: Conformance Check (0.5h)
Run full conformance and analyze improvements

## Key Learnings

1. **DefId collision was silent** - No warnings, just wrong type names
2. **Tracing was essential** - Without it, would still be guessing
3. **Atomic operations don't prevent logic bugs** - `fetch_add` is correct, but using multiple counters isn't
4. **Structural investigation > guessing** - Traced from symptom to root cause systematically

## Success Criteria

âœ… **Analysis Complete**
- Root cause identified with proof
- Fix strategy documented
- Impact quantified
- Next steps clear

ðŸ”„ **Implementation Pending**
- Straightforward refactoring
- Well-defined scope
- Clear verification steps

## Related Documents

- `docs/sessions/2026-02-13-COMPLETE-SESSION-SUMMARY.md` - Previous 11h session
- `docs/sessions/2026-02-13-TS2769-INVESTIGATION.md` - Initial 70% investigation
- `docs/sessions/2026-02-13-TS2769-BUG-ANALYSIS.md` - Detailed analysis

---

**Status**: âœ… **READY FOR IMPLEMENTATION**
**Confidence**: VERY HIGH (root cause proven with traces)
**Effort**: 2-3 hours to implement and verify
**Impact**: 20-30+ conformance tests
**Risk**: LOW (well-understood, localized change)

This is an **excellent stopping point** - root cause fully diagnosed, fix strategy clear, ready for fresh implementation session.
