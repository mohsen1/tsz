# TS2411 Implementation Session - February 12, 2026

## Summary

Successfully implemented TS2411 error checking for properties that are incompatible with inherited interface index signatures. This fixes a gap where derived interfaces extending base interfaces with index signatures were not having their properties validated against those signatures.

## Problem

TypeScript requires that when an interface extends a base interface with index signatures, all properties in the derived interface must be compatible with the inherited index signatures. For example:

```typescript
interface Base {
    [x: string]: { x: number }
}

interface Derived extends Base {
    foo: { y: number }  // Should error TS2411
}
```

Previously, tsz did not emit TS2411 for this case.

## Root Cause Analysis

Through debugging with tracing, we identified three interconnected issues:

1. **Wrong type returned for interface declarations**:
   - `get_type_of_node(interface_decl)` returned `TypeId::VOID` (5) instead of the interface type
   - Interface declarations are statements, not expressions, so they don't have a value type

2. **Property types resolving to ERROR**:
   - When getting property types, they resolved to `TypeId::ERROR` (1)
   - This happened because we were calling `get_type_of_interface` during checking, causing recursive type resolution issues

3. **Index signature inheritance working but not checked**:
   - The type merging code in `interface_type.rs` correctly preserved inherited index signatures
   - But we couldn't access them due to issues #1 and #2

## Solution

### 1. Use `get_type_of_symbol` for Interface Type

Instead of calling `get_type_of_interface(stmt_idx)`, we now:
1. Get the interface name from the declaration
2. Look up the symbol in `binder.file_locals`
3. Call `get_type_of_symbol(sym_id)` to get the cached type

This avoids recursive type computation and uses the already-computed type.

### 2. Resolve Property Types from Type Annotations

For interface properties, we now get types from the `type_annotation` node:

```rust
let (prop_name, name_idx, type_annotation_idx) = if member_node.kind == PROPERTY_SIGNATURE {
    let sig = self.ctx.arena.get_signature(member_node)?;
    (name, sig.name, sig.type_annotation)  // Extract type annotation
};

let prop_type = if !type_annotation_idx.is_none() {
    self.get_type_from_type_node(type_annotation_idx)  // Resolve from annotation
} else {
    self.get_type_of_node(member_idx)  // Fallback for methods
};
```

### 3. Check Both Number and String Index Signatures

Numeric properties must be checked against BOTH number and string index signatures (since JavaScript allows numeric access via strings):

```rust
let is_numeric_property = prop_name.parse::<f64>().is_ok();

// Check number index first for numeric properties
if let Some(ref number_idx) = index_info.number_index {
    if is_numeric_property && !is_assignable_to(prop_type, number_idx.value_type) {
        emit_error(...);
    }
}

// Check string index for ALL properties
if let Some(ref string_idx) = index_info.string_index {
    if !is_assignable_to(prop_type, string_idx.value_type) {
        emit_error(...);
    }
}
```

## Files Modified

- `crates/tsz-checker/src/state_checking_members.rs`:
  - Modified `check_interface_declaration` to use `get_type_of_symbol`
  - Updated `check_index_signature_compatibility` to resolve property types from annotations
  - Added proper handling for numeric properties vs string index signatures

- `crates/tsz-checker/src/interface_type.rs`:
  - Removed debug tracing (cleanup)

## Test Results

### Before
- TS2411 errors: 0 emitted for inherited index signatures
- Test file `derivedInterfaceIncompatibleWithBaseIndexer.ts`: 0 errors (should have 7)

### After
- TS2411 errors: Now correctly emitted
- Test file `derivedInterfaceIncompatibleWithBaseIndexer.ts`: 5 errors (tsc has 7)

### Conformance Impact
- Pass rate: **53.8%** (1,681/3,123 tests)
- All 332 unit tests pass
- Estimated 5-9 conformance tests fixed

## Known Limitations

### 1. Method Signatures Not Fully Handled
Line 20 of test has a method signature that should error:
```typescript
interface Derived4 extends Base {
    foo(): { x: number } // Should error - function type incompatible
}
```
We don't emit TS2411 for this case.

### 2. Numeric Properties and String Index
Some numeric properties are not being checked against string index signatures in all cases. Lines 8 and 12 of the test should emit 2 errors each (number + string index), but we only emit 1 (number index).

### 3. Line 29 False Positive
We emit an error on line 29 that tsc doesn't emit - this may be a duplicate interface declaration issue.

## Technical Insights

### Type Resolution Timing
- Interface types are cached during binding/resolution phase
- Checking phase should use cached types, not recompute them
- Recursive `get_type_of_interface` calls during checking cause ERROR types

### Interface Member Types
- Property signatures have type annotations, not computed types
- Method signatures need their full signature type
- Accessors (getters/setters) aggregate read/write types

### Index Signature Semantics
- Numeric properties can be accessed via string keys in JavaScript
- Both `[x: number]` and `[x: string]` signatures apply to numeric properties
- tsc checks both - we implemented this but have edge cases

## Debugging Techniques Used

1. **Tracing with `TSZ_LOG=trace`**: Added trace statements to see:
   - What type IDs were being returned
   - Whether index signatures were found
   - Property type resolution

2. **Minimal test cases**: Created `tmp/test_2411.ts` to isolate the issue

3. **Comparison with tsc**: Ran tsc on same inputs to verify expected behavior

4. **TypeId constant checking**: Identified that TypeId(1) = ERROR, TypeId(5) = VOID

## Next Steps

To complete TS2411 implementation:
1. Handle method signature types correctly
2. Ensure numeric properties are always checked against string index
3. Investigate line 29 false positive (may be unrelated issue)
4. Add unit tests for interface index signature checking

## Commit

```
fix(checker): emit TS2411 for properties incompatible with inherited index signatures

When an interface extends a base interface with index signatures, the derived
interface's properties must be compatible with those inherited index signatures.

Fixes:
- Use get_type_of_symbol to get cached interface type, avoiding recursion
- Resolve property types from type_annotation nodes for interface members
- Check properties against both number and string index signatures
```

---

**Session Duration**: ~3 hours
**Code Quality**: All unit tests pass, clean clippy, formatted
**Documentation**: Detailed investigation and solution documented
