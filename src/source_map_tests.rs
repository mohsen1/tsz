//! Tests for source_map.rs

use crate::emit_context::EmitContext;
use crate::lowering_pass::LoweringPass;
use crate::source_map::*;
use crate::thin_emitter::{PrinterOptions, ScriptTarget, ThinPrinter};
use crate::thin_parser::ThinParserState;
use serde_json::Value;

#[derive(Debug)]
struct DecodedMapping {
    generated_line: u32,
    generated_column: u32,
    source_index: u32,
    original_line: u32,
    original_column: u32,
    #[allow(dead_code)]
    name_index: Option<u32>,
}

fn decode_mappings(mappings: &str) -> Vec<DecodedMapping> {
    let mut decoded = Vec::new();
    let mut generated_line = 0u32;
    let mut prev_generated_column = 0i32;
    let mut prev_source_index = 0i32;
    let mut prev_original_line = 0i32;
    let mut prev_original_column = 0i32;
    let mut prev_name_index = 0i32;

    for line in mappings.split(';') {
        if line.is_empty() {
            generated_line += 1;
            prev_generated_column = 0;
            continue;
        }

        for segment in line.split(',') {
            if segment.is_empty() {
                continue;
            }

            let mut rest = segment;
            let (gen_col_delta, consumed) = vlq::decode(rest).expect("decode generated column");
            rest = &rest[consumed..];

            let gen_col = prev_generated_column + gen_col_delta;
            prev_generated_column = gen_col;

            if rest.is_empty() {
                continue;
            }

            let (src_delta, consumed) = vlq::decode(rest).expect("decode source index");
            rest = &rest[consumed..];
            let (orig_line_delta, consumed) = vlq::decode(rest).expect("decode original line");
            rest = &rest[consumed..];
            let (orig_col_delta, consumed) = vlq::decode(rest).expect("decode original column");
            rest = &rest[consumed..];

            let source_index = prev_source_index + src_delta;
            let original_line = prev_original_line + orig_line_delta;
            let original_column = prev_original_column + orig_col_delta;

            prev_source_index = source_index;
            prev_original_line = original_line;
            prev_original_column = original_column;

            let name_index = if !rest.is_empty() {
                let (name_delta, consumed) = vlq::decode(rest).expect("decode name index");
                rest = &rest[consumed..];
                let name_index = prev_name_index + name_delta;
                prev_name_index = name_index;
                Some(name_index as u32)
            } else {
                None
            };

            assert!(
                rest.is_empty(),
                "unexpected trailing data in mappings segment: {segment}"
            );

            decoded.push(DecodedMapping {
                generated_line,
                generated_column: gen_col as u32,
                source_index: source_index as u32,
                original_line: original_line as u32,
                original_column: original_column as u32,
                name_index,
            });
        }

        generated_line += 1;
        prev_generated_column = 0;
    }

    decoded
}

fn find_line_col(text: &str, needle: &str) -> (u32, u32) {
    let idx = text
        .find(needle)
        .unwrap_or_else(|| panic!("expected to find {needle} in {text}"));

    let mut line = 0u32;
    let mut col = 0u32;
    for &b in text.as_bytes().iter().take(idx) {
        if b == b'\n' {
            line += 1;
            col = 0;
        } else {
            col += 1;
        }
    }

    (line, col)
}

fn has_mapping_for_prefixes(
    decoded: &[DecodedMapping],
    output: &str,
    source: &str,
    needle: &str,
    prefixes: &[&str],
) -> bool {
    let (target_line, target_col) = find_line_col(source, needle);
    let needle_len = needle.len() as u32;
    let lower_bound = target_col.saturating_sub(6);
    let upper_bound = target_col + needle_len;

    for entry in decoded.iter() {
        if entry.source_index != 0 {
            continue;
        }
        if entry.original_line != target_line {
            continue;
        }
        if entry.original_column < lower_bound || entry.original_column > upper_bound {
            continue;
        }

        let output_line_text = match output.lines().nth(entry.generated_line as usize) {
            Some(line) => line,
            None => continue,
        };
        let output_slice = match output_line_text.get(entry.generated_column as usize..) {
            Some(slice) => slice,
            None => continue,
        };
        if prefixes
            .iter()
            .any(|prefix| output_slice.starts_with(prefix))
        {
            return true;
        }
    }

    false
}

#[test]
fn test_vlq_encode_positive() {
    // Simple positive numbers
    assert_eq!(vlq::encode(0), "A");
    assert_eq!(vlq::encode(1), "C");
    assert_eq!(vlq::encode(15), "e");
    assert_eq!(vlq::encode(16), "gB");
}

#[test]
fn test_vlq_encode_negative() {
    // Negative numbers (sign in LSB)
    assert_eq!(vlq::encode(-1), "D");
    assert_eq!(vlq::encode(-15), "f");
}

#[test]
fn test_vlq_decode() {
    // Decode what we encode
    for value in [-100, -1, 0, 1, 100, 1000] {
        let encoded = vlq::encode(value);
        let (decoded, consumed) = vlq::decode(&encoded).unwrap();
        assert_eq!(decoded, value, "Failed for value {}", value);
        assert_eq!(consumed, encoded.len());
    }
}

#[test]
fn test_source_map_simple() {
    let mut generator = SourceMapGenerator::new("output.js".to_string());
    let source_idx = generator.add_source("input.ts".to_string());

    generator.add_simple_mapping(0, 0, source_idx, 0, 0);
    generator.add_simple_mapping(0, 10, source_idx, 0, 5);
    generator.add_simple_mapping(1, 0, source_idx, 1, 0);

    let json = generator.to_json();
    assert!(
        json.contains("\"version\":3") || json.contains("\"version\": 3"),
        "Should be v3 source map: {}",
        json
    );
    assert!(
        json.contains("\"file\":\"output.js\"") || json.contains("\"file\": \"output.js\""),
        "Should have file: {}",
        json
    );
    assert!(
        json.contains("\"sources\":[\"input.ts\"]") || json.contains("\"sources\": [\"input.ts\"]"),
        "Should have sources: {}",
        json
    );
    assert!(
        json.contains("\"mappings\""),
        "Should have mappings: {}",
        json
    );
}

#[test]
fn test_source_map_with_content() {
    let mut generator = SourceMapGenerator::new("output.js".to_string());
    generator.add_source_with_content("input.ts".to_string(), "const x = 1;".to_string());

    generator.add_simple_mapping(0, 0, 0, 0, 0);

    let json = generator.to_json();
    assert!(json.contains("\"sourcesContent\""));
    assert!(json.contains("const x = 1;"));
}

#[test]
fn test_source_map_with_names() {
    let mut generator = SourceMapGenerator::new("output.js".to_string());
    let source_idx = generator.add_source("input.ts".to_string());
    let name_idx = generator.add_name("myVariable".to_string());

    generator.add_named_mapping(0, 0, source_idx, 0, 0, name_idx);

    let json = generator.to_json();
    assert!(
        json.contains("\"names\":[\"myVariable\"]") || json.contains("\"names\": [\"myVariable\"]"),
        "Should have names: {}",
        json
    );
}

#[test]
fn test_decode_mappings_round_trip() {
    let mut generator = SourceMapGenerator::new("output.js".to_string());
    let source_idx = generator.add_source("input.ts".to_string());

    generator.add_simple_mapping(0, 0, source_idx, 0, 0);
    generator.add_simple_mapping(0, 5, source_idx, 0, 3);
    generator.add_simple_mapping(1, 0, source_idx, 1, 0);

    let json = generator.to_json();
    let map_value: Value = serde_json::from_str(&json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    assert_eq!(decoded.len(), 3);
    assert_eq!(decoded[0].generated_line, 0);
    assert_eq!(decoded[0].generated_column, 0);
    assert_eq!(decoded[0].original_line, 0);
    assert_eq!(decoded[0].original_column, 0);
    assert_eq!(decoded[1].generated_line, 0);
    assert_eq!(decoded[1].generated_column, 5);
    assert_eq!(decoded[1].original_line, 0);
    assert_eq!(decoded[1].original_column, 3);
    assert_eq!(decoded[2].generated_line, 1);
    assert_eq!(decoded[2].generated_column, 0);
    assert_eq!(decoded[2].original_line, 1);
    assert_eq!(decoded[2].original_column, 0);
}

#[test]
fn test_source_map_es5_transform_records_names() {
    let source = "const value = 1; const other = value;";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let names = map_value
        .get("names")
        .and_then(|value| value.as_array())
        .expect("expected names array");
    assert!(
        names.iter().any(|name| name.as_str() == Some("value")),
        "expected names to include value. names: {names:?}"
    );

    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");
    let decoded = decode_mappings(mappings);
    let value_index = names
        .iter()
        .position(|name| name.as_str() == Some("value"))
        .expect("value not found in names");
    assert!(
        decoded
            .iter()
            .any(|entry| entry.name_index == Some(value_index as u32)),
        "expected name mapping for value. mappings: {mappings}"
    );
}

#[test]
fn test_inline_source_map() {
    let mut generator = SourceMapGenerator::new("output.js".to_string());
    generator.add_source("input.ts".to_string());
    generator.add_simple_mapping(0, 0, 0, 0, 0);

    let inline = generator.to_inline_comment();
    assert!(inline.starts_with("//# sourceMappingURL=data:application/json;base64,"));
}

#[test]
fn test_base64_encode() {
    assert_eq!(base64_encode(b""), "");
    assert_eq!(base64_encode(b"f"), "Zg==");
    assert_eq!(base64_encode(b"fo"), "Zm8=");
    assert_eq!(base64_encode(b"foo"), "Zm9v");
    assert_eq!(base64_encode(b"foobar"), "Zm9vYmFy");
}

#[test]
fn test_escape_json() {
    assert_eq!(escape_json("hello"), "hello");
    assert_eq!(escape_json("hello\"world"), "hello\\\"world");
    assert_eq!(escape_json("path\\to\\file"), "path\\\\to\\\\file");
    assert_eq!(escape_json("line1\nline2"), "line1\\nline2");
}

#[test]
fn test_source_map_es5_transform_async_await_mapping() {
    let source = "async function fetch(payload) { await payload; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (source_line, source_col) = find_line_col(source, "payload");
    let (output_line, output_col) = find_line_col(&output, "payload");

    let mapping = decoded
        .iter()
        .find(|entry| entry.original_line == source_line && entry.original_column == source_col)
        .unwrap_or_else(|| {
            panic!("expected mapping for payload. mappings: {mappings} output: {output}")
        });

    assert_eq!(mapping.source_index, 0);
    assert_eq!(mapping.generated_line, output_line);
    assert_eq!(mapping.generated_column, output_col);
}

#[test]
fn test_source_map_es5_transform_async_await_return_mapping() {
    let source = "async function compute(value) { return await value; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (source_line, source_col) = find_line_col(source, "value");

    let mapping = decoded
        .iter()
        .find(|entry| entry.original_line == source_line && entry.original_column == source_col)
        .unwrap_or_else(|| {
            panic!("expected mapping for value. mappings: {mappings} output: {output}")
        });

    assert_eq!(mapping.source_index, 0);

    let output_line_text = output
        .lines()
        .nth(mapping.generated_line as usize)
        .unwrap_or_else(|| {
            panic!(
                "missing output line {} in output: {output}",
                mapping.generated_line
            )
        });
    let output_slice = output_line_text
        .get(mapping.generated_column as usize..)
        .unwrap_or_else(|| {
            panic!(
                "missing output column {} in line: {output_line_text}",
                mapping.generated_column
            )
        });
    assert!(
        output_slice.starts_with("value"),
        "expected mapped output to start with value. line: {output_line_text} column: {} output: {output}",
        mapping.generated_column
    );
}

#[test]
fn test_source_map_es5_transform_async_await_property_access_mapping() {
    let source = "async function load(user) { return (await user).name; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (source_line, source_col) = find_line_col(source, "user");

    let mapping = decoded
        .iter()
        .find(|entry| entry.original_line == source_line && entry.original_column == source_col)
        .unwrap_or_else(|| {
            panic!("expected mapping for user. mappings: {mappings} output: {output}")
        });

    assert_eq!(mapping.source_index, 0);
    let output_line_text = output
        .lines()
        .nth(mapping.generated_line as usize)
        .unwrap_or_else(|| {
            panic!(
                "missing output line {} in output: {output}",
                mapping.generated_line
            )
        });
    let output_slice = output_line_text
        .get(mapping.generated_column as usize..)
        .unwrap_or_else(|| {
            panic!(
                "missing output column {} in line: {output_line_text}",
                mapping.generated_column
            )
        });
    assert!(
        output_slice.starts_with("user"),
        "expected mapped output to start with user. line: {output_line_text} column: {} output: {output}",
        mapping.generated_column
    );
}

#[test]
fn test_source_map_es5_transform_async_arrow_mapping() {
    let source = "const run = async (value) => { return await value; };";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (source_line, source_col) = find_line_col(source, "value");

    let mapping = decoded
        .iter()
        .find(|entry| entry.original_line == source_line && entry.original_column == source_col)
        .unwrap_or_else(|| {
            panic!("expected mapping for value. mappings: {mappings} output: {output}")
        });

    assert_eq!(mapping.source_index, 0);
    let output_line_text = output
        .lines()
        .nth(mapping.generated_line as usize)
        .unwrap_or_else(|| {
            panic!(
                "missing output line {} in output: {output}",
                mapping.generated_line
            )
        });
    let output_slice = output_line_text
        .get(mapping.generated_column as usize..)
        .unwrap_or_else(|| {
            panic!(
                "missing output column {} in line: {output_line_text}",
                mapping.generated_column
            )
        });
    assert!(
        output_slice.starts_with("value"),
        "expected mapped output to start with value. line: {output_line_text} column: {} output: {output}",
        mapping.generated_column
    );
}

#[test]
fn test_source_map_es5_transform_async_class_method_mapping() {
    let source = "class Box {\n    async run(value) { return await value; }\n}";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("Box.prototype.run"),
        "expected class method downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (param_line, param_col) = find_line_col(source, "value");

    if let Some(mapping) = decoded
        .iter()
        .find(|entry| entry.original_line == param_line && entry.original_column == param_col)
    {
        assert_eq!(mapping.source_index, 0);
        let output_line_text = output
            .lines()
            .nth(mapping.generated_line as usize)
            .unwrap_or_else(|| {
                panic!(
                    "missing output line {} in output: {output}",
                    mapping.generated_line
                )
            });
        let output_slice = output_line_text
            .get(mapping.generated_column as usize..)
            .unwrap_or_else(|| {
                panic!(
                    "missing output column {} in line: {output_line_text}",
                    mapping.generated_column
                )
            });
        assert!(
            output_slice.starts_with("value"),
            "expected mapped output to start with value. line: {output_line_text} column: {} output: {output}",
            mapping.generated_column
        );
    } else {
        let (method_line, _) = find_line_col(source, "async run");
        let (output_line, output_col) = find_line_col(&output, "run = function");
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before method output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= method_line,
            "expected mapping before or on method line. mapping line: {} method line: {}",
            mapping.original_line,
            method_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_nested_function_offset_mapping() {
    let source = "function outer() {\n    const before = 1;\n    async function run() {\n        await payloadValue;\n    }\n}";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (await_line, await_col) = find_line_col(source, "payloadValue");

    let mapping = decoded
        .iter()
        .find(|entry| entry.original_line == await_line && entry.original_column == await_col)
        .unwrap_or_else(|| {
            panic!("expected mapping for payloadValue. mappings: {mappings} output: {output}")
        });

    assert_eq!(mapping.source_index, 0);
    let output_line_text = output
        .lines()
        .nth(mapping.generated_line as usize)
        .unwrap_or_else(|| {
            panic!(
                "missing output line {} in output: {output}",
                mapping.generated_line
            )
        });
    let output_slice = output_line_text
        .get(mapping.generated_column as usize..)
        .unwrap_or_else(|| {
            panic!(
                "missing output column {} in line: {output_line_text}",
                mapping.generated_column
            )
        });
    assert!(
        output_slice.starts_with("payloadValue"),
        "expected mapped output to start with payloadValue. line: {output_line_text} column: {} output: {output}",
        mapping.generated_column
    );
}

#[test]
fn test_source_map_es5_transform_async_await_conditional_mapping() {
    let source = "const run = async (value) => (value ? await value : 0);";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (source_line, source_col) = find_line_col(source, "value ?");

    if let Some(mapping) = decoded
        .iter()
        .find(|entry| entry.original_line == source_line && entry.original_column == source_col)
    {
        assert_eq!(mapping.source_index, 0);
        let output_line_text = output
            .lines()
            .nth(mapping.generated_line as usize)
            .unwrap_or_else(|| {
                panic!(
                    "missing output line {} in output: {output}",
                    mapping.generated_line
                )
            });
        let output_slice = output_line_text
            .get(mapping.generated_column as usize..)
            .unwrap_or_else(|| {
                panic!(
                    "missing output column {} in line: {output_line_text}",
                    mapping.generated_column
                )
            });
        assert!(
            output_slice.starts_with("value"),
            "expected mapped output to start with value. line: {output_line_text} column: {} output: {output}",
            mapping.generated_column
        );
    } else {
        let (output_line, output_col) = if output.contains("value ?") {
            find_line_col(&output, "value ?")
        } else if output.contains("void 0") {
            find_line_col(&output, "void 0")
        } else {
            find_line_col(&output, "return [2")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before conditional output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= source_line,
            "expected mapping before or on conditional line. mapping line: {} conditional line: {}",
            mapping.original_line,
            source_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_arrow_captures_this_mapping() {
    let source = "const run = async function() { return await this.value; };";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (source_line, source_col) = find_line_col(source, "this.value");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == source_line && entry.original_column == source_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("this") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (output_line, output_col) = if output.contains("this.value") {
            find_line_col(&output, "this.value")
        } else {
            find_line_col(&output, "return [4")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before await output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= source_line,
            "expected mapping before or on await line. mapping line: {} await line: {}",
            mapping.original_line,
            source_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_mapping() {
    let source = "async function run() { try { await foo(); } catch { bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (source_line, source_col) = find_line_col(source, "foo()");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == source_line && entry.original_column == source_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("foo") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_await_mapping() {
    let source = "async function run() { try { await foo(); } catch (err) { await bar(err); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar(");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_return_await_mapping() {
    let source =
        "async function run() { try { await foo(); } catch (err) { return await bar(err); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar(");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_throw_await_mapping() {
    let source =
        "async function run() { try { await foo(); } catch (err) { throw await bar(err); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar(");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_only_await_mapping() {
    let source = "async function run() { try { foo(); } catch (err) { await bar(err); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (bar_line, bar_col) = find_line_col(source, "bar(");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == bar_line && entry.original_column == bar_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("bar") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_finally_only_mapping() {
    let source =
        "async function run() { try { foo(); } catch { await bar(); } finally { baz(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (bar_line, bar_col) = find_line_col(source, "bar()");
    let (baz_line, baz_col) = find_line_col(source, "baz()");

    let targets = [("bar", bar_line, bar_col), ("baz", baz_line, baz_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_if_else_mapping() {
    let source = "async function run(flag) { if (flag) { await foo(); } else { await bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_if_await_condition_mapping() {
    let source =
        "async function run(flag){ if (await foo(flag)) { bar(); } else { await baz(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo(");
    let (baz_line, baz_col) = find_line_col(source, "baz(");

    let targets = [("foo", foo_line, foo_col), ("baz", baz_line, baz_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_if_await_and_mapping() {
    let source = "async function run(flag){ if ((await foo(flag)) && await bar()) { baz(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo(");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_while_await_condition_mapping() {
    let source = "async function run(cond){ while (await foo(cond)) { bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo(");

    let targets = [("foo", foo_line, foo_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_while_await_condition_list_mapping() {
    let source = "async function run(){ while ((await foo(), await bar())) { baz(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [
        ("foo", find_line_col(source, "foo()")),
        ("bar", find_line_col(source, "bar()")),
    ];

    for (label, (target_line, target_col)) in targets {
        let direct_mapping = decoded.iter().find(|entry| {
            entry.original_line == target_line && entry.original_column == target_col
        });
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_ternary_mapping() {
    let source = "async function run(flag, a, b) { return flag ? await foo(a) : await bar(b); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo(");
    let (bar_line, bar_col) = find_line_col(source, "bar(");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_ternary_await_condition_mapping() {
    let source = "async function run(){ return (await cond()) ? foo() : await bar(); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (cond_line, cond_col) = find_line_col(source, "cond()");
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [
        ("cond", cond_line, cond_col),
        ("foo", foo_line, foo_col),
        ("bar", bar_line, bar_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_ternary_consequent_await_mapping() {
    let source = "async function run(flag){ return flag ? await foo() : bar(); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_logical_and_mapping() {
    let source = "async function run() { return (await foo()) && (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_logical_or_mapping() {
    let source = "async function run() { return (await foo()) || (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_logical_or_await_rhs_mapping() {
    let source = "async function run() { return foo() || await bar(); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_logical_and_await_rhs_mapping() {
    let source = "async function run() { return foo() && await bar(); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_logical_or_complex_mapping() {
    let source = "async function run(a, b){ return (await foo(a)) || (bar() && await baz(b)); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo(a)");
    let (bar_line, bar_col) = find_line_col(source, "bar()");
    let (baz_line, baz_col) = find_line_col(source, "baz(b)");

    let targets = [
        ("foo", foo_line, foo_col),
        ("bar", bar_line, bar_col),
        ("baz", baz_line, baz_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_logical_and_both_awaits_mapping() {
    let source = "async function run() { return (await foo()) && (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_add_mapping() {
    let source = "async function run() { return (await foo()) + (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_multiply_mapping() {
    let source = "async function run() { return (await foo()) * (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_subtract_mapping() {
    let source = "async function run() { return (await foo()) - (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_divide_mapping() {
    let source = "async function run() { return (await foo()) / (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_modulo_mapping() {
    let source = "async function run() { return (await foo()) % (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_less_than_mapping() {
    let source = "async function run() { return (await foo()) < (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_strict_equal_mapping() {
    let source = "async function run() { return (await foo()) === (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_strict_not_equal_mapping() {
    let source = "async function run() { return (await foo()) !== (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_greater_equal_mapping() {
    let source = "async function run() { return (await foo()) >= (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_less_equal_mapping() {
    let source = "async function run() { return (await foo()) <= (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_greater_than_mapping() {
    let source = "async function run() { return (await foo()) > (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_equal_mapping() {
    let source = "async function run() { return (await foo()) == (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_not_equal_mapping() {
    let source = "async function run() { return (await foo()) != (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_bitwise_and_mapping() {
    let source = "async function run() { return (await foo()) & (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_bitwise_or_mapping() {
    let source = "async function run() { return (await foo()) | (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_bitwise_xor_mapping() {
    let source = "async function run() { return (await foo()) ^ (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_destructuring_mapping() {
    let source = "async function run(){ const { value } = await foo(); return value; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (return_line, return_col) = find_line_col(source, "return value");
    let value_col = return_col + "return ".len() as u32;

    let targets = [
        ("foo", foo_line, foo_col),
        ("value", return_line, value_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_shift_left_mapping() {
    let source = "async function run() { return (await foo()) << (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_shift_right_mapping() {
    let source = "async function run() { return (await foo()) >> (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_binary_unsigned_shift_right_mapping() {
    let source = "async function run() { return (await foo()) >>> (await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_array_literal_mapping() {
    let source = "async function run(){ return [await foo(), await bar()]; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_array_literal_spread_mapping() {
    let source = "async function run(){ return [...await foo(), await bar()]; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_object_literal_mapping() {
    let source = "async function run(){ return { value: await foo(), other: await bar() }; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_object_literal_spread_mapping() {
    let source = "async function run(){ return { ...await foo(), value: await bar() }; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_object_literal_computed_mapping() {
    let source = "async function run(){ return { [await key()]: 1, other: 2 }; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (key_line, key_col) = find_line_col(source, "key()");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == key_line && entry.original_column == key_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("key") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output for computed key. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line for computed key. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_nested_await_call_mapping() {
    let source = "async function run(){ return await foo(await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo(");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_call_spread_mapping() {
    let source = "async function run(){ return foo(...await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo(");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_template_literal_mapping() {
    let source = "async function run(){ return `value ${await foo()}`; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == foo_line && entry.original_column == foo_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("foo") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_return_await_in_try_mapping() {
    let source =
        "async function run() { try { return await foo(); } catch (err) { await bar(err); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar(");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_try_finally_mapping() {
    let source = "async function run() { try { await foo(); } finally { bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (source_line, source_col) = find_line_col(source, "foo()");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == source_line && entry.original_column == source_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("foo") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_try_finally_only_await_mapping() {
    let source = "async function run() { try { foo(); } finally { await bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == bar_line && entry.original_column == bar_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("bar") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_try_finally_await_mapping() {
    let source = "async function run() { try { await foo(); } finally { await bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_try_finally_await_in_finally_direct_mapping() {
    let source = "async function run() {\n    try {\n        await work();\n    } finally {\n        const done = await cleanup();\n        report(done);\n    }\n}";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [
        ("work()", &["work"][..]),
        ("cleanup()", &["cleanup"][..]),
        ("report(done)", &["report"][..]),
    ];
    let mut mapped = false;

    for (needle, prefixes) in targets {
        if has_mapping_for_prefixes(&decoded, &output, source, needle, prefixes) {
            mapped = true;
            break;
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_try_finally_return_mapping() {
    let source = "async function run() { try { return await foo(); } finally { await bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_finally_mapping() {
    let source =
        "async function run() { try { await foo(); } catch { bar(); } finally { baz(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");
    let (baz_line, baz_col) = find_line_col(source, "baz()");

    let targets = [
        ("foo", foo_line, foo_col),
        ("bar", bar_line, bar_col),
        ("baz", baz_line, baz_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_finally_await_in_finally_mapping() {
    let source = "async function run() { try { foo(); } catch (err) { bar(err); } finally { await baz(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar(");
    let (baz_line, baz_col) = find_line_col(source, "baz()");

    let targets = [
        ("foo", foo_line, foo_col),
        ("bar", bar_line, bar_col),
        ("baz", baz_line, baz_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_finally_catch_finally_awaits_mapping() {
    let source = "async function run() { try { foo(); } catch (err) { await bar(err); } finally { await baz(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar(");
    let (baz_line, baz_col) = find_line_col(source, "baz()");

    let targets = [
        ("foo", foo_line, foo_col),
        ("bar", bar_line, bar_col),
        ("baz", baz_line, baz_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_finally_awaits_mapping() {
    let source = "async function run() { try { await foo(); } catch (err) { await bar(err); } finally { await baz(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar(");
    let (baz_line, baz_col) = find_line_col(source, "baz()");

    let targets = [
        ("foo", foo_line, foo_col),
        ("bar", bar_line, bar_col),
        ("baz", baz_line, baz_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_assignment_mapping() {
    let source = "async function run(){ let value; value = await foo(); return value; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (return_line, return_col) = find_line_col(source, "return value");
    let value_col = return_col + "return ".len() as u32;

    let targets = [
        ("foo", foo_line, foo_col),
        ("value", return_line, value_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_variable_initializer_await_mapping() {
    let source = "async function run(){ let value = await foo(); return value; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == foo_line && entry.original_column == foo_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("foo") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output for foo initializer. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line for foo initializer. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_variable_declaration_list_await_mapping() {
    let source = "async function run(){ let first = await getFirst(), second = await getSecond(); return second; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [
        ("getFirst", find_line_col(source, "getFirst()")),
        ("getSecond", find_line_col(source, "getSecond()")),
    ];

    for (label, (src_line, src_col)) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_unary_not_mapping() {
    let source = "async function run(){ return !(await foo()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == foo_line && entry.original_column == foo_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("foo") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_unary_negative_mapping() {
    let source = "async function run(){ return -(await foo()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == foo_line && entry.original_column == foo_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("foo") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_unary_bitwise_not_mapping() {
    let source = "async function run(){ return ~(await foo()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == foo_line && entry.original_column == foo_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("foo") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_unary_void_mapping() {
    let source = "async function run(){ return void (await foo()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == foo_line && entry.original_column == foo_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("foo") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_unary_typeof_mapping() {
    let source = "async function run(){ return typeof (await foo()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");

    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == foo_line && entry.original_column == foo_col);
    let direct_valid = direct_mapping.and_then(|mapping| {
        if mapping.source_index != 0 {
            return None;
        }

        let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
        let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
        if output_slice.starts_with("foo") {
            Some(mapping)
        } else {
            None
        }
    });

    if direct_valid.is_none() {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_sequence_await_mapping() {
    let source = "async function run(){ return (await foo(), await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_sequence_mixed_await_mapping() {
    let source = "async function run(){ return (foo(), await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_optional_chaining_await_mapping() {
    let source = "async function run(){ return await foo?.bar(); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo");
    let (bar_line, bar_col) = find_line_col(source, "bar");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_nullish_coalescing_await_mapping() {
    let source = "async function run(){ return (await foo()) ?? bar(); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_delete_mapping() {
    let source = "async function run(){ return delete (await foo()).bar; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_compound_assignment_mapping() {
    let source = "async function run(){ let value = 0; value += await foo(); return value; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (return_line, return_col) = find_line_col(source, "return value");
    let value_col = return_col + "return ".len() as u32;

    let targets = [
        ("foo", foo_line, foo_col),
        ("value", return_line, value_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_compound_assignment_multiply_mapping() {
    let source = "async function run(){ let value = 2; value *= await foo(); return value; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (return_line, return_col) = find_line_col(source, "return value");
    let value_col = return_col + "return ".len() as u32;

    let targets = [
        ("foo", foo_line, foo_col),
        ("value", return_line, value_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_compound_assignment_divide_mapping() {
    let source = "async function run(){ let value = 4; value /= await foo(); return value; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (return_line, return_col) = find_line_col(source, "return value");
    let value_col = return_col + "return ".len() as u32;

    let targets = [
        ("foo", foo_line, foo_col),
        ("value", return_line, value_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_compound_assignment_subtract_mapping() {
    let source = "async function run(){ let value = 5; value -= await foo(); return value; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (return_line, return_col) = find_line_col(source, "return value");
    let value_col = return_col + "return ".len() as u32;

    let targets = [
        ("foo", foo_line, foo_col),
        ("value", return_line, value_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_compound_assignment_modulo_mapping() {
    let source = "async function run(){ let value = 7; value %= await foo(); return value; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (return_line, return_col) = find_line_col(source, "return value");
    let value_col = return_col + "return ".len() as u32;

    let targets = [
        ("foo", foo_line, foo_col),
        ("value", return_line, value_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_nested_arrow_capture_mapping() {
    let source = "async function run() { const bar = () => this.x; await bar(); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [("this.x", &["this", "_this"][..]), ("bar()", &["bar"][..])];
    let mut mapped = false;

    for (needle, prefixes) in targets {
        let (target_line, target_col) = find_line_col(source, needle);
        let direct_mapping = decoded.iter().find(|entry| {
            entry.original_line == target_line && entry.original_column == target_col
        });

        if let Some(mapping) = direct_mapping {
            if mapping.source_index == 0 {
                let output_line_text = output.lines().nth(mapping.generated_line as usize);
                let output_slice =
                    output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
                if let Some(output_slice) = output_slice {
                    if prefixes
                        .iter()
                        .any(|prefix| output_slice.starts_with(prefix))
                    {
                        mapped = true;
                        break;
                    }
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_try_catch_nested_arrow_mapping() {
    let source =
        "async function run(){ try { const bar=()=>this.x; await bar(); } catch { baz(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [
        ("this.x", &["this", "_this"][..]),
        ("bar()", &["bar"][..]),
        ("baz()", &["baz"][..]),
    ];
    let mut mapped = false;

    for (needle, prefixes) in targets {
        let (target_line, target_col) = find_line_col(source, needle);
        let direct_mapping = decoded.iter().find(|entry| {
            entry.original_line == target_line && entry.original_column == target_col
        });

        if let Some(mapping) = direct_mapping {
            if mapping.source_index == 0 {
                let output_line_text = output.lines().nth(mapping.generated_line as usize);
                let output_slice =
                    output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
                if let Some(output_slice) = output_slice {
                    if prefixes
                        .iter()
                        .any(|prefix| output_slice.starts_with(prefix))
                    {
                        mapped = true;
                        break;
                    }
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_object_literal_arrow_mapping() {
    let source = "const obj = { run: async () => { await foo(); return this.x; } };";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [("foo()", &["foo"][..]), ("this.x", &["this", "_this"][..])];
    let mut mapped = false;

    for (needle, prefixes) in targets {
        let (target_line, target_col) = find_line_col(source, needle);
        let direct_mapping = decoded.iter().find(|entry| {
            entry.original_line == target_line && entry.original_column == target_col
        });

        if let Some(mapping) = direct_mapping {
            if mapping.source_index == 0 {
                let output_line_text = output.lines().nth(mapping.generated_line as usize);
                let output_slice =
                    output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
                if let Some(output_slice) = output_slice {
                    if prefixes
                        .iter()
                        .any(|prefix| output_slice.starts_with(prefix))
                    {
                        mapped = true;
                        break;
                    }
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "const obj");
        let (output_line, output_col) = if output.contains("obj = {") {
            find_line_col(&output, "obj = {")
        } else if output.contains("obj =") {
            find_line_col(&output, "obj =")
        } else {
            find_line_col(&output, "obj")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before object output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on object line. mapping line: {} object line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_switch_mapping() {
    let source =
        "async function run(x){ switch(x){ case 1: await foo(); break; default: bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [("foo()", &["foo"][..]), ("bar()", &["bar"][..])];
    let mut mapped = false;

    for (needle, prefixes) in targets {
        let (target_line, target_col) = find_line_col(source, needle);
        let direct_mapping = decoded.iter().find(|entry| {
            entry.original_line == target_line && entry.original_column == target_col
        });

        if let Some(mapping) = direct_mapping {
            if mapping.source_index == 0 {
                let output_line_text = output.lines().nth(mapping.generated_line as usize);
                let output_slice =
                    output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
                if let Some(output_slice) = output_slice {
                    if prefixes
                        .iter()
                        .any(|prefix| output_slice.starts_with(prefix))
                    {
                        mapped = true;
                        break;
                    }
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_for_loop_mapping() {
    let source = "async function run(){ for (let i=0;i<1;i++){ await foo(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (target_line, target_col) = find_line_col(source, "foo()");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == target_line && entry.original_column == target_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("foo") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_for_loop_await_condition_mapping() {
    let source = "async function run(cond){ for (; await foo(cond); ) { bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (target_line, target_col) = find_line_col(source, "foo(");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == target_line && entry.original_column == target_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("foo") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_for_loop_await_condition_list_mapping() {
    let source = "async function run(){ for (; (await foo(), await bar()); ) { baz(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [
        ("foo", find_line_col(source, "foo()")),
        ("bar", find_line_col(source, "bar()")),
    ];

    for (label, (target_line, target_col)) in targets {
        let direct_mapping = decoded.iter().find(|entry| {
            entry.original_line == target_line && entry.original_column == target_col
        });

        let mut mapped = false;
        if let Some(mapping) = direct_mapping {
            if mapping.source_index == 0 {
                let output_line_text = output.lines().nth(mapping.generated_line as usize);
                let output_slice =
                    output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
                if let Some(output_slice) = output_slice {
                    if output_slice.starts_with(label) {
                        mapped = true;
                    }
                }
            }
        }

        if !mapped {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_for_loop_await_initializer_mapping() {
    let source = "async function run(){ for (let i = await foo(); i < 1; i++) { bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (target_line, target_col) = find_line_col(source, "foo()");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == target_line && entry.original_column == target_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("foo") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_for_loop_await_initializer_list_mapping() {
    let source =
        "async function run(){ for (let i = await foo(), j = await bar(); i < j; i++) { baz(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [
        ("foo", find_line_col(source, "foo()")),
        ("bar", find_line_col(source, "bar()")),
    ];

    for (label, (target_line, target_col)) in targets {
        let direct_mapping = decoded.iter().find(|entry| {
            entry.original_line == target_line && entry.original_column == target_col
        });

        let mut mapped = false;
        if let Some(mapping) = direct_mapping {
            if mapping.source_index == 0 {
                let output_line_text = output.lines().nth(mapping.generated_line as usize);
                let output_slice =
                    output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
                if let Some(output_slice) = output_slice {
                    if output_slice.starts_with(label) {
                        mapped = true;
                    }
                }
            }
        }

        if !mapped {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_for_loop_await_update_list_mapping() {
    let source = "async function run(){ let j = 0; for (let i = 0; i < 1; i = await foo(), j = await bar()) { baz(i, j); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [
        ("foo", find_line_col(source, "foo()")),
        ("bar", find_line_col(source, "bar()")),
    ];

    for (label, (target_line, target_col)) in targets {
        let direct_mapping = decoded.iter().find(|entry| {
            entry.original_line == target_line && entry.original_column == target_col
        });

        let mut mapped = false;
        if let Some(mapping) = direct_mapping {
            if mapping.source_index == 0 {
                let output_line_text = output.lines().nth(mapping.generated_line as usize);
                let output_slice =
                    output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
                if let Some(output_slice) = output_slice {
                    if output_slice.starts_with(label) {
                        mapped = true;
                    }
                }
            }
        }

        if !mapped {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_for_loop_await_update_mapping() {
    let source = "async function run(){ for (let i = 0; i < 1; i = await foo()) { bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (target_line, target_col) = find_line_col(source, "foo()");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == target_line && entry.original_column == target_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("foo") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_for_loop_header_awaits_mapping() {
    let source = "async function run() {\n    for (let i = await init(); await cond(i); i = await step(i)) {\n        await body(i);\n    }\n}";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [
        ("init()", &["init"][..]),
        ("cond(i)", &["cond"][..]),
        ("step(i)", &["step"][..]),
        ("body(i)", &["body"][..]),
    ];
    let mut mapped = false;

    for (needle, prefixes) in targets {
        if has_mapping_for_prefixes(&decoded, &output, source, needle, prefixes) {
            mapped = true;
            break;
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_while_loop_mapping() {
    let source = "async function run(cond){ while (cond) { await foo(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (target_line, target_col) = find_line_col(source, "foo()");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == target_line && entry.original_column == target_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("foo") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_do_while_mapping() {
    let source = "async function run(cond){ do { await foo(); } while (cond); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (target_line, target_col) = find_line_col(source, "foo()");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == target_line && entry.original_column == target_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("foo") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_do_while_await_condition_mapping() {
    let source = "async function run(cond){ do { bar(); } while (await foo(cond)); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (target_line, target_col) = find_line_col(source, "foo(");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == target_line && entry.original_column == target_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("foo") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_do_while_await_condition_list_mapping() {
    let source = "async function run(){ do { baz(); } while ((await foo(), await bar())); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let targets = [
        ("foo", find_line_col(source, "foo()")),
        ("bar", find_line_col(source, "bar()")),
    ];

    for (label, (target_line, target_col)) in targets {
        let direct_mapping = decoded.iter().find(|entry| {
            entry.original_line == target_line && entry.original_column == target_col
        });
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_do_while_await_condition_direct_mapping() {
    let source = "async function run(flag) {\n    do {\n        tick(flag);\n    } while (await shouldContinue(flag));\n}";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let mapped = has_mapping_for_prefixes(
        &decoded,
        &output,
        source,
        "shouldContinue(flag)",
        &["shouldContinue"],
    );

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_for_of_mapping() {
    let source = "async function run(items){ for (const item of items) { await foo(item); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (target_line, target_col) = find_line_col(source, "foo(");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == target_line && entry.original_column == target_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("foo") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_for_of_await_rhs_mapping() {
    let source = "async function run(items){ for (const item of await foo(items)) { bar(item); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (target_line, target_col) = find_line_col(source, "foo(");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == target_line && entry.original_column == target_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("foo") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_for_in_mapping() {
    let source = "async function run(obj){ for (const key in obj) { await foo(obj[key]); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (target_line, target_col) = find_line_col(source, "foo(");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == target_line && entry.original_column == target_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("foo") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_for_in_await_rhs_mapping() {
    let source = "async function run(obj){ for (const key in await foo(obj)) { bar(key); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (target_line, target_col) = find_line_col(source, "foo(");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == target_line && entry.original_column == target_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("foo") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_switch_default_await_mapping() {
    let source =
        "async function run(x){ switch(x){ case 1: await foo(); break; default: await bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (bar_line, bar_col) = find_line_col(source, "bar()");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == bar_line && entry.original_column == bar_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("bar") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_switch_default_only_await_mapping() {
    let source = "async function run(x){ switch(x){ case 1: break; default: await bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (bar_line, bar_col) = find_line_col(source, "bar()");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == bar_line && entry.original_column == bar_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("bar") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_switch_case_await_mapping() {
    let source = "async function run(x){ switch(x){ case 1: await foo(); break; case 2: await bar(); break; } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (bar_line, bar_col) = find_line_col(source, "bar()");
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == bar_line && entry.original_column == bar_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("bar") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_switch_return_await_mapping() {
    let source = "async function run(x){ switch(x){ case 1: return await foo(); default: return await bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_switch_await_discriminant_mapping() {
    let source = "async function run(payload){ switch(await payload){ case 1: await foo(); break; default: await bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (await_line, await_col) = find_line_col(source, "await payload");
    let payload_col = await_col + "await ".len() as u32;
    let direct_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == await_line && entry.original_column == payload_col);

    let mut mapped = false;
    if let Some(mapping) = direct_mapping {
        if mapping.source_index == 0 {
            let output_line_text = output.lines().nth(mapping.generated_line as usize);
            let output_slice =
                output_line_text.and_then(|line| line.get(mapping.generated_column as usize..));
            if let Some(output_slice) = output_slice {
                if output_slice.starts_with("payload") {
                    mapped = true;
                }
            }
        }
    }

    if !mapped {
        let (func_line, _) = find_line_col(source, "async function run");
        let (output_line, output_col) = if output.contains("function run") {
            find_line_col(&output, "function run")
        } else if output.contains("run = function") {
            find_line_col(&output, "run = function")
        } else {
            find_line_col(&output, "run")
        };
        let mapping = decoded
            .iter()
            .filter(|entry| {
                entry.generated_line < output_line
                    || (entry.generated_line == output_line
                        && entry.generated_column <= output_col)
            })
            .max_by_key(|entry| (entry.generated_line, entry.generated_column))
            .unwrap_or_else(|| {
                panic!(
                    "expected mapping at or before async function output. mappings: {mappings} output: {output}"
                )
            });

        assert_eq!(mapping.source_index, 0);
        assert!(
            mapping.original_line <= func_line,
            "expected mapping before or on function line. mapping line: {} function line: {}",
            mapping.original_line,
            func_line
        );
    }
}

#[test]
fn test_source_map_es5_transform_async_switch_fallthrough_await_mapping() {
    let source = "async function run(x){ switch(x){ case 1: case 2: await foo(); break; default: await bar(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "foo()");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("foo", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_class_extends_mapping() {
    let source = "class Base { base = 1; }\nclass Derived extends Base { value = 2; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__extends"),
        "expected __extends helper in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (source_line, source_col) = find_line_col(source, "class Derived");
    let (output_line, output_col) = find_line_col(&output, "var Derived");

    let mapping = decoded
        .iter()
        .find(|entry| entry.original_line == source_line && entry.original_column == source_col)
        .unwrap_or_else(|| {
            panic!("expected mapping for Derived class. mappings: {mappings} output: {output}")
        });

    assert_eq!(mapping.source_index, 0);
    assert_eq!(mapping.generated_line, output_line);
    assert_eq!(mapping.generated_column, output_col);
}

#[test]
fn test_source_map_es5_transform_class_property_initializer_mapping() {
    let source = "class Box { foo = 1; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("this.foo = 1"),
        "expected downlevel property initializer, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (source_line, _) = find_line_col(source, "foo = 1");
    let (output_line, output_col) = find_line_col(&output, "this.foo = 1");

    // Use the closest mapping at or before the initializer output position.
    let mapping = decoded
        .iter()
        .filter(|entry| {
            entry.generated_line < output_line
                || (entry.generated_line == output_line
                    && entry.generated_column <= output_col)
        })
        .max_by_key(|entry| (entry.generated_line, entry.generated_column))
        .unwrap_or_else(|| {
            panic!(
                "expected mapping at or before initializer output. mappings: {mappings} output: {output}"
            )
        });

    assert_eq!(mapping.source_index, 0);
    assert_eq!(mapping.original_line, source_line);
}

#[test]
fn test_source_map_es5_transform_derived_ctor_super_initializer_mapping() {
    let source = "class Base {}\nclass Derived extends Base {\n    constructor() { super(); this.foo = 1; }\n}\n";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__extends"),
        "expected __extends helper in output: {output}"
    );
    assert!(
        output.contains("foo = 1"),
        "expected downlevel initializer in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (class_line, _) = find_line_col(source, "class Derived");
    let (output_line, output_col) = find_line_col(&output, "foo = 1");

    let mapping = decoded
        .iter()
        .filter(|entry| {
            entry.generated_line < output_line
                || (entry.generated_line == output_line
                    && entry.generated_column <= output_col)
        })
        .max_by_key(|entry| (entry.generated_line, entry.generated_column))
        .unwrap_or_else(|| {
            panic!(
                "expected mapping at or before initializer output. mappings: {mappings} output: {output}"
            )
        });

    assert_eq!(mapping.source_index, 0);
    assert_eq!(mapping.original_line, class_line);
}

#[test]
fn test_source_map_es5_transform_async_new_expression_mapping() {
    let source = "async function run(){ return new Foo(await bar()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (foo_line, foo_col) = find_line_col(source, "new Foo");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("new", foo_line, foo_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_tagged_template_mapping() {
    let source = "async function run(){ return tag`hello ${await bar()}`; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (tag_line, tag_col) = find_line_col(source, "tag`");
    let (bar_line, bar_col) = find_line_col(source, "bar()");

    let targets = [("tag", tag_line, tag_col), ("bar", bar_line, bar_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_instanceof_mapping() {
    let source = "async function run(){ return (await bar()) instanceof Foo; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (bar_line, bar_col) = find_line_col(source, "bar()");
    let (foo_line, foo_col) = find_line_col(source, "instanceof Foo");

    let targets = [
        ("bar", bar_line, bar_col),
        ("instanceof", foo_line, foo_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_exponentiation_mapping() {
    let source = "async function run(){ return (await base()) ** (await exp()); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (base_line, base_col) = find_line_col(source, "base()");
    let (exp_line, exp_col) = find_line_col(source, "exp()");

    let targets = [("base", base_line, base_col), ("exp", exp_line, exp_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_in_operator_mapping() {
    let source = "async function run(){ return (await key()) in obj; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (key_line, key_col) = find_line_col(source, "key()");

    let targets = [("key", key_line, key_col)];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_nested_try_finally_mapping() {
    let source = "async function run(){ try { try { await inner(); } finally { await cleanup1(); } } finally { await cleanup2(); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (inner_line, inner_col) = find_line_col(source, "inner()");
    let (cleanup1_line, cleanup1_col) = find_line_col(source, "cleanup1()");
    let (cleanup2_line, cleanup2_col) = find_line_col(source, "cleanup2()");

    let targets = [
        ("inner", inner_line, inner_col),
        ("cleanup1", cleanup1_line, cleanup1_col),
        ("cleanup2", cleanup2_line, cleanup2_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_async_for_of_destructuring_mapping() {
    let source =
        "async function run(){ for (const [a, b] of await items()) { await process(a, b); } }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("__awaiter(") && output.contains("__generator("),
        "expected async downlevel output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (items_line, items_col) = find_line_col(source, "items()");
    let (process_line, process_col) = find_line_col(source, "process(");

    let targets = [
        ("items", items_line, items_col),
        ("process", process_line, process_col),
    ];

    for (label, src_line, src_col) in targets {
        let direct_mapping = decoded
            .iter()
            .find(|entry| entry.original_line == src_line && entry.original_column == src_col);
        let direct_valid = direct_mapping.and_then(|mapping| {
            if mapping.source_index != 0 {
                return None;
            }

            let output_line_text = output.lines().nth(mapping.generated_line as usize)?;
            let output_slice = output_line_text.get(mapping.generated_column as usize..)?;
            if output_slice.starts_with(label) {
                Some(mapping)
            } else {
                None
            }
        });

        if direct_valid.is_none() {
            let (func_line, _) = find_line_col(source, "async function run");
            let (output_line, output_col) = if output.contains("function run") {
                find_line_col(&output, "function run")
            } else if output.contains("run = function") {
                find_line_col(&output, "run = function")
            } else {
                find_line_col(&output, "run")
            };
            let mapping = decoded
                .iter()
                .filter(|entry| {
                    entry.generated_line < output_line
                        || (entry.generated_line == output_line
                            && entry.generated_column <= output_col)
                })
                .max_by_key(|entry| (entry.generated_line, entry.generated_column))
                .unwrap_or_else(|| {
                    panic!(
                        "expected mapping at or before async function output for {label}. mappings: {mappings} output: {output}"
                    )
                });

            assert_eq!(mapping.source_index, 0);
            assert!(
                mapping.original_line <= func_line,
                "expected mapping before or on function line for {label}. mapping line: {} function line: {}",
                mapping.original_line,
                func_line
            );
        }
    }
}

#[test]
fn test_source_map_es5_transform_generator_yield_mapping() {
    let source = "function* gen() { yield first(); yield second(); }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    // Generator functions may or may not be downleveled depending on implementation
    // Just verify the output contains yield or __generator
    assert!(
        output.contains("yield") || output.contains("__generator("),
        "expected generator output, got: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    let (func_line, func_col) = find_line_col(source, "function* gen");
    let (yield1_line, yield1_col) = find_line_col(source, "yield first");
    let (yield2_line, yield2_col) = find_line_col(source, "yield second");

    // Verify we have mappings for the function declaration
    let func_mapping = decoded
        .iter()
        .find(|entry| entry.original_line == func_line && entry.original_column == func_col);
    assert!(
        func_mapping.is_some(),
        "expected mapping for function* gen. mappings: {mappings}"
    );

    // Verify we have mappings somewhere in the yield range
    let has_yield1_mapping = decoded.iter().any(|entry| {
        entry.original_line == yield1_line
            && entry.original_column >= yield1_col
            && entry.original_column <= yield1_col + 12
    });
    let has_yield2_mapping = decoded.iter().any(|entry| {
        entry.original_line == yield2_line
            && entry.original_column >= yield2_col
            && entry.original_column <= yield2_col + 13
    });

    assert!(
        has_yield1_mapping || has_yield2_mapping,
        "expected at least one mapping for yield expressions. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_names_array_multiple_identifiers() {
    let source = "function greet(name) { const message = 'Hello ' + name; return message; }";
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    // Verify the names array exists
    let names = map_value
        .get("names")
        .and_then(|value| value.as_array())
        .expect("expected names array in source map");

    // Check that expected identifiers are in the names array
    let expected_names = ["greet", "name", "message"];
    for expected in expected_names {
        assert!(
            names.iter().any(|n| n.as_str() == Some(expected)),
            "expected names array to include '{}'. names: {:?}",
            expected,
            names
        );
    }

    // Verify mappings reference the names
    let mappings = map_value
        .get("mappings")
        .and_then(|value| value.as_str())
        .unwrap_or("");
    let decoded = decode_mappings(mappings);

    // At least some mappings should have name indices
    let mappings_with_names = decoded.iter().filter(|m| m.name_index.is_some()).count();
    assert!(
        mappings_with_names > 0,
        "expected some mappings to have name indices. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_sources_content_accuracy() {
    // Test with multiline source containing various constructs
    let source = r#"function hello(name: string): string {
    const greeting = "Hello, " + name;
    return greeting;
}

const result = hello("World");
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    // Verify sources array exists and contains the source file
    let sources = map_value
        .get("sources")
        .and_then(|v| v.as_array())
        .expect("expected sources array");
    assert_eq!(sources.len(), 1, "expected one source file");
    assert_eq!(
        sources[0].as_str(),
        Some("test.ts"),
        "expected source file name"
    );

    // Verify sourcesContent array exists and has same length as sources
    let sources_content = map_value
        .get("sourcesContent")
        .and_then(|v| v.as_array())
        .expect("expected sourcesContent array");
    assert_eq!(
        sources_content.len(),
        sources.len(),
        "sourcesContent length should match sources length"
    );

    // Verify the sourcesContent contains the exact original source
    let content = sources_content[0]
        .as_str()
        .expect("expected sourcesContent to be a string");
    assert_eq!(
        content, source,
        "sourcesContent should exactly match original source"
    );
}

#[test]
fn test_source_map_with_decorators() {
    // Test decorators on class and method
    let source = r#"function sealed(target: Function) {}
function log(target: any, key: string) {}

@sealed
class Example {
    @log
    greet() { return "hello"; }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the decorator functions
    let (sealed_line, sealed_col) = find_line_col(source, "function sealed");
    let has_sealed_mapping = decoded.iter().any(|entry| {
        entry.original_line == sealed_line
            && entry.original_column >= sealed_col
            && entry.original_column <= sealed_col + 15
    });

    let (log_line, log_col) = find_line_col(source, "function log");
    let has_log_mapping = decoded.iter().any(|entry| {
        entry.original_line == log_line
            && entry.original_column >= log_col
            && entry.original_column <= log_col + 12
    });

    // Verify we have mappings for decorator functions
    assert!(
        has_sealed_mapping || has_log_mapping,
        "expected mappings for decorator functions. mappings: {mappings}"
    );

    // Verify output contains the decorated class emitted as ES5 IIFE
    assert!(
        output.contains("Example") && output.contains("greet"),
        "expected output to contain decorated class and method. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for decorated code"
    );
}

#[test]
fn test_source_map_optional_chaining() {
    // Test optional chaining operators: ?. ?.[] ?.()
    let source = r#"const obj = { a: { b: 1 } };
const x = obj?.a?.b;
const arr = [1, 2, 3];
const y = arr?.[0];
const fn = (x: number) => x * 2;
const z = fn?.(5);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the variable declarations
    let (obj_line, obj_col) = find_line_col(source, "const obj");
    let has_obj_mapping = decoded.iter().any(|entry| {
        entry.original_line == obj_line
            && entry.original_column >= obj_col
            && entry.original_column <= obj_col + 9
    });

    let (x_line, x_col) = find_line_col(source, "const x");
    let has_x_mapping = decoded.iter().any(|entry| {
        entry.original_line == x_line
            && entry.original_column >= x_col
            && entry.original_column <= x_col + 7
    });

    // At minimum, we should have mappings for one of the declarations
    assert!(
        has_obj_mapping || has_x_mapping,
        "expected mappings for optional chaining declarations. mappings: {mappings}"
    );

    // Verify the output contains the variable names (optional chaining should be downleveled)
    assert!(
        output.contains("obj") && output.contains("arr") && output.contains("fn"),
        "expected output to contain variable names. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for optional chaining code"
    );
}

#[test]
fn test_source_map_logical_assignment_operators() {
    // Test logical assignment operators: ||= &&= ??=
    let source = r#"let a = null;
let b = 0;
let c = "hello";
a ||= "default";
b &&= 10;
c ??= "fallback";"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the variable declarations
    let (a_line, a_col) = find_line_col(source, "let a");
    let has_a_mapping = decoded.iter().any(|entry| {
        entry.original_line == a_line
            && entry.original_column >= a_col
            && entry.original_column <= a_col + 5
    });

    let (b_line, b_col) = find_line_col(source, "let b");
    let has_b_mapping = decoded.iter().any(|entry| {
        entry.original_line == b_line
            && entry.original_column >= b_col
            && entry.original_column <= b_col + 5
    });

    // At minimum, we should have mappings for the declarations
    assert!(
        has_a_mapping || has_b_mapping,
        "expected mappings for logical assignment declarations. mappings: {mappings}"
    );

    // Verify output contains the variable names
    assert!(
        output.contains("var a") || output.contains("var b") || output.contains("var c"),
        "expected output to contain variable declarations. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for logical assignment code"
    );
}

#[test]
fn test_source_map_bigint_literals() {
    // Test BigInt literals with n suffix
    let source = r#"const small = 123n;
const large = 9007199254740991n;
const hex = 0xFFFFFFFFFFFFFFFFn;
const binary = 0b1010n;
const sum = small + large;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the variable declarations
    let (small_line, small_col) = find_line_col(source, "const small");
    let has_small_mapping = decoded.iter().any(|entry| {
        entry.original_line == small_line
            && entry.original_column >= small_col
            && entry.original_column <= small_col + 11
    });

    let (large_line, large_col) = find_line_col(source, "const large");
    let has_large_mapping = decoded.iter().any(|entry| {
        entry.original_line == large_line
            && entry.original_column >= large_col
            && entry.original_column <= large_col + 11
    });

    // At minimum, we should have mappings for one of the declarations
    assert!(
        has_small_mapping || has_large_mapping,
        "expected mappings for BigInt declarations. mappings: {mappings}"
    );

    // Verify output contains the variable names
    assert!(
        output.contains("small") && output.contains("large"),
        "expected output to contain variable names. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for BigInt code"
    );
}

#[test]
fn test_source_map_class_static_blocks() {
    // Test class static blocks (ES2022)
    let source = r#"class Counter {
    static count = 0;
    static {
        Counter.count = 10;
        console.log("initialized");
    }
    static {
        Counter.count += 5;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the class declaration
    let (class_line, class_col) = find_line_col(source, "class Counter");
    let has_class_mapping = decoded.iter().any(|entry| {
        entry.original_line == class_line
            && entry.original_column >= class_col
            && entry.original_column <= class_col + 13
    });

    // Verify we have mappings for the static property
    let (count_line, count_col) = find_line_col(source, "static count");
    let has_count_mapping = decoded.iter().any(|entry| {
        entry.original_line == count_line
            && entry.original_column >= count_col
            && entry.original_column <= count_col + 12
    });

    // At minimum, we should have mappings for the class or static property
    assert!(
        has_class_mapping || has_count_mapping,
        "expected mappings for class with static blocks. mappings: {mappings}"
    );

    // Verify output contains the class name
    assert!(
        output.contains("Counter"),
        "expected output to contain class name. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class static blocks"
    );
}

#[test]
fn test_source_map_dynamic_import() {
    // Test dynamic import() expressions
    let source = r#"async function loadModule() {
    const mod = await import("./module");
    return mod.default;
}

const lazy = import("./lazy");
const conditional = true ? import("./a") : import("./b");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the async function
    let (func_line, func_col) = find_line_col(source, "async function loadModule");
    let has_func_mapping = decoded.iter().any(|entry| {
        entry.original_line == func_line
            && entry.original_column >= func_col
            && entry.original_column <= func_col + 25
    });

    // Verify we have mappings for the lazy variable
    let (lazy_line, lazy_col) = find_line_col(source, "const lazy");
    let has_lazy_mapping = decoded.iter().any(|entry| {
        entry.original_line == lazy_line
            && entry.original_column >= lazy_col
            && entry.original_column <= lazy_col + 10
    });

    // At minimum, we should have mappings for function or variable
    assert!(
        has_func_mapping || has_lazy_mapping,
        "expected mappings for dynamic import code. mappings: {mappings}"
    );

    // Verify output contains expected identifiers
    assert!(
        output.contains("loadModule") || output.contains("lazy"),
        "expected output to contain function or variable names. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for dynamic import"
    );
}

#[test]
fn test_source_map_rest_and_default_parameters() {
    // Test rest parameters (...args) and default parameters (x = value)
    let source = r#"function greet(name = "World", ...titles: string[]) {
    return titles.join(" ") + " " + name;
}

const sum = (a: number, b = 0, ...rest: number[]) => {
    return a + b + rest.reduce((x, y) => x + y, 0);
};

greet("Alice", "Dr.", "Prof.");
sum(1, 2, 3, 4, 5);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the function declaration
    let (greet_line, greet_col) = find_line_col(source, "function greet");
    let has_greet_mapping = decoded.iter().any(|entry| {
        entry.original_line == greet_line
            && entry.original_column >= greet_col
            && entry.original_column <= greet_col + 14
    });

    // Verify we have mappings for the arrow function
    let (sum_line, sum_col) = find_line_col(source, "const sum");
    let has_sum_mapping = decoded.iter().any(|entry| {
        entry.original_line == sum_line
            && entry.original_column >= sum_col
            && entry.original_column <= sum_col + 9
    });

    // At minimum, we should have mappings for function declarations
    assert!(
        has_greet_mapping || has_sum_mapping,
        "expected mappings for rest/default parameter functions. mappings: {mappings}"
    );

    // Verify output contains the function names
    assert!(
        output.contains("greet") && output.contains("sum"),
        "expected output to contain function names. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for rest/default parameters"
    );
}

#[test]
fn test_source_map_async_es5_offset_accuracy() {
    // Test source-map offset accuracy for async function ES5 downleveling
    // The __awaiter/__generator transform should preserve correct source mappings
    let source = r#"async function fetchData(url: string) {
    const response = await fetch(url);
    const data = await response.json();
    return data;
}

async function processItems(items: string[]) {
    for (const item of items) {
        await processItem(item);
    }
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify ES5 async transform was applied
    assert!(
        output.contains("__awaiter") || output.contains("__generator"),
        "expected async ES5 helpers in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for both async function declarations
    let (fetch_line, _) = find_line_col(source, "async function fetchData");
    let has_fetch_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == fetch_line);

    let (process_line, _) = find_line_col(source, "async function processItems");
    let has_process_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == process_line);

    // Verify we have mappings for await expressions
    let (await_fetch_line, _) = find_line_col(source, "await fetch");
    let has_await_fetch_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == await_fetch_line);

    let (await_json_line, _) = find_line_col(source, "await response.json");
    let has_await_json_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == await_json_line);

    // We should have mappings for both function declarations
    assert!(
        has_fetch_mapping && has_process_mapping,
        "expected mappings for both async function declarations. mappings: {mappings}"
    );

    // We should have mappings for await expression lines
    assert!(
        has_await_fetch_mapping || has_await_json_mapping,
        "expected mappings for await expression lines. mappings: {mappings}"
    );

    // Verify non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async ES5 code"
    );

    // Verify mappings span multiple source lines (not all on line 0)
    let unique_source_lines: std::collections::HashSet<_> =
        decoded.iter().map(|m| m.original_line).collect();
    assert!(
        unique_source_lines.len() >= 3,
        "expected mappings from at least 3 different source lines, got: {:?}",
        unique_source_lines
    );
}

#[test]
fn test_source_map_typescript_enums() {
    // Test TypeScript enum declarations (downleveled to IIFE)
    let source = r#"enum Color {
    Red,
    Green,
    Blue
}

enum Status {
    Active = 1,
    Inactive = 2,
    Pending = 3
}

const myColor = Color.Red;
const myStatus = Status.Active;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the enum declaration
    let (color_line, color_col) = find_line_col(source, "enum Color");
    let has_color_mapping = decoded.iter().any(|entry| {
        entry.original_line == color_line
            && entry.original_column >= color_col
            && entry.original_column <= color_col + 10
    });

    // Verify we have mappings for the variable declaration
    let (var_line, var_col) = find_line_col(source, "const myColor");
    let has_var_mapping = decoded.iter().any(|entry| {
        entry.original_line == var_line
            && entry.original_column >= var_col
            && entry.original_column <= var_col + 13
    });

    // At minimum, we should have mappings for enum or variable
    assert!(
        has_color_mapping || has_var_mapping,
        "expected mappings for enum declarations. mappings: {mappings}"
    );

    // Verify output contains the enum names
    assert!(
        output.contains("Color") && output.contains("Status"),
        "expected output to contain enum names. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for TypeScript enums"
    );
}

#[test]
fn test_source_map_generator_es5_offset_accuracy() {
    // Test source-map offset accuracy for generator function ES5 downleveling
    let source = r#"function* numberGenerator() {
    yield 1;
    yield 2;
    yield 3;
}

function* infiniteSequence() {
    let i = 0;
    while (true) {
        yield i++;
    }
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify generator function is in output (may be __generator helper or function* syntax)
    assert!(
        output.contains("__generator")
            || output.contains("numberGenerator")
            || output.contains("function*"),
        "expected generator function in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for generator function declarations
    let (num_gen_line, _) = find_line_col(source, "function* numberGenerator");
    let has_num_gen_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == num_gen_line);

    let (inf_seq_line, _) = find_line_col(source, "function* infiniteSequence");
    let has_inf_seq_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == inf_seq_line);

    // We should have mappings for both generator declarations
    assert!(
        has_num_gen_mapping || has_inf_seq_mapping,
        "expected mappings for generator function declarations. mappings: {mappings}"
    );

    // Verify non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator ES5 code"
    );

    // Verify mappings span multiple source lines
    let unique_source_lines: std::collections::HashSet<_> =
        decoded.iter().map(|m| m.original_line).collect();
    assert!(
        unique_source_lines.len() >= 2,
        "expected mappings from at least 2 different source lines, got: {:?}",
        unique_source_lines
    );
}

#[test]
fn test_source_map_destructuring_patterns() {
    // Test object and array destructuring patterns
    let source = r#"const obj = { a: 1, b: 2, c: 3 };
const { a, b: renamed, ...rest } = obj;

const arr = [1, 2, 3, 4, 5];
const [first, second, ...remaining] = arr;

function processPoint({ x, y }: { x: number; y: number }) {
    return x + y;
}

const swap = ([a, b]: [number, number]) => [b, a];

const result = processPoint({ x: 10, y: 20 });
const swapped = swap([1, 2]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the object declaration
    let (obj_line, obj_col) = find_line_col(source, "const obj");
    let has_obj_mapping = decoded.iter().any(|entry| {
        entry.original_line == obj_line
            && entry.original_column >= obj_col
            && entry.original_column <= obj_col + 9
    });

    // Verify we have mappings for the function declaration
    let (fn_line, fn_col) = find_line_col(source, "function processPoint");
    let has_fn_mapping = decoded.iter().any(|entry| {
        entry.original_line == fn_line
            && entry.original_column >= fn_col
            && entry.original_column <= fn_col + 21
    });

    // At minimum, we should have mappings for declarations
    assert!(
        has_obj_mapping || has_fn_mapping,
        "expected mappings for destructuring patterns. mappings: {mappings}"
    );

    // Verify output contains expected identifiers
    assert!(
        output.contains("processPoint") && output.contains("swap"),
        "expected output to contain function names. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for destructuring patterns"
    );
}

#[test]
fn test_source_map_private_class_fields() {
    // Test private class fields (#field) source map coverage
    let source = r#"class Counter {
    #count = 0;
    #name: string;

    constructor(name: string) {
        this.#name = name;
    }

    increment() {
        this.#count++;
        return this.#count;
    }

    get value() {
        return this.#count;
    }

    set value(n: number) {
        this.#count = n;
    }

    static #instances = 0;

    static create(name: string) {
        Counter.#instances++;
        return new Counter(name);
    }
}

const c = new Counter("test");
c.increment();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the class declaration
    let (class_line, class_col) = find_line_col(source, "class Counter");
    let has_class_mapping = decoded.iter().any(|entry| {
        entry.original_line == class_line
            && entry.original_column >= class_col
            && entry.original_column <= class_col + 13
    });

    // Verify we have mappings for method declarations
    let (inc_line, inc_col) = find_line_col(source, "increment()");
    let has_inc_mapping = decoded.iter().any(|entry| {
        entry.original_line == inc_line
            && entry.original_column >= inc_col
            && entry.original_column <= inc_col + 10
    });

    // At minimum, we should have mappings for class or methods
    assert!(
        has_class_mapping || has_inc_mapping || !decoded.is_empty(),
        "expected mappings for private class fields. mappings: {mappings}"
    );

    // Verify output contains Counter class name
    assert!(
        output.contains("Counter"),
        "expected output to contain class name. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private class fields"
    );
}

#[test]
fn test_source_map_class_static_block_mapping() {
    // Test source-map accuracy for class static blocks
    let source = r#"class Config {
    static initialized = false;
    static settings: Record<string, string> = {};

    static {
        Config.initialized = true;
        Config.settings["mode"] = "production";
    }

    static {
        console.log("Config loaded");
    }
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify class name is in output
    assert!(
        output.contains("Config"),
        "expected class name in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the class declaration
    let (class_line, _) = find_line_col(source, "class Config");
    let has_class_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == class_line);

    // Verify we have mappings for static properties
    let (initialized_line, _) = find_line_col(source, "static initialized");
    let has_initialized_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == initialized_line);

    // We should have mappings for the class and static members
    assert!(
        has_class_mapping || has_initialized_mapping,
        "expected mappings for class static blocks. mappings: {mappings}"
    );

    // Verify non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class static blocks"
    );

    // Verify we have mappings (at least one source line covered)
    let unique_source_lines: std::collections::HashSet<_> =
        decoded.iter().map(|m| m.original_line).collect();
    assert!(
        !unique_source_lines.is_empty(),
        "expected at least one source line covered in mappings, got: {:?}",
        unique_source_lines
    );
}

#[test]
fn test_source_map_nullish_coalescing() {
    // Test nullish coalescing operator (??) source map coverage
    let source = r#"const value1 = null ?? "default1";
const value2 = undefined ?? "default2";
const value3 = 0 ?? "not used";
const value4 = "" ?? "not used either";

function getValue(input: string | null | undefined) {
    return input ?? "fallback";
}

const nested = null ?? undefined ?? "final";

const obj = { prop: null };
const result = obj.prop ?? "missing";

const arr: (number | null)[] = [1, null, 3];
const mapped = arr.map(x => x ?? 0);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the const declarations
    let (value1_line, value1_col) = find_line_col(source, "const value1");
    let has_value1_mapping = decoded.iter().any(|entry| {
        entry.original_line == value1_line
            && entry.original_column >= value1_col
            && entry.original_column <= value1_col + 12
    });

    // Verify we have mappings for the function declaration
    let (fn_line, fn_col) = find_line_col(source, "function getValue");
    let has_fn_mapping = decoded.iter().any(|entry| {
        entry.original_line == fn_line
            && entry.original_column >= fn_col
            && entry.original_column <= fn_col + 17
    });

    // At minimum, we should have mappings for declarations
    assert!(
        has_value1_mapping || has_fn_mapping || !decoded.is_empty(),
        "expected mappings for nullish coalescing. mappings: {mappings}"
    );

    // Verify output contains expected identifiers
    assert!(
        output.contains("getValue") && output.contains("value1"),
        "expected output to contain function and variable names. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nullish coalescing"
    );
}

#[test]
fn test_source_map_template_literals() {
    // Test template literals with expressions source map coverage
    let source = r#"const name = "World";
const greeting = `Hello, ${name}!`;

const a = 10;
const b = 20;
const sum = `${a} + ${b} = ${a + b}`;

function format(items: string[]) {
    return `Items: ${items.join(", ")}`;
}

const nested = `outer ${`inner ${name}`}`;

const multiline = `
    Line 1
    Line 2: ${name}
    Line 3
`;

const tagged = String.raw`path\to\${name}`;

const result = format(["apple", "banana"]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the const declarations
    let (name_line, name_col) = find_line_col(source, "const name");
    let has_name_mapping = decoded.iter().any(|entry| {
        entry.original_line == name_line
            && entry.original_column >= name_col
            && entry.original_column <= name_col + 10
    });

    // Verify we have mappings for the function declaration
    let (fn_line, fn_col) = find_line_col(source, "function format");
    let has_fn_mapping = decoded.iter().any(|entry| {
        entry.original_line == fn_line
            && entry.original_column >= fn_col
            && entry.original_column <= fn_col + 15
    });

    // At minimum, we should have mappings for declarations
    assert!(
        has_name_mapping || has_fn_mapping || !decoded.is_empty(),
        "expected mappings for template literals. mappings: {mappings}"
    );

    // Verify output contains expected identifiers
    assert!(
        output.contains("format") && output.contains("greeting"),
        "expected output to contain function and variable names. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for template literals"
    );
}

#[test]
fn test_source_map_class_expressions() {
    // Test class expressions source map coverage
    let source = r#"const MyClass = class {
    value = 42;

    getValue() {
        return this.value;
    }
};

const NamedClass = class InternalName {
    static count = 0;

    constructor() {
        InternalName.count++;
    }
};

const factory = () => class {
    data: string;

    constructor(data: string) {
        this.data = data;
    }
};

const instance1 = new MyClass();
const instance2 = new NamedClass();
const DynamicClass = factory();
const instance3 = new DynamicClass("test");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the const declarations
    let (myclass_line, myclass_col) = find_line_col(source, "const MyClass");
    let has_myclass_mapping = decoded.iter().any(|entry| {
        entry.original_line == myclass_line
            && entry.original_column >= myclass_col
            && entry.original_column <= myclass_col + 13
    });

    // Verify we have mappings for the factory function
    let (factory_line, factory_col) = find_line_col(source, "const factory");
    let has_factory_mapping = decoded.iter().any(|entry| {
        entry.original_line == factory_line
            && entry.original_column >= factory_col
            && entry.original_column <= factory_col + 13
    });

    // At minimum, we should have mappings for declarations
    assert!(
        has_myclass_mapping || has_factory_mapping || !decoded.is_empty(),
        "expected mappings for class expressions. mappings: {mappings}"
    );

    // Verify output contains expected identifiers
    assert!(
        output.contains("MyClass") && output.contains("factory"),
        "expected output to contain class and function names. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expressions"
    );
}

#[test]
fn test_source_map_exponentiation_operator_mapping() {
    // Test source-map accuracy for exponentiation operator (**)
    let source = r#"const square = 2 ** 2;
const cube = 3 ** 3;
const power = base ** exponent;
let x = 2;
x **= 3;"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("square") && output.contains("cube"),
        "expected variable names in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for exponentiation operator"
    );
}

#[test]
fn test_source_map_rest_spread_mapping() {
    // Test source-map accuracy for rest parameters and spread arguments
    let source = r#"function sum(...numbers: number[]): number {
    return numbers.reduce((a, b) => a + b, 0);
}

const arr = [1, 2, 3];
const result = sum(...arr);

const [first, ...rest] = arr;
const { x, ...others } = { x: 1, y: 2, z: 3 };"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("sum") && output.contains("arr"),
        "expected function and variable names in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for rest/spread"
    );
}

#[test]
fn test_source_map_default_parameters_mapping() {
    // Test source-map accuracy for default parameter values
    let source = r#"function greet(name: string = "World", count: number = 1): string {
    return `Hello ${name}!`.repeat(count);
}

const add = (a: number = 0, b: number = 0) => a + b;

class Calculator {
    multiply(x: number = 1, y: number = 1): number {
        return x * y;
    }
}

function format(value: string, options: { uppercase?: boolean } = {}): string {
    return options.uppercase ? value.toUpperCase() : value;
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("greet") && output.contains("add") && output.contains("Calculator"),
        "expected function and class names in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the function declarations
    let (greet_line, _) = find_line_col(source, "function greet");
    let has_greet_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == greet_line);

    let (add_line, _) = find_line_col(source, "const add");
    let has_add_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == add_line);

    assert!(
        has_greet_mapping || has_add_mapping,
        "expected mappings for default parameter declarations. mappings: {mappings}"
    );

    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for default parameters"
    );

    let unique_source_lines: std::collections::HashSet<_> =
        decoded.iter().map(|m| m.original_line).collect();
    assert!(
        unique_source_lines.len() >= 3,
        "expected mappings from at least 3 different source lines, got: {:?}",
        unique_source_lines
    );
}

#[test]
fn test_source_map_arrow_functions() {
    // Test arrow functions source map coverage
    let source = r#"const add = (a: number, b: number) => a + b;

const square = (x: number) => x * x;

const identity = <T>(value: T) => value;

const multiLine = (x: number, y: number) => {
    const sum = x + y;
    const product = x * y;
    return { sum, product };
};

const nested = (a: number) => (b: number) => (c: number) => a + b + c;

const withThis = {
    value: 10,
    getValue: function() {
        return () => this.value;
    }
};

const arr = [1, 2, 3, 4, 5];
const doubled = arr.map(x => x * 2);
const filtered = arr.filter(x => x > 2);
const reduced = arr.reduce((acc, x) => acc + x, 0);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the const declarations
    let (add_line, add_col) = find_line_col(source, "const add");
    let has_add_mapping = decoded.iter().any(|entry| {
        entry.original_line == add_line
            && entry.original_column >= add_col
            && entry.original_column <= add_col + 9
    });

    // Verify we have mappings for multiLine function
    let (multi_line, multi_col) = find_line_col(source, "const multiLine");
    let has_multi_mapping = decoded.iter().any(|entry| {
        entry.original_line == multi_line
            && entry.original_column >= multi_col
            && entry.original_column <= multi_col + 15
    });

    // At minimum, we should have mappings for declarations
    assert!(
        has_add_mapping || has_multi_mapping || !decoded.is_empty(),
        "expected mappings for arrow functions. mappings: {mappings}"
    );

    // Verify output contains expected identifiers
    assert!(
        output.contains("multiLine") && output.contains("doubled"),
        "expected output to contain function and variable names. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow functions"
    );
}

#[test]
fn test_source_map_computed_property_names_mapping() {
    // Test source-map accuracy for computed property names
    let source = r#"const key = "dynamic";
const sym = Symbol("unique");

const obj = {
    [key]: "value1",
    [sym]: "value2",
    ["literal"]: "value3"
};

class MyClass {
    [key]: string = "field";

    [sym]() {
        return "method";
    }
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("key") && output.contains("obj") && output.contains("MyClass"),
        "expected variable and class names in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for computed property names"
    );
}

#[test]
fn test_source_map_shorthand_properties_mapping() {
    // Test source-map accuracy for shorthand property syntax
    let source = r#"const name = "John";
const age = 30;
const active = true;

const person = { name, age, active };

function createUser(id: number, email: string) {
    return { id, email, createdAt: Date.now() };
}

const coords = { x: 10, y: 20 };
const { x, y } = coords;

const merged = { ...coords, z: 30 };"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("name") && output.contains("person") && output.contains("createUser"),
        "expected variable and function names in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    let (name_line, _) = find_line_col(source, "const name");
    let has_name_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == name_line);

    let (person_line, _) = find_line_col(source, "const person");
    let has_person_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == person_line);

    assert!(
        has_name_mapping || has_person_mapping,
        "expected mappings for shorthand property declarations. mappings: {mappings}"
    );

    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for shorthand properties"
    );

    let unique_source_lines: std::collections::HashSet<_> =
        decoded.iter().map(|m| m.original_line).collect();
    assert!(
        unique_source_lines.len() >= 3,
        "expected mappings from at least 3 different source lines, got: {:?}",
        unique_source_lines
    );
}

#[test]
fn test_source_map_method_definitions_mapping() {
    // Test source-map accuracy for method definition syntax
    let source = r#"const calculator = {
    add(a: number, b: number): number {
        return a + b;
    },
    subtract(a: number, b: number): number {
        return a - b;
    },
    *generator() {
        yield 1;
        yield 2;
    },
    async fetchData() {
        return await Promise.resolve(42);
    },
    get value() {
        return this._value;
    },
    set value(v: number) {
        this._value = v;
    }
};

class Counter {
    private count = 0;

    increment(): void {
        this.count++;
    }

    decrement(): void {
        this.count--;
    }

    async loadAsync(): Promise<number> {
        return this.count;
    }
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("calculator") && output.contains("Counter") && output.contains("add"),
        "expected object and class names in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    let (calc_line, _) = find_line_col(source, "const calculator");
    let has_calc_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == calc_line);

    let (counter_line, _) = find_line_col(source, "class Counter");
    let has_counter_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == counter_line);

    assert!(
        has_calc_mapping || has_counter_mapping,
        "expected mappings for method definitions. mappings: {mappings}"
    );

    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for method definitions"
    );

    let unique_source_lines: std::collections::HashSet<_> =
        decoded.iter().map(|m| m.original_line).collect();
    assert!(
        unique_source_lines.len() >= 5,
        "expected mappings from at least 5 different source lines, got: {:?}",
        unique_source_lines
    );
}

#[test]
fn test_source_map_for_of_for_in_loops_mapping() {
    // Test source-map accuracy for for-of and for-in loops
    let source = r#"const numbers = [1, 2, 3, 4, 5];
const obj = { a: 1, b: 2, c: 3 };

for (const num of numbers) {
    console.log(num);
}

for (const key in obj) {
    console.log(key, obj[key]);
}

for (let i of [10, 20, 30]) {
    i *= 2;
    console.log(i);
}

const iterable = new Map([["x", 1], ["y", 2]]);
for (const [key, value] of iterable) {
    console.log(key, value);
}

async function processItems(items: number[]) {
    for await (const item of items) {
        console.log(item);
    }
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    assert!(
        output.contains("numbers") && output.contains("obj"),
        "expected variable names in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    let (numbers_line, _) = find_line_col(source, "const numbers");
    let has_numbers_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == numbers_line);

    let (for_of_line, _) = find_line_col(source, "for (const num of");
    let has_for_of_mapping = decoded
        .iter()
        .any(|m| m.source_index == 0 && m.original_line == for_of_line);

    assert!(
        has_numbers_mapping || has_for_of_mapping,
        "expected mappings for for-of/for-in loops. mappings: {mappings}"
    );

    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-of/for-in loops"
    );

    let unique_source_lines: std::collections::HashSet<_> =
        decoded.iter().map(|m| m.original_line).collect();
    assert!(
        unique_source_lines.len() >= 5,
        "expected mappings from at least 5 different source lines, got: {:?}",
        unique_source_lines
    );
}

#[test]
fn test_source_map_typescript_namespaces() {
    // Test source-map accuracy for TypeScript namespace declarations
    let source = r#"namespace MyNamespace {
    export const value = 42;

    export function greet(name: string): string {
        return "Hello, " + name;
    }

    export class Helper {
        static compute(x: number): number {
            return x * 2;
        }
    }
}

namespace Nested.Inner {
    export const nested = "inner value";
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the namespace declaration
    let (ns_line, ns_col) = find_line_col(source, "namespace MyNamespace");
    let has_ns_mapping = decoded.iter().any(|entry| {
        entry.original_line == ns_line
            && entry.original_column >= ns_col
            && entry.original_column <= ns_col + 20
    });

    // Verify we have mappings for the nested namespace
    let (nested_line, nested_col) = find_line_col(source, "namespace Nested");
    let has_nested_mapping = decoded.iter().any(|entry| {
        entry.original_line == nested_line
            && entry.original_column >= nested_col
            && entry.original_column <= nested_col + 16
    });

    // At minimum, we should have mappings for namespace declarations
    assert!(
        has_ns_mapping || has_nested_mapping || !decoded.is_empty(),
        "expected mappings for namespace declarations. mappings: {mappings}"
    );

    // Verify output contains namespace IIFE pattern
    assert!(
        output.contains("MyNamespace") || output.contains("var MyNamespace"),
        "expected output to contain namespace identifiers. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for TypeScript namespaces"
    );
}

#[test]
fn test_source_map_block_scoping_let_const_mapping() {
    // Test let/const to var transform source mapping
    let source = r#"let x = 1;
const y = 2;
let z = x + y;
console.log(z);"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify let/const are transformed to var
    assert!(
        output.contains("var x") || output.contains("var y") || output.contains("var z"),
        "expected let/const transformed to var in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the variable declarations
    let (let_line, _) = find_line_col(source, "let x");
    let has_let_mapping = decoded.iter().any(|entry| entry.original_line == let_line);

    let (const_line, _) = find_line_col(source, "const y");
    let has_const_mapping = decoded
        .iter()
        .any(|entry| entry.original_line == const_line);

    assert!(
        has_let_mapping || has_const_mapping || !decoded.is_empty(),
        "expected mappings for let/const declarations. mappings: {mappings}"
    );

    // Verify source index is consistent
    assert!(
        decoded.iter().all(|m| m.source_index == 0),
        "expected all mappings to reference source file index 0"
    );
}

#[test]
fn test_source_map_block_scoping_nested_blocks_mapping() {
    // Test nested block scoping with shadowing
    let source = r#"let x = 1;
{
    let x = 2;
    console.log(x);
}
console.log(x);"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have non-empty mappings for nested blocks
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested block scoping. output: {output}"
    );

    // Verify console.log is in output
    assert!(
        output.contains("console.log"),
        "expected console.log in output: {output}"
    );
}

#[test]
fn test_source_map_block_scoping_for_loop_mapping() {
    // Test for loop with let variable
    let source = r#"for (let i = 0; i < 10; i++) {
    console.log(i);
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify for loop is in output
    assert!(
        output.contains("for") && (output.contains("var i") || output.contains("let i")),
        "expected for loop with variable in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the for loop
    let (for_line, _) = find_line_col(source, "for (let i");
    let has_for_mapping = decoded.iter().any(|entry| entry.original_line == for_line);

    assert!(
        has_for_mapping || !decoded.is_empty(),
        "expected mappings for for loop with let. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_block_scoping_function_scope_mapping() {
    // Test function-scoped let/const
    let source = r#"function test() {
    let local = 1;
    const result = local * 2;
    return result;
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify function is in output
    assert!(
        output.contains("function test"),
        "expected function in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the function declaration
    let (func_line, _) = find_line_col(source, "function test");
    let has_func_mapping = decoded.iter().any(|entry| entry.original_line == func_line);

    assert!(
        has_func_mapping || !decoded.is_empty(),
        "expected mappings for function with let/const. mappings: {mappings}"
    );

    // Verify we have mappings covering multiple source lines
    let unique_source_lines: std::collections::HashSet<_> =
        decoded.iter().map(|m| m.original_line).collect();
    assert!(
        unique_source_lines.len() >= 2,
        "expected mappings from at least 2 different source lines, got: {:?}",
        unique_source_lines
    );
}

#[test]
fn test_source_map_enum_es5_string_enum_mapping() {
    // Test string enum transforms to IIFE pattern without reverse mapping
    let source = r#"enum Direction {
    Up = "UP",
    Down = "DOWN",
    Left = "LEFT",
    Right = "RIGHT"
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify string enum generates IIFE pattern
    assert!(
        output.contains("var Direction"),
        "expected var Direction declaration in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for string enum"
    );

    // Verify source index is consistent
    assert!(
        decoded.iter().all(|m| m.source_index == 0),
        "expected all mappings to reference source file index 0"
    );
}

#[test]
fn test_source_map_enum_es5_exported_enum_mapping() {
    // Test exported enum with source mapping
    let source = r#"export enum Status {
    Active = 1,
    Inactive = 0,
    Pending = 2
}

const current = Status.Active;"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify enum is in output
    assert!(
        output.contains("Status"),
        "expected Status enum in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the enum
    let (enum_line, _) = find_line_col(source, "enum Status");
    let has_enum_mapping = decoded.iter().any(|entry| entry.original_line == enum_line);

    assert!(
        has_enum_mapping || !decoded.is_empty(),
        "expected mappings for exported enum. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_enum_es5_computed_member_mapping() {
    // Test enum with computed member values
    let source = r#"enum Computed {
    A = 1,
    B = A * 2,
    C = 10
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify enum generates IIFE pattern
    assert!(
        output.contains("var Computed") || output.contains("Computed"),
        "expected Computed enum in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for computed enum members"
    );
}

#[test]
fn test_source_map_enum_es5_mixed_values_mapping() {
    // Test enum with mixed numeric and auto-increment values
    let source = r#"enum Mixed {
    First,
    Second,
    Third = 10,
    Fourth,
    Fifth = 100
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify enum IIFE pattern
    assert!(
        output.contains("var Mixed"),
        "expected var Mixed declaration in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the enum declaration
    let (enum_line, _) = find_line_col(source, "enum Mixed");
    let has_enum_mapping = decoded.iter().any(|entry| entry.original_line == enum_line);

    assert!(
        has_enum_mapping || !decoded.is_empty(),
        "expected mappings for enum with mixed values. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_commonjs_import_mapping() {
    // Test CommonJS import transform source mapping
    let source = r#"import { foo, bar } from "./module";
import * as utils from "./utils";
import defaultExport from "./default";

console.log(foo, bar, utils, defaultExport);"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify CommonJS require pattern
    assert!(
        output.contains("require") || output.contains("import"),
        "expected require or import in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for CommonJS imports"
    );

    // Verify source index is consistent
    assert!(
        decoded.iter().all(|m| m.source_index == 0),
        "expected all mappings to reference source file index 0"
    );
}

#[test]
fn test_source_map_commonjs_export_mapping() {
    // Test CommonJS export transform source mapping
    let source = r#"export const value = 42;
export function greet(name: string) {
    return "Hello " + name;
}
export class MyClass {
    constructor() {}
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify exports pattern
    assert!(
        output.contains("exports") || output.contains("export"),
        "expected exports in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for the export declarations
    let (value_line, _) = find_line_col(source, "export const value");
    let has_value_mapping = decoded
        .iter()
        .any(|entry| entry.original_line == value_line);

    let (func_line, _) = find_line_col(source, "export function greet");
    let has_func_mapping = decoded.iter().any(|entry| entry.original_line == func_line);

    assert!(
        has_value_mapping || has_func_mapping || !decoded.is_empty(),
        "expected mappings for CommonJS exports. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_commonjs_default_export_mapping() {
    // Test CommonJS default export transform source mapping
    let source = r#"const myValue = 100;

export default myValue;"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify default export or myValue in output
    assert!(
        output.contains("myValue") || output.contains("default"),
        "expected default export in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for default export"
    );
}

#[test]
fn test_source_map_commonjs_reexport_mapping() {
    // Test CommonJS re-export transform source mapping
    let source = r#"export { foo, bar } from "./module";
export * from "./utils";"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for re-exports
    let (reexport_line, _) = find_line_col(source, "export { foo");
    let has_reexport_mapping = decoded
        .iter()
        .any(|entry| entry.original_line == reexport_line);

    assert!(
        has_reexport_mapping || !decoded.is_empty(),
        "expected mappings for re-exports. mappings: {mappings} output: {output}"
    );
}

#[test]
fn test_source_map_type_assertions_and_const() {
    // Test source-map accuracy for type assertions and const assertions
    let source = r#"const value: unknown = "hello";
const str = value as string;
const num = <number>someValue;

const config = {
    name: "app",
    version: 1
} as const;

const colors = ["red", "green", "blue"] as const;

function process(input: unknown) {
    const data = input as { id: number; name: string };
    return data.id;
}

type Point = { x: number; y: number };
const origin = { x: 0, y: 0 } as Point;"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for variable declarations
    let (value_line, _) = find_line_col(source, "const value");
    let has_value_mapping = decoded
        .iter()
        .any(|entry| entry.original_line == value_line);

    let (config_line, _) = find_line_col(source, "const config");
    let has_config_mapping = decoded
        .iter()
        .any(|entry| entry.original_line == config_line);

    // At minimum, we should have mappings for declarations
    assert!(
        has_value_mapping || has_config_mapping || !decoded.is_empty(),
        "expected mappings for type assertions. mappings: {mappings}"
    );

    // Type assertions should be stripped from output
    assert!(
        !output.contains(" as string") && !output.contains(" as const"),
        "expected type assertions to be stripped. output: {output}"
    );

    // Verify source map has non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for type assertions"
    );
}

#[test]
fn test_source_map_jsx_element_mapping() {
    // Test JSX element source mapping
    let source = r#"const element = <div className="container">Hello</div>;"#;
    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let mut printer = ThinPrinter::with_options(&parser.arena, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify JSX is in output
    assert!(
        output.contains("<div") || output.contains("div"),
        "expected JSX element in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for JSX element"
    );

    // Verify source index is consistent
    assert!(
        decoded.iter().all(|m| m.source_index == 0),
        "expected all mappings to reference source file index 0"
    );
}

#[test]
fn test_source_map_jsx_fragment_mapping() {
    // Test JSX fragment source mapping
    let source = r#"const fragment = <>
    <span>First</span>
    <span>Second</span>
</>;"#;
    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let mut printer = ThinPrinter::with_options(&parser.arena, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify JSX fragment is in output
    assert!(
        output.contains("<>") || output.contains("Fragment") || output.contains("span"),
        "expected JSX fragment in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for JSX fragment"
    );
}

#[test]
fn test_source_map_jsx_expression_mapping() {
    // Test JSX with expressions source mapping
    let source = r#"const name = "World";
const greeting = <h1>Hello, {name}!</h1>;"#;
    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let mut printer = ThinPrinter::with_options(&parser.arena, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify JSX with expression is in output
    assert!(
        output.contains("name") && output.contains("h1"),
        "expected JSX expression in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have mappings for both declarations
    let (name_line, _) = find_line_col(source, "const name");
    let has_name_mapping = decoded.iter().any(|entry| entry.original_line == name_line);

    let (greeting_line, _) = find_line_col(source, "const greeting");
    let has_greeting_mapping = decoded
        .iter()
        .any(|entry| entry.original_line == greeting_line);

    assert!(
        has_name_mapping || has_greeting_mapping || !decoded.is_empty(),
        "expected mappings for JSX expressions. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_jsx_component_mapping() {
    // Test JSX component with props source mapping
    let source = r#"function Button({ onClick, children }: { onClick: () => void; children: React.ReactNode }) {
    return <button onClick={onClick}>{children}</button>;
}

const app = <Button onClick={() => console.log("clicked")}>Click me</Button>;"#;
    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let options = PrinterOptions::default();
    let mut printer = ThinPrinter::with_options(&parser.arena, options);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Verify component is in output
    assert!(
        output.contains("Button") && output.contains("button"),
        "expected JSX component in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify we have non-empty mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for JSX component"
    );

    // Verify mappings cover multiple source lines
    let unique_source_lines: std::collections::HashSet<_> =
        decoded.iter().map(|m| m.original_line).collect();
    assert!(
        unique_source_lines.len() >= 2,
        "expected mappings from at least 2 different source lines, got: {:?}",
        unique_source_lines
    );
}

#[test]
fn test_source_map_namespace_es5_basic_mapping() {
    // Basic namespace transforms to IIFE pattern
    let source = r#"namespace Foo {
    export const value = 42;
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("var Foo;"),
        "expected var Foo declaration in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for namespace"
    );
}

#[test]
fn test_source_map_namespace_es5_nested_mapping() {
    // Nested/qualified namespace A.B.C
    let source = r#"namespace A.B.C {
    export function greet() {
        return "hello";
    }
}"#;
    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("var A;") || output.contains("var A "),
        "expected var A declaration for nested namespace in output: {output}"
    );

    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");
    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested namespace"
    );
}

#[test]
fn test_source_map_class_decorator_single() {
    // Test single class decorator source mapping
    let source = r#"function Component(target: Function) {
    return target;
}

@Component
class MyComponent {
    render() {
        return "hello";
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains the class and decorator pattern
    assert!(
        output.contains("MyComponent") && output.contains("render"),
        "expected output to contain class and method. output: {output}"
    );

    // Verify we have source mappings that reference source file
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class decorator"
    );

    // Verify at least some mappings reference the source file (index 0)
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_class_decorator_multiple() {
    // Test multiple class decorators source mapping
    let source = r#"function Component(target: Function) {}
function Injectable(target: Function) {}
function Sealed(target: Function) {}

@Component
@Injectable
@Sealed
class Service {
    constructor() {}
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains the decorated class
    assert!(
        output.contains("Service"),
        "expected output to contain Service class. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple class decorators"
    );

    // Verify at least some mappings reference the source file (index 0)
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_method_decorator_single() {
    // Test single method decorator source mapping
    let source = r#"function Log(target: any, key: string, descriptor: PropertyDescriptor) {
    return descriptor;
}

class Logger {
    @Log
    log(message: string) {
        console.log(message);
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains the class and method
    assert!(
        output.contains("Logger") && output.contains("log"),
        "expected output to contain Logger class and log method. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for method decorator"
    );

    // Verify at least some mappings reference the source file (index 0)
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_method_decorator_multiple() {
    // Test multiple method decorators source mapping
    let source = r#"function Bind(target: any, key: string, descriptor: PropertyDescriptor) {}
function Memoize(target: any, key: string, descriptor: PropertyDescriptor) {}
function Validate(target: any, key: string, descriptor: PropertyDescriptor) {}

class Calculator {
    @Bind
    @Memoize
    @Validate
    calculate(x: number, y: number) {
        return x + y;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains the class and method
    assert!(
        output.contains("Calculator") && output.contains("calculate"),
        "expected output to contain Calculator class and calculate method. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple method decorators"
    );

    // Verify at least some mappings reference the source file (index 0)
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_parameter_decorator() {
    // Test parameter decorator source mapping
    let source = r#"function Inject(target: any, key: string, index: number) {}

class Container {
    constructor(@Inject service: any) {}
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains the class
    assert!(
        output.contains("Container"),
        "expected output to contain Container class. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for parameter decorator"
    );

    // Verify at least some mappings reference the source file (index 0)
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_parameter_decorator_multiple_params() {
    // Test multiple parameter decorators on different parameters
    let source = r#"function Required(target: any, key: string, index: number) {}
function Optional(target: any, key: string, index: number) {}

class Service {
    process(@Required input: string, @Optional options?: object) {
        return input;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains the class (process may be transformed/elided)
    assert!(
        output.contains("Service"),
        "expected output to contain Service class. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple parameter decorators"
    );

    // Verify at least some mappings reference the source file (index 0)
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_property_decorator() {
    // Test property decorator source mapping
    let source = r#"function Column(target: any, key: string) {}
function PrimaryKey(target: any, key: string) {}

class Entity {
    @PrimaryKey
    id: number = 0;

    @Column
    name: string = "";
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains the class
    assert!(
        output.contains("Entity"),
        "expected output to contain Entity class. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for property decorators"
    );

    // Verify at least some mappings reference the source file (index 0)
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_accessor_decorator() {
    // Test accessor (getter/setter) decorator source mapping
    let source = r#"function Cached(target: any, key: string, descriptor: PropertyDescriptor) {}
function Validate(target: any, key: string, descriptor: PropertyDescriptor) {}

class Config {
    private _value: number = 0;

    @Cached
    get value(): number {
        return this._value;
    }

    @Validate
    set value(v: number) {
        this._value = v;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains the class and accessors
    assert!(
        output.contains("Config") && output.contains("value"),
        "expected output to contain Config class and value accessor. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for accessor decorators"
    );

    // Verify at least some mappings reference the source file (index 0)
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_decorator_factory() {
    // Test decorator factory (decorator with arguments) source mapping
    let source = r#"function Route(path: string) {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {};
}

function Method(method: string) {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {};
}

class Controller {
    @Route("/api/users")
    @Method("GET")
    getUsers() {
        return [];
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains the class and method
    assert!(
        output.contains("Controller") && output.contains("getUsers"),
        "expected output to contain Controller class and getUsers method. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for decorator factories"
    );

    // Verify at least some mappings reference the source file (index 0)
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_mixed_decorators() {
    // Test class with class, method, property, and parameter decorators
    let source = r#"function Entity(target: Function) {}
function Column(target: any, key: string) {}
function BeforeInsert(target: any, key: string, descriptor: PropertyDescriptor) {}
function Inject(target: any, key: string, index: number) {}

@Entity
class User {
    @Column
    name: string = "";

    @BeforeInsert
    validate(@Inject validator: any) {
        return true;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains the class (validate may be transformed/elided)
    assert!(
        output.contains("User"),
        "expected output to contain User class. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for mixed decorators"
    );

    // Verify at least some mappings reference the source file (index 0)
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file. mappings: {mappings}"
    );
}

#[test]
fn test_source_map_async_multiple_awaits() {
    // Test async function with multiple await expressions in sequence
    let source = r#"async function processAll(a: Promise<number>, b: Promise<string>, c: Promise<boolean>) {
    const numResult = await a;
    const strResult = await b;
    const boolResult = await c;
    return { numResult, strResult, boolResult };
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains async transform helpers
    assert!(
        output.contains("__awaiter") || output.contains("__generator"),
        "expected async downlevel output. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple awaits"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_try_catch() {
    // Test async function with try/catch around await
    let source = r#"async function safeFetch(url: string) {
    try {
        const response = await fetch(url);
        return await response.json();
    } catch (error) {
        console.error(error);
        return null;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains async transform and try/catch
    assert!(
        output.contains("__awaiter") || output.contains("__generator"),
        "expected async downlevel output. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async try/catch"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_for_of_loop() {
    // Test async function with await inside for...of loop
    let source = r#"async function processItems(items: Promise<number>[]) {
    const results: number[] = [];
    for (const item of items) {
        const value = await item;
        results.push(value);
    }
    return results;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains async transform
    assert!(
        output.contains("__awaiter") || output.contains("__generator"),
        "expected async downlevel output. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async for-of loop"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_iife() {
    // Test async IIFE (Immediately Invoked Function Expression)
    let source = r#"const result = (async () => {
    const data = await fetchData();
    return data.value;
})();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains result variable
    assert!(
        output.contains("result"),
        "expected output to contain result variable. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async IIFE"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_rest_params() {
    // Test async function with rest parameters
    let source = r#"async function processMany(...promises: Promise<number>[]) {
    const results: number[] = [];
    for (const p of promises) {
        results.push(await p);
    }
    return results;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("processMany"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async rest params"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_default_params() {
    // Test async function with default parameters
    let source = r#"async function fetchWithTimeout(url: string, timeout: number = 5000) {
    const controller = new AbortController();
    setTimeout(() => controller.abort(), timeout);
    return await fetch(url, { signal: controller.signal });
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("fetchWithTimeout"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async default params"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_destructuring_await() {
    // Test async function with destructuring of awaited value
    let source = r#"async function getUser(id: number) {
    const { name, email, age } = await fetchUser(id);
    return { name, email, age };
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("getUser"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async destructuring"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_nested_functions() {
    // Test nested async functions
    let source = r#"async function outer() {
    async function inner(value: number) {
        return await Promise.resolve(value * 2);
    }
    const result = await inner(21);
    return result;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains both function names
    assert!(
        output.contains("outer") && output.contains("inner"),
        "expected output to contain both function names. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested async functions"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_class_static_method() {
    // Test async static class method
    let source = r#"class DataService {
    static async fetchAll() {
        const items = await getItems();
        return items;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("DataService"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async static method"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_while_loop() {
    // Test async function with await in while loop
    let source = r#"async function pollUntilDone(checkStatus: () => Promise<boolean>) {
    while (!(await checkStatus())) {
        await delay(1000);
    }
    return true;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("pollUntilDone"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async while loop"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// ES5 Class Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_es5_class_basic_iife() {
    // Test basic class lowered to ES5 IIFE pattern
    let source = r#"class Point {
    x: number;
    y: number;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name as function
    assert!(
        output.contains("Point"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ES5 class IIFE"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_es5_class_constructor() {
    // Test class with constructor lowered to ES5
    let source = r#"class Rectangle {
    width: number;
    height: number;
    constructor(w: number, h: number) {
        this.width = w;
        this.height = h;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name and property assignments
    assert!(
        output.contains("Rectangle"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ES5 class constructor"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_es5_class_instance_methods() {
    // Test class with instance methods lowered to ES5
    let source = r#"class Calculator {
    add(a: number, b: number): number {
        return a + b;
    }
    subtract(a: number, b: number): number {
        return a - b;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class and method names
    assert!(
        output.contains("Calculator"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ES5 class instance methods"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_es5_class_static_methods() {
    // Test class with static methods lowered to ES5
    let source = r#"class MathUtils {
    static PI: number = 3.14159;
    static square(x: number): number {
        return x * x;
    }
    static cube(x: number): number {
        return x * x * x;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class and static members
    assert!(
        output.contains("MathUtils"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ES5 class static methods"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_es5_class_accessors() {
    // Test class with getters and setters lowered to ES5
    let source = r#"class Person {
    private _name: string = "";
    get name(): string {
        return this._name;
    }
    set name(value: string) {
        this._name = value;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Person"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ES5 class accessors"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_es5_class_inheritance() {
    // Test class inheritance lowered to ES5 with __extends
    let source = r#"class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
}
class Dog extends Animal {
    breed: string;
    constructor(name: string, breed: string) {
        super(name);
        this.breed = breed;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains both class names
    assert!(
        output.contains("Animal") && output.contains("Dog"),
        "expected output to contain class names. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ES5 class inheritance"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_es5_class_super_method_call() {
    // Test super method calls in derived class lowered to ES5
    let source = r#"class Base {
    greet(): string {
        return "Hello";
    }
}
class Derived extends Base {
    greet(): string {
        return super.greet() + " World";
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class names
    assert!(
        output.contains("Base") && output.contains("Derived"),
        "expected output to contain class names. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ES5 super method call"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_es5_class_computed_property() {
    // Test class with computed property names lowered to ES5
    let source = r#"const methodName = "dynamicMethod";
class DynamicClass {
    [methodName](): string {
        return "dynamic";
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("DynamicClass"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ES5 computed property"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_es5_class_multiple_inheritance_levels() {
    // Test multi-level inheritance chain lowered to ES5
    let source = r#"class GrandParent {
    level(): number { return 1; }
}
class Parent extends GrandParent {
    level(): number { return 2; }
}
class Child extends Parent {
    level(): number { return 3; }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains all class names
    assert!(
        output.contains("GrandParent") && output.contains("Parent") && output.contains("Child"),
        "expected output to contain all class names. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ES5 multi-level inheritance"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_es5_class_expression() {
    // Test class expressions lowered to ES5
    let source = r#"const MyClass = class {
    value: number = 42;
    getValue(): number {
        return this.value;
    }
};"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("MyClass"),
        "expected output to contain class expression variable. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ES5 class expression"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Generator Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_generator_basic_yield() {
    // Test basic generator function with single yield
    let source = r#"function* simpleGenerator() {
    yield 1;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains generator function name
    assert!(
        output.contains("simpleGenerator"),
        "expected output to contain generator function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic generator"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_multiple_yields() {
    // Test generator function with multiple yield statements
    let source = r#"function* multiYield() {
    yield 1;
    yield 2;
    yield 3;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains generator function name
    assert!(
        output.contains("multiYield"),
        "expected output to contain generator function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multi-yield generator"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_yield_in_loop() {
    // Test generator with yield inside a loop
    let source = r#"function* loopGenerator(max: number) {
    for (let i = 0; i < max; i++) {
        yield i;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains generator function name
    assert!(
        output.contains("loopGenerator"),
        "expected output to contain generator function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for loop generator"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_yield_delegation() {
    // Test generator with yield* (delegation)
    let source = r#"function* inner() {
    yield 1;
    yield 2;
}
function* outer() {
    yield* inner();
    yield 3;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains both generator function names
    assert!(
        output.contains("inner") && output.contains("outer"),
        "expected output to contain both generator function names. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for yield delegation"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_with_return() {
    // Test generator function with return value
    let source = r#"function* generatorWithReturn() {
    yield 1;
    yield 2;
    return "done";
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains generator function name
    assert!(
        output.contains("generatorWithReturn"),
        "expected output to contain generator function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator with return"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_class_method() {
    // Test generator as class method
    let source = r#"class Counter {
    *count(max: number) {
        for (let i = 1; i <= max; i++) {
            yield i;
        }
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Counter"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator class method"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_try_catch() {
    // Test generator with try/catch block
    let source = r#"function* safeGenerator() {
    try {
        yield 1;
        yield 2;
    } catch (e) {
        yield -1;
    } finally {
        yield 0;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains generator function name
    assert!(
        output.contains("safeGenerator"),
        "expected output to contain generator function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator with try/catch"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_with_parameters() {
    // Test generator function with typed parameters
    let source = r#"function* rangeGenerator(start: number, end: number, step: number = 1) {
    for (let i = start; i < end; i += step) {
        yield i;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains generator function name
    assert!(
        output.contains("rangeGenerator"),
        "expected output to contain generator function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator with parameters"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_object_yield() {
    // Test generator yielding objects
    let source = r#"interface Item { id: number; name: string; }
function* itemGenerator(): Generator<Item> {
    yield { id: 1, name: "first" };
    yield { id: 2, name: "second" };
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains generator function name
    assert!(
        output.contains("itemGenerator"),
        "expected output to contain generator function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator yielding objects"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_expression() {
    // Test generator expression assigned to variable
    let source = r#"const fibonacci = function* () {
    let a = 0, b = 1;
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
};"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("fibonacci"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator expression"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Namespace Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_namespace_with_function() {
    // Test namespace with function declarations
    let source = r#"namespace Utils {
    export function add(a: number, b: number): number {
        return a + b;
    }
    export function subtract(a: number, b: number): number {
        return a - b;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains namespace name
    assert!(
        output.contains("Utils"),
        "expected output to contain namespace name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for namespace with functions"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_namespace_with_class() {
    // Test namespace with class declaration
    let source = r#"namespace Models {
    export class User {
        name: string;
        constructor(name: string) {
            this.name = name;
        }
        greet(): string {
            return "Hello, " + this.name;
        }
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains namespace and class names
    assert!(
        output.contains("Models"),
        "expected output to contain namespace name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for namespace with class"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_namespace_with_enum() {
    // Test namespace with enum declaration
    let source = r#"namespace Constants {
    export enum Color {
        Red = 0,
        Green = 1,
        Blue = 2
    }
    export enum Size {
        Small = "S",
        Medium = "M",
        Large = "L"
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains namespace name
    assert!(
        output.contains("Constants"),
        "expected output to contain namespace name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for namespace with enum"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_nested_namespace_dot_notation() {
    // Test nested namespace using dot notation (A.B.C)
    let source = r#"namespace Company.Department.Team {
    export const name = "Engineering";
    export function getInfo(): string {
        return name;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains top-level namespace name
    assert!(
        output.contains("Company"),
        "expected output to contain namespace name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested namespace"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_namespace_merging() {
    // Test namespace merging with multiple declarations
    let source = r#"namespace Merged {
    export function first(): number {
        return 1;
    }
}
namespace Merged {
    export function second(): number {
        return 2;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains namespace name
    assert!(
        output.contains("Merged"),
        "expected output to contain namespace name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for merged namespace"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_namespace_with_variables() {
    // Test namespace with const and let variables
    let source = r#"namespace Config {
    export const VERSION = "1.0.0";
    export const DEBUG = true;
    export let counter = 0;
    export function increment(): number {
        return ++counter;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains namespace name
    assert!(
        output.contains("Config"),
        "expected output to contain namespace name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for namespace with variables"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_exported_namespace() {
    // Test exported namespace
    let source = r#"export namespace API {
    export interface Request {
        url: string;
    }
    export function fetch(url: string): void {
        console.log(url);
    }
    export class Client {
        baseUrl: string;
        constructor(base: string) {
            this.baseUrl = base;
        }
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains namespace name
    assert!(
        output.contains("API"),
        "expected output to contain namespace name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for exported namespace"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_namespace_nested_declaration() {
    // Test namespace with nested namespace declaration
    let source = r#"namespace Outer {
    export namespace Inner {
        export function helper(): string {
            return "inner helper";
        }
    }
    export function outerFunc(): string {
        return Inner.helper();
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains both namespace names
    assert!(
        output.contains("Outer"),
        "expected output to contain outer namespace name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested namespace declaration"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_namespace_with_interface_only() {
    // Test namespace with only interfaces (should compile to minimal output)
    let source = r#"namespace Types {
    export interface User {
        id: number;
        name: string;
    }
    export interface Product {
        sku: string;
        price: number;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Interfaces are type-only, so namespace may be empty or have minimal output
    // Just verify the source map was generated correctly
    assert!(
        map_json.contains("\"version\":3"),
        "expected valid source map. map: {map_json}"
    );

    // Even with type-only content, we should have valid mappings structure
    assert!(
        mappings.is_empty() || !decoded.is_empty(),
        "expected either empty or valid mappings"
    );
}

#[test]
fn test_source_map_namespace_mixed_content() {
    // Test namespace with mixed content (functions, classes, enums, interfaces)
    let source = r#"namespace Mixed {
    export interface Config {
        debug: boolean;
    }
    export enum Level {
        Low = 1,
        High = 2
    }
    export class Handler {
        level: Level;
        constructor(lvl: Level) {
            this.level = lvl;
        }
    }
    export function process(cfg: Config): void {
        console.log(cfg.debug);
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains namespace name
    assert!(
        output.contains("Mixed"),
        "expected output to contain namespace name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for mixed namespace content"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Spread and Rest Parameter Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_rest_parameter_function() {
    // Test rest parameter in regular function
    let source = r#"function sum(...numbers: number[]): number {
    return numbers.reduce((a, b) => a + b, 0);
}
const result = sum(1, 2, 3, 4, 5);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("sum"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for rest parameter function"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_rest_parameter_arrow() {
    // Test rest parameter in arrow function
    let source = r#"const concat = (...strings: string[]): string => {
    return strings.join("");
};
const greeting = concat("Hello", " ", "World");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("concat"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for rest parameter arrow"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_function_call() {
    // Test spread in function call arguments
    let source = r#"function multiply(a: number, b: number, c: number): number {
    return a * b * c;
}
const nums = [2, 3, 4];
const product = multiply(...nums);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("multiply"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for spread function call"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_array_literal() {
    // Test spread in array literal
    let source = r#"const first = [1, 2, 3];
const second = [4, 5, 6];
const combined = [...first, ...second, 7, 8, 9];"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("combined"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for spread array literal"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_object_literal() {
    // Test spread in object literal
    let source = r#"const defaults = { theme: "dark", size: "medium" };
const overrides = { size: "large", color: "blue" };
const merged = { ...defaults, ...overrides, custom: true };"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("merged"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for spread object literal"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_rest_array_destructuring() {
    // Test rest in array destructuring
    let source = r#"const numbers = [1, 2, 3, 4, 5];
const [first, second, ...remaining] = numbers;
console.log(first, second, remaining);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("numbers"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for rest array destructuring"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_rest_object_destructuring() {
    // Test rest in object destructuring
    let source = r#"const person = { name: "John", age: 30, city: "NYC", job: "dev" };
const { name, age, ...details } = person;
console.log(name, age, details);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("person"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for rest object destructuring"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_rest_parameter_class_method() {
    // Test rest parameter in class method
    let source = r#"class Logger {
    log(level: string, ...messages: string[]): void {
        console.log(level, ...messages);
    }
    error(...errors: Error[]): void {
        errors.forEach(e => console.error(e));
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Logger"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for rest parameter class method"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_new_expression() {
    // Test spread in new expression
    let source = r#"class Point {
    constructor(public x: number, public y: number, public z: number) {}
}
const coords = [1, 2, 3];
const point = new Point(...coords);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Point"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for spread new expression"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_combined_rest_spread() {
    // Test combined rest parameters and spread operators
    let source = r#"function merge<T>(...arrays: T[][]): T[] {
    return arrays.reduce((acc, arr) => [...acc, ...arr], []);
}
const a = [1, 2];
const b = [3, 4];
const c = [5, 6];
const result = merge(a, b, c);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("merge"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined rest spread"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Template Literal Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_template_literal_simple() {
    // Test simple template literal without expressions
    let source = r#"const message = `Hello, World!`;
console.log(message);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("message"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for simple template literal"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_with_expression() {
    // Test template literal with single expression
    let source = r#"const name = "Alice";
const greeting = `Hello, ${name}!`;
console.log(greeting);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("greeting"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for template literal with expression"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_multiple_expressions() {
    // Test template literal with multiple expressions
    let source = r#"const firstName = "John";
const lastName = "Doe";
const age = 30;
const info = `Name: ${firstName} ${lastName}, Age: ${age}`;
console.log(info);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("info"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for template literal with multiple expressions"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_nested() {
    // Test nested template literals
    let source = r#"const inner = "world";
const outer = `Hello, ${`dear ${inner}`}!`;
console.log(outer);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("outer"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested template literal"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_tagged_template_literal() {
    // Test tagged template literal
    let source = r#"function highlight(strings: TemplateStringsArray, ...values: any[]): string {
    return strings.reduce((acc, str, i) => acc + str + (values[i] || ""), "");
}
const name = "TypeScript";
const result = highlight`Language: ${name}`;
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("highlight"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for tagged template literal"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_in_function() {
    // Test template literal used in function arguments
    let source = r#"function greet(message: string): void {
    console.log(message);
}
const user = "Bob";
greet(`Welcome, ${user}! Enjoy your stay.`);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("greet"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for template literal in function"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_with_method_calls() {
    // Test template literal with method call expressions
    let source = r#"const text = "hello";
const result = `Uppercase: ${text.toUpperCase()}, Length: ${text.length}`;
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("result"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for template literal with method calls"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_conditional() {
    // Test template literal with conditional expressions
    let source = r#"const score = 85;
const grade = `Grade: ${score >= 90 ? "A" : score >= 80 ? "B" : "C"}`;
console.log(grade);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("grade"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for template literal with conditional"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_multiline() {
    // Test multi-line template literal
    let source = r#"const title = "Report";
const content = `
===== ${title} =====
Generated at: ${new Date().toISOString()}
Status: Complete
`;
console.log(content);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("content"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiline template literal"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_in_class() {
    // Test template literal in class methods
    let source = r#"class Formatter {
    private prefix: string;
    constructor(prefix: string) {
        this.prefix = prefix;
    }
    format(value: string): string {
        return `${this.prefix}: ${value}`;
    }
}
const fmt = new Formatter("LOG");
console.log(fmt.format("test message"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Formatter"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for template literal in class"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Destructuring Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_destructuring_object_basic() {
    // Test basic object destructuring
    let source = r#"const obj = { a: 1, b: 2, c: 3 };
const { a, b, c } = obj;
console.log(a, b, c);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("obj"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for object destructuring"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_array_basic() {
    // Test basic array destructuring
    let source = r#"const arr = [1, 2, 3];
const [first, second, third] = arr;
console.log(first, second, third);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("arr"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for array destructuring"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_object_with_rename() {
    // Test object destructuring with property renaming
    let source = r#"const person = { firstName: "John", lastName: "Doe" };
const { firstName: first, lastName: last } = person;
console.log(first, last);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("person"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for object destructuring with rename"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_array_with_skip() {
    // Test array destructuring with skipped elements
    let source = r#"const numbers = [1, 2, 3, 4, 5];
const [first, , third, , fifth] = numbers;
console.log(first, third, fifth);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("numbers"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for array destructuring with skip"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_nested_object() {
    // Test nested object destructuring
    let source = r#"const user = {
    name: "John",
    address: { city: "NYC", zip: "10001" }
};
const { name, address: { city, zip } } = user;
console.log(name, city, zip);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("user"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested object destructuring"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_nested_array() {
    // Test nested array destructuring
    let source = r#"const matrix = [[1, 2], [3, 4], [5, 6]];
const [[a, b], [c, d]] = matrix;
console.log(a, b, c, d);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("matrix"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested array destructuring"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_object_with_defaults() {
    // Test object destructuring with default values
    let source = r#"const config = { host: "localhost" };
const { host, port = 3000, protocol = "http" } = config;
console.log(host, port, protocol);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("config"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for object destructuring with defaults"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_array_with_defaults() {
    // Test array destructuring with default values
    let source = r#"const partial = [1];
const [x = 0, y = 0, z = 0] = partial;
console.log(x, y, z);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("partial"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for array destructuring with defaults"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_function_params() {
    // Test destructuring in function parameters
    let source = r#"function processUser({ name, age }: { name: string, age: number }) {
    console.log(name, age);
}
function processCoords([x, y]: [number, number]) {
    console.log(x, y);
}
processUser({ name: "John", age: 30 });
processCoords([10, 20]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function names
    assert!(
        output.contains("processUser"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for destructuring in function params"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_mixed() {
    // Test mixed object and array destructuring
    let source = r#"const data = {
    items: [1, 2, 3],
    meta: { count: 3, page: 1 }
};
const { items: [first, second], meta: { count } } = data;
console.log(first, second, count);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("data"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for mixed destructuring"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Optional Chaining Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_optional_chaining_property_access() {
    // Test optional chaining property access
    let source = r#"const user = { name: "John", address: { city: "NYC" } };
const city = user?.address?.city;
console.log(city);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("user"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for optional chaining property access"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_optional_chaining_method_call() {
    // Test optional chaining method call
    let source = r#"const obj = {
    greet: function(name: string) { return "Hello " + name; }
};
const result = obj?.greet?.("World");
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("obj"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for optional chaining method call"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_optional_chaining_element_access() {
    // Test optional chaining element access
    let source = r#"const arr = [1, 2, 3];
const item = arr?.[0];
const obj = { items: ["a", "b", "c"] };
const val = obj?.items?.[1];
console.log(item, val);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("arr"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for optional chaining element access"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_optional_chaining_nested() {
    // Test deeply nested optional chaining
    let source = r#"const data = {
    level1: {
        level2: {
            level3: {
                value: 42
            }
        }
    }
};
const result = data?.level1?.level2?.level3?.value;
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("data"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested optional chaining"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_optional_chaining_with_nullish_coalescing() {
    // Test optional chaining with nullish coalescing
    let source = r#"const config = { timeout: null };
const timeout = config?.timeout ?? 3000;
const host = config?.host ?? "localhost";
console.log(timeout, host);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("config"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for optional chaining with nullish coalescing"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_optional_chaining_in_function() {
    // Test optional chaining inside function
    let source = r#"function getCity(user: { address?: { city?: string } } | null) {
    return user?.address?.city ?? "Unknown";
}
const result = getCity({ address: { city: "NYC" } });
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("getCity"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for optional chaining in function"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_optional_chaining_with_method_chain() {
    // Test optional chaining with method chaining
    let source = r#"const str = "hello";
const result = str?.toUpperCase?.()?.toLowerCase?.();
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("str"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for optional chaining with method chain"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_optional_chaining_delete() {
    // Test optional chaining with delete
    let source = r#"const obj: { prop?: string } = { prop: "value" };
delete obj?.prop;
console.log(obj);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("obj"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for optional chaining delete"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_optional_chaining_call_expression() {
    // Test optional chaining with call expression
    let source = r#"const fn: (() => number) | undefined = () => 42;
const result = fn?.();
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("fn"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for optional chaining call expression"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_optional_chaining_combined() {
    // Test combined optional chaining patterns
    let source = r#"interface User {
    profile?: {
        getName?: () => string;
        settings?: { theme?: string }[];
    };
}
const user: User = {};
const name = user?.profile?.getName?.() ?? "Anonymous";
const theme = user?.profile?.settings?.[0]?.theme ?? "light";
console.log(name, theme);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("user"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined optional chaining"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Nullish Coalescing Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_nullish_coalescing_basic() {
    // Test basic nullish coalescing
    let source = r#"const value = null;
const result = value ?? "default";
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("value"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic nullish coalescing"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_nullish_coalescing_with_null() {
    // Test nullish coalescing with explicit null
    let source = r#"function getValue(): string | null {
    return null;
}
const result = getValue() ?? "fallback";
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("getValue"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nullish coalescing with null"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_nullish_coalescing_with_undefined() {
    // Test nullish coalescing with undefined
    let source = r#"const config: { port?: number } = {};
const port = config.port ?? 8080;
console.log(port);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("config"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nullish coalescing with undefined"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_nullish_coalescing_chained() {
    // Test chained nullish coalescing
    let source = r#"const a: string | null = null;
const b: string | undefined = undefined;
const c = "final";
const result = a ?? b ?? c;
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("result"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for chained nullish coalescing"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_nullish_coalescing_with_function_call() {
    // Test nullish coalescing with function call as fallback
    let source = r#"function getDefault(): string {
    return "default value";
}
const input: string | null = null;
const result = input ?? getDefault();
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("getDefault"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nullish coalescing with function call"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_nullish_coalescing_assignment() {
    // Test nullish coalescing assignment operator
    let source = r#"let value: number | null = null;
value ??= 42;
console.log(value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("value"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nullish coalescing assignment"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_nullish_coalescing_in_conditional() {
    // Test nullish coalescing in conditional expression
    let source = r#"const input: number | null = null;
const threshold = 10;
const result = (input ?? 0) > threshold ? "above" : "below";
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("threshold"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nullish coalescing in conditional"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_nullish_coalescing_with_objects() {
    // Test nullish coalescing with object fallback
    let source = r#"const defaults = { host: "localhost", port: 3000 };
const config: { host?: string; port?: number } | null = null;
const merged = config ?? defaults;
console.log(merged.host, merged.port);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("defaults"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nullish coalescing with objects"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_nullish_coalescing_in_function() {
    // Test nullish coalescing in function body
    let source = r#"function greet(name: string | null | undefined): string {
    const displayName = name ?? "Guest";
    return "Hello, " + displayName;
}
const message = greet(null);
console.log(message);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("greet"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nullish coalescing in function"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_nullish_coalescing_combined() {
    // Test combined nullish coalescing patterns
    let source = r#"interface Config {
    api?: {
        endpoint?: string;
        timeout?: number;
    };
}
const userConfig: Config = {};
const endpoint = userConfig.api?.endpoint ?? "https://api.example.com";
const timeout = userConfig.api?.timeout ?? 5000;
let retries: number | null = null;
retries ??= 3;
console.log(endpoint, timeout, retries);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("userConfig"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined nullish coalescing"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Logical Assignment Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_logical_and_assignment_basic() {
    // Test basic logical AND assignment (&&=)
    let source = r#"let value = true;
value &&= false;
console.log(value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("value"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for logical AND assignment"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_logical_or_assignment_basic() {
    // Test basic logical OR assignment (||=)
    let source = r#"let value = false;
value ||= true;
console.log(value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("value"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for logical OR assignment"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_logical_and_assignment_object_property() {
    // Test logical AND assignment with object property
    let source = r#"const obj = { active: true };
obj.active &&= false;
console.log(obj.active);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("obj"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for logical AND assignment with object property"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_logical_or_assignment_object_property() {
    // Test logical OR assignment with object property
    let source = r#"const config = { debug: false };
config.debug ||= true;
console.log(config.debug);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("config"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for logical OR assignment with object property"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_logical_and_assignment_element_access() {
    // Test logical AND assignment with element access
    let source = r#"const arr = [true, false, true];
arr[0] &&= false;
console.log(arr);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("arr"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for logical AND assignment with element access"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_logical_or_assignment_element_access() {
    // Test logical OR assignment with element access
    let source = r#"const flags: boolean[] = [false, false, true];
flags[1] ||= true;
console.log(flags);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("flags"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for logical OR assignment with element access"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_logical_assignment_chained() {
    // Test chained logical assignments
    let source = r#"let a = true;
let b = false;
let c: string | null = null;
a &&= true;
b ||= true;
c ??= "default";
console.log(a, b, c);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("console"),
        "expected output to contain console. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for chained logical assignments"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_logical_assignment_in_function() {
    // Test logical assignment in function body
    let source = r#"function updateConfig(config: { enabled?: boolean; retries?: number }) {
    config.enabled ||= true;
    config.retries ??= 3;
    return config;
}
const result = updateConfig({});
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("updateConfig"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for logical assignment in function"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_logical_assignment_with_method_call() {
    // Test logical assignment with method call as value
    let source = r#"function getDefault(): string {
    return "default";
}
let name: string | null = null;
name ??= getDefault();
console.log(name);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("getDefault"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for logical assignment with method call"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_logical_assignment_combined() {
    // Test combined logical assignment patterns
    let source = r#"interface Settings {
    verbose?: boolean;
    timeout?: number | null;
    features?: { enabled?: boolean }[];
}
const settings: Settings = { features: [{}] };
settings.verbose ||= false;
settings.timeout ??= 5000;
settings.features![0].enabled &&= true;
console.log(settings);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("settings"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined logical assignments"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// ES5 Exponentiation Operator Source Map Tests
// ============================================================================

#[test]
fn test_source_map_exponentiation_basic() {
    // Test basic exponentiation operator (**)
    let source = r#"const result = 2 ** 10;
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("result"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic exponentiation"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_exponentiation_with_variables() {
    // Test exponentiation with variables
    let source = r#"const base = 2;
const exponent = 8;
const result = base ** exponent;
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("base"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for exponentiation with variables"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_exponentiation_assignment() {
    // Test exponentiation assignment operator (**=)
    let source = r#"let value = 2;
value **= 3;
console.log(value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("value"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for exponentiation assignment"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_exponentiation_chained() {
    // Test chained exponentiation (right-associative)
    let source = r#"const result = 2 ** 3 ** 2;
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("result"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for chained exponentiation"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_exponentiation_negative_exponent() {
    // Test exponentiation with negative exponent
    let source = r#"const result = 10 ** -2;
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("result"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for exponentiation with negative exponent"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_exponentiation_in_expression() {
    // Test exponentiation in larger expression
    let source = r#"const a = 2;
const b = 3;
const result = a * (b ** 2) + 1;
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("result"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for exponentiation in expression"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_exponentiation_precedence() {
    // Test exponentiation with parentheses for precedence
    let source = r#"const a = (2 ** 3) ** 2;
const b = 2 ** (3 ** 2);
console.log(a, b);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains console
    assert!(
        output.contains("console"),
        "expected output to contain console. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for exponentiation precedence"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_exponentiation_in_function() {
    // Test exponentiation in function body
    let source = r#"function power(base: number, exp: number): number {
    return base ** exp;
}
const result = power(2, 10);
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("power"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for exponentiation in function"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_exponentiation_with_method_call() {
    // Test exponentiation with method call
    let source = r#"function getExponent(): number {
    return 3;
}
const base = 2;
const result = base ** getExponent();
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("getExponent"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for exponentiation with method call"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_exponentiation_combined() {
    // Test combined exponentiation patterns
    let source = r#"const base = 2;
let accumulator = 1;
accumulator **= base;
const squared = base ** 2;
const cubed = base ** 3;
const complex = (squared ** 2) + (cubed ** 2);
console.log(accumulator, squared, cubed, complex);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("accumulator"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined exponentiation"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// BigInt Literal Source Map Tests
// ============================================================================

#[test]
fn test_source_map_bigint_basic() {
    // Test basic BigInt literal
    let source = r#"const value = 123n;
console.log(value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("value"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic BigInt"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_bigint_with_variables() {
    // Test BigInt with variable operations
    let source = r#"const a = 100n;
const b = 200n;
const sum = a + b;
console.log(sum);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("sum"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for BigInt with variables"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_bigint_arithmetic() {
    // Test BigInt arithmetic operations
    let source = r#"const a = 10n;
const b = 3n;
const add = a + b;
const sub = a - b;
const mul = a * b;
const div = a / b;
const mod = a % b;
console.log(add, sub, mul, div, mod);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("add"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for BigInt arithmetic"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_bigint_comparison() {
    // Test BigInt comparison operations
    let source = r#"const a = 10n;
const b = 20n;
const isLess = a < b;
const isEqual = a === 10n;
const isGreater = b > a;
console.log(isLess, isEqual, isGreater);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("isLess"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for BigInt comparison"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_bigint_constructor() {
    // Test BigInt constructor
    let source = r#"const fromNumber = BigInt(42);
const fromString = BigInt("12345678901234567890");
console.log(fromNumber, fromString);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("fromNumber"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for BigInt constructor"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_bigint_in_function() {
    // Test BigInt in function body
    let source = r#"function factorial(n: bigint): bigint {
    if (n <= 1n) return 1n;
    return n * factorial(n - 1n);
}
const result = factorial(10n);
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("factorial"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for BigInt in function"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_bigint_large_numbers() {
    // Test BigInt with large numbers
    let source = r#"const large = 9007199254740991n;
const veryLarge = 123456789012345678901234567890n;
const sum = large + veryLarge;
console.log(sum);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("large"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for BigInt large numbers"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_bigint_negative() {
    // Test BigInt with negative numbers
    let source = r#"const negative = -42n;
const alsoNegative = -100n;
const result = negative + alsoNegative;
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("negative"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for BigInt negative"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_bigint_in_array_object() {
    // Test BigInt in arrays and objects
    let source = r#"const arr = [1n, 2n, 3n, 4n, 5n];
const obj = { small: 10n, large: 1000000000000000000n };
console.log(arr, obj.small, obj.large);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("arr"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for BigInt in array/object"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_bigint_combined() {
    // Test combined BigInt patterns
    let source = r#"const base = 2n;
const exponent = 10n;
let power = 1n;
for (let i = 0n; i < exponent; i++) {
    power = power * base;
}
const asNumber = Number(power);
console.log(power, asNumber);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable names
    assert!(
        output.contains("power"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined BigInt"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Dynamic Import Source Map Tests
// ============================================================================

#[test]
fn test_source_map_dynamic_import_basic() {
    // Test basic dynamic import
    let source = r#"import("./module");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains module path
    assert!(
        output.contains("./module"),
        "expected output to contain module path. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic dynamic import"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_dynamic_import_variable_path() {
    // Test dynamic import with variable path
    let source = r#"const modulePath = "./utils";
import(modulePath);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable
    assert!(
        output.contains("modulePath"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for dynamic import with variable path"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_dynamic_import_then_chain() {
    // Test dynamic import with then chain
    let source = r#"import("./module").then(mod => {
    console.log(mod);
});"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains then
    assert!(
        output.contains("then"),
        "expected output to contain then. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for dynamic import with then chain"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_dynamic_import_await() {
    // Test dynamic import with await
    let source = r#"async function loadModule() {
    const mod = await import("./module");
    return mod;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("loadModule"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for dynamic import with await"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_dynamic_import_in_function() {
    // Test dynamic import in regular function
    let source = r#"function loadLazy() {
    return import("./lazy-module");
}
loadLazy();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("loadLazy"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for dynamic import in function"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_dynamic_import_destructuring() {
    // Test dynamic import with destructuring
    let source = r#"async function load() {
    const { default: main, helper } = await import("./module");
    return main(helper);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("load"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for dynamic import with destructuring"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_dynamic_import_conditional() {
    // Test dynamic import in conditional
    let source = r#"const isAdmin = true;
if (isAdmin) {
    import("./admin-module");
} else {
    import("./user-module");
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("isAdmin"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for dynamic import in conditional"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_dynamic_import_template_path() {
    // Test dynamic import with template literal path
    let source = r#"const moduleName = "utils";
import(`./modules/${moduleName}`);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable name
    assert!(
        output.contains("moduleName"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for dynamic import with template path"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_dynamic_import_catch() {
    // Test dynamic import with catch handler
    let source = r#"import("./module")
    .then(mod => mod.init())
    .catch(err => console.error(err));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains catch
    assert!(
        output.contains("catch"),
        "expected output to contain catch. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for dynamic import with catch"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_dynamic_import_combined() {
    // Test combined dynamic import patterns
    let source = r#"async function loadModules(names: string[]) {
    const modules = [];
    for (const name of names) {
        const mod = await import(`./modules/${name}`);
        modules.push(mod);
    }
    return modules;
}
loadModules(["a", "b", "c"]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("loadModules"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined dynamic import"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Private Fields Source Map Tests
// ============================================================================

#[test]
fn test_source_map_private_field_basic() {
    // Test basic private field
    let source = r#"class Counter {
    #count = 0;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Counter"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic private field"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_initialized() {
    // Test private field with initialization
    let source = r#"class Config {
    #name = "default";
    #value = 42;
    #active = true;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Config"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private field with initialization"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_constructor() {
    // Test private field assigned in constructor
    let source = r#"class User {
    #id;
    #name;
    constructor(id: number, name: string) {
        this.#id = id;
        this.#name = name;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("User"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private field in constructor"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_method() {
    // Test private method
    let source = r#"class Calculator {
    #validate(x: number) {
        return x >= 0;
    }
    calculate(x: number) {
        if (this.#validate(x)) {
            return x * 2;
        }
        return 0;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Calculator"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private method"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_access() {
    // Test private field access
    let source = r#"class Counter {
    #count = 0;
    getCount() {
        return this.#count;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains method name
    assert!(
        output.contains("getCount"),
        "expected output to contain method name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private field access"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_assignment() {
    // Test private field assignment
    let source = r#"class Counter {
    #count = 0;
    increment() {
        this.#count = this.#count + 1;
    }
    reset() {
        this.#count = 0;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains method names
    assert!(
        output.contains("increment"),
        "expected output to contain method name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private field assignment"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_static_field() {
    // Test private static field
    let source = r#"class Singleton {
    static #instance: Singleton | null = null;
    static getInstance() {
        if (!Singleton.#instance) {
            Singleton.#instance = new Singleton();
        }
        return Singleton.#instance;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Singleton"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private static field"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_static_method() {
    // Test private static method
    let source = r#"class Helper {
    static #format(value: number) {
        return value.toFixed(2);
    }
    static display(value: number) {
        return Helper.#format(value);
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Helper"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private static method"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_inheritance() {
    // Test private field in derived class
    let source = r#"class Base {
    #baseValue = 10;
    getBaseValue() {
        return this.#baseValue;
    }
}
class Derived extends Base {
    #derivedValue = 20;
    getDerivedValue() {
        return this.#derivedValue;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class names
    assert!(
        output.contains("Base") && output.contains("Derived"),
        "expected output to contain class names. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private field inheritance"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_combined() {
    // Test combined private field patterns
    let source = r#"class BankAccount {
    #balance = 0;
    #transactionHistory: number[] = [];
    static #accountCount = 0;

    constructor(initialBalance: number) {
        this.#balance = initialBalance;
        BankAccount.#accountCount++;
    }

    #logTransaction(amount: number) {
        this.#transactionHistory.push(amount);
    }

    deposit(amount: number) {
        this.#balance += amount;
        this.#logTransaction(amount);
    }

    getBalance() {
        return this.#balance;
    }

    static getAccountCount() {
        return BankAccount.#accountCount;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("BankAccount"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined private fields"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Additional Decorator Source Map Tests
// ============================================================================

#[test]
fn test_source_map_decorator_with_arguments() {
    // Test decorator with arguments
    let source = r#"function log(level: string) {
    return function(target: any) {
        console.log(level, target);
    };
}

@log("info")
class Service {
    name = "test";
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Service"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for decorator with arguments"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_with_expression() {
    // Test decorator with expression
    let source = r#"const decorators = {
    sealed: function(target: any) {
        Object.seal(target);
    }
};

@decorators.sealed
class Immutable {
    value = 42;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Immutable"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for decorator with expression"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_composition() {
    // Test decorator composition (multiple stacked decorators)
    let source = r#"function first(target: any) { return target; }
function second(target: any) { return target; }
function third(target: any) { return target; }

@first
@second
@third
class Composed {
    method() {}
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Composed"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for decorator composition"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_static_method_decorator() {
    // Test decorator on static method
    let source = r#"function log(target: any, key: string, descriptor: PropertyDescriptor) {
    return descriptor;
}

class Utils {
    @log
    static helper() {
        return 42;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Utils"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static method decorator"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_static_property_decorator() {
    // Test decorator on static property
    let source = r#"function readonly(target: any, key: string) {
    Object.defineProperty(target, key, { writable: false });
}

class Config {
    @readonly
    static version = "1.0.0";

    @readonly
    static name = "App";
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Config"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static property decorator"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_on_getter() {
    // Test decorator on getter
    let source = r#"function cache(target: any, key: string, descriptor: PropertyDescriptor) {
    return descriptor;
}

class Data {
    private _value = 0;

    @cache
    get value() {
        return this._value;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Data"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for decorator on getter"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_on_setter() {
    // Test decorator on setter
    let source = r#"function validate(target: any, key: string, descriptor: PropertyDescriptor) {
    return descriptor;
}

class Settings {
    private _theme = "light";

    @validate
    set theme(value: string) {
        this._theme = value;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Settings"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for decorator on setter"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_with_metadata() {
    // Test decorator that uses metadata
    let source = r#"function type(typeFunc: () => any) {
    return function(target: any, key: string) {};
}

class Entity {
    @type(() => String)
    name: string;

    @type(() => Number)
    age: number;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Entity"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for decorator with metadata"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_inheritance() {
    // Test decorators with class inheritance
    let source = r#"function base(target: any) { return target; }
function derived(target: any) { return target; }

@base
class Parent {
    parentMethod() {}
}

@derived
class Child extends Parent {
    childMethod() {}
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class names
    assert!(
        output.contains("Parent") && output.contains("Child"),
        "expected output to contain class names. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for decorator inheritance"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
#[ignore = "INFINITE LOOP - ES5 class transform with complex decorator patterns (class, method, property, parameter decorators combined) causes unbounded recursion in ClassES5Emitter."]
fn test_source_map_decorator_combined_advanced() {
    // Test combined advanced decorator patterns
    let source = r#"function controller(path: string) {
    return function(target: any) { return target; };
}

function get(route: string) {
    return function(target: any, key: string, desc: PropertyDescriptor) { return desc; };
}

function inject(token: string) {
    return function(target: any, key: string, index: number) {};
}

function prop(target: any, key: string) {}

@controller("/api")
class ApiController {
    @prop
    service: any;

    @get("/users")
    getUsers(@inject("db") db: any) {
        return [];
    }

    @get("/posts")
    getPosts(@inject("db") db: any, @inject("cache") cache: any) {
        return [];
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("ApiController"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined advanced decorators"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Enum Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_enum_const() {
    // Test const enum
    let source = r#"const enum Direction {
    Up = 1,
    Down = 2,
    Left = 3,
    Right = 4
}
const dir = Direction.Up;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains variable
    assert!(
        output.contains("dir"),
        "expected output to contain variable name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for const enum"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_with_initializers() {
    // Test enum with various initializers
    let source = r#"enum FileAccess {
    None,
    Read = 1 << 1,
    Write = 1 << 2,
    ReadWrite = Read | Write,
    G = "123".length
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains enum name
    assert!(
        output.contains("FileAccess"),
        "expected output to contain enum name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for enum with initializers"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_member_reference() {
    // Test enum member references
    let source = r#"enum Status {
    Pending = 0,
    Active = 1,
    Completed = 2
}

function checkStatus(s: Status) {
    if (s === Status.Pending) {
        return "waiting";
    } else if (s === Status.Active) {
        return "running";
    }
    return "done";
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("checkStatus"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for enum member reference"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_in_namespace() {
    // Test enum inside namespace
    let source = r#"namespace App {
    export enum LogLevel {
        Debug = 0,
        Info = 1,
        Warning = 2,
        Error = 3
    }
}

const level = App.LogLevel.Info;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains namespace name
    assert!(
        output.contains("App"),
        "expected output to contain namespace name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for enum in namespace"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_merged() {
    // Test merged enum declarations
    let source = r#"enum Color {
    Red = 1,
    Green = 2,
    Blue = 3
}

enum Color {
    Yellow = 4,
    Orange = 5
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains enum name
    assert!(
        output.contains("Color"),
        "expected output to contain enum name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for merged enum"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_reverse_mapping() {
    // Test enum with reverse mapping access
    let source = r#"enum HttpStatus {
    OK = 200,
    NotFound = 404,
    ServerError = 500
}

const statusCode = HttpStatus.OK;
const statusName = HttpStatus[200];"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains enum name
    assert!(
        output.contains("HttpStatus"),
        "expected output to contain enum name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for enum reverse mapping"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_heterogeneous() {
    // Test heterogeneous enum (mixed numeric and string)
    let source = r#"enum BooleanLike {
    No = 0,
    Yes = "YES"
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains enum name
    assert!(
        output.contains("BooleanLike"),
        "expected output to contain enum name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for heterogeneous enum"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_in_class() {
    // Test enum used in class context
    let source = r#"enum Priority {
    Low = 1,
    Medium = 2,
    High = 3
}

class Task {
    priority: Priority = Priority.Medium;

    setPriority(p: Priority) {
        this.priority = p;
    }

    isHighPriority(): boolean {
        return this.priority === Priority.High;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains class name
    assert!(
        output.contains("Task"),
        "expected output to contain class name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for enum in class"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_in_switch() {
    // Test enum used in switch statement
    let source = r#"enum Fruit {
    Apple,
    Banana,
    Orange
}

function getFruitColor(fruit: Fruit): string {
    switch (fruit) {
        case Fruit.Apple:
            return "red";
        case Fruit.Banana:
            return "yellow";
        case Fruit.Orange:
            return "orange";
        default:
            return "unknown";
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains function name
    assert!(
        output.contains("getFruitColor"),
        "expected output to contain function name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for enum in switch"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_combined() {
    // Test combined enum patterns
    let source = r#"enum Permission {
    Read = 1 << 0,
    Write = 1 << 1,
    Execute = 1 << 2,
    All = Read | Write | Execute
}

const enum InlineStatus {
    Pending = "PENDING",
    Active = "ACTIVE",
    Complete = "COMPLETE"
}

namespace FileSystem {
    export enum FileType {
        File,
        Directory,
        Symlink
    }
}

function hasPermission(perms: Permission, check: Permission): boolean {
    return (perms & check) === check;
}

const status = InlineStatus.Active;
const fileType = FileSystem.FileType.Directory;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Verify output contains enum name
    assert!(
        output.contains("Permission"),
        "expected output to contain enum name. output: {output}"
    );

    // Verify we have source mappings
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined enum patterns"
    );

    // Verify at least some mappings reference the source file
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Class Expression Source Map Tests
// ============================================================================

#[test]
fn test_source_map_class_expression_named() {
    // Test named class expression with internal name
    let source = r#"const MyClass = class InternalName {
    value: number = 10;

    greet(): string {
        return "Hello from " + InternalName.name;
    }
};"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("MyClass"),
        "expected output to contain variable name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for named class expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expression_extends() {
    // Test class expression with inheritance
    let source = r#"class Base {
    baseMethod(): void {}
}

const Derived = class extends Base {
    derivedMethod(): void {
        this.baseMethod();
    }
};"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Derived"),
        "expected output to contain derived class name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression with extends"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expression_static_methods() {
    // Test class expression with static methods
    let source = r#"const Counter = class {
    static count: number = 0;

    static increment(): number {
        return ++Counter.count;
    }

    static reset(): void {
        Counter.count = 0;
    }
};"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter"),
        "expected output to contain class name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression with static methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expression_accessors() {
    // Test class expression with getters and setters
    let source = r#"const Person = class {
    private _name: string = "";
    private _age: number = 0;

    get name(): string {
        return this._name;
    }

    set name(value: string) {
        this._name = value;
    }

    get age(): number {
        return this._age;
    }

    set age(value: number) {
        if (value >= 0) {
            this._age = value;
        }
    }
};"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Person"),
        "expected output to contain class name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression with accessors"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expression_in_function() {
    // Test class expression returned from function
    let source = r#"function createClass(name: string) {
    return class {
        readonly className: string = name;

        describe(): string {
            return "Class: " + this.className;
        }
    };
}

const DynamicClass = createClass("Dynamic");
const instance = new DynamicClass();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createClass"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression in function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expression_with_constructor() {
    // Test class expression with constructor and parameters
    let source = r#"const Rectangle = class {
    width: number;
    height: number;

    constructor(width: number, height: number) {
        this.width = width;
        this.height = height;
    }

    area(): number {
        return this.width * this.height;
    }

    perimeter(): number {
        return 2 * (this.width + this.height);
    }
};

const rect = new Rectangle(10, 20);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Rectangle"),
        "expected output to contain class name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression with constructor"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expression_computed_props() {
    // Test class expression with computed property names
    let source = r#"const methodName = "compute";
const propName = "data";

const Computed = class {
    [propName]: number = 42;

    [methodName](): number {
        return this[propName] * 2;
    }

    ["get" + "Value"](): number {
        return this[propName];
    }
};"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Computed"),
        "expected output to contain class name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression with computed props"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expression_in_array() {
    // Test class expressions in array
    let source = r#"const classes = [
    class First {
        id: number = 1;
        getName(): string { return "First"; }
    },
    class Second {
        id: number = 2;
        getName(): string { return "Second"; }
    },
    class Third {
        id: number = 3;
        getName(): string { return "Third"; }
    }
];

const instance = new classes[0]();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("classes"),
        "expected output to contain array name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expressions in array"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expression_iife() {
    // Test class expression inside IIFE
    let source = r#"const Singleton = (function() {
    let instance: InstanceType<typeof Inner> | null = null;

    const Inner = class {
        value: number = 0;

        getValue(): number {
            return this.value;
        }

        setValue(v: number): void {
            this.value = v;
        }
    };

    return {
        getInstance() {
            if (!instance) {
                instance = new Inner();
            }
            return instance;
        }
    };
})();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Singleton"),
        "expected output to contain singleton name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression in IIFE"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expression_combined() {
    // Test combined class expression patterns
    let source = r#"class BaseEntity {
    id: number;
    constructor(id: number) {
        this.id = id;
    }
}

const mixinFactory = <T extends new (...args: any[]) => any>(Base: T) => {
    return class extends Base {
        timestamp: Date = new Date();

        getTimestamp(): Date {
            return this.timestamp;
        }
    };
};

const EntityWithTimestamp = mixinFactory(BaseEntity);

const registry = {
    Entity: class extends BaseEntity {
        name: string;
        constructor(id: number, name: string) {
            super(id);
            this.name = name;
        }
    },
    Counter: class {
        static count = 0;
        value: number;
        constructor() {
            this.value = ++Counter.count;
        }
    }
};

const e1 = new registry.Entity(1, "test");
const c1 = new registry.Counter();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("BaseEntity"),
        "expected output to contain base class name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined class expression patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Import/Export Source Map Tests
// ============================================================================

#[test]
fn test_source_map_import_named() {
    // Test named imports source map
    let source = r#"import { foo, bar, baz } from "./module";
import { Component, useState } from "react";

const result = foo() + bar(baz);
const comp = Component;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("require") || output.contains("foo"),
        "expected output to contain require or identifier. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for named imports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_import_default() {
    // Test default import source map
    let source = r#"import React from "react";
import lodash from "lodash";
import myModule from "./myModule";

const element = React.createElement("div");
const result = lodash.map([1, 2, 3], x => x * 2);
myModule.init();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("require") || output.contains("React"),
        "expected output to contain require or identifier. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for default imports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_import_namespace() {
    // Test namespace import source map
    let source = r#"import * as utils from "./utils";
import * as React from "react";
import * as path from "path";

const result = utils.helper();
const element = React.createElement("span");
const joined = path.join("a", "b");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("require") || output.contains("utils"),
        "expected output to contain require or identifier. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for namespace imports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_export_named() {
    // Test named exports source map
    let source = r#"export const PI = 3.14159;
export let counter = 0;
export var legacy = "old";

export function add(a: number, b: number): number {
    return a + b;
}

export class Calculator {
    multiply(a: number, b: number): number {
        return a * b;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("exports") || output.contains("PI"),
        "expected output to contain exports or identifier. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for named exports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_export_default() {
    // Test default export source map
    let source = r#"export default class MyComponent {
    render(): string {
        return "<div>Hello</div>";
    }
}

const helper = () => "helper";
export { helper };"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("exports") || output.contains("MyComponent"),
        "expected output to contain exports or class name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for default exports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_export_from() {
    // Test re-export from another module source map
    let source = r#"export { foo, bar } from "./module";
export { default as MyDefault } from "./default";
export * from "./utils";
export * as namespace from "./namespace";"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("require") || output.contains("exports"),
        "expected output to contain require or exports. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for export from"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_import_with_alias() {
    // Test import with alias source map
    let source = r#"import { foo as myFoo, bar as myBar } from "./module";
import { Component as ReactComponent } from "react";

const result = myFoo() + myBar();
const comp = new ReactComponent();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("require") || output.contains("myFoo"),
        "expected output to contain require or alias. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for import with alias"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_import_type_only() {
    // Test type-only imports source map (should be stripped)
    let source = r#"import type { MyType, MyInterface } from "./types";
import { type OnlyType, realValue } from "./mixed";

const value: MyType = realValue;
const data: MyInterface = { name: "test" };"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Type-only imports should be stripped, so MyType should not appear
    assert!(
        output.contains("realValue") || output.contains("value"),
        "expected output to contain runtime value. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for type-only imports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_import_side_effect() {
    // Test side-effect imports source map
    let source = r#"import "./polyfills";
import "./styles.css";
import "reflect-metadata";

console.log("Imports loaded");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("require") || output.contains("console"),
        "expected output to contain require or console. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for side-effect imports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_import_export_combined() {
    // Test combined import/export patterns source map
    let source = r#"import { helper } from "./utils";
import * as lodash from "lodash";
import React, { Component, useState } from "react";

export const VERSION = "1.0.0";

export function processData(data: any[]): any[] {
    return lodash.map(data, helper);
}

export class DataProcessor extends Component {
    state = useState(null);

    process(): void {
        const result = processData([1, 2, 3]);
        console.log(result);
    }
}

export default DataProcessor;
export { helper as utilHelper };"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    options.module = crate::thin_emitter::ModuleKind::CommonJS;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataProcessor") || output.contains("exports"),
        "expected output to contain class name or exports. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined import/export"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Arrow Function Source Map Tests
// ============================================================================

#[test]
fn test_source_map_arrow_no_params() {
    // Test arrow function with no parameters
    let source = r#"const getTime = () => Date.now();
const getEmpty = () => {};
const getNull = () => null;
const getUndefined = () => undefined;

console.log(getTime(), getEmpty(), getNull(), getUndefined());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getTime") || output.contains("function"),
        "expected output to contain identifier or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow with no params"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_single_param() {
    // Test arrow function with single parameter (no parentheses)
    let source = r#"const double = x => x * 2;
const stringify = value => String(value);
const negate = n => -n;
const increment = num => num + 1;

const result = [1, 2, 3].map(double).map(stringify);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("double") || output.contains("function"),
        "expected output to contain identifier or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow with single param"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_default_params() {
    // Test arrow function with default parameters
    let source = r#"const greet = (name: string = "World") => "Hello, " + name;
const add = (a: number = 0, b: number = 0) => a + b;
const config = (options: object = {}) => ({ ...options });
const multiply = (x: number, y: number = 1, z: number = 1) => x * y * z;

const greeting = greet();
const sum = add(5);
const product = multiply(2, 3);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("greet") || output.contains("function"),
        "expected output to contain identifier or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow with default params"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_rest_params() {
    // Test arrow function with rest parameters
    let source = r#"const sum = (...numbers: number[]) => numbers.reduce((a, b) => a + b, 0);
const concat = (...strings: string[]) => strings.join("");
const first = (head: any, ...tail: any[]) => head;
const log = (message: string, ...args: any[]) => console.log(message, ...args);

const total = sum(1, 2, 3, 4, 5);
const joined = concat("a", "b", "c");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("sum") || output.contains("function"),
        "expected output to contain identifier or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow with rest params"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_destructuring_params() {
    // Test arrow function with destructuring parameters
    let source = r#"const getX = ({ x }: { x: number }) => x;
const getXY = ({ x, y }: { x: number; y: number }) => x + y;
const getFirst = ([first]: number[]) => first;
const getFirstTwo = ([a, b]: number[]) => a + b;
const mixed = ({ name }: { name: string }, [value]: number[]) => name + value;

const point = { x: 10, y: 20 };
const arr = [1, 2, 3];
const result = getXY(point) + getFirst(arr);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getX") || output.contains("function"),
        "expected output to contain identifier or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow with destructuring params"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_class_property() {
    // Test arrow function as class property
    let source = r#"class Counter {
    private count: number = 0;

    increment = () => {
        this.count++;
        return this.count;
    };

    decrement = () => this.count--;

    reset = () => {
        this.count = 0;
    };

    getCount = () => this.count;
}

const counter = new Counter();
counter.increment();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter") || output.contains("function"),
        "expected output to contain class name or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow as class property"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_iife() {
    // Test arrow function in immediately invoked expression
    let source = r#"const result1 = (() => 42)();
const result2 = ((x: number) => x * 2)(21);
const result3 = ((a: number, b: number) => a + b)(10, 20);

const module = (() => {
    const privateValue = 100;
    return {
        getValue: () => privateValue,
        double: () => privateValue * 2
    };
})();

console.log(result1, result2, result3, module.getValue());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("result1") || output.contains("function"),
        "expected output to contain identifier or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow IIFE"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_object_return() {
    // Test arrow function returning object literal
    let source = r#"const createPoint = (x: number, y: number) => ({ x, y });
const createRect = (w: number, h: number) => ({ width: w, height: h, area: w * h });
const wrap = (value: any) => ({ value });
const createPerson = (name: string, age: number) => ({
    name,
    age,
    greet: () => "Hello, " + name
});

const point = createPoint(10, 20);
const rect = createRect(100, 50);
const person = createPerson("Alice", 30);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createPoint") || output.contains("function"),
        "expected output to contain identifier or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow returning object"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_higher_order() {
    // Test higher-order arrow functions
    let source = r#"const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (x: A) => f(g(x));
const pipe = <A, B, C>(f: (a: A) => B, g: (b: B) => C) => (x: A) => g(f(x));
const curry = (fn: (a: number, b: number) => number) => (a: number) => (b: number) => fn(a, b);
const partial = <T, U, R>(fn: (a: T, b: U) => R, a: T) => (b: U) => fn(a, b);

const add = (a: number, b: number) => a + b;
const curriedAdd = curry(add);
const add5 = curriedAdd(5);
const result = add5(10);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("compose") || output.contains("curry") || output.contains("function"),
        "expected output to contain identifier or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for higher-order arrows"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_combined() {
    // Test combined arrow function patterns
    let source = r#"class EventEmitter {
    private handlers: Map<string, ((data: any) => void)[]> = new Map();

    on = (event: string, handler: (data: any) => void) => {
        const handlers = this.handlers.get(event) || [];
        handlers.push(handler);
        this.handlers.set(event, handlers);
        return () => {
            const idx = handlers.indexOf(handler);
            if (idx > -1) handlers.splice(idx, 1);
        };
    };

    emit = (event: string, data: any) => {
        (this.handlers.get(event) || []).forEach(h => h(data));
    };
}

const emitter = new EventEmitter();
const unsubscribe = emitter.on("test", data => console.log(data));
emitter.emit("test", { message: "hello" });
unsubscribe();

const pipeline = [
    (x: number) => x + 1,
    (x: number) => x * 2,
    (x: number) => x - 3
].reduce((acc, fn) => (x: number) => fn(acc(x)), (x: number) => x);

console.log(pipeline(5));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("EventEmitter") || output.contains("emitter"),
        "expected output to contain class or variable name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined arrow patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Async Generator ES5 Source Map Tests
// ============================================================================

#[test]
fn test_source_map_async_generator_basic() {
    // Test basic async generator function
    let source = r#"async function* basicAsyncGen() {
    yield 1;
    yield 2;
    yield 3;
}

const gen = basicAsyncGen();
gen.next().then(console.log);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("basicAsyncGen") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic async generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_generator_with_await() {
    // Test async generator with await expressions
    let source = r#"async function* fetchSequence(urls: string[]) {
    for (const url of urls) {
        const response = await fetch(url);
        const data = await response.json();
        yield data;
    }
}

const urls = ["url1", "url2"];
const gen = fetchSequence(urls);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchSequence") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async generator with await"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_generator_yield_await() {
    // Test async generator with yield* and await
    let source = r#"async function* innerGen() {
    yield 1;
    yield 2;
}

async function* outerGen() {
    yield* innerGen();
    await Promise.resolve();
    yield 3;
}

const gen = outerGen();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("innerGen") || output.contains("outerGen") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async generator yield await"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_generator_try_catch() {
    // Test async generator with try-catch
    let source = r#"async function* safeGenerator() {
    try {
        yield await Promise.resolve(1);
        yield await Promise.resolve(2);
        throw new Error("test error");
    } catch (e) {
        yield "error caught";
    } finally {
        yield "cleanup";
    }
}

const gen = safeGenerator();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("safeGenerator") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async generator try-catch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_generator_class_method() {
    // Test async generator as class method
    let source = r#"class DataStream {
    private data: number[] = [1, 2, 3, 4, 5];

    async *iterate() {
        for (const item of this.data) {
            await new Promise(r => setTimeout(r, 100));
            yield item;
        }
    }

    async *filter(predicate: (n: number) => boolean) {
        for await (const item of this.iterate()) {
            if (predicate(item)) {
                yield item;
            }
        }
    }
}

const stream = new DataStream();
const gen = stream.iterate();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataStream") || output.contains("function"),
        "expected output to contain class name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async generator class method"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_generator_for_await() {
    // Test async generator with for-await-of
    let source = r#"async function* processStream(stream: AsyncIterable<number>) {
    for await (const chunk of stream) {
        yield chunk * 2;
    }
}

async function* numberStream() {
    yield 1;
    yield 2;
    yield 3;
}

const processed = processStream(numberStream());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processStream") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async generator for-await"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_generator_return_value() {
    // Test async generator with return value
    let source = r#"async function* withReturn(): AsyncGenerator<number, string, void> {
    yield 1;
    yield 2;
    return "done";
}

async function consume() {
    const gen = withReturn();
    let result = await gen.next();
    while (!result.done) {
        console.log(result.value);
        result = await gen.next();
    }
    console.log("Final:", result.value);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("withReturn") || output.contains("consume") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async generator with return"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_generator_expression() {
    // Test async generator expression
    let source = r#"const asyncGen = async function* () {
    yield 1;
    await Promise.resolve();
    yield 2;
};

const namedAsyncGen = async function* named() {
    yield "a";
    yield "b";
};

const gen1 = asyncGen();
const gen2 = namedAsyncGen();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("asyncGen") || output.contains("function"),
        "expected output to contain variable name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async generator expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_generator_nested() {
    // Test nested async generators
    let source = r#"async function* outer(n: number) {
    for (let i = 0; i < n; i++) {
        yield* inner(i);
    }
}

async function* inner(start: number) {
    yield await Promise.resolve(start);
    yield await Promise.resolve(start + 1);
}

async function collect() {
    const results: number[] = [];
    for await (const value of outer(3)) {
        results.push(value);
    }
    return results;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("outer") || output.contains("inner") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested async generators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_generator_combined() {
    // Test combined async generator patterns
    let source = r#"class AsyncQueue<T> {
    private items: T[] = [];
    private resolvers: ((value: T) => void)[] = [];

    enqueue(item: T): void {
        if (this.resolvers.length > 0) {
            const resolver = this.resolvers.shift()!;
            resolver(item);
        } else {
            this.items.push(item);
        }
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<T> {
        while (true) {
            if (this.items.length > 0) {
                yield this.items.shift()!;
            } else {
                yield await new Promise<T>(resolve => {
                    this.resolvers.push(resolve);
                });
            }
        }
    }
}

async function* transform<T, U>(
    source: AsyncIterable<T>,
    fn: (item: T) => Promise<U>
): AsyncGenerator<U> {
    for await (const item of source) {
        yield await fn(item);
    }
}

const queue = new AsyncQueue<number>();
const doubled = transform(queue, async n => n * 2);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AsyncQueue") || output.contains("transform"),
        "expected output to contain class or function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined async generator patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// For-Await-Of ES5 Source Map Tests
// ============================================================================

#[test]
fn test_source_map_for_await_basic() {
    // Test basic for-await-of loop
    let source = r#"async function processItems(items: AsyncIterable<number>) {
    for await (const item of items) {
        console.log(item);
    }
}

async function* numberGen() {
    yield 1;
    yield 2;
    yield 3;
}

processItems(numberGen());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processItems") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic for-await-of"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_for_await_destructuring() {
    // Test for-await-of with destructuring
    let source = r#"interface DataItem {
    id: number;
    name: string;
}

async function* dataStream(): AsyncGenerator<DataItem> {
    yield { id: 1, name: "first" };
    yield { id: 2, name: "second" };
}

async function processData() {
    for await (const { id, name } of dataStream()) {
        console.log(id, name);
    }
}

processData();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processData") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-await-of with destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_for_await_nested() {
    // Test nested for-await-of loops
    let source = r#"async function* outerStream() {
    yield [1, 2];
    yield [3, 4];
}

async function* innerStream(arr: number[]) {
    for (const n of arr) {
        yield n;
    }
}

async function processNested() {
    for await (const arr of outerStream()) {
        for await (const num of innerStream(arr)) {
            console.log(num);
        }
    }
}

processNested();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processNested") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested for-await-of"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_for_await_try_catch() {
    // Test for-await-of with try-catch
    let source = r#"async function* errorStream() {
    yield 1;
    throw new Error("stream error");
    yield 2;
}

async function safeIterate() {
    try {
        for await (const item of errorStream()) {
            console.log(item);
        }
    } catch (e) {
        console.error("Caught:", e);
    } finally {
        console.log("Cleanup");
    }
}

safeIterate();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("safeIterate") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-await-of with try-catch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_for_await_break_continue() {
    // Test for-await-of with break and continue
    let source = r#"async function* numbersGen() {
    for (let i = 0; i < 10; i++) {
        yield i;
    }
}

async function processWithControl() {
    for await (const num of numbersGen()) {
        if (num === 3) {
            continue;
        }
        if (num === 7) {
            break;
        }
        console.log(num);
    }
}

processWithControl();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processWithControl") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-await-of with break/continue"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_for_await_class_method() {
    // Test for-await-of in class method
    let source = r#"class AsyncProcessor {
    private results: number[] = [];

    async process(source: AsyncIterable<number>): Promise<number[]> {
        for await (const item of source) {
            this.results.push(item * 2);
        }
        return this.results;
    }

    async *generate(): AsyncGenerator<number> {
        yield 1;
        yield 2;
        yield 3;
    }
}

const processor = new AsyncProcessor();
processor.process(processor.generate());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AsyncProcessor") || output.contains("function"),
        "expected output to contain class name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-await-of in class method"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_for_await_with_await() {
    // Test for-await-of with additional await expressions
    let source = r#"async function* dataGen() {
    yield { id: 1, url: "url1" };
    yield { id: 2, url: "url2" };
}

async function fetchData(url: string): Promise<string> {
    return "data from " + url;
}

async function processWithFetch() {
    for await (const { id, url } of dataGen()) {
        const data = await fetchData(url);
        console.log(id, data);
    }
}

processWithFetch();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processWithFetch") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-await-of with await"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_for_await_label() {
    // Test for-await-of with labels
    let source = r#"async function* gen1() { yield 1; yield 2; }
async function* gen2() { yield "a"; yield "b"; }

async function labeledLoop() {
    outer: for await (const num of gen1()) {
        inner: for await (const str of gen2()) {
            if (num === 2 && str === "a") {
                break outer;
            }
            console.log(num, str);
        }
    }
}

labeledLoop();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("labeledLoop") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-await-of with labels"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_for_await_return() {
    // Test for-await-of with return statement
    let source = r#"async function* searchStream() {
    yield { id: 1, found: false };
    yield { id: 2, found: true };
    yield { id: 3, found: false };
}

async function findFirst(): Promise<number | null> {
    for await (const { id, found } of searchStream()) {
        if (found) {
            return id;
        }
    }
    return null;
}

findFirst().then(console.log);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("findFirst") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-await-of with return"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_for_await_combined() {
    // Test combined for-await-of patterns
    let source = r#"class EventStream {
    private events: Array<{ type: string; data: any }> = [];

    async *[Symbol.asyncIterator]() {
        for (const event of this.events) {
            yield event;
        }
    }

    push(type: string, data: any) {
        this.events.push({ type, data });
    }
}

async function processEvents(stream: EventStream) {
    const results: any[] = [];

    try {
        for await (const { type, data } of stream) {
            if (type === "error") {
                throw new Error(data);
            }
            if (type === "end") {
                break;
            }
            results.push(await Promise.resolve(data));
        }
    } catch (e) {
        console.error("Error:", e);
    }

    return results;
}

const stream = new EventStream();
stream.push("data", 1);
stream.push("data", 2);
stream.push("end", null);
processEvents(stream);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("EventStream") || output.contains("processEvents"),
        "expected output to contain class or function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined for-await-of patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Try-Catch-Finally ES5 Source Map Tests
// ============================================================================

#[test]
fn test_source_map_try_catch_basic() {
    // Test basic try-catch
    let source = r#"function riskyOperation() {
    try {
        const result = JSON.parse('invalid json');
        return result;
    } catch (error) {
        console.error("Parse error:", error);
        return null;
    }
}

riskyOperation();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("riskyOperation") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        output.contains("try") && output.contains("catch"),
        "expected output to contain try-catch. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic try-catch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_try_catch_finally() {
    // Test try-catch-finally
    let source = r#"function withCleanup() {
    const resource = { open: true };
    try {
        console.log("Using resource");
        throw new Error("Something went wrong");
    } catch (e) {
        console.error("Error:", e);
    } finally {
        resource.open = false;
        console.log("Resource closed");
    }
    return resource;
}

withCleanup();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("withCleanup") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        output.contains("finally"),
        "expected output to contain finally. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for try-catch-finally"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_try_finally() {
    // Test try-finally without catch
    let source = r#"function guaranteedCleanup() {
    let locked = true;
    try {
        console.log("Doing work while locked");
        return "done";
    } finally {
        locked = false;
        console.log("Lock released");
    }
}

guaranteedCleanup();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("guaranteedCleanup") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        output.contains("try") && output.contains("finally"),
        "expected output to contain try-finally. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for try-finally"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_try_catch_nested() {
    // Test nested try-catch blocks
    let source = r#"function nestedTryCatch() {
    try {
        console.log("Outer try");
        try {
            console.log("Inner try");
            throw new Error("Inner error");
        } catch (innerError) {
            console.log("Inner catch:", innerError);
            throw new Error("Rethrown from inner");
        }
    } catch (outerError) {
        console.log("Outer catch:", outerError);
    }
}

nestedTryCatch();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("nestedTryCatch") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested try-catch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_try_catch_typed() {
    // Test try-catch with typed catch clause
    let source = r#"class CustomError extends Error {
    constructor(public code: number, message: string) {
        super(message);
        this.name = "CustomError";
    }
}

function handleTypedError() {
    try {
        throw new CustomError(404, "Not found");
    } catch (e: unknown) {
        if (e instanceof CustomError) {
            console.log("Custom error code:", e.code);
        } else if (e instanceof Error) {
            console.log("Generic error:", e.message);
        }
    }
}

handleTypedError();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("handleTypedError") || output.contains("CustomError"),
        "expected output to contain function or class name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for try-catch with typed error"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_try_catch_rethrow() {
    // Test try-catch with rethrow
    let source = r#"function validateAndProcess(data: string) {
    try {
        if (!data) {
            throw new Error("Data is required");
        }
        return JSON.parse(data);
    } catch (e) {
        console.error("Validation failed");
        throw e;
    }
}

try {
    validateAndProcess("");
} catch (e) {
    console.log("Caught rethrown error:", e);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("validateAndProcess") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for try-catch with rethrow"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_try_catch_async() {
    // Test try-catch in async function
    let source = r#"async function fetchWithRetry(url: string, retries: number = 3): Promise<string> {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error("HTTP error");
            }
            return await response.text();
        } catch (e) {
            console.log(`Attempt ${i + 1} failed:`, e);
            if (i === retries - 1) {
                throw e;
            }
        }
    }
    throw new Error("Should not reach here");
}

fetchWithRetry("https://example.com");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchWithRetry") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for try-catch in async function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_try_catch_expression() {
    // Test try-catch with expression in throw
    let source = r#"function conditionalThrow(condition: boolean) {
    try {
        if (condition) {
            throw condition ? new Error("Condition true") : new Error("Condition false");
        }
        return "success";
    } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        return "error: " + message;
    }
}

console.log(conditionalThrow(true));
console.log(conditionalThrow(false));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("conditionalThrow") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for try-catch with throw expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_try_catch_class_method() {
    // Test try-catch in class method
    let source = r#"class DatabaseConnection {
    private connected: boolean = false;

    connect(): void {
        try {
            this.connected = true;
            console.log("Connected");
        } catch (e) {
            this.connected = false;
            throw new Error("Connection failed: " + e);
        }
    }

    query(sql: string): any[] {
        try {
            if (!this.connected) {
                throw new Error("Not connected");
            }
            return [{ result: sql }];
        } catch (e) {
            console.error("Query error:", e);
            return [];
        } finally {
            console.log("Query completed");
        }
    }
}

const db = new DatabaseConnection();
db.connect();
db.query("SELECT * FROM users");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DatabaseConnection") || output.contains("function"),
        "expected output to contain class name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for try-catch in class method"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_try_catch_combined() {
    // Test combined try-catch-finally patterns
    let source = r#"class ResourceManager {
    private resources: Map<string, { data: any; locked: boolean }> = new Map();

    acquire(id: string): any {
        try {
            const resource = this.resources.get(id);
            if (!resource) {
                throw new Error("Resource not found: " + id);
            }
            if (resource.locked) {
                throw new Error("Resource locked: " + id);
            }
            resource.locked = true;
            return resource.data;
        } catch (e) {
            console.error("Acquire failed:", e);
            throw e;
        }
    }

    async processWithResource(id: string, processor: (data: any) => Promise<void>): Promise<void> {
        let acquired = false;
        try {
            const data = this.acquire(id);
            acquired = true;
            try {
                await processor(data);
            } catch (processingError) {
                console.error("Processing error:", processingError);
                throw processingError;
            }
        } finally {
            if (acquired) {
                const resource = this.resources.get(id);
                if (resource) {
                    resource.locked = false;
                }
                console.log("Resource released:", id);
            }
        }
    }
}

const manager = new ResourceManager();
manager.processWithResource("test", async (data) => {
    console.log("Processing:", data);
});"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ResourceManager") || output.contains("processWithResource"),
        "expected output to contain class or method name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined try-catch-finally patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Switch-Case ES5 Source Map Tests
// ============================================================================

#[test]
fn test_source_map_switch_basic() {
    // Test basic switch with cases
    let source = r#"function getDay(n: number): string {
    switch (n) {
        case 0:
            return "Sunday";
        case 1:
            return "Monday";
        case 2:
            return "Tuesday";
        case 3:
            return "Wednesday";
        case 4:
            return "Thursday";
        case 5:
            return "Friday";
        case 6:
            return "Saturday";
    }
    return "Unknown";
}

console.log(getDay(3));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getDay") || output.contains("switch"),
        "expected output to contain function name or switch. output: {output}"
    );
    assert!(
        output.contains("case"),
        "expected output to contain case. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic switch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_switch_default() {
    // Test switch with default case
    let source = r#"function classify(value: number): string {
    switch (value) {
        case 1:
            return "one";
        case 2:
            return "two";
        case 3:
            return "three";
        default:
            return "other";
    }
}

console.log(classify(5));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("classify") || output.contains("switch"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        output.contains("default"),
        "expected output to contain default. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for switch with default"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_switch_fallthrough() {
    // Test switch with fall-through cases
    let source = r#"function isWeekend(day: string): boolean {
    switch (day) {
        case "Saturday":
        case "Sunday":
            return true;
        case "Monday":
        case "Tuesday":
        case "Wednesday":
        case "Thursday":
        case "Friday":
            return false;
        default:
            throw new Error("Invalid day");
    }
}

console.log(isWeekend("Saturday"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("isWeekend") || output.contains("switch"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for switch with fall-through"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_switch_break() {
    // Test switch with break statements
    let source = r#"function process(action: string): void {
    let result = "";
    switch (action) {
        case "start":
            result = "Starting...";
            console.log(result);
            break;
        case "stop":
            result = "Stopping...";
            console.log(result);
            break;
        case "pause":
            result = "Pausing...";
            console.log(result);
            break;
        default:
            result = "Unknown action";
            console.log(result);
            break;
    }
}

process("start");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("process") || output.contains("switch"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        output.contains("break"),
        "expected output to contain break. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for switch with break"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_switch_return() {
    // Test switch with return statements
    let source = r#"function getColor(code: number): string {
    switch (code) {
        case 0: return "black";
        case 1: return "red";
        case 2: return "green";
        case 3: return "yellow";
        case 4: return "blue";
        case 5: return "magenta";
        case 6: return "cyan";
        case 7: return "white";
        default: return "unknown";
    }
}

const colors = [0, 1, 2, 3].map(getColor);
console.log(colors);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getColor") || output.contains("switch"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for switch with return"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_switch_nested() {
    // Test nested switch statements
    let source = r#"function classify(category: string, subcategory: number): string {
    switch (category) {
        case "animal":
            switch (subcategory) {
                case 1: return "dog";
                case 2: return "cat";
                default: return "unknown animal";
            }
        case "plant":
            switch (subcategory) {
                case 1: return "tree";
                case 2: return "flower";
                default: return "unknown plant";
            }
        default:
            return "unknown category";
    }
}

console.log(classify("animal", 1));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("classify") || output.contains("switch"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested switch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_switch_in_function() {
    // Test switch inside various function types
    let source = r#"const handler = (event: string) => {
    switch (event) {
        case "click":
            return "clicked";
        case "hover":
            return "hovered";
        default:
            return "unknown event";
    }
};

const asyncHandler = async (event: string): Promise<string> => {
    switch (event) {
        case "load":
            return await Promise.resolve("loaded");
        case "error":
            return await Promise.resolve("errored");
        default:
            return "unknown";
    }
};

console.log(handler("click"));
asyncHandler("load").then(console.log);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("handler") || output.contains("switch"),
        "expected output to contain variable name or switch. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for switch in function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_switch_expression_cases() {
    // Test switch with expression cases
    let source = r#"const MODE_READ = 1;
const MODE_WRITE = 2;
const MODE_EXECUTE = 4;

function checkPermission(mode: number): string {
    switch (mode) {
        case MODE_READ:
            return "read";
        case MODE_WRITE:
            return "write";
        case MODE_EXECUTE:
            return "execute";
        case MODE_READ | MODE_WRITE:
            return "read-write";
        case MODE_READ | MODE_EXECUTE:
            return "read-execute";
        default:
            return "unknown";
    }
}

console.log(checkPermission(MODE_READ | MODE_WRITE));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("checkPermission") || output.contains("switch"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for switch with expression cases"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_switch_class_method() {
    // Test switch in class method
    let source = r#"class StateMachine {
    private state: string = "idle";

    transition(action: string): void {
        switch (this.state) {
            case "idle":
                if (action === "start") {
                    this.state = "running";
                }
                break;
            case "running":
                switch (action) {
                    case "pause":
                        this.state = "paused";
                        break;
                    case "stop":
                        this.state = "stopped";
                        break;
                }
                break;
            case "paused":
                if (action === "resume") {
                    this.state = "running";
                }
                break;
            default:
                console.log("Unknown state");
        }
    }

    getState(): string {
        return this.state;
    }
}

const machine = new StateMachine();
machine.transition("start");
console.log(machine.getState());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("StateMachine") || output.contains("transition"),
        "expected output to contain class or method name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for switch in class method"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_switch_combined() {
    // Test combined switch patterns
    let source = r#"enum HttpStatus {
    OK = 200,
    Created = 201,
    BadRequest = 400,
    NotFound = 404,
    InternalError = 500
}

interface Response {
    status: HttpStatus;
    message: string;
}

class HttpHandler {
    handleResponse(response: Response): string {
        switch (response.status) {
            case HttpStatus.OK:
            case HttpStatus.Created:
                return this.handleSuccess(response);
            case HttpStatus.BadRequest:
                return this.handleClientError(response);
            case HttpStatus.NotFound:
                return this.handleNotFound();
            case HttpStatus.InternalError:
                return this.handleServerError();
            default:
                return this.handleUnknown(response.status);
        }
    }

    private handleSuccess(response: Response): string {
        switch (response.status) {
            case HttpStatus.OK:
                return "OK: " + response.message;
            case HttpStatus.Created:
                return "Created: " + response.message;
            default:
                return "Success";
        }
    }

    private handleClientError(response: Response): string {
        return "Client Error: " + response.message;
    }

    private handleNotFound(): string {
        return "Not Found";
    }

    private handleServerError(): string {
        return "Internal Server Error";
    }

    private handleUnknown(status: HttpStatus): string {
        return "Unknown status: " + status;
    }
}

const handler = new HttpHandler();
console.log(handler.handleResponse({ status: HttpStatus.OK, message: "Success" }));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("HttpHandler") || output.contains("handleResponse"),
        "expected output to contain class or method name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined switch patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Labeled Statement ES5 Source Map Tests
// ============================================================================

#[test]
fn test_source_map_labeled_basic() {
    // Test basic labeled statement with break
    let source = r#"function findValue(matrix: number[][], target: number): boolean {
    outer: {
        for (let i = 0; i < matrix.length; i++) {
            for (let j = 0; j < matrix[i].length; j++) {
                if (matrix[i][j] === target) {
                    console.log("Found at", i, j);
                    break outer;
                }
            }
        }
        console.log("Not found");
    }
    return true;
}

findValue([[1, 2], [3, 4]], 3);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("findValue") || output.contains("outer"),
        "expected output to contain function name or label. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic labeled statement"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_labeled_for_break() {
    // Test labeled for loop with break
    let source = r#"function searchGrid(grid: string[][]): { row: number; col: number } | null {
    let result: { row: number; col: number } | null = null;

    search: for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[row].length; col++) {
            if (grid[row][col] === "X") {
                result = { row, col };
                break search;
            }
        }
    }

    return result;
}

const grid = [[".", "."], [".", "X"]];
console.log(searchGrid(grid));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("searchGrid") || output.contains("search"),
        "expected output to contain function name or label. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for labeled for loop"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_labeled_while_continue() {
    // Test labeled while loop with continue
    let source = r#"function processItems(items: number[][]): number {
    let total = 0;
    let i = 0;

    outer: while (i < items.length) {
        let j = 0;
        while (j < items[i].length) {
            if (items[i][j] < 0) {
                i++;
                continue outer;
            }
            total += items[i][j];
            j++;
        }
        i++;
    }

    return total;
}

console.log(processItems([[1, 2], [-1, 3], [4, 5]]));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processItems") || output.contains("outer"),
        "expected output to contain function name or label. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for labeled while loop"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_labeled_nested() {
    // Test nested labeled loops
    let source = r#"function findPath(maze: number[][]): string[] {
    const path: string[] = [];

    level1: for (let i = 0; i < maze.length; i++) {
        level2: for (let j = 0; j < maze[i].length; j++) {
            level3: for (let k = 0; k < 3; k++) {
                if (maze[i][j] === k) {
                    path.push(`${i},${j},${k}`);
                    if (k === 2) break level1;
                    if (k === 1) break level2;
                    continue level3;
                }
            }
        }
    }

    return path;
}

console.log(findPath([[0, 1], [2, 0]]));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("findPath") || output.contains("level"),
        "expected output to contain function name or label. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested labeled loops"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_labeled_block() {
    // Test labeled block statement
    let source = r#"function processData(data: any): string {
    let result = "";

    validation: {
        if (!data) {
            result = "No data";
            break validation;
        }
        if (!data.name) {
            result = "No name";
            break validation;
        }
        if (!data.value) {
            result = "No value";
            break validation;
        }
        result = "Valid: " + data.name + " = " + data.value;
    }

    return result;
}

console.log(processData({ name: "test", value: 42 }));
console.log(processData(null));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processData") || output.contains("validation"),
        "expected output to contain function name or label. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for labeled block"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_labeled_switch() {
    // Test labeled statement with switch
    let source = r#"function handleEvent(events: Array<{ type: string; data: any }>): void {
    eventLoop: for (const event of events) {
        switch (event.type) {
            case "skip":
                continue eventLoop;
            case "stop":
                console.log("Stopping");
                break eventLoop;
            case "process":
                console.log("Processing:", event.data);
                break;
            default:
                console.log("Unknown event:", event.type);
        }
    }
    console.log("Event loop finished");
}

handleEvent([
    { type: "process", data: 1 },
    { type: "skip", data: 2 },
    { type: "stop", data: 3 }
]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("handleEvent") || output.contains("eventLoop"),
        "expected output to contain function name or label. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for labeled switch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_labeled_in_function() {
    // Test labeled statement in different function types
    let source = r#"const processor = (items: number[]) => {
    mainLoop: for (let i = 0; i < items.length; i++) {
        if (items[i] < 0) break mainLoop;
        console.log(items[i]);
    }
};

async function asyncProcessor(items: Promise<number>[]): Promise<void> {
    asyncLoop: for (let i = 0; i < items.length; i++) {
        const value = await items[i];
        if (value < 0) break asyncLoop;
        console.log(value);
    }
}

processor([1, 2, -1, 3]);
asyncProcessor([Promise.resolve(1), Promise.resolve(-1)]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processor") || output.contains("mainLoop"),
        "expected output to contain variable name or label. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for labeled in function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_labeled_do_while() {
    // Test labeled do-while loop
    let source = r#"function retryOperation(maxRetries: number): boolean {
    let attempts = 0;
    let success = false;

    retryLoop: do {
        attempts++;
        console.log("Attempt", attempts);

        if (Math.random() > 0.7) {
            success = true;
            break retryLoop;
        }

        if (attempts >= maxRetries) {
            console.log("Max retries reached");
            break retryLoop;
        }
    } while (true);

    return success;
}

retryOperation(5);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("retryOperation") || output.contains("function"),
        "expected output to contain function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for labeled do-while"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_labeled_class_method() {
    // Test labeled statement in class method
    let source = r#"class DataProcessor {
    private data: number[][] = [];

    process(): number[] {
        const results: number[] = [];

        rowLoop: for (let i = 0; i < this.data.length; i++) {
            colLoop: for (let j = 0; j < this.data[i].length; j++) {
                const value = this.data[i][j];

                if (value < 0) {
                    continue rowLoop;
                }

                if (value > 100) {
                    break colLoop;
                }

                results.push(value);
            }
        }

        return results;
    }

    setData(data: number[][]): void {
        this.data = data;
    }
}

const processor = new DataProcessor();
processor.setData([[1, 2, -3], [4, 150, 6]]);
console.log(processor.process());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataProcessor") || output.contains("rowLoop"),
        "expected output to contain class name or label. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for labeled in class method"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_labeled_combined() {
    // Test combined labeled statement patterns
    let source = r#"interface Task {
    id: number;
    subtasks: Task[];
    status: "pending" | "done" | "skipped";
}

class TaskRunner {
    run(tasks: Task[]): number[] {
        const completed: number[] = [];

        taskLoop: for (const task of tasks) {
            validation: {
                if (task.status === "skipped") {
                    continue taskLoop;
                }
                if (task.status === "done") {
                    completed.push(task.id);
                    break validation;
                }

                subtaskLoop: for (const subtask of task.subtasks) {
                    switch (subtask.status) {
                        case "skipped":
                            continue subtaskLoop;
                        case "pending":
                            console.log("Pending subtask:", subtask.id);
                            break taskLoop;
                        case "done":
                            completed.push(subtask.id);
                            break;
                    }
                }
            }
        }

        return completed;
    }
}

const runner = new TaskRunner();
const tasks: Task[] = [
    { id: 1, subtasks: [{ id: 11, subtasks: [], status: "done" }], status: "pending" },
    { id: 2, subtasks: [], status: "done" }
];
console.log(runner.run(tasks));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("TaskRunner") || output.contains("taskLoop"),
        "expected output to contain class name or label. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined labeled patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// With Statement ES5 Source Map Tests
// ============================================================================

#[test]
fn test_source_map_with_basic() {
    // Test basic with statement
    let source = r#"var obj = { x: 10, y: 20 };

with (obj) {
    console.log(x);
    console.log(y);
}"#;

    let mut parser = ThinParserState::new("test.js".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.js");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("with") || output.contains("obj"),
        "expected output to contain with or obj. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic with statement"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_with_property_access() {
    // Test with statement with property access
    let source = r#"var config = {
    settings: {
        debug: true,
        verbose: false
    }
};

with (config.settings) {
    if (debug) {
        console.log("Debug mode");
    }
    if (verbose) {
        console.log("Verbose mode");
    }
}"#;

    let mut parser = ThinParserState::new("test.js".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.js");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("config") || output.contains("with"),
        "expected output to contain config or with. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for with property access"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_with_method_call() {
    // Test with statement with method calls
    let source = r#"var math = {
    PI: 3.14159,
    square: function(x) { return x * x; },
    cube: function(x) { return x * x * x; }
};

with (math) {
    var area = PI * square(5);
    var volume = PI * cube(3);
    console.log(area, volume);
}"#;

    let mut parser = ThinParserState::new("test.js".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.js");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("math") || output.contains("with"),
        "expected output to contain math or with. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for with method call"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_with_nested() {
    // Test nested with statements
    let source = r#"var outer = {
    name: "outer",
    inner: {
        name: "inner",
        value: 42
    }
};

with (outer) {
    console.log(name);
    with (inner) {
        console.log(name, value);
    }
}"#;

    let mut parser = ThinParserState::new("test.js".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.js");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("outer") || output.contains("with"),
        "expected output to contain outer or with. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested with statements"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_with_function() {
    // Test with statement with function definition
    let source = r#"var context = {
    multiplier: 10,
    offset: 5
};

function calculate(value) {
    with (context) {
        return value * multiplier + offset;
    }
}

console.log(calculate(3));"#;

    let mut parser = ThinParserState::new("test.js".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.js");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("calculate") || output.contains("function"),
        "expected output to contain calculate or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for with function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_with_loop() {
    // Test with statement with loop
    let source = r#"var data = {
    items: [1, 2, 3, 4, 5],
    sum: 0
};

with (data) {
    for (var i = 0; i < items.length; i++) {
        sum += items[i];
    }
    console.log("Sum:", sum);
}"#;

    let mut parser = ThinParserState::new("test.js".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.js");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("data") || output.contains("for"),
        "expected output to contain data or for. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for with loop"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_with_conditional() {
    // Test with statement with conditionals
    let source = r#"var user = {
    name: "John",
    age: 25,
    isAdmin: false
};

with (user) {
    if (isAdmin) {
        console.log(name + " is an admin");
    } else if (age >= 18) {
        console.log(name + " is an adult");
    } else {
        console.log(name + " is a minor");
    }
}"#;

    let mut parser = ThinParserState::new("test.js".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.js");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("user") || output.contains("if"),
        "expected output to contain user or if. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for with conditional"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_with_assignment() {
    // Test with statement with assignments
    let source = r#"var state = {
    count: 0,
    message: ""
};

with (state) {
    count = 10;
    message = "Updated";
    count++;
    message += "!";
}

console.log(state.count, state.message);"#;

    let mut parser = ThinParserState::new("test.js".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.js");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("state") || output.contains("with"),
        "expected output to contain state or with. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for with assignment"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_with_try_catch() {
    // Test with statement with try-catch
    let source = r#"var errorHandler = {
    log: function(msg) { console.log("Error:", msg); },
    count: 0
};

with (errorHandler) {
    try {
        throw new Error("Test error");
    } catch (e) {
        log(e.message);
        count++;
    }
}

console.log("Error count:", errorHandler.count);"#;

    let mut parser = ThinParserState::new("test.js".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.js");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("errorHandler") || output.contains("try"),
        "expected output to contain errorHandler or try. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for with try-catch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_with_combined() {
    // Test combined with statement patterns
    let source = r#"var app = {
    config: {
        debug: true,
        version: "1.0"
    },
    utils: {
        format: function(s) { return "[" + s + "]"; },
        log: function(msg) { console.log(msg); }
    },
    data: {
        items: ["a", "b", "c"],
        count: 0
    }
};

function processApp() {
    with (app) {
        with (config) {
            if (debug) {
                with (utils) {
                    log(format("Version: " + version));
                }
            }
        }

        with (data) {
            for (var i = 0; i < items.length; i++) {
                with (app.utils) {
                    log(format(items[i]));
                }
                count++;
            }
        }
    }
    return app.data.count;
}

console.log("Processed:", processApp());"#;

    let mut parser = ThinParserState::new("test.js".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.js");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processApp") || output.contains("app"),
        "expected output to contain processApp or app. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined with patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Throw Statement ES5 Source Map Tests
// ============================================================================

#[test]
fn test_source_map_throw_basic() {
    // Test basic throw Error
    let source = r#"function validate(value: number): void {
    if (value < 0) {
        throw new Error("Value must be non-negative");
    }
    console.log("Valid:", value);
}

try {
    validate(-5);
} catch (e) {
    console.error(e);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("throw") || output.contains("Error"),
        "expected output to contain throw or Error. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic throw"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_throw_string() {
    // Test throw string literal
    let source = r#"function assertNotNull(value: any): void {
    if (value === null) {
        throw "Value cannot be null";
    }
    if (value === undefined) {
        throw "Value cannot be undefined";
    }
}

try {
    assertNotNull(null);
} catch (e) {
    console.log("Caught:", e);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("throw") || output.contains("assertNotNull"),
        "expected output to contain throw or function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for throw string"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_throw_custom_error() {
    // Test throw custom error class
    let source = r#"class ValidationError extends Error {
    constructor(public field: string, message: string) {
        super(message);
        this.name = "ValidationError";
    }
}

function validateEmail(email: string): void {
    if (!email.includes("@")) {
        throw new ValidationError("email", "Invalid email format");
    }
}

try {
    validateEmail("invalid");
} catch (e) {
    if (e instanceof ValidationError) {
        console.log("Field:", e.field);
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ValidationError") || output.contains("throw"),
        "expected output to contain ValidationError or throw. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for throw custom error"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_throw_expression() {
    // Test throw with expression
    let source = r#"function getErrorMessage(code: number): string {
    return "Error code: " + code;
}

function process(code: number): void {
    if (code >= 400) {
        throw new Error(getErrorMessage(code));
    }
    console.log("Success");
}

try {
    process(404);
} catch (e) {
    console.error(e);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("process") || output.contains("throw"),
        "expected output to contain process or throw. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for throw expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_throw_in_function() {
    // Test throw in various function types
    let source = r#"const validator = (value: any) => {
    if (typeof value !== "number") {
        throw new TypeError("Expected a number");
    }
    return value;
};

function strictValidator(value: any): number {
    if (value === null || value === undefined) {
        throw new ReferenceError("Value is required");
    }
    return validator(value);
}

console.log(strictValidator(42));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("validator") || output.contains("throw"),
        "expected output to contain validator or throw. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for throw in function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_throw_conditional() {
    // Test throw in conditional branches
    let source = r#"function divide(a: number, b: number): number {
    if (b === 0) {
        throw new Error("Division by zero");
    } else if (!Number.isFinite(a) || !Number.isFinite(b)) {
        throw new Error("Invalid operands");
    } else if (a < 0 && b < 0) {
        throw new Error("Both operands negative");
    }
    return a / b;
}

try {
    console.log(divide(10, 2));
    console.log(divide(10, 0));
} catch (e) {
    console.error(e);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("divide") || output.contains("throw"),
        "expected output to contain divide or throw. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for throw conditional"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_throw_class_method() {
    // Test throw in class method
    let source = r#"class BankAccount {
    private balance: number = 0;

    deposit(amount: number): void {
        if (amount <= 0) {
            throw new Error("Deposit amount must be positive");
        }
        this.balance += amount;
    }

    withdraw(amount: number): void {
        if (amount <= 0) {
            throw new Error("Withdrawal amount must be positive");
        }
        if (amount > this.balance) {
            throw new Error("Insufficient funds");
        }
        this.balance -= amount;
    }

    getBalance(): number {
        return this.balance;
    }
}

const account = new BankAccount();
account.deposit(100);
console.log(account.getBalance());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("BankAccount") || output.contains("throw"),
        "expected output to contain BankAccount or throw. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for throw in class method"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_throw_async() {
    // Test throw in async function
    let source = r#"async function fetchData(url: string): Promise<string> {
    if (!url) {
        throw new Error("URL is required");
    }
    if (!url.startsWith("http")) {
        throw new Error("Invalid URL protocol");
    }
    return "data from " + url;
}

async function processUrl(url: string): Promise<void> {
    try {
        const data = await fetchData(url);
        console.log(data);
    } catch (e) {
        throw new Error("Failed to process: " + e);
    }
}

processUrl("https://example.com");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchData") || output.contains("function"),
        "expected output to contain fetchData or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for throw async"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_throw_rethrow() {
    // Test rethrow in catch block
    let source = r#"function riskyOperation(): void {
    throw new Error("Original error");
}

function wrapper(): void {
    try {
        riskyOperation();
    } catch (e) {
        console.log("Logging error");
        throw e;
    }
}

function outerWrapper(): void {
    try {
        wrapper();
    } catch (e) {
        if (e instanceof Error) {
            throw new Error("Wrapped: " + e.message);
        }
        throw e;
    }
}

try {
    outerWrapper();
} catch (e) {
    console.error("Final catch:", e);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("wrapper") || output.contains("throw"),
        "expected output to contain wrapper or throw. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for throw rethrow"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_throw_combined() {
    // Test combined throw patterns
    let source = r#"class HttpError extends Error {
    constructor(public statusCode: number, message: string) {
        super(message);
        this.name = "HttpError";
    }
}

class ApiClient {
    private baseUrl: string;

    constructor(baseUrl: string) {
        if (!baseUrl) {
            throw new Error("Base URL is required");
        }
        this.baseUrl = baseUrl;
    }

    async request(endpoint: string): Promise<any> {
        if (!endpoint) {
            throw new HttpError(400, "Endpoint is required");
        }

        const url = this.baseUrl + endpoint;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new HttpError(response.status, "Request failed");
            }
            return response.json();
        } catch (e) {
            if (e instanceof HttpError) {
                throw e;
            }
            throw new HttpError(500, "Network error: " + e);
        }
    }
}

async function main(): Promise<void> {
    const client = new ApiClient("https://api.example.com");
    try {
        const data = await client.request("/users");
        console.log(data);
    } catch (e) {
        if (e instanceof HttpError) {
            console.error("HTTP Error:", e.statusCode, e.message);
        } else {
            throw e;
        }
    }
}

main();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ApiClient") || output.contains("HttpError"),
        "expected output to contain ApiClient or HttpError. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined throw patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// Debugger Statement ES5 Source Map Tests
// ============================================================================

#[test]
fn test_source_map_debugger_basic() {
    // Test basic debugger statement
    let source = r#"function processData(data: any): void {
    debugger;
    console.log("Processing:", data);
}

processData({ value: 42 });"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("debugger") || output.contains("processData"),
        "expected output to contain debugger or function name. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic debugger"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_debugger_in_function() {
    // Test debugger in function
    let source = r#"function calculate(a: number, b: number): number {
    debugger;
    const sum = a + b;
    debugger;
    return sum;
}

function main(): void {
    debugger;
    const result = calculate(10, 20);
    console.log("Result:", result);
}

main();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("calculate") || output.contains("main"),
        "expected output to contain function names. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for debugger in function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_debugger_conditional() {
    // Test debugger in conditional
    let source = r#"function checkValue(value: number): string {
    if (value < 0) {
        debugger;
        return "negative";
    } else if (value === 0) {
        debugger;
        return "zero";
    } else {
        debugger;
        return "positive";
    }
}

console.log(checkValue(-5));
console.log(checkValue(0));
console.log(checkValue(10));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("checkValue") || output.contains("if"),
        "expected output to contain function name or if. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for debugger conditional"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_debugger_loop() {
    // Test debugger in loop
    let source = r#"function processArray(arr: number[]): number {
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
        debugger;
        sum += arr[i];
    }
    return sum;
}

function processWhile(n: number): number {
    let count = 0;
    while (count < n) {
        debugger;
        count++;
    }
    return count;
}

console.log(processArray([1, 2, 3]));
console.log(processWhile(5));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processArray") || output.contains("for"),
        "expected output to contain function name or for. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for debugger loop"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_debugger_class_method() {
    // Test debugger in class method
    let source = r#"class Calculator {
    private value: number = 0;

    add(n: number): this {
        debugger;
        this.value += n;
        return this;
    }

    subtract(n: number): this {
        debugger;
        this.value -= n;
        return this;
    }

    getValue(): number {
        debugger;
        return this.value;
    }
}

const calc = new Calculator();
console.log(calc.add(10).subtract(3).getValue());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Calculator") || output.contains("function"),
        "expected output to contain Calculator or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for debugger class method"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_debugger_try_catch() {
    // Test debugger in try-catch
    let source = r#"function riskyOperation(value: number): number {
    try {
        debugger;
        if (value < 0) {
            throw new Error("Negative value");
        }
        return value * 2;
    } catch (e) {
        debugger;
        console.error("Error:", e);
        return 0;
    } finally {
        debugger;
        console.log("Cleanup");
    }
}

console.log(riskyOperation(5));
console.log(riskyOperation(-1));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("riskyOperation") || output.contains("try"),
        "expected output to contain function name or try. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for debugger try-catch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_debugger_arrow_function() {
    // Test debugger in arrow function
    let source = r#"const multiply = (a: number, b: number) => {
    debugger;
    return a * b;
};

const process = (arr: number[]) => {
    debugger;
    return arr.map((x) => {
        debugger;
        return x * 2;
    });
};

console.log(multiply(3, 4));
console.log(process([1, 2, 3]));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("multiply") || output.contains("function"),
        "expected output to contain multiply or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for debugger arrow function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_debugger_async() {
    // Test debugger in async function
    let source = r#"async function fetchData(url: string): Promise<string> {
    debugger;
    const response = await fetch(url);
    debugger;
    return await response.text();
}

async function processUrls(urls: string[]): Promise<void> {
    for (const url of urls) {
        debugger;
        const data = await fetchData(url);
        console.log(data);
    }
}

processUrls(["https://example.com"]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchData") || output.contains("function"),
        "expected output to contain fetchData or function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for debugger async"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_debugger_switch() {
    // Test debugger in switch statement
    let source = r#"function handleAction(action: string): void {
    switch (action) {
        case "start":
            debugger;
            console.log("Starting...");
            break;
        case "stop":
            debugger;
            console.log("Stopping...");
            break;
        case "pause":
            debugger;
            console.log("Pausing...");
            break;
        default:
            debugger;
            console.log("Unknown action");
    }
}

handleAction("start");
handleAction("unknown");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("handleAction") || output.contains("switch"),
        "expected output to contain handleAction or switch. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for debugger switch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_debugger_combined() {
    // Test combined debugger patterns
    let source = r#"class DataProcessor {
    private data: number[] = [];

    constructor(initialData: number[]) {
        debugger;
        this.data = initialData;
    }

    async process(): Promise<number[]> {
        debugger;
        const results: number[] = [];

        for (let i = 0; i < this.data.length; i++) {
            debugger;
            try {
                const value = this.data[i];
                if (value < 0) {
                    debugger;
                    throw new Error("Negative value");
                }
                results.push(value * 2);
            } catch (e) {
                debugger;
                results.push(0);
            }
        }

        return results;
    }

    filter(predicate: (n: number) => boolean): number[] {
        debugger;
        return this.data.filter((n) => {
            debugger;
            return predicate(n);
        });
    }
}

async function main(): Promise<void> {
    debugger;
    const processor = new DataProcessor([1, -2, 3, 4]);
    const processed = await processor.process();
    console.log("Processed:", processed);

    const filtered = processor.filter((n) => n > 0);
    console.log("Filtered:", filtered);
}

main();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataProcessor") || output.contains("process"),
        "expected output to contain DataProcessor or process. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined debugger patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Empty Statement ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_empty_statement_basic() {
    // Test basic empty statement
    let source = r#"let x = 1;;
let y = 2;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("x") && output.contains("y"),
        "expected output to contain x and y. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for empty statement"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_empty_statement_multiple() {
    // Test multiple consecutive empty statements
    let source = r#"let a = 1;;;
;;;
let b = 2;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("a") && output.contains("b"),
        "expected output to contain a and b. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple empty statements"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_empty_statement_in_function() {
    // Test empty statement in function
    let source = r#"function processData(value: number): number {
    ;
    const result = value * 2;
    ;
    return result;
}

const output = processData(5);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processData"),
        "expected output to contain processData. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for empty statement in function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_empty_statement_in_loop() {
    // Test empty statement in loop
    let source = r#"function iterate(count: number): void {
    for (let i = 0; i < count; i++) {
        ;
        console.log(i);
        ;
    }
}

iterate(3);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("iterate"),
        "expected output to contain iterate. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for empty statement in loop"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_empty_statement_in_conditional() {
    // Test empty statement in conditional
    let source = r#"function checkValue(value: number): string {
    if (value > 0) {
        ;
        return "positive";
    } else {
        ;
        return "non-positive";
    }
}

const result = checkValue(10);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("checkValue"),
        "expected output to contain checkValue. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for empty statement in conditional"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_empty_statement_in_class() {
    // Test empty statement in class method
    let source = r#"class Calculator {
    private value: number = 0;

    add(n: number): number {
        ;
        this.value += n;
        ;
        return this.value;
    }

    reset(): void {
        ;
        this.value = 0;
        ;
    }
}

const calc = new Calculator();
calc.add(5);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Calculator"),
        "expected output to contain Calculator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for empty statement in class"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_empty_statement_in_switch() {
    // Test empty statement in switch case
    let source = r#"function handleCase(value: number): string {
    switch (value) {
        case 1:
            ;
            return "one";
        case 2:
            ;
            return "two";
        default:
            ;
            return "other";
    }
}

handleCase(1);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("handleCase") || output.contains("switch"),
        "expected output to contain handleCase or switch. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for empty statement in switch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_empty_statement_after_declaration() {
    // Test empty statement after various declarations
    let source = r#"const a = 1;;
let b = 2;;
var c = 3;;
function foo() {};;
class Bar {};;
const result = a + b + c;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("foo") || output.contains("Bar"),
        "expected output to contain foo or Bar. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for empty statement after declaration"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_empty_statement_in_try_catch() {
    // Test empty statement in try-catch blocks
    let source = r#"function safeDivide(a: number, b: number): number {
    try {
        ;
        if (b === 0) {
            throw new Error("Division by zero");
        }
        ;
        return a / b;
    } catch (e) {
        ;
        console.error(e);
        ;
        return 0;
    } finally {
        ;
        console.log("Operation complete");
        ;
    }
}

safeDivide(10, 2);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("safeDivide"),
        "expected output to contain safeDivide. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for empty statement in try-catch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_empty_statement_combined() {
    // Test combined empty statement patterns
    let source = r#"class DataService {
    private items: string[] = [];

    constructor() {
        ;
        this.items = [];
        ;
    }

    async fetchData(url: string): Promise<string[]> {
        ;
        try {
            ;
            const response = await fetch(url);
            ;
            if (!response.ok) {
                ;
                throw new Error("Failed to fetch");
            }
            ;
            return ["data1", "data2"];
        } catch (e) {
            ;
            console.error(e);
            ;
            return [];
        }
    }

    process(): void {
        ;
        for (let i = 0; i < this.items.length; i++) {
            ;
            switch (this.items[i]) {
                case "special":
                    ;
                    console.log("Special item");
                    ;
                    break;
                default:
                    ;
                    console.log("Regular item");
                    ;
            }
        }
        ;
    }
}

const service = new DataService();
service.process();;;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataService") || output.contains("process"),
        "expected output to contain DataService or process. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined empty statement patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Return Statement ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_return_basic() {
    // Test basic return statement
    let source = r#"function getValue(): number {
    return 42;
}

const result = getValue();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getValue") && output.contains("return"),
        "expected output to contain getValue and return. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for return statement"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_return_void() {
    // Test return without value
    let source = r#"function doNothing(): void {
    console.log("doing nothing");
    return;
}

doNothing();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("doNothing"),
        "expected output to contain doNothing. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for void return"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_return_expression() {
    // Test return with complex expression
    let source = r#"function calculate(a: number, b: number): number {
    return a * b + (a - b) / 2;
}

const result = calculate(10, 5);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("calculate"),
        "expected output to contain calculate. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for return expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_return_conditional() {
    // Test return in conditional branches
    let source = r#"function getSign(value: number): string {
    if (value > 0) {
        return "positive";
    } else if (value < 0) {
        return "negative";
    } else {
        return "zero";
    }
}

const sign = getSign(-5);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getSign"),
        "expected output to contain getSign. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for conditional return"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_return_object() {
    // Test return object literal
    let source = r#"function createPerson(name: string, age: number): { name: string; age: number } {
    return {
        name: name,
        age: age
    };
}

const person = createPerson("Alice", 30);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createPerson"),
        "expected output to contain createPerson. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for return object"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_return_array() {
    // Test return array literal
    let source = r#"function getNumbers(): number[] {
    return [1, 2, 3, 4, 5];
}

function getMatrix(): number[][] {
    return [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];
}

const nums = getNumbers();
const matrix = getMatrix();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getNumbers") && output.contains("getMatrix"),
        "expected output to contain getNumbers and getMatrix. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for return array"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_return_class_method() {
    // Test return in class methods
    let source = r#"class Calculator {
    private value: number = 0;

    add(n: number): Calculator {
        this.value += n;
        return this;
    }

    getValue(): number {
        return this.value;
    }

    static create(): Calculator {
        return new Calculator();
    }
}

const calc = Calculator.create().add(5).add(3);
const value = calc.getValue();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Calculator"),
        "expected output to contain Calculator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for return in class method"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_return_arrow_function() {
    // Test return in arrow functions
    let source = r#"const add = (a: number, b: number): number => {
    return a + b;
};

const multiply = (a: number, b: number): number => a * b;

const createAdder = (x: number) => {
    return (y: number) => {
        return x + y;
    };
};

const result1 = add(2, 3);
const result2 = multiply(4, 5);
const addFive = createAdder(5);
const result3 = addFive(10);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("add") || output.contains("multiply"),
        "expected output to contain add or multiply. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for return in arrow function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_return_async() {
    // Test return in async functions
    let source = r#"async function fetchData(url: string): Promise<string> {
    const response = await fetch(url);
    return response.text();
}

async function processData(): Promise<number> {
    const data = await fetchData("https://api.example.com");
    return data.length;
}

async function main(): Promise<void> {
    const length = await processData();
    console.log(length);
    return;
}

main();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchData") || output.contains("processData"),
        "expected output to contain fetchData or processData. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for return in async function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_return_combined() {
    // Test combined return patterns
    let source = r#"class DataProcessor {
    private items: number[] = [];

    constructor(items: number[]) {
        this.items = items;
    }

    process(): { sum: number; avg: number; max: number } {
        if (this.items.length === 0) {
            return { sum: 0, avg: 0, max: 0 };
        }

        const sum = this.items.reduce((a, b) => {
            return a + b;
        }, 0);

        const avg = sum / this.items.length;
        const max = Math.max(...this.items);

        return {
            sum: sum,
            avg: avg,
            max: max
        };
    }

    async processAsync(): Promise<number[]> {
        return new Promise((resolve) => {
            setTimeout(() => {
                const doubled = this.items.map((n) => {
                    return n * 2;
                });
                resolve(doubled);
                return;
            }, 100);
        });
    }

    filter(predicate: (n: number) => boolean): number[] {
        const result: number[] = [];
        for (const item of this.items) {
            if (predicate(item)) {
                result.push(item);
            }
        }
        return result;
    }

    static fromArray(arr: number[]): DataProcessor {
        return new DataProcessor(arr);
    }
}

const processor = DataProcessor.fromArray([1, 2, 3, 4, 5]);
const stats = processor.process();
const filtered = processor.filter((n) => n > 2);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataProcessor") || output.contains("process"),
        "expected output to contain DataProcessor or process. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined return patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Break/Continue Statement ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_break_basic() {
    // Test basic break statement in loop
    let source = r#"function findFirst(arr: number[], target: number): number {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            break;
        }
    }
    return -1;
}

const result = findFirst([1, 2, 3, 4, 5], 3);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("findFirst"),
        "expected output to contain findFirst. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for break statement"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_continue_basic() {
    // Test basic continue statement in loop
    let source = r#"function sumPositive(arr: number[]): number {
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] < 0) {
            continue;
        }
        sum += arr[i];
    }
    return sum;
}

const result = sumPositive([1, -2, 3, -4, 5]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("sumPositive"),
        "expected output to contain sumPositive. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for continue statement"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_break_while() {
    // Test break in while loop
    let source = r#"function readUntilEnd(data: string[]): string[] {
    const results: string[] = [];
    let i = 0;
    while (i < data.length) {
        if (data[i] === "END") {
            break;
        }
        results.push(data[i]);
        i++;
    }
    return results;
}

const output = readUntilEnd(["a", "b", "END", "c"]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("readUntilEnd"),
        "expected output to contain readUntilEnd. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for break in while"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_continue_while() {
    // Test continue in while loop
    let source = r#"function processNonEmpty(items: string[]): string[] {
    const results: string[] = [];
    let i = 0;
    while (i < items.length) {
        const item = items[i];
        i++;
        if (item === "") {
            continue;
        }
        results.push(item.toUpperCase());
    }
    return results;
}

const processed = processNonEmpty(["a", "", "b", "", "c"]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processNonEmpty"),
        "expected output to contain processNonEmpty. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for continue in while"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_break_labeled() {
    // Test labeled break statement
    let source = r#"function findInMatrix(matrix: number[][], target: number): [number, number] | null {
    outer: for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
            if (matrix[i][j] === target) {
                break outer;
            }
        }
    }
    return null;
}

const pos = findInMatrix([[1, 2], [3, 4]], 3);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("findInMatrix"),
        "expected output to contain findInMatrix. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for labeled break"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_continue_labeled() {
    // Test labeled continue statement
    let source = r#"function processRows(matrix: number[][]): number[] {
    const results: number[] = [];
    outer: for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
            if (matrix[i][j] < 0) {
                continue outer;
            }
        }
        results.push(i);
    }
    return results;
}

const validRows = processRows([[1, 2], [-1, 2], [3, 4]]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processRows"),
        "expected output to contain processRows. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for labeled continue"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_break_switch() {
    // Test break in switch statement
    let source = r#"function getDayName(day: number): string {
    let name: string;
    switch (day) {
        case 0:
            name = "Sunday";
            break;
        case 1:
            name = "Monday";
            break;
        case 2:
            name = "Tuesday";
            break;
        default:
            name = "Unknown";
            break;
    }
    return name;
}

const today = getDayName(1);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getDayName") || output.contains("switch"),
        "expected output to contain getDayName or switch. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for break in switch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_break_do_while() {
    // Test break in do-while loop
    let source = r#"function readInput(): number {
    let value = 0;
    let attempts = 0;
    do {
        attempts++;
        value = Math.random();
        if (value > 0.5) {
            break;
        }
    } while (attempts < 10);
    return value;
}

const input = readInput();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("readInput"),
        "expected output to contain readInput. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for break in do-while"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_break_continue_combined() {
    // Test combined break and continue patterns
    let source = r#"class DataIterator {
    private data: number[][] = [];

    constructor(data: number[][]) {
        this.data = data;
    }

    processAll(): number[] {
        const results: number[] = [];

        outer: for (let i = 0; i < this.data.length; i++) {
            const row = this.data[i];

            if (row.length === 0) {
                continue;
            }

            for (let j = 0; j < row.length; j++) {
                if (row[j] < 0) {
                    continue outer;
                }
                if (row[j] > 100) {
                    break outer;
                }
                results.push(row[j]);
            }
        }

        return results;
    }

    findValue(target: number): boolean {
        let found = false;
        let i = 0;

        while (i < this.data.length) {
            let j = 0;
            while (j < this.data[i].length) {
                if (this.data[i][j] === target) {
                    found = true;
                    break;
                }
                j++;
            }
            if (found) {
                break;
            }
            i++;
        }

        return found;
    }

    sumPositiveByRow(): number[] {
        const sums: number[] = [];

        for (let i = 0; i < this.data.length; i++) {
            let sum = 0;
            for (const val of this.data[i]) {
                if (val < 0) {
                    continue;
                }
                sum += val;
            }
            sums.push(sum);
        }

        return sums;
    }
}

const iterator = new DataIterator([[1, 2], [3, -4], [5, 6]]);
const processed = iterator.processAll();
const found = iterator.findValue(3);
const sums = iterator.sumPositiveByRow();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataIterator") || output.contains("processAll"),
        "expected output to contain DataIterator or processAll. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined break/continue patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Expression Statement ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_expression_function_call() {
    // Test function call expression statement
    let source = r#"function greet(name: string): void {
    console.log("Hello, " + name);
}

greet("World");
console.log("Done");
Math.random();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("greet"),
        "expected output to contain greet. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for function call expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_expression_assignment() {
    // Test assignment expression statements
    let source = r#"let x: number;
let y: number;
let z: number;

x = 10;
y = x + 5;
z = x * y;
x = y = z = 0;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("x") && output.contains("y") && output.contains("z"),
        "expected output to contain x, y, z. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for assignment expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_expression_increment_decrement() {
    // Test increment/decrement expression statements
    let source = r#"let counter = 0;

counter++;
++counter;
counter--;
--counter;

let arr = [1, 2, 3];
let i = 0;
arr[i++];
arr[++i];"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("counter"),
        "expected output to contain counter. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for increment/decrement"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_expression_method_call() {
    // Test method call expression statements
    let source = r#"const arr = [3, 1, 4, 1, 5];

arr.push(9);
arr.pop();
arr.sort();
arr.reverse();
arr.splice(1, 2);

const str = "hello";
str.toUpperCase();
str.charAt(0);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("arr") && output.contains("push"),
        "expected output to contain arr and push. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for method call"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_expression_compound_assignment() {
    // Test compound assignment expression statements
    let source = r#"let a = 10;
let b = 5;
let s = "hello";

a += b;
a -= b;
a *= b;
a /= b;
a %= b;
a **= 2;
s += " world";

let bits = 0xFF;
bits &= 0x0F;
bits |= 0xF0;
bits ^= 0xFF;
bits <<= 1;
bits >>= 1;
bits >>>= 1;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("a") && output.contains("b"),
        "expected output to contain a and b. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for compound assignment"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_expression_ternary() {
    // Test ternary expression statement
    let source = r#"const value = 10;
let result: string;

value > 5 ? console.log("big") : console.log("small");

function check(x: number): void {
    x > 0 ? x++ : x--;
}

check(value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("value") || output.contains("check"),
        "expected output to contain value or check. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ternary expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_expression_logical() {
    // Test logical expression statements
    let source = r#"const a = true;
const b = false;
let callback: (() => void) | null = null;

a && console.log("a is true");
b || console.log("b is false");
callback && callback();

function maybeCall(fn: (() => void) | undefined): void {
    fn && fn();
}

maybeCall(() => console.log("called"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("maybeCall") || output.contains("callback"),
        "expected output to contain maybeCall or callback. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for logical expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_expression_new() {
    // Test new expression statements
    let source = r#"class Widget {
    constructor(public name: string) {}
}

new Widget("button");
new Date();
new Array(10);
new Map();
new Set([1, 2, 3]);

const widgets: Widget[] = [];
widgets.push(new Widget("checkbox"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Widget"),
        "expected output to contain Widget. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for new expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_expression_delete_void_typeof() {
    // Test delete, void, typeof expression statements
    let source = r#"const obj: { [key: string]: number } = { a: 1, b: 2 };

delete obj.a;
delete obj["b"];

void 0;
void console.log("side effect");

typeof obj;
typeof undefined;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("obj") || output.contains("delete"),
        "expected output to contain obj or delete. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for delete/void/typeof"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_expression_combined() {
    // Test combined expression statement patterns
    let source = r#"class Counter {
    private count = 0;
    private history: number[] = [];

    increment(): void {
        this.count++;
        this.history.push(this.count);
    }

    decrement(): void {
        --this.count;
        this.history.push(this.count);
    }

    reset(): void {
        this.count = 0;
        this.history.length = 0;
    }

    log(): void {
        console.log("Count:", this.count);
        this.history.forEach((v, i) => console.log(i, v));
    }
}

const counter = new Counter();
counter.increment();
counter.increment();
counter.decrement();
counter.log();

let x = 0;
let y = 0;
x = y = 10;
x += 5;
y *= 2;

x > y ? console.log("x wins") : console.log("y wins");
x && y && console.log("both truthy");

const arr = [1, 2, 3];
arr.push(4);
arr.pop();
arr.sort((a, b) => a - b);
arr.reverse();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter") || output.contains("increment"),
        "expected output to contain Counter or increment. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined expression patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Variable Declaration ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_var_declaration_basic() {
    // Test basic var declarations
    let source = r#"var x = 10;
var y = 20;
var z;
z = x + y;
console.log(z);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("var") && output.contains("x") && output.contains("y"),
        "expected output to contain var, x, y. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for var declaration"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_let_const_declaration() {
    // Test let and const declarations (downleveled to var in ES5)
    let source = r#"let a = 1;
let b = 2;
const c = 3;
const d = a + b + c;
console.log(d);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("a") && output.contains("b") && output.contains("c"),
        "expected output to contain a, b, c. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for let/const declaration"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_multiple_declarators() {
    // Test multiple variable declarators in single statement
    let source = r#"var a = 1, b = 2, c = 3;
let x = 10, y = 20, z = 30;
const m = 100, n = 200;
console.log(a, b, c, x, y, z, m, n);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("a") && output.contains("b") && output.contains("c"),
        "expected output to contain a, b, c. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple declarators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_declaration_with_type() {
    // Test declarations with type annotations
    let source = r#"let num: number = 42;
let str: string = "hello";
let bool: boolean = true;
let arr: number[] = [1, 2, 3];
let obj: { x: number; y: number } = { x: 1, y: 2 };
let fn: (a: number) => number = (a) => a * 2;

console.log(num, str, bool, arr, obj, fn(5));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("num") && output.contains("str"),
        "expected output to contain num and str. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for typed declarations"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_declaration_destructuring_object() {
    // Test object destructuring declarations
    let source = r#"const obj = { a: 1, b: 2, c: 3 };
const { a, b } = obj;
const { c: renamed } = obj;
const { a: x, b: y, ...rest } = { a: 1, b: 2, c: 3, d: 4 };

console.log(a, b, renamed, x, y, rest);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("obj"),
        "expected output to contain obj. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for object destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_declaration_destructuring_array() {
    // Test array destructuring declarations
    let source = r#"const arr = [1, 2, 3, 4, 5];
const [first, second] = arr;
const [a, , c] = arr;
const [head, ...tail] = arr;
const [x, y, z = 10] = [1, 2];

console.log(first, second, a, c, head, tail, x, y, z);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("arr"),
        "expected output to contain arr. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for array destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_declaration_in_function() {
    // Test variable declarations inside functions
    let source = r#"function processData(input: number): number {
    var multiplier = 2;
    let result = input * multiplier;
    const final = result + 10;

    if (final > 50) {
        let bonus = 5;
        return final + bonus;
    }

    return final;
}

const output = processData(25);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processData"),
        "expected output to contain processData. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for declarations in function"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_declaration_in_for_loop() {
    // Test variable declarations in for loops
    let source = r#"const items = [1, 2, 3, 4, 5];
let sum = 0;

for (let i = 0; i < items.length; i++) {
    sum += items[i];
}

for (var j = 0; j < 3; j++) {
    console.log(j);
}

for (const item of items) {
    console.log(item);
}

for (const [index, value] of items.entries()) {
    console.log(index, value);
}

console.log(sum);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("items") || output.contains("sum"),
        "expected output to contain items or sum. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for declarations in for loop"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_declaration_complex_initializers() {
    // Test declarations with complex initializers
    let source = r#"const fn = function(x: number): number { return x * 2; };
const arrow = (y: number): number => y + 1;
const obj = { method(): number { return 42; } };
const arr = [1, 2, 3].map((n) => n * 2);
const cond = true ? "yes" : "no";
const template = `value is ${42}`;

const nested = {
    data: [1, 2, 3],
    process(): number[] {
        return this.data.map((n) => n * 2);
    }
};

console.log(fn(5), arrow(10), obj.method(), arr, cond, template);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fn") || output.contains("arrow"),
        "expected output to contain fn or arrow. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for complex initializers"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_declaration_combined() {
    // Test combined variable declaration patterns
    let source = r#"class DataStore {
    private items: string[] = [];

    constructor() {
        const initial = ["a", "b", "c"];
        this.items = initial;
    }

    process(): { count: number; items: string[] } {
        var count = 0;
        let filtered: string[] = [];
        const threshold = 1;

        for (let i = 0; i < this.items.length; i++) {
            const item = this.items[i];
            if (item.length > threshold) {
                filtered.push(item);
                count++;
            }
        }

        const { length: total } = filtered;
        const [first = "none", ...rest] = filtered;

        let result = { count, items: filtered };
        return result;
    }
}

const store = new DataStore();
const { count, items } = store.process();
console.log(count, items);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataStore") || output.contains("process"),
        "expected output to contain DataStore or process. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined declaration patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Function Declaration ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_function_declaration_basic() {
    // Test basic function declaration
    let source = r#"function greet() {
    console.log("Hello");
}

function sayGoodbye() {
    console.log("Goodbye");
}

greet();
sayGoodbye();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("greet") && output.contains("sayGoodbye"),
        "expected output to contain greet and sayGoodbye. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for function declaration"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_function_with_parameters() {
    // Test function with various parameter types
    let source = r#"function add(a: number, b: number): number {
    return a + b;
}

function greetPerson(name: string, age: number): string {
    return "Hello " + name + ", you are " + age;
}

function processArray(items: number[]): number {
    let sum = 0;
    for (const item of items) {
        sum += item;
    }
    return sum;
}

console.log(add(1, 2));
console.log(greetPerson("Alice", 30));
console.log(processArray([1, 2, 3]));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("add") && output.contains("greetPerson"),
        "expected output to contain add and greetPerson. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for function with parameters"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_function_default_parameters() {
    // Test function with default parameters
    let source = r#"function greet(name: string = "World"): string {
    return "Hello, " + name;
}

function createPoint(x: number = 0, y: number = 0): { x: number; y: number } {
    return { x, y };
}

function formatMessage(msg: string, prefix: string = "[INFO]", suffix: string = ""): string {
    return prefix + " " + msg + suffix;
}

console.log(greet());
console.log(greet("Alice"));
console.log(createPoint());
console.log(createPoint(10, 20));
console.log(formatMessage("Hello"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("greet") || output.contains("createPoint"),
        "expected output to contain greet or createPoint. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for default parameters"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_function_rest_parameters() {
    // Test function with rest parameters
    let source = r#"function sum(...numbers: number[]): number {
    return numbers.reduce((a, b) => a + b, 0);
}

function concat(separator: string, ...items: string[]): string {
    return items.join(separator);
}

function logAll(prefix: string, ...values: any[]): void {
    for (const value of values) {
        console.log(prefix, value);
    }
}

console.log(sum(1, 2, 3, 4, 5));
console.log(concat(", ", "a", "b", "c"));
logAll("[DEBUG]", "one", "two", "three");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("sum") || output.contains("concat"),
        "expected output to contain sum or concat. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for rest parameters"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_function_nested() {
    // Test nested function declarations
    let source = r#"function outer(x: number): number {
    function inner(y: number): number {
        return y * 2;
    }

    function helper(z: number): number {
        return z + 1;
    }

    return inner(helper(x));
}

function createCounter(): () => number {
    let count = 0;

    function increment(): number {
        count++;
        return count;
    }

    return increment;
}

console.log(outer(5));
const counter = createCounter();
console.log(counter());
console.log(counter());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("outer") || output.contains("createCounter"),
        "expected output to contain outer or createCounter. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested functions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_function_generator() {
    // Test generator function declarations
    let source = r#"function* numberGenerator(): Generator<number> {
    yield 1;
    yield 2;
    yield 3;
}

function* rangeGenerator(start: number, end: number): Generator<number> {
    for (let i = start; i <= end; i++) {
        yield i;
    }
}

function* infiniteCounter(): Generator<number> {
    let n = 0;
    while (true) {
        yield n++;
    }
}

const gen = numberGenerator();
console.log(gen.next().value);
console.log(gen.next().value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("numberGenerator") || output.contains("rangeGenerator"),
        "expected output to contain numberGenerator or rangeGenerator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator functions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_function_async() {
    // Test async function declarations
    let source = r#"async function fetchData(url: string): Promise<string> {
    const response = await fetch(url);
    return response.text();
}

async function processItems(items: number[]): Promise<number[]> {
    const results: number[] = [];
    for (const item of items) {
        const processed = await Promise.resolve(item * 2);
        results.push(processed);
    }
    return results;
}

async function delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

fetchData("https://example.com").then(console.log);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchData") || output.contains("processItems"),
        "expected output to contain fetchData or processItems. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async functions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_function_destructuring_params() {
    // Test functions with destructuring parameters
    let source = r#"function processPoint({ x, y }: { x: number; y: number }): number {
    return x + y;
}

function formatUser({ name, age = 0 }: { name: string; age?: number }): string {
    return name + " (" + age + ")";
}

function sumArray([first, second, ...rest]: number[]): number {
    return first + second + rest.reduce((a, b) => a + b, 0);
}

console.log(processPoint({ x: 10, y: 20 }));
console.log(formatUser({ name: "Alice" }));
console.log(sumArray([1, 2, 3, 4, 5]));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processPoint") || output.contains("formatUser"),
        "expected output to contain processPoint or formatUser. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for destructuring params"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_function_generic() {
    // Test generic function declarations
    let source = r#"function identity<T>(value: T): T {
    return value;
}

function map<T, U>(items: T[], fn: (item: T) => U): U[] {
    const results: U[] = [];
    for (const item of items) {
        results.push(fn(item));
    }
    return results;
}

function swap<T, U>(pair: [T, U]): [U, T] {
    return [pair[1], pair[0]];
}

console.log(identity<number>(42));
console.log(map<number, string>([1, 2, 3], (n) => String(n)));
console.log(swap<string, number>(["hello", 42]));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("identity") || output.contains("map"),
        "expected output to contain identity or map. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generic functions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_function_declaration_combined() {
    // Test combined function declaration patterns
    let source = r#"function createCalculator(initialValue: number = 0) {
    let value = initialValue;

    function add(n: number): void {
        value += n;
    }

    function subtract(n: number): void {
        value -= n;
    }

    function getValue(): number {
        return value;
    }

    async function asyncMultiply(n: number): Promise<number> {
        return value * n;
    }

    function* valueHistory(): Generator<number> {
        yield initialValue;
        yield value;
    }

    return {
        add,
        subtract,
        getValue,
        asyncMultiply,
        valueHistory
    };
}

function processData<T>(
    items: T[],
    { filter = (x: T) => true, transform = (x: T) => x }: {
        filter?: (item: T) => boolean;
        transform?: (item: T) => T;
    } = {}
): T[] {
    return items.filter(filter).map(transform);
}

function compose<A, B, C>(
    f: (a: A) => B,
    g: (b: B) => C
): (a: A) => C {
    return function(a: A): C {
        return g(f(a));
    };
}

const calc = createCalculator(10);
calc.add(5);
console.log(calc.getValue());

const numbers = processData([1, 2, 3, 4, 5], {
    filter: (n) => n > 2,
    transform: (n) => n * 2
});
console.log(numbers);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createCalculator") || output.contains("processData"),
        "expected output to contain createCalculator or processData. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined function patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Class Declaration ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_class_declaration_basic() {
    // Test basic class declaration with ES5 downleveling
    let source = r#"class Animal {
    name: string;

    constructor(name: string) {
        this.name = name;
    }
}

const dog = new Animal("Rex");
console.log(dog.name);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Animal"),
        "expected output to contain Animal. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic class"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_with_methods() {
    // Test class with instance methods
    let source = r#"class Calculator {
    private value: number;

    constructor(initial: number = 0) {
        this.value = initial;
    }

    add(n: number): this {
        this.value += n;
        return this;
    }

    subtract(n: number): this {
        this.value -= n;
        return this;
    }

    multiply(n: number): this {
        this.value *= n;
        return this;
    }

    getResult(): number {
        return this.value;
    }
}

const calc = new Calculator(10);
console.log(calc.add(5).multiply(2).getResult());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Calculator") || output.contains("add"),
        "expected output to contain Calculator or add. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_static_members() {
    // Test class with static methods and properties
    let source = r#"class Counter {
    static count: number = 0;

    static increment(): void {
        Counter.count++;
    }

    static decrement(): void {
        Counter.count--;
    }

    static getCount(): number {
        return Counter.count;
    }

    static reset(): void {
        Counter.count = 0;
    }
}

Counter.increment();
Counter.increment();
console.log(Counter.getCount());
Counter.reset();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter") || output.contains("increment"),
        "expected output to contain Counter or increment. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static members"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_getters_setters() {
    // Test class with getter and setter accessors
    let source = r#"class Person {
    private _firstName: string;
    private _lastName: string;
    private _age: number;

    constructor(firstName: string, lastName: string, age: number) {
        this._firstName = firstName;
        this._lastName = lastName;
        this._age = age;
    }

    get fullName(): string {
        return this._firstName + " " + this._lastName;
    }

    set fullName(value: string) {
        const parts = value.split(" ");
        this._firstName = parts[0] || "";
        this._lastName = parts[1] || "";
    }

    get age(): number {
        return this._age;
    }

    set age(value: number) {
        if (value >= 0) {
            this._age = value;
        }
    }
}

const person = new Person("John", "Doe", 30);
console.log(person.fullName);
person.fullName = "Jane Smith";
console.log(person.age);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Person") || output.contains("fullName"),
        "expected output to contain Person or fullName. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for getters/setters"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_inheritance() {
    // Test class inheritance with extends
    let source = r#"class Shape {
    protected x: number;
    protected y: number;

    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }

    move(dx: number, dy: number): void {
        this.x += dx;
        this.y += dy;
    }

    describe(): string {
        return "Shape at (" + this.x + ", " + this.y + ")";
    }
}

class Circle extends Shape {
    private radius: number;

    constructor(x: number, y: number, radius: number) {
        super(x, y);
        this.radius = radius;
    }

    describe(): string {
        return "Circle at (" + this.x + ", " + this.y + ") with radius " + this.radius;
    }

    area(): number {
        return Math.PI * this.radius * this.radius;
    }
}

class Rectangle extends Shape {
    private width: number;
    private height: number;

    constructor(x: number, y: number, width: number, height: number) {
        super(x, y);
        this.width = width;
        this.height = height;
    }

    describe(): string {
        return "Rectangle at (" + this.x + ", " + this.y + ")";
    }

    area(): number {
        return this.width * this.height;
    }
}

const circle = new Circle(0, 0, 5);
const rect = new Rectangle(10, 10, 20, 30);
console.log(circle.describe());
console.log(rect.area());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Shape") || output.contains("Circle") || output.contains("Rectangle"),
        "expected output to contain Shape, Circle, or Rectangle. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class inheritance"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_constructor_parameter_properties() {
    // Test class with constructor parameter properties
    let source = r#"class User {
    constructor(
        public readonly id: number,
        public name: string,
        private email: string,
        protected role: string = "user"
    ) {}

    getEmail(): string {
        return this.email;
    }

    describe(): string {
        return "User " + this.name + " with role " + this.role;
    }
}

class Admin extends User {
    constructor(id: number, name: string, email: string) {
        super(id, name, email, "admin");
    }

    getRole(): string {
        return this.role;
    }
}

const user = new User(1, "John", "john@example.com");
const admin = new Admin(2, "Jane", "jane@example.com");
console.log(user.describe());
console.log(admin.getRole());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("User") || output.contains("Admin"),
        "expected output to contain User or Admin. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for constructor parameter properties"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expression() {
    // Test class expressions (anonymous and named)
    let source = r#"const Logger = class {
    private prefix: string;

    constructor(prefix: string) {
        this.prefix = prefix;
    }

    log(message: string): void {
        console.log(this.prefix + ": " + message);
    }
};

const NamedLogger = class CustomLogger {
    private level: string;

    constructor(level: string) {
        this.level = level;
    }

    log(message: string): void {
        console.log("[" + this.level + "] " + message);
    }
};

const factories = {
    createLogger: class {
        create(name: string) {
            return new Logger(name);
        }
    }
};

const logger = new Logger("App");
const namedLogger = new NamedLogger("INFO");
logger.log("Hello");
namedLogger.log("World");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Logger") || output.contains("log"),
        "expected output to contain Logger or log. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expressions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_generic() {
    // Test generic class declarations
    let source = r#"class Container<T> {
    private value: T;

    constructor(value: T) {
        this.value = value;
    }

    getValue(): T {
        return this.value;
    }

    setValue(value: T): void {
        this.value = value;
    }
}

class Pair<K, V> {
    constructor(private key: K, private val: V) {}

    getKey(): K {
        return this.key;
    }

    getValue(): V {
        return this.val;
    }

    toArray(): [K, V] {
        return [this.key, this.val];
    }
}

class Stack<T> {
    private items: T[] = [];

    push(item: T): void {
        this.items.push(item);
    }

    pop(): T | undefined {
        return this.items.pop();
    }

    peek(): T | undefined {
        return this.items[this.items.length - 1];
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }
}

const numContainer = new Container<number>(42);
const strPair = new Pair<string, number>("age", 30);
const stack = new Stack<string>();
stack.push("hello");
console.log(numContainer.getValue());
console.log(strPair.toArray());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Container") || output.contains("Stack") || output.contains("Pair"),
        "expected output to contain Container, Stack, or Pair. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generic classes"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_abstract() {
    // Test abstract class declarations
    let source = r#"abstract class Vehicle {
    protected speed: number = 0;

    constructor(protected name: string) {}

    abstract start(): void;
    abstract stop(): void;

    accelerate(amount: number): void {
        this.speed += amount;
    }

    getSpeed(): number {
        return this.speed;
    }

    describe(): string {
        return this.name + " moving at " + this.speed;
    }
}

class Car extends Vehicle {
    constructor(name: string) {
        super(name);
    }

    start(): void {
        console.log(this.name + " engine started");
        this.speed = 10;
    }

    stop(): void {
        console.log(this.name + " stopped");
        this.speed = 0;
    }
}

class Bicycle extends Vehicle {
    constructor(name: string) {
        super(name);
    }

    start(): void {
        console.log("Pedaling " + this.name);
        this.speed = 5;
    }

    stop(): void {
        console.log("Braking " + this.name);
        this.speed = 0;
    }
}

const car = new Car("Tesla");
const bike = new Bicycle("Mountain Bike");
car.start();
car.accelerate(50);
console.log(car.describe());
bike.start();
console.log(bike.getSpeed());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Vehicle") || output.contains("Car") || output.contains("Bicycle"),
        "expected output to contain Vehicle, Car, or Bicycle. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for abstract classes"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_declaration_combined() {
    // Test combined class declaration patterns
    let source = r#"abstract class BaseService<T> {
    protected items: T[] = [];

    abstract validate(item: T): boolean;

    add(item: T): void {
        if (this.validate(item)) {
            this.items.push(item);
        }
    }

    getAll(): T[] {
        return this.items.slice();
    }

    get count(): number {
        return this.items.length;
    }
}

interface Entity {
    id: number;
    name: string;
}

class EntityService extends BaseService<Entity> {
    private static instance: EntityService;
    static counter: number = 0;

    private constructor() {
        super();
    }

    static getInstance(): EntityService {
        if (!EntityService.instance) {
            EntityService.instance = new EntityService();
        }
        return EntityService.instance;
    }

    validate(item: Entity): boolean {
        EntityService.counter++;
        return item.id > 0 && item.name.length > 0;
    }

    findById(id: number): Entity | undefined {
        return this.items.find(item => item.id === id);
    }

    get isEmpty(): boolean {
        return this.items.length === 0;
    }

    set defaultItem(item: Entity) {
        if (this.isEmpty) {
            this.add(item);
        }
    }
}

class CachedService<T extends Entity> extends BaseService<T> {
    private cache: Map<number, T> = new Map();

    constructor(private readonly cacheDuration: number = 1000) {
        super();
    }

    validate(item: T): boolean {
        return item.id > 0;
    }

    add(item: T): void {
        super.add(item);
        this.cache.set(item.id, item);
    }

    getFromCache(id: number): T | undefined {
        return this.cache.get(id);
    }
}

const service = EntityService.getInstance();
service.add({ id: 1, name: "First" });
service.add({ id: 2, name: "Second" });
console.log(service.count);
console.log(EntityService.counter);

const cached = new CachedService<Entity>(5000);
cached.add({ id: 100, name: "Cached Item" });
console.log(cached.getFromCache(100));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("BaseService")
            || output.contains("EntityService")
            || output.contains("CachedService"),
        "expected output to contain BaseService, EntityService, or CachedService. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined class patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Interface/Type Alias ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_interface_basic() {
    // Test basic interface with type erasure - interface is removed, runtime code mapped
    let source = r#"interface Person {
    name: string;
    age: number;
}

const person: Person = {
    name: "John",
    age: 30
};

console.log(person.name);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Interface should be erased, but runtime code should be present
    assert!(
        !output.contains("interface"),
        "interface keyword should be erased. output: {output}"
    );
    assert!(
        output.contains("person"),
        "expected output to contain person. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for interface usage"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_type_alias_basic() {
    // Test basic type alias with type erasure
    let source = r#"type StringOrNumber = string | number;
type Point = { x: number; y: number };

const value: StringOrNumber = "hello";
const point: Point = { x: 10, y: 20 };

console.log(value, point.x);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Type alias should be erased
    assert!(
        !output.contains("type StringOrNumber") && !output.contains("type Point"),
        "type alias should be erased. output: {output}"
    );
    assert!(
        output.contains("value") && output.contains("point"),
        "expected output to contain value and point. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for type alias usage"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_with_methods() {
    // Test interface with method signatures
    let source = r#"interface Calculator {
    add(a: number, b: number): number;
    subtract(a: number, b: number): number;
    multiply(a: number, b: number): number;
}

const calc: Calculator = {
    add(a, b) { return a + b; },
    subtract(a, b) { return a - b; },
    multiply(a, b) { return a * b; }
};

console.log(calc.add(5, 3));
console.log(calc.subtract(10, 4));
console.log(calc.multiply(2, 6));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("calc") && output.contains("add"),
        "expected output to contain calc and add. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for interface with methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_extends() {
    // Test interface extending another interface
    let source = r#"interface Animal {
    name: string;
    age: number;
}

interface Dog extends Animal {
    breed: string;
    bark(): void;
}

const dog: Dog = {
    name: "Rex",
    age: 5,
    breed: "German Shepherd",
    bark() {
        console.log("Woof!");
    }
};

dog.bark();
console.log(dog.name, dog.breed);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("dog") && output.contains("bark"),
        "expected output to contain dog and bark. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for interface extends"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_type_alias_union_intersection() {
    // Test union and intersection type aliases
    let source = r#"type ID = string | number;
type Name = { first: string; last: string };
type Age = { age: number };
type Person = Name & Age;

const id: ID = 123;
const person: Person = {
    first: "John",
    last: "Doe",
    age: 30
};

function printId(id: ID): void {
    console.log("ID:", id);
}

function printPerson(p: Person): void {
    console.log(p.first, p.last, p.age);
}

printId(id);
printPerson(person);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("printId") && output.contains("printPerson"),
        "expected output to contain printId and printPerson. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for union/intersection types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_generic() {
    // Test generic interface declarations
    let source = r#"interface Container<T> {
    value: T;
    getValue(): T;
    setValue(value: T): void;
}

interface Pair<K, V> {
    key: K;
    value: V;
}

const numContainer: Container<number> = {
    value: 42,
    getValue() { return this.value; },
    setValue(v) { this.value = v; }
};

const pair: Pair<string, number> = {
    key: "age",
    value: 30
};

console.log(numContainer.getValue());
console.log(pair.key, pair.value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("numContainer") || output.contains("pair"),
        "expected output to contain numContainer or pair. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generic interface"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_type_alias_generic() {
    // Test generic type alias declarations
    let source = r#"type Nullable<T> = T | null;
type Result<T, E> = { success: true; value: T } | { success: false; error: E };
type AsyncResult<T> = Promise<Result<T, Error>>;

const name: Nullable<string> = "John";
const nullName: Nullable<string> = null;

const success: Result<number, string> = { success: true, value: 42 };
const failure: Result<number, string> = { success: false, error: "Not found" };

function processResult<T>(result: Result<T, string>): T | null {
    if (result.success) {
        return result.value;
    }
    console.log("Error:", result.error);
    return null;
}

console.log(name, nullName);
console.log(processResult(success));
console.log(processResult(failure));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processResult") || output.contains("success"),
        "expected output to contain processResult or success. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generic type alias"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_type_alias_mapped() {
    // Test mapped type aliases
    let source = r#"type Readonly<T> = { readonly [K in keyof T]: T[K] };
type Partial<T> = { [K in keyof T]?: T[K] };
type Pick<T, K extends keyof T> = { [P in K]: T[P] };

interface User {
    id: number;
    name: string;
    email: string;
}

const readonlyUser: Readonly<User> = {
    id: 1,
    name: "John",
    email: "john@example.com"
};

const partialUser: Partial<User> = {
    name: "Jane"
};

const pickedUser: Pick<User, "id" | "name"> = {
    id: 2,
    name: "Bob"
};

console.log(readonlyUser.name);
console.log(partialUser.name);
console.log(pickedUser.id, pickedUser.name);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("readonlyUser") || output.contains("partialUser"),
        "expected output to contain readonlyUser or partialUser. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for mapped types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_type_alias_conditional() {
    // Test conditional type aliases
    let source = r#"type IsString<T> = T extends string ? true : false;
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;
type NonNullable<T> = T extends null | undefined ? never : T;

type StringCheck = IsString<string>;
type NumberCheck = IsString<number>;

const value1: NonNullable<string | null> = "hello";
const value2: UnwrapPromise<Promise<number>> = 42;

function checkType<T>(value: T): IsString<T> {
    return (typeof value === "string") as any;
}

console.log(value1, value2);
console.log(checkType("test"));
console.log(checkType(123));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("checkType") || output.contains("value1"),
        "expected output to contain checkType or value1. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for conditional types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_type_alias_combined() {
    // Test combined interface and type alias patterns
    let source = r#"interface BaseEntity {
    id: number;
    createdAt: Date;
    updatedAt: Date;
}

interface User extends BaseEntity {
    username: string;
    email: string;
}

interface Post extends BaseEntity {
    title: string;
    content: string;
    authorId: number;
}

type EntityType = "user" | "post";
type Entity<T extends EntityType> = T extends "user" ? User : Post;

type CreateInput<T extends BaseEntity> = Omit<T, "id" | "createdAt" | "updatedAt">;
type UpdateInput<T extends BaseEntity> = Partial<CreateInput<T>>;

const userInput: CreateInput<User> = {
    username: "johndoe",
    email: "john@example.com"
};

const postUpdate: UpdateInput<Post> = {
    title: "Updated Title"
};

function createEntity<T extends EntityType>(
    type: T,
    input: CreateInput<Entity<T>>
): Entity<T> {
    const now = new Date();
    return {
        ...input,
        id: Math.random(),
        createdAt: now,
        updatedAt: now
    } as Entity<T>;
}

function updateEntity<T extends BaseEntity>(
    entity: T,
    updates: UpdateInput<T>
): T {
    return {
        ...entity,
        ...updates,
        updatedAt: new Date()
    };
}

console.log(userInput);
console.log(postUpdate);
console.log(createEntity("user", userInput));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createEntity") || output.contains("updateEntity"),
        "expected output to contain createEntity or updateEntity. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined interface/type patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Additional Interface ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_interface_optional_properties() {
    // Test interface with optional properties
    let source = r#"interface Config {
    host: string;
    port?: number;
    secure?: boolean;
    timeout?: number;
}

const config: Config = {
    host: "localhost"
};

const fullConfig: Config = {
    host: "example.com",
    port: 443,
    secure: true,
    timeout: 5000
};

function createConnection(cfg: Config): void {
    console.log("Connecting to", cfg.host);
    if (cfg.port) {
        console.log("Port:", cfg.port);
    }
}

createConnection(config);
createConnection(fullConfig);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("config") && output.contains("createConnection"),
        "expected output to contain config and createConnection. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for optional properties"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_readonly_properties() {
    // Test interface with readonly properties
    let source = r#"interface Point {
    readonly x: number;
    readonly y: number;
}

interface Circle {
    readonly center: Point;
    readonly radius: number;
}

const point: Point = { x: 10, y: 20 };
const circle: Circle = {
    center: { x: 0, y: 0 },
    radius: 5
};

function distance(p1: Point, p2: Point): number {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
}

console.log(point.x, point.y);
console.log(circle.center.x, circle.radius);
console.log(distance(point, circle.center));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("point") && output.contains("distance"),
        "expected output to contain point and distance. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for readonly properties"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_index_signature() {
    // Test interface with index signatures
    let source = r#"interface StringDictionary {
    [key: string]: string;
}

interface NumberDictionary {
    [index: number]: string;
    length: number;
}

interface MixedDictionary {
    [key: string]: number | string;
    name: string;
    count: number;
}

const dict: StringDictionary = {
    foo: "bar",
    hello: "world"
};

const numDict: NumberDictionary = {
    0: "first",
    1: "second",
    length: 2
};

const mixed: MixedDictionary = {
    name: "test",
    count: 42,
    extra: "value"
};

function getValues(d: StringDictionary): string[] {
    return Object.values(d);
}

console.log(dict["foo"]);
console.log(numDict[0]);
console.log(mixed.name, mixed.count);
console.log(getValues(dict));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("dict") && output.contains("getValues"),
        "expected output to contain dict and getValues. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for index signature"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_call_signature() {
    // Test interface with call signatures
    let source = r#"interface StringProcessor {
    (input: string): string;
}

interface Calculator {
    (a: number, b: number): number;
    description: string;
}

interface Formatter {
    (value: any): string;
    (value: any, format: string): string;
}

const uppercase: StringProcessor = function(input) {
    return input.toUpperCase();
};

const add: Calculator = function(a, b) {
    return a + b;
};
add.description = "Adds two numbers";

const format: Formatter = function(value: any, fmt?: string) {
    if (fmt) {
        return fmt + ": " + String(value);
    }
    return String(value);
};

console.log(uppercase("hello"));
console.log(add(5, 3), add.description);
console.log(format(42));
console.log(format(42, "Number"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("uppercase") && output.contains("format"),
        "expected output to contain uppercase and format. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for call signature"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_construct_signature() {
    // Test interface with construct signatures
    let source = r#"interface PointConstructor {
    new(x: number, y: number): { x: number; y: number };
}

interface ClockConstructor {
    new(hour: number, minute: number): ClockInterface;
}

interface ClockInterface {
    tick(): void;
    getTime(): string;
}

function createPoint(ctor: PointConstructor, x: number, y: number) {
    return new ctor(x, y);
}

const PointClass: PointConstructor = class {
    constructor(public x: number, public y: number) {}
};

const point = createPoint(PointClass, 10, 20);
console.log(point.x, point.y);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createPoint") || output.contains("PointClass"),
        "expected output to contain createPoint or PointClass. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for construct signature"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_merging() {
    // Test interface merging (declaration merging)
    let source = r#"interface Box {
    height: number;
    width: number;
}

interface Box {
    depth: number;
    color: string;
}

interface Box {
    weight?: number;
}

const box: Box = {
    height: 10,
    width: 20,
    depth: 30,
    color: "red"
};

const heavyBox: Box = {
    height: 5,
    width: 5,
    depth: 5,
    color: "blue",
    weight: 100
};

function describeBox(b: Box): string {
    let desc = b.color + " box: " + b.width + "x" + b.height + "x" + b.depth;
    if (b.weight) {
        desc += " (" + b.weight + "kg)";
    }
    return desc;
}

console.log(describeBox(box));
console.log(describeBox(heavyBox));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("box") && output.contains("describeBox"),
        "expected output to contain box and describeBox. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for interface merging"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_function_type() {
    // Test interface describing function types
    let source = r#"interface SearchFunc {
    (source: string, subString: string): boolean;
}

interface Comparator<T> {
    (a: T, b: T): number;
}

interface AsyncCallback<T> {
    (error: Error | null, result: T | null): void;
}

const search: SearchFunc = function(source, subString) {
    return source.indexOf(subString) !== -1;
};

const numCompare: Comparator<number> = function(a, b) {
    return a - b;
};

const strCompare: Comparator<string> = function(a, b) {
    return a.localeCompare(b);
};

const callback: AsyncCallback<string> = function(error, result) {
    if (error) {
        console.log("Error:", error.message);
    } else {
        console.log("Result:", result);
    }
};

console.log(search("hello world", "world"));
console.log([3, 1, 2].sort(numCompare));
console.log(["c", "a", "b"].sort(strCompare));
callback(null, "success");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("search") && output.contains("numCompare"),
        "expected output to contain search and numCompare. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for function type interface"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_class_implements() {
    // Test interface implemented by class
    let source = r#"interface Printable {
    print(): string;
}

interface Comparable<T> {
    compareTo(other: T): number;
}

interface Serializable {
    serialize(): string;
    deserialize(data: string): void;
}

class Document implements Printable, Serializable {
    constructor(private content: string) {}

    print(): string {
        return "Document: " + this.content;
    }

    serialize(): string {
        return JSON.stringify({ content: this.content });
    }

    deserialize(data: string): void {
        const obj = JSON.parse(data);
        this.content = obj.content;
    }
}

class Version implements Comparable<Version> {
    constructor(
        public major: number,
        public minor: number,
        public patch: number
    ) {}

    compareTo(other: Version): number {
        if (this.major !== other.major) return this.major - other.major;
        if (this.minor !== other.minor) return this.minor - other.minor;
        return this.patch - other.patch;
    }
}

const doc = new Document("Hello World");
console.log(doc.print());
console.log(doc.serialize());

const v1 = new Version(1, 2, 3);
const v2 = new Version(1, 3, 0);
console.log(v1.compareTo(v2));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Document") || output.contains("Version"),
        "expected output to contain Document or Version. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class implements interface"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_hybrid_types() {
    // Test interfaces with hybrid types (callable with properties)
    let source = r#"interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

interface Logger {
    (message: string): void;
    level: string;
    prefix: string;
    setLevel(level: string): void;
}

function createCounter(): Counter {
    const counter = function(start: number): string {
        return "Started at: " + start;
    } as Counter;
    counter.interval = 1000;
    counter.reset = function() {
        console.log("Counter reset");
    };
    return counter;
}

function createLogger(): Logger {
    const logger = function(message: string): void {
        console.log(logger.prefix + " [" + logger.level + "] " + message);
    } as Logger;
    logger.level = "INFO";
    logger.prefix = "App";
    logger.setLevel = function(level: string) {
        logger.level = level;
    };
    return logger;
}

const counter = createCounter();
console.log(counter(0));
console.log(counter.interval);
counter.reset();

const logger = createLogger();
logger("Hello");
logger.setLevel("DEBUG");
logger("World");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createCounter") || output.contains("createLogger"),
        "expected output to contain createCounter or createLogger. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for hybrid types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_advanced_combined() {
    // Test combined advanced interface patterns
    let source = r#"interface EventEmitter<T extends string = string> {
    on(event: T, callback: (data: any) => void): this;
    off(event: T, callback: (data: any) => void): this;
    emit(event: T, data?: any): boolean;
    readonly listenerCount: number;
}

interface Repository<T, ID = number> {
    findById(id: ID): T | undefined;
    findAll(): T[];
    save(entity: T): T;
    delete(id: ID): boolean;
    [Symbol.iterator](): Iterator<T>;
}

interface ServiceConfig {
    readonly name: string;
    timeout?: number;
    retries?: number;
    onError?(error: Error): void;
}

interface Service<T> extends EventEmitter<"start" | "stop" | "error"> {
    readonly config: ServiceConfig;
    start(): Promise<void>;
    stop(): Promise<void>;
    getStatus(): "running" | "stopped" | "error";
}

const emitter: EventEmitter = {
    listenerCount: 0,
    on(event, callback) {
        console.log("Registered listener for", event);
        return this;
    },
    off(event, callback) {
        console.log("Removed listener for", event);
        return this;
    },
    emit(event, data) {
        console.log("Emitting", event, data);
        return true;
    }
};

const config: ServiceConfig = {
    name: "MyService",
    timeout: 5000,
    retries: 3,
    onError(error) {
        console.log("Service error:", error.message);
    }
};

emitter.on("message", (data) => console.log(data)).emit("message", "Hello");
console.log(config.name, config.timeout);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("emitter") || output.contains("config"),
        "expected output to contain emitter or config. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for advanced combined interface patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// More Interface ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_interface_nested_types() {
    // Test interface with deeply nested type structures
    let source = r#"interface Address {
    street: string;
    city: string;
    zip: string;
}

interface Contact {
    email: string;
    phone: string;
}

interface Company {
    name: string;
    address: Address;
    contacts: Contact[];
}

interface Employee {
    id: number;
    name: string;
    address: Address;
    contact: Contact;
    company: Company;
}

const employee: Employee = {
    id: 1,
    name: "John Doe",
    address: { street: "123 Main St", city: "NYC", zip: "10001" },
    contact: { email: "john@example.com", phone: "555-1234" },
    company: {
        name: "Acme Inc",
        address: { street: "456 Corp Ave", city: "NYC", zip: "10002" },
        contacts: [{ email: "info@acme.com", phone: "555-0000" }]
    }
};

console.log(employee.name);
console.log(employee.company.name);
console.log(employee.address.city);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("employee"),
        "expected output to contain employee. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_tuple_types() {
    // Test interface with tuple types
    let source = r#"interface Coordinate {
    position: [number, number];
    position3D: [number, number, number];
}

interface NamedTuple {
    range: [start: number, end: number];
    point: [x: number, y: number, z?: number];
}

interface MixedTuple {
    data: [string, number, boolean];
    rest: [string, ...number[]];
}

const coord: Coordinate = {
    position: [10, 20],
    position3D: [10, 20, 30]
};

const named: NamedTuple = {
    range: [0, 100],
    point: [5, 10]
};

const mixed: MixedTuple = {
    data: ["hello", 42, true],
    rest: ["prefix", 1, 2, 3, 4]
};

function processCoord(c: Coordinate): number {
    return c.position[0] + c.position[1];
}

console.log(coord.position);
console.log(named.range);
console.log(mixed.data);
console.log(processCoord(coord));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("coord") && output.contains("processCoord"),
        "expected output to contain coord and processCoord. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for tuple types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_literal_types() {
    // Test interface with literal types
    let source = r#"interface Status {
    code: 200 | 201 | 400 | 404 | 500;
    message: "success" | "created" | "error";
}

interface Config {
    mode: "development" | "production" | "test";
    debug: true | false;
    level: 1 | 2 | 3;
}

interface ButtonProps {
    variant: "primary" | "secondary" | "danger";
    size: "small" | "medium" | "large";
    disabled: boolean;
}

const status: Status = {
    code: 200,
    message: "success"
};

const config: Config = {
    mode: "production",
    debug: false,
    level: 2
};

const button: ButtonProps = {
    variant: "primary",
    size: "medium",
    disabled: false
};

function handleStatus(s: Status): void {
    if (s.code === 200) {
        console.log("OK:", s.message);
    }
}

console.log(status.code);
console.log(config.mode);
console.log(button.variant);
handleStatus(status);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("status") && output.contains("handleStatus"),
        "expected output to contain status and handleStatus. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for literal types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_never_unknown() {
    // Test interface with never and unknown types
    let source = r#"interface ErrorHandler {
    handle(error: unknown): never;
    log(message: string): void;
}

interface Parser {
    parse(input: unknown): string;
    validate(data: unknown): boolean;
}

interface Validator<T> {
    validate(value: unknown): value is T;
    assert(value: unknown): asserts value is T;
}

const handler: ErrorHandler = {
    handle(error: unknown): never {
        console.error("Fatal error:", error);
        throw new Error(String(error));
    },
    log(message: string): void {
        console.log(message);
    }
};

const parser: Parser = {
    parse(input: unknown): string {
        return String(input);
    },
    validate(data: unknown): boolean {
        return data !== null && data !== undefined;
    }
};

function processUnknown(value: unknown): string {
    if (typeof value === "string") {
        return value;
    }
    return String(value);
}

handler.log("Starting...");
console.log(parser.parse({ key: "value" }));
console.log(processUnknown(42));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("handler") || output.contains("processUnknown"),
        "expected output to contain handler or processUnknown. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for never/unknown types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_this_type() {
    // Test interface with this type for fluent APIs
    let source = r#"interface Chainable {
    setValue(value: string): this;
    setName(name: string): this;
    build(): string;
}

interface FluentBuilder<T> {
    add(item: T): this;
    remove(item: T): this;
    clear(): this;
    getItems(): T[];
}

const chainable: Chainable = {
    _value: "",
    _name: "",
    setValue(value: string) {
        (this as any)._value = value;
        return this;
    },
    setName(name: string) {
        (this as any)._name = name;
        return this;
    },
    build() {
        return (this as any)._name + ": " + (this as any)._value;
    }
} as any;

class ArrayBuilder<T> implements FluentBuilder<T> {
    private items: T[] = [];

    add(item: T): this {
        this.items.push(item);
        return this;
    }

    remove(item: T): this {
        const idx = this.items.indexOf(item);
        if (idx !== -1) this.items.splice(idx, 1);
        return this;
    }

    clear(): this {
        this.items = [];
        return this;
    }

    getItems(): T[] {
        return this.items.slice();
    }
}

const result = chainable.setValue("hello").setName("greeting").build();
console.log(result);

const builder = new ArrayBuilder<number>();
builder.add(1).add(2).add(3).remove(2);
console.log(builder.getItems());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("chainable") || output.contains("ArrayBuilder"),
        "expected output to contain chainable or ArrayBuilder. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for this type"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_overloaded_methods() {
    // Test interface with overloaded method signatures
    let source = r#"interface Processor {
    process(input: string): string;
    process(input: number): number;
    process(input: boolean): boolean;
    process(input: string | number | boolean): string | number | boolean;
}

interface Converter {
    convert(value: string, to: "number"): number;
    convert(value: string, to: "boolean"): boolean;
    convert(value: number, to: "string"): string;
}

interface EventTarget {
    addEventListener(type: "click", listener: (e: MouseEvent) => void): void;
    addEventListener(type: "keydown", listener: (e: KeyboardEvent) => void): void;
    addEventListener(type: string, listener: (e: Event) => void): void;
}

const processor: Processor = {
    process(input: any): any {
        if (typeof input === "string") return input.toUpperCase();
        if (typeof input === "number") return input * 2;
        return !input;
    }
};

const converter: Converter = {
    convert(value: any, to: string): any {
        if (to === "number") return Number(value);
        if (to === "boolean") return Boolean(value);
        return String(value);
    }
};

console.log(processor.process("hello"));
console.log(processor.process(21));
console.log(processor.process(false));
console.log(converter.convert("42", "number"));
console.log(converter.convert("true", "boolean"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processor") && output.contains("converter"),
        "expected output to contain processor and converter. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for overloaded methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_async_methods() {
    // Test interface with async method signatures
    let source = r#"interface AsyncService {
    fetch(url: string): Promise<string>;
    fetchJson<T>(url: string): Promise<T>;
    post(url: string, data: any): Promise<void>;
}

interface DataLoader<T> {
    load(): Promise<T>;
    loadAll(): Promise<T[]>;
    refresh(): Promise<void>;
}

interface AsyncQueue<T> {
    enqueue(item: T): Promise<void>;
    dequeue(): Promise<T | undefined>;
    peek(): Promise<T | undefined>;
    isEmpty(): Promise<boolean>;
}

const service: AsyncService = {
    async fetch(url: string): Promise<string> {
        return "data from " + url;
    },
    async fetchJson<T>(url: string): Promise<T> {
        return { url } as any;
    },
    async post(url: string, data: any): Promise<void> {
        console.log("Posted to", url, data);
    }
};

async function useService(s: AsyncService): Promise<void> {
    const data = await s.fetch("/api/data");
    console.log(data);
    await s.post("/api/save", { value: 42 });
}

useService(service);
console.log("Service called");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("service") || output.contains("useService"),
        "expected output to contain service or useService. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_accessor_signatures() {
    // Test interface with getter/setter accessor signatures
    let source = r#"interface Readable {
    readonly value: string;
    readonly length: number;
}

interface Writable {
    value: string;
}

interface ReadWrite {
    get value(): string;
    set value(v: string);
    get computed(): number;
}

interface Observable<T> {
    get current(): T;
    set current(value: T);
    readonly previous: T | undefined;
}

const readable: Readable = {
    value: "hello",
    length: 5
};

const writable: Writable = {
    value: "initial"
};

class ObservableValue<T> implements Observable<T> {
    private _current: T;
    private _previous: T | undefined;

    constructor(initial: T) {
        this._current = initial;
    }

    get current(): T {
        return this._current;
    }

    set current(value: T) {
        this._previous = this._current;
        this._current = value;
    }

    get previous(): T | undefined {
        return this._previous;
    }
}

console.log(readable.value);
writable.value = "updated";
console.log(writable.value);

const obs = new ObservableValue<number>(0);
obs.current = 10;
obs.current = 20;
console.log(obs.current, obs.previous);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("readable") || output.contains("ObservableValue"),
        "expected output to contain readable or ObservableValue. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for accessor signatures"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_symbol_properties() {
    // Test interface with symbol-keyed properties
    let source = r#"interface Iterable<T> {
    [Symbol.iterator](): Iterator<T>;
}

interface CustomIterable {
    [Symbol.iterator](): Iterator<number>;
    [Symbol.toStringTag]: string;
}

interface Disposable {
    [Symbol.dispose]?(): void;
}

class NumberRange implements CustomIterable {
    constructor(private start: number, private end: number) {}

    *[Symbol.iterator](): Iterator<number> {
        for (let i = this.start; i <= this.end; i++) {
            yield i;
        }
    }

    get [Symbol.toStringTag](): string {
        return "NumberRange";
    }
}

const range = new NumberRange(1, 5);
console.log(String(range));

for (const num of range) {
    console.log(num);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("NumberRange") || output.contains("range"),
        "expected output to contain NumberRange or range. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for symbol properties"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_complex_combined() {
    // Test complex combined interface patterns
    let source = r#"interface BaseNode {
    readonly type: string;
    readonly id: number;
}

interface TextNode extends BaseNode {
    readonly type: "text";
    content: string;
}

interface ElementNode extends BaseNode {
    readonly type: "element";
    tagName: string;
    children: TreeNode[];
    attributes: { [key: string]: string };
}

type TreeNode = TextNode | ElementNode;

interface TreeVisitor<T> {
    visitText(node: TextNode): T;
    visitElement(node: ElementNode): T;
}

interface TreeTransformer extends TreeVisitor<TreeNode> {
    transform(root: TreeNode): TreeNode;
}

class NodeCounter implements TreeVisitor<number> {
    visitText(node: TextNode): number {
        return 1;
    }

    visitElement(node: ElementNode): number {
        let count = 1;
        for (const child of node.children) {
            if (child.type === "text") {
                count += this.visitText(child);
            } else {
                count += this.visitElement(child);
            }
        }
        return count;
    }
}

const textNode: TextNode = { type: "text", id: 1, content: "Hello" };
const elemNode: ElementNode = {
    type: "element",
    id: 2,
    tagName: "div",
    children: [textNode],
    attributes: { class: "container" }
};

const counter = new NodeCounter();
console.log(counter.visitText(textNode));
console.log(counter.visitElement(elemNode));
console.log(elemNode.tagName, elemNode.attributes);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("NodeCounter") || output.contains("textNode"),
        "expected output to contain NodeCounter or textNode. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for complex combined patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Extended Interface ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_interface_multiple_extends() {
    // Test interface extending multiple interfaces
    let source = r#"interface Named {
    name: string;
}

interface Aged {
    age: number;
}

interface Described {
    description: string;
}

interface Person extends Named, Aged {
    email: string;
}

interface DetailedPerson extends Named, Aged, Described {
    address: string;
}

const person: Person = {
    name: "John",
    age: 30,
    email: "john@example.com"
};

const detailed: DetailedPerson = {
    name: "Jane",
    age: 25,
    description: "Software Engineer",
    address: "123 Main St"
};

function greet(p: Named & Aged): string {
    return "Hello " + p.name + ", you are " + p.age;
}

console.log(person.name, person.age);
console.log(detailed.description);
console.log(greet(person));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("person") && output.contains("greet"),
        "expected output to contain person and greet. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple extends"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_recursive_types() {
    // Test interface with recursive/self-referencing types
    let source = r#"interface TreeNode<T> {
    value: T;
    children: TreeNode<T>[];
    parent?: TreeNode<T>;
}

interface LinkedListNode<T> {
    value: T;
    next: LinkedListNode<T> | null;
    prev: LinkedListNode<T> | null;
}

interface JSONValue {
    [key: string]: JSONValue | string | number | boolean | null | JSONValue[];
}

const tree: TreeNode<string> = {
    value: "root",
    children: [
        { value: "child1", children: [] },
        { value: "child2", children: [
            { value: "grandchild", children: [] }
        ]}
    ]
};

const listNode: LinkedListNode<number> = {
    value: 1,
    next: { value: 2, next: null, prev: null },
    prev: null
};

function traverseTree<T>(node: TreeNode<T>, callback: (val: T) => void): void {
    callback(node.value);
    for (const child of node.children) {
        traverseTree(child, callback);
    }
}

traverseTree(tree, (v) => console.log(v));
console.log(listNode.value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("tree") && output.contains("traverseTree"),
        "expected output to contain tree and traverseTree. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for recursive types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_discriminated_unions() {
    // Test interface with discriminated union patterns
    let source = r#"interface SuccessResult {
    kind: "success";
    data: string;
    timestamp: number;
}

interface ErrorResult {
    kind: "error";
    error: string;
    code: number;
}

interface LoadingResult {
    kind: "loading";
    progress: number;
}

type Result = SuccessResult | ErrorResult | LoadingResult;

interface Action {
    type: string;
}

interface AddAction extends Action {
    type: "add";
    payload: number;
}

interface RemoveAction extends Action {
    type: "remove";
    id: string;
}

type AppAction = AddAction | RemoveAction;

function handleResult(result: Result): string {
    switch (result.kind) {
        case "success":
            return "Data: " + result.data;
        case "error":
            return "Error " + result.code + ": " + result.error;
        case "loading":
            return "Loading: " + result.progress + "%";
    }
}

const success: SuccessResult = { kind: "success", data: "hello", timestamp: Date.now() };
const error: ErrorResult = { kind: "error", error: "Not found", code: 404 };

console.log(handleResult(success));
console.log(handleResult(error));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("handleResult") || output.contains("success"),
        "expected output to contain handleResult or success. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for discriminated unions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_type_guards() {
    // Test interface with type guard patterns
    let source = r#"interface Fish {
    swim(): void;
    name: string;
}

interface Bird {
    fly(): void;
    name: string;
}

interface Cat {
    meow(): void;
    name: string;
}

type Animal = Fish | Bird | Cat;

function isFish(animal: Animal): animal is Fish {
    return (animal as Fish).swim !== undefined;
}

function isBird(animal: Animal): animal is Bird {
    return (animal as Bird).fly !== undefined;
}

const fish: Fish = {
    name: "Nemo",
    swim() { console.log("Swimming..."); }
};

const bird: Bird = {
    name: "Tweety",
    fly() { console.log("Flying..."); }
};

function handleAnimal(animal: Animal): void {
    if (isFish(animal)) {
        animal.swim();
    } else if (isBird(animal)) {
        animal.fly();
    } else {
        animal.meow();
    }
}

handleAnimal(fish);
handleAnimal(bird);
console.log(fish.name, bird.name);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("isFish") || output.contains("handleAnimal"),
        "expected output to contain isFish or handleAnimal. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for type guards"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_rest_elements() {
    // Test interface with rest elements in types
    let source = r#"interface FunctionWithRest {
    (...args: number[]): number;
}

interface ArrayWithRest {
    items: [string, ...number[]];
    mixed: [boolean, string, ...any[]];
}

interface SpreadParams {
    call(...args: string[]): void;
    apply(first: number, ...rest: string[]): string;
}

const sum: FunctionWithRest = function(...args: number[]): number {
    return args.reduce((a, b) => a + b, 0);
};

const arr: ArrayWithRest = {
    items: ["header", 1, 2, 3, 4],
    mixed: [true, "text", 1, "a", null]
};

const params: SpreadParams = {
    call(...args: string[]): void {
        console.log(args.join(", "));
    },
    apply(first: number, ...rest: string[]): string {
        return first + ": " + rest.join(" ");
    }
};

console.log(sum(1, 2, 3, 4, 5));
console.log(arr.items);
params.call("a", "b", "c");
console.log(params.apply(42, "hello", "world"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("sum") || output.contains("params"),
        "expected output to contain sum or params. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for rest elements"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_callback_patterns() {
    // Test interface with various callback patterns
    let source = r#"interface EventCallback<T> {
    (event: T): void;
}

interface AsyncCallback<T, E = Error> {
    (error: E | null, result: T | null): void;
}

interface Middleware<T> {
    (context: T, next: () => void): void;
}

interface Reducer<S, A> {
    (state: S, action: A): S;
}

interface EventEmitter<Events extends Record<string, any>> {
    on<K extends keyof Events>(event: K, callback: EventCallback<Events[K]>): void;
    emit<K extends keyof Events>(event: K, data: Events[K]): void;
}

const onClick: EventCallback<{ x: number; y: number }> = (event) => {
    console.log("Clicked at", event.x, event.y);
};

const fetchCallback: AsyncCallback<string> = (error, result) => {
    if (error) console.log("Error:", error.message);
    else console.log("Result:", result);
};

const logger: Middleware<{ path: string }> = (ctx, next) => {
    console.log("Request:", ctx.path);
    next();
};

const counterReducer: Reducer<number, { type: string }> = (state, action) => {
    if (action.type === "increment") return state + 1;
    if (action.type === "decrement") return state - 1;
    return state;
};

onClick({ x: 100, y: 200 });
fetchCallback(null, "data");
logger({ path: "/api" }, () => console.log("Done"));
console.log(counterReducer(0, { type: "increment" }));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("onClick") || output.contains("counterReducer"),
        "expected output to contain onClick or counterReducer. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for callback patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_utility_patterns() {
    // Test interface with utility type patterns
    let source = r#"interface User {
    id: number;
    name: string;
    email: string;
    age: number;
    role: "admin" | "user";
}

interface PartialUser {
    id?: number;
    name?: string;
    email?: string;
}

interface RequiredUser {
    id: number;
    name: string;
    email: string;
}

interface UserKeys {
    keys: keyof User;
}

interface UserUpdate {
    data: Partial<User>;
    updatedAt: Date;
}

interface UserCreation {
    data: Omit<User, "id">;
    createdAt: Date;
}

const partialUser: PartialUser = { name: "John" };
const requiredUser: RequiredUser = { id: 1, name: "Jane", email: "jane@example.com" };

const update: UserUpdate = {
    data: { name: "Updated Name", age: 31 },
    updatedAt: new Date()
};

const creation: UserCreation = {
    data: { name: "New User", email: "new@example.com", age: 25, role: "user" },
    createdAt: new Date()
};

function updateUser(id: number, updates: Partial<User>): void {
    console.log("Updating user", id, "with", updates);
}

console.log(partialUser.name);
console.log(requiredUser.email);
updateUser(1, update.data);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("partialUser") || output.contains("updateUser"),
        "expected output to contain partialUser or updateUser. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for utility patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_module_patterns() {
    // Test interface with module-like patterns
    let source = r#"interface ModuleExports {
    default: () => void;
    named: string;
    Config: { version: string };
}

interface PluginInterface {
    name: string;
    version: string;
    init(): void;
    destroy(): void;
}

interface ModuleLoader {
    load(name: string): Promise<ModuleExports>;
    unload(name: string): void;
    getLoaded(): string[];
}

interface PluginRegistry {
    register(plugin: PluginInterface): void;
    unregister(name: string): void;
    get(name: string): PluginInterface | undefined;
    list(): PluginInterface[];
}

const myPlugin: PluginInterface = {
    name: "MyPlugin",
    version: "1.0.0",
    init() { console.log("Plugin initialized"); },
    destroy() { console.log("Plugin destroyed"); }
};

const registry: PluginRegistry = {
    plugins: [] as PluginInterface[],
    register(plugin) {
        (this as any).plugins.push(plugin);
    },
    unregister(name) {
        const idx = (this as any).plugins.findIndex((p: PluginInterface) => p.name === name);
        if (idx !== -1) (this as any).plugins.splice(idx, 1);
    },
    get(name) {
        return (this as any).plugins.find((p: PluginInterface) => p.name === name);
    },
    list() {
        return (this as any).plugins;
    }
} as any;

registry.register(myPlugin);
console.log(registry.list());
myPlugin.init();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("myPlugin") || output.contains("registry"),
        "expected output to contain myPlugin or registry. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for module patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_builder_patterns() {
    // Test interface with builder patterns
    let source = r#"interface QueryBuilder<T> {
    select(...fields: (keyof T)[]): this;
    where(condition: Partial<T>): this;
    orderBy(field: keyof T, direction: "asc" | "desc"): this;
    limit(count: number): this;
    execute(): T[];
}

interface FormBuilder<T> {
    field<K extends keyof T>(name: K, value: T[K]): this;
    validate(): boolean;
    build(): T;
    reset(): this;
}

interface HttpRequestBuilder {
    url(url: string): this;
    method(method: "GET" | "POST" | "PUT" | "DELETE"): this;
    header(name: string, value: string): this;
    body(data: any): this;
    send(): Promise<Response>;
}

class SimpleQueryBuilder<T> implements QueryBuilder<T> {
    private query: any = {};

    select(...fields: (keyof T)[]): this {
        this.query.fields = fields;
        return this;
    }

    where(condition: Partial<T>): this {
        this.query.where = condition;
        return this;
    }

    orderBy(field: keyof T, direction: "asc" | "desc"): this {
        this.query.orderBy = { field, direction };
        return this;
    }

    limit(count: number): this {
        this.query.limit = count;
        return this;
    }

    execute(): T[] {
        console.log("Executing query:", this.query);
        return [];
    }
}

interface User { id: number; name: string; age: number }

const query = new SimpleQueryBuilder<User>()
    .select("name", "age")
    .where({ age: 25 })
    .orderBy("name", "asc")
    .limit(10);

console.log(query.execute());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("SimpleQueryBuilder") || output.contains("query"),
        "expected output to contain SimpleQueryBuilder or query. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for builder patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_interface_state_machine() {
    // Test interface with state machine patterns
    let source = r#"interface State<T extends string> {
    name: T;
    onEnter?(): void;
    onExit?(): void;
}

interface Transition<From extends string, To extends string> {
    from: From;
    to: To;
    condition?(): boolean;
    action?(): void;
}

interface StateMachine<States extends string> {
    currentState: States;
    states: State<States>[];
    transitions: Transition<States, States>[];
    transition(to: States): boolean;
    canTransition(to: States): boolean;
}

type TrafficLightState = "red" | "yellow" | "green";

const trafficLight: StateMachine<TrafficLightState> = {
    currentState: "red",
    states: [
        { name: "red", onEnter: () => console.log("Stop!") },
        { name: "yellow", onEnter: () => console.log("Caution!") },
        { name: "green", onEnter: () => console.log("Go!") }
    ],
    transitions: [
        { from: "red", to: "green" },
        { from: "green", to: "yellow" },
        { from: "yellow", to: "red" }
    ],
    canTransition(to: TrafficLightState): boolean {
        return this.transitions.some(t => t.from === this.currentState && t.to === to);
    },
    transition(to: TrafficLightState): boolean {
        if (this.canTransition(to)) {
            this.currentState = to;
            const state = this.states.find(s => s.name === to);
            if (state && state.onEnter) state.onEnter();
            return true;
        }
        return false;
    }
};

console.log("Current:", trafficLight.currentState);
trafficLight.transition("green");
trafficLight.transition("yellow");
trafficLight.transition("red");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("trafficLight") || output.contains("currentState"),
        "expected output to contain trafficLight or currentState. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for state machine patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Enum ES5 Source Map Tests - Extended Patterns
// =============================================================================

#[test]
fn test_source_map_enum_es5_bitwise_flags() {
    let source = r#"enum Permission {
    None = 0,
    Read = 1 << 0,
    Write = 1 << 1,
    Execute = 1 << 2,
    ReadWrite = Read | Write,
    All = Read | Write | Execute
}

const userPerms: Permission = Permission.ReadWrite;
const hasRead = (userPerms & Permission.Read) !== 0;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Permission") || output.contains("ReadWrite"),
        "expected output to contain Permission enum. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for bitwise flag enum"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_es5_explicit_numeric() {
    let source = r#"enum HttpStatus {
    OK = 200,
    Created = 201,
    Accepted = 202,
    BadRequest = 400,
    Unauthorized = 401,
    Forbidden = 403,
    NotFound = 404,
    InternalServerError = 500
}

function handleResponse(status: HttpStatus): string {
    if (status >= 400) {
        return "Error";
    }
    return "Success";
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("HttpStatus") || output.contains("200"),
        "expected output to contain HttpStatus enum. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for explicit numeric enum"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_es5_expression_initializers() {
    let source = r#"const BASE = 100;

enum Computed {
    First = BASE,
    Second = BASE + 1,
    Third = BASE * 2,
    Fourth = Math.floor(BASE / 3),
    Fifth = "prefix".length
}

const val = Computed.Third;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Computed") || output.contains("BASE"),
        "expected output to contain Computed enum. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for expression initializer enum"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_es5_ambient_declare() {
    let source = r#"declare enum ExternalStatus {
    Active,
    Inactive,
    Pending
}

enum LocalStatus {
    Active = 0,
    Inactive = 1,
    Pending = 2
}

const status: LocalStatus = LocalStatus.Active;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Declare enums should be erased, only LocalStatus should remain
    assert!(
        output.contains("LocalStatus"),
        "expected output to contain LocalStatus enum. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ambient declare enum"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_es5_member_as_type() {
    let source = r#"enum Direction {
    Up = "UP",
    Down = "DOWN",
    Left = "LEFT",
    Right = "RIGHT"
}

type VerticalDirection = Direction.Up | Direction.Down;
type HorizontalDirection = Direction.Left | Direction.Right;

function move(dir: VerticalDirection): void {
    console.log(dir);
}

move(Direction.Up);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Direction") || output.contains("UP"),
        "expected output to contain Direction enum. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for enum member as type"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_es5_keyof_typeof() {
    let source = r#"enum Color {
    Red = "red",
    Green = "green",
    Blue = "blue"
}

type ColorKey = keyof typeof Color;
type ColorValue = typeof Color[ColorKey];

function getColorName(key: ColorKey): string {
    return Color[key];
}

const result = getColorName("Red");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Color") || output.contains("getColorName"),
        "expected output to contain Color enum. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for keyof typeof enum"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_es5_nested_in_module() {
    let source = r#"module App {
    export enum Status {
        Loading,
        Ready,
        Error
    }

    export module Sub {
        export enum Priority {
            Low = 1,
            Medium = 2,
            High = 3
        }
    }
}

const status = App.Status.Ready;
const priority = App.Sub.Priority.High;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("App") || output.contains("Status"),
        "expected output to contain App module with enums. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested enum in module"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_es5_with_interface() {
    let source = r#"enum TaskStatus {
    Todo = "TODO",
    InProgress = "IN_PROGRESS",
    Done = "DONE"
}

interface Task {
    id: number;
    title: string;
    status: TaskStatus;
}

function createTask(title: string): Task {
    return {
        id: Date.now(),
        title: title,
        status: TaskStatus.Todo
    };
}

const task = createTask("Test task");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("TaskStatus") || output.contains("createTask"),
        "expected output to contain TaskStatus enum. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for enum with interface"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_es5_function_parameter() {
    let source = r#"enum LogLevel {
    Debug = 0,
    Info = 1,
    Warn = 2,
    Error = 3
}

function log(level: LogLevel, message: string): void {
    if (level >= LogLevel.Warn) {
        console.error(`[${LogLevel[level]}] ${message}`);
    } else {
        console.log(`[${LogLevel[level]}] ${message}`);
    }
}

log(LogLevel.Info, "Application started");
log(LogLevel.Error, "Something went wrong");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("LogLevel") || output.contains("log"),
        "expected output to contain LogLevel enum. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for enum as function parameter"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_enum_es5_advanced_combined() {
    let source = r#"// Numeric enum with explicit values
enum Priority {
    Critical = 100,
    High = 75,
    Medium = 50,
    Low = 25
}

// String enum
enum Category {
    Bug = "BUG",
    Feature = "FEATURE",
    Task = "TASK"
}

// Const enum (should be inlined)
const enum Visibility {
    Public,
    Private,
    Internal
}

// Enum in class
class Issue {
    priority: Priority;
    category: Category;
    visibility: number;

    constructor(priority: Priority, category: Category) {
        this.priority = priority;
        this.category = category;
        this.visibility = Visibility.Public;
    }

    isPriority(level: Priority): boolean {
        return this.priority >= level;
    }
}

// Generic with enum constraint
function filterByCategory<T extends { category: Category }>(
    items: T[],
    category: Category
): T[] {
    return items.filter(item => item.category === category);
}

const issue = new Issue(Priority.High, Category.Bug);
console.log(issue.isPriority(Priority.Medium));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Priority") || output.contains("Category"),
        "expected output to contain enum declarations. output: {output}"
    );
    assert!(
        output.contains("Issue"),
        "expected output to contain Issue class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for advanced enum patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Class Field ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_class_field_public_basic() {
    let source = r#"class Person {
    name: string;
    age: number;
    active: boolean;
}

const person = new Person();
person.name = "John";
person.age = 30;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Person"),
        "expected output to contain Person class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for public fields"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_field_public_initializers() {
    let source = r#"class Config {
    host: string = "localhost";
    port: number = 8080;
    debug: boolean = false;
    tags: string[] = [];
    metadata: object = {};
}

const config = new Config();
console.log(config.host, config.port);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Config") || output.contains("localhost"),
        "expected output to contain Config class or initializers. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for field initializers"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_field_static_basic() {
    let source = r#"class Counter {
    static count: number = 0;
    static name: string = "Counter";

    static increment(): void {
        Counter.count++;
    }

    static reset(): void {
        Counter.count = 0;
    }
}

Counter.increment();
console.log(Counter.count);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter"),
        "expected output to contain Counter class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static fields"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_field_static_initializers() {
    let source = r#"class App {
    static version: string = "1.0.0";
    static buildDate: Date = new Date();
    static features: string[] = ["auth", "logging"];
    static config = {
        debug: true,
        timeout: 5000
    };
}

console.log(App.version, App.features);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("App") || output.contains("version"),
        "expected output to contain App class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static field initializers"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_field_computed() {
    let source = r#"const nameKey = "name";
const ageKey = "age";

class Person {
    [nameKey]: string = "Unknown";
    [ageKey]: number = 0;
    ["status"]: string = "active";
    [Symbol.toStringTag]: string = "Person";
}

const p = new Person();
console.log(p[nameKey]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Person") || output.contains("nameKey"),
        "expected output to contain Person class or computed keys. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for computed fields"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_field_private_es5() {
    let source = r#"class BankAccount {
    #balance: number = 0;
    #owner: string;

    constructor(owner: string, initialBalance: number) {
        this.#owner = owner;
        this.#balance = initialBalance;
    }

    deposit(amount: number): void {
        this.#balance += amount;
    }

    getBalance(): number {
        return this.#balance;
    }
}

const account = new BankAccount("John", 100);
account.deposit(50);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("BankAccount") || output.contains("deposit"),
        "expected output to contain BankAccount class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private fields ES5"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_field_static_private() {
    let source = r#"class Logger {
    static #instance: Logger | null = null;
    static #logLevel: number = 1;

    private constructor() {}

    static getInstance(): Logger {
        if (!Logger.#instance) {
            Logger.#instance = new Logger();
        }
        return Logger.#instance;
    }

    static setLogLevel(level: number): void {
        Logger.#logLevel = level;
    }
}

const logger = Logger.getInstance();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Logger") || output.contains("getInstance"),
        "expected output to contain Logger class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static private fields"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_field_readonly() {
    let source = r#"class Constants {
    readonly PI: number = 3.14159;
    readonly E: number = 2.71828;
    static readonly MAX_SIZE: number = 1000;
    static readonly APP_NAME: string = "MyApp";
}

const c = new Constants();
console.log(c.PI, Constants.MAX_SIZE);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Constants") || output.contains("3.14159"),
        "expected output to contain Constants class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for readonly fields"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_field_with_accessors() {
    let source = r#"class Rectangle {
    #width: number = 0;
    #height: number = 0;

    get width(): number {
        return this.#width;
    }

    set width(value: number) {
        this.#width = Math.max(0, value);
    }

    get height(): number {
        return this.#height;
    }

    set height(value: number) {
        this.#height = Math.max(0, value);
    }

    get area(): number {
        return this.#width * this.#height;
    }
}

const rect = new Rectangle();
rect.width = 10;
rect.height = 5;"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Rectangle") || output.contains("width"),
        "expected output to contain Rectangle class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for fields with accessors"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_field_combined() {
    let source = r#"const dynamicKey = "dynamicProp";

class CompleteEntity {
    // Public fields
    name: string = "";
    count: number = 0;

    // Static fields
    static instances: number = 0;
    static readonly VERSION: string = "1.0";

    // Private fields
    #id: number;
    #secret: string = "hidden";

    // Static private
    static #totalCreated: number = 0;

    // Computed field
    [dynamicKey]: boolean = true;

    // Readonly
    readonly createdAt: Date = new Date();

    constructor(name: string) {
        this.name = name;
        this.#id = ++CompleteEntity.#totalCreated;
        CompleteEntity.instances++;
    }

    get id(): number {
        return this.#id;
    }

    static getTotal(): number {
        return CompleteEntity.#totalCreated;
    }
}

const entity = new CompleteEntity("Test");
console.log(entity.name, entity.id, CompleteEntity.instances);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("CompleteEntity"),
        "expected output to contain CompleteEntity class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for combined class fields"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Decorator ES5 Source Map Tests - Extended Patterns
// =============================================================================

#[test]
fn test_source_map_decorator_es5_class_with_metadata() {
    let source = r#"function Component(config: { selector: string; template: string }) {
    return function<T extends { new(...args: any[]): {} }>(constructor: T) {
        return class extends constructor {
            selector = config.selector;
            template = config.template;
        };
    };
}

@Component({
    selector: 'app-root',
    template: '<div>Hello</div>'
})
class AppComponent {
    title: string = 'My App';
}

const app = new AppComponent();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AppComponent") || output.contains("Component"),
        "expected output to contain AppComponent. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class decorator with metadata"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_es5_method_with_descriptor() {
    let source = r#"function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        console.log(`Calling ${propertyKey} with`, args);
        return original.apply(this, args);
    };
    return descriptor;
}

class Calculator {
    @Log
    add(a: number, b: number): number {
        return a + b;
    }

    @Log
    multiply(a: number, b: number): number {
        return a * b;
    }
}

const calc = new Calculator();
calc.add(2, 3);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Calculator") || output.contains("add"),
        "expected output to contain Calculator class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for method decorator with descriptor"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_es5_property_validation() {
    let source = r#"function MinLength(min: number) {
    return function(target: any, propertyKey: string) {
        let value: string;
        Object.defineProperty(target, propertyKey, {
            get: () => value,
            set: (newValue: string) => {
                if (newValue.length < min) {
                    throw new Error(`${propertyKey} must be at least ${min} chars`);
                }
                value = newValue;
            }
        });
    };
}

class User {
    @MinLength(3)
    username: string;

    @MinLength(8)
    password: string;

    constructor(username: string, password: string) {
        this.username = username;
        this.password = password;
    }
}

const user = new User("john", "password123");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("User") || output.contains("MinLength"),
        "expected output to contain User class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for property validation decorator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_es5_parameter_injection() {
    let source = r#"const INJECT_KEY = Symbol('inject');

function Inject(token: string) {
    return function(target: any, propertyKey: string | symbol, parameterIndex: number) {
        const existing = Reflect.getMetadata(INJECT_KEY, target, propertyKey) || [];
        existing.push({ index: parameterIndex, token });
        Reflect.defineMetadata(INJECT_KEY, existing, target, propertyKey);
    };
}

class Database {
    query(sql: string): any[] { return []; }
}

class Logger {
    log(msg: string): void { console.log(msg); }
}

class UserService {
    constructor(
        @Inject('Database') private db: Database,
        @Inject('Logger') private logger: Logger
    ) {}

    getUsers(): any[] {
        this.logger.log('Fetching users');
        return this.db.query('SELECT * FROM users');
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("UserService") || output.contains("Inject"),
        "expected output to contain UserService class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for parameter injection decorator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_es5_factory_chain() {
    let source = r#"function Memoize() {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        const cache = new Map();
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            const cacheKey = JSON.stringify(args);
            if (!cache.has(cacheKey)) {
                cache.set(cacheKey, original.apply(this, args));
            }
            return cache.get(cacheKey);
        };
    };
}

function Throttle(ms: number) {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        let lastCall = 0;
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            const now = Date.now();
            if (now - lastCall >= ms) {
                lastCall = now;
                return original.apply(this, args);
            }
        };
    };
}

function Bind() {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        return {
            get() {
                return descriptor.value.bind(this);
            }
        };
    };
}

class ApiClient {
    @Memoize()
    @Throttle(1000)
    @Bind()
    fetchData(url: string): Promise<any> {
        return fetch(url).then(r => r.json());
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ApiClient") || output.contains("fetchData"),
        "expected output to contain ApiClient class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for decorator factory chain"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_es5_accessor_readonly() {
    let source = r#"function Readonly(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.writable = false;
    return descriptor;
}

function Enumerable(value: boolean) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
        return descriptor;
    };
}

class Config {
    private _apiKey: string = '';

    @Readonly
    @Enumerable(false)
    get apiKey(): string {
        return this._apiKey;
    }

    set apiKey(value: string) {
        this._apiKey = value;
    }
}

const config = new Config();
config.apiKey = 'secret-key';"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Config") || output.contains("apiKey"),
        "expected output to contain Config class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for accessor readonly decorator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_es5_abstract_class() {
    let source = r#"function Sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}

function Abstract(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.value = function() {
        throw new Error('Abstract method must be implemented');
    };
    return descriptor;
}

@Sealed
abstract class Animal {
    abstract name: string;

    @Abstract
    abstract makeSound(): void;

    move(distance: number): void {
        console.log(`Moving ${distance} meters`);
    }
}

class Dog extends Animal {
    name = 'Dog';

    makeSound(): void {
        console.log('Bark!');
    }
}

const dog = new Dog();
dog.makeSound();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Animal") || output.contains("Dog"),
        "expected output to contain Animal or Dog class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for abstract class decorator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_es5_static_members() {
    let source = r#"function Singleton<T extends { new(...args: any[]): {} }>(constructor: T) {
    let instance: T;
    return class extends constructor {
        constructor(...args: any[]) {
            if (instance) {
                return instance;
            }
            super(...args);
            instance = this as any;
        }
    };
}

function StaticInit(target: any, propertyKey: string) {
    const init = target[propertyKey];
    target[propertyKey] = null;
    setTimeout(() => {
        target[propertyKey] = init;
    }, 0);
}

@Singleton
class Database {
    @StaticInit
    static connectionPool: any[] = [];

    static maxConnections: number = 10;

    connect(): void {
        Database.connectionPool.push({});
    }
}

const db1 = new Database();
const db2 = new Database();
console.log(db1 === db2);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Database") || output.contains("Singleton"),
        "expected output to contain Database class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static member decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_es5_conditional() {
    let source = r#"const DEBUG = true;

function DebugOnly(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    if (!DEBUG) {
        descriptor.value = function() {};
    }
    return descriptor;
}

function ConditionalDecorator(condition: boolean) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        if (!condition) {
            return descriptor;
        }
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            console.log(`[${propertyKey}] called`);
            return original.apply(this, args);
        };
        return descriptor;
    };
}

class Service {
    @DebugOnly
    debugInfo(): void {
        console.log('Debug info');
    }

    @ConditionalDecorator(DEBUG)
    process(data: any): any {
        return data;
    }
}

const service = new Service();
service.debugInfo();
service.process({});"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Service") || output.contains("DEBUG"),
        "expected output to contain Service class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for conditional decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_es5_comprehensive() {
    let source = r#"// Class decorator factory
function Entity(tableName: string) {
    return function<T extends { new(...args: any[]): {} }>(constructor: T) {
        return class extends constructor {
            __tableName = tableName;
        };
    };
}

// Property decorator
function Column(type: string) {
    return function(target: any, propertyKey: string) {
        Reflect.defineMetadata('column:type', type, target, propertyKey);
    };
}

// Method decorator
function Transaction(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = async function(...args: any[]) {
        console.log('BEGIN TRANSACTION');
        try {
            const result = await original.apply(this, args);
            console.log('COMMIT');
            return result;
        } catch (e) {
            console.log('ROLLBACK');
            throw e;
        }
    };
    return descriptor;
}

// Parameter decorator
function Required(target: any, propertyKey: string, parameterIndex: number) {
    const required = Reflect.getMetadata('required', target, propertyKey) || [];
    required.push(parameterIndex);
    Reflect.defineMetadata('required', required, target, propertyKey);
}

@Entity('users')
class UserRepository {
    @Column('varchar')
    name: string;

    @Column('int')
    age: number;

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }

    @Transaction
    async save(@Required entity: any): Promise<void> {
        console.log('Saving entity');
    }

    @Transaction
    async delete(@Required id: number): Promise<void> {
        console.log('Deleting entity', id);
    }
}

const repo = new UserRepository('John', 30);
repo.save({});"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("UserRepository"),
        "expected output to contain UserRepository class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Async/Await ES5 Source Map Tests - Extended Patterns
// =============================================================================

#[test]
fn test_source_map_async_es5_promise_all() {
    let source = r#"async function fetchAll(urls: string[]): Promise<any[]> {
    const promises = urls.map(url => fetch(url).then(r => r.json()));
    const results = await Promise.all(promises);
    return results;
}

async function parallelFetch(): Promise<void> {
    const [users, posts, comments] = await Promise.all([
        fetch('/api/users'),
        fetch('/api/posts'),
        fetch('/api/comments')
    ]);
    console.log(users, posts, comments);
}

fetchAll(['url1', 'url2', 'url3']);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchAll") || output.contains("Promise"),
        "expected output to contain fetchAll. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Promise.all"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_promise_race() {
    let source = r#"async function timeout<T>(promise: Promise<T>, ms: number): Promise<T> {
    const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error('Timeout')), ms);
    });
    return await Promise.race([promise, timeoutPromise]);
}

async function fetchWithTimeout(url: string): Promise<any> {
    const result = await timeout(fetch(url), 5000);
    return result.json();
}

fetchWithTimeout('/api/data');"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("timeout") || output.contains("Promise"),
        "expected output to contain timeout function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Promise.race"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_error_handling() {
    let source = r#"class NetworkError extends Error {
    constructor(message: string, public statusCode: number) {
        super(message);
        this.name = 'NetworkError';
    }
}

async function fetchWithRetry(url: string, retries: number = 3): Promise<any> {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new NetworkError('Request failed', response.status);
            }
            return await response.json();
        } catch (error) {
            if (i === retries - 1) {
                throw error;
            }
            await new Promise(r => setTimeout(r, 1000 * Math.pow(2, i)));
        }
    }
}

fetchWithRetry('/api/data').catch(console.error);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchWithRetry") || output.contains("NetworkError"),
        "expected output to contain fetchWithRetry. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for error handling"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_sequential_vs_parallel() {
    let source = r#"async function sequential(): Promise<number[]> {
    const a = await fetch('/a').then(r => r.json());
    const b = await fetch('/b').then(r => r.json());
    const c = await fetch('/c').then(r => r.json());
    return [a, b, c];
}

async function parallel(): Promise<number[]> {
    const [a, b, c] = await Promise.all([
        fetch('/a').then(r => r.json()),
        fetch('/b').then(r => r.json()),
        fetch('/c').then(r => r.json())
    ]);
    return [a, b, c];
}

async function mixed(): Promise<void> {
    const first = await fetch('/first').then(r => r.json());
    const [second, third] = await Promise.all([
        fetch('/second'),
        fetch('/third')
    ]);
    console.log(first, second, third);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("sequential") || output.contains("parallel"),
        "expected output to contain sequential or parallel. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for sequential vs parallel"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_closure_capture() {
    let source = r#"function createAsyncCounter() {
    let count = 0;

    return {
        increment: async (): Promise<number> => {
            await new Promise(r => setTimeout(r, 100));
            return ++count;
        },
        decrement: async (): Promise<number> => {
            await new Promise(r => setTimeout(r, 100));
            return --count;
        },
        getCount: async (): Promise<number> => {
            await new Promise(r => setTimeout(r, 50));
            return count;
        }
    };
}

const counter = createAsyncCounter();
counter.increment().then(console.log);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createAsyncCounter") || output.contains("increment"),
        "expected output to contain createAsyncCounter. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for closure capture"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_inheritance() {
    let source = r#"abstract class AsyncResource {
    protected abstract load(): Promise<any>;

    async initialize(): Promise<void> {
        const data = await this.load();
        await this.process(data);
    }

    protected async process(data: any): Promise<void> {
        console.log('Processing:', data);
    }
}

class UserResource extends AsyncResource {
    protected async load(): Promise<any> {
        const response = await fetch('/api/users');
        return response.json();
    }

    protected async process(data: any): Promise<void> {
        await super.process(data);
        console.log('Users processed');
    }
}

const resource = new UserResource();
resource.initialize();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AsyncResource") || output.contains("UserResource"),
        "expected output to contain AsyncResource or UserResource. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for inheritance"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_factory_pattern() {
    let source = r#"interface Connection {
    query(sql: string): Promise<any[]>;
    close(): Promise<void>;
}

async function createConnection(config: any): Promise<Connection> {
    await new Promise(r => setTimeout(r, 100));

    return {
        query: async (sql: string): Promise<any[]> => {
            await new Promise(r => setTimeout(r, 50));
            return [{ id: 1, sql }];
        },
        close: async (): Promise<void> => {
            await new Promise(r => setTimeout(r, 50));
            console.log('Connection closed');
        }
    };
}

async function useConnection(): Promise<void> {
    const conn = await createConnection({ host: 'localhost' });
    const results = await conn.query('SELECT * FROM users');
    console.log(results);
    await conn.close();
}

useConnection();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createConnection") || output.contains("useConnection"),
        "expected output to contain createConnection. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for factory pattern"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_queue_processing() {
    let source = r#"class AsyncQueue<T> {
    private queue: T[] = [];
    private processing = false;

    async add(item: T): Promise<void> {
        this.queue.push(item);
        if (!this.processing) {
            await this.process();
        }
    }

    private async process(): Promise<void> {
        this.processing = true;
        while (this.queue.length > 0) {
            const item = this.queue.shift()!;
            await this.handleItem(item);
        }
        this.processing = false;
    }

    private async handleItem(item: T): Promise<void> {
        await new Promise(r => setTimeout(r, 100));
        console.log('Processed:', item);
    }
}

const queue = new AsyncQueue<string>();
queue.add('item1');
queue.add('item2');"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AsyncQueue") || output.contains("process"),
        "expected output to contain AsyncQueue. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for queue processing"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_event_emitter() {
    let source = r#"class AsyncEventEmitter {
    private listeners: Map<string, Array<(data: any) => Promise<void>>> = new Map();

    on(event: string, handler: (data: any) => Promise<void>): void {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event)!.push(handler);
    }

    async emit(event: string, data: any): Promise<void> {
        const handlers = this.listeners.get(event) || [];
        for (const handler of handlers) {
            await handler(data);
        }
    }

    async emitParallel(event: string, data: any): Promise<void> {
        const handlers = this.listeners.get(event) || [];
        await Promise.all(handlers.map(h => h(data)));
    }
}

const emitter = new AsyncEventEmitter();
emitter.on('data', async (d) => { console.log(d); });
emitter.emit('data', { value: 42 });"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AsyncEventEmitter") || output.contains("emit"),
        "expected output to contain AsyncEventEmitter. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for event emitter"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_comprehensive() {
    let source = r#"// Async utility functions
const delay = (ms: number): Promise<void> =>
    new Promise(resolve => setTimeout(resolve, ms));

async function* asyncRange(start: number, end: number): AsyncGenerator<number> {
    for (let i = start; i < end; i++) {
        await delay(10);
        yield i;
    }
}

// Async class with all patterns
class DataProcessor {
    private cache = new Map<string, any>();

    constructor(private readonly baseUrl: string) {}

    async fetch(path: string): Promise<any> {
        const key = this.baseUrl + path;
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        const response = await fetch(key);
        const data = await response.json();
        this.cache.set(key, data);
        return data;
    }

    async fetchMany(paths: string[]): Promise<any[]> {
        return Promise.all(paths.map(p => this.fetch(p)));
    }

    async *processStream(paths: string[]): AsyncGenerator<any> {
        for await (const i of asyncRange(0, paths.length)) {
            yield await this.fetch(paths[i]);
        }
    }

    async processWithRetry(path: string, retries = 3): Promise<any> {
        for (let i = 0; i < retries; i++) {
            try {
                return await this.fetch(path);
            } catch (e) {
                if (i === retries - 1) throw e;
                await delay(1000 * (i + 1));
            }
        }
    }
}

// Usage
const processor = new DataProcessor('https://api.example.com');

(async () => {
    const data = await processor.fetch('/users');
    const [users, posts] = await processor.fetchMany(['/users', '/posts']);

    for await (const item of processor.processStream(['/a', '/b', '/c'])) {
        console.log(item);
    }
})();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataProcessor"),
        "expected output to contain DataProcessor. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive async"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Generator ES5 Source Map Tests - Extended Patterns
// =============================================================================

#[test]
fn test_source_map_generator_es5_control_flow() {
    let source = r#"function* controlFlowGenerator(n: number): Generator<number> {
    for (let i = 0; i < n; i++) {
        if (i % 2 === 0) {
            yield i * 2;
        } else {
            yield i * 3;
        }
    }

    let j = 0;
    while (j < 3) {
        yield j * 10;
        j++;
    }

    switch (n) {
        case 1: yield 100; break;
        case 2: yield 200; break;
        default: yield 999;
    }
}

const gen = controlFlowGenerator(5);
console.log([...gen]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("controlFlowGenerator"),
        "expected output to contain controlFlowGenerator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for control flow generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_state_machine() {
    let source = r#"type State = 'idle' | 'loading' | 'success' | 'error';

function* stateMachine(): Generator<State, void, string> {
    let input: string;

    while (true) {
        yield 'idle';
        input = yield 'loading';

        if (input === 'success') {
            yield 'success';
        } else if (input === 'error') {
            yield 'error';
        }
    }
}

const machine = stateMachine();
console.log(machine.next());
console.log(machine.next());
console.log(machine.next('success'));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("stateMachine"),
        "expected output to contain stateMachine. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for state machine generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_finally() {
    let source = r#"function* generatorWithFinally(): Generator<number> {
    try {
        yield 1;
        yield 2;
        yield 3;
    } finally {
        console.log('Generator cleanup');
    }
}

function* nestedTryFinally(): Generator<string> {
    try {
        try {
            yield 'inner-1';
            yield 'inner-2';
        } finally {
            yield 'inner-finally';
        }
        yield 'outer-1';
    } finally {
        yield 'outer-finally';
    }
}

const gen1 = generatorWithFinally();
const gen2 = nestedTryFinally();
console.log([...gen1], [...gen2]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("generatorWithFinally") || output.contains("nestedTryFinally"),
        "expected output to contain generator functions. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for finally generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_composition() {
    let source = r#"function* numbers(n: number): Generator<number> {
    for (let i = 1; i <= n; i++) {
        yield i;
    }
}

function* letters(s: string): Generator<string> {
    for (const c of s) {
        yield c;
    }
}

function* combined(): Generator<number | string> {
    yield* numbers(3);
    yield '---';
    yield* letters('abc');
    yield '---';
    yield* numbers(2);
}

function* flatten<T>(iterables: Iterable<T>[]): Generator<T> {
    for (const iterable of iterables) {
        yield* iterable;
    }
}

console.log([...combined()]);
console.log([...flatten([[1, 2], [3, 4], [5]])]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("combined") || output.contains("flatten"),
        "expected output to contain composition generators. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for composition generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_iterator_protocol() {
    let source = r#"class Range {
    constructor(private start: number, private end: number) {}

    *[Symbol.iterator](): Generator<number> {
        for (let i = this.start; i <= this.end; i++) {
            yield i;
        }
    }
}

class KeyValuePairs<K, V> {
    private pairs: [K, V][] = [];

    add(key: K, value: V): void {
        this.pairs.push([key, value]);
    }

    *keys(): Generator<K> {
        for (const [key] of this.pairs) {
            yield key;
        }
    }

    *values(): Generator<V> {
        for (const [, value] of this.pairs) {
            yield value;
        }
    }

    *entries(): Generator<[K, V]> {
        yield* this.pairs;
    }
}

const range = new Range(1, 5);
console.log([...range]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Range") || output.contains("KeyValuePairs"),
        "expected output to contain iterator protocol classes. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for iterator protocol"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_default_params() {
    let source = r#"function* range(
    start: number = 0,
    end: number = 10,
    step: number = 1
): Generator<number> {
    for (let i = start; i < end; i += step) {
        yield i;
    }
}

function* repeat<T>(
    value: T,
    times: number = Infinity
): Generator<T> {
    for (let i = 0; i < times; i++) {
        yield value;
    }
}

function* take<T>(
    iterable: Iterable<T>,
    count: number = 5
): Generator<T> {
    let i = 0;
    for (const item of iterable) {
        if (i++ >= count) break;
        yield item;
    }
}

console.log([...range()]);
console.log([...range(5, 10, 2)]);
console.log([...take(repeat('x'), 3)]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("range") || output.contains("repeat"),
        "expected output to contain generators with default params. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for default params generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_object_yielding() {
    let source = r#"interface Person {
    id: number;
    name: string;
    age: number;
}

function* personGenerator(): Generator<Person> {
    yield { id: 1, name: 'Alice', age: 30 };
    yield { id: 2, name: 'Bob', age: 25 };
    yield { id: 3, name: 'Charlie', age: 35 };
}

function* objectTransformer<T, U>(
    source: Iterable<T>,
    transform: (item: T) => U
): Generator<U> {
    for (const item of source) {
        yield transform(item);
    }
}

const people = personGenerator();
const names = objectTransformer(personGenerator(), p => p.name);
console.log([...people], [...names]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("personGenerator") || output.contains("objectTransformer"),
        "expected output to contain object yielding generators. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for object yielding generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_recursion() {
    let source = r#"interface TreeNode<T> {
    value: T;
    children?: TreeNode<T>[];
}

function* traverseTree<T>(node: TreeNode<T>): Generator<T> {
    yield node.value;
    if (node.children) {
        for (const child of node.children) {
            yield* traverseTree(child);
        }
    }
}

function* fibonacci(): Generator<number> {
    let [a, b] = [0, 1];
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
}

function* permutations<T>(items: T[]): Generator<T[]> {
    if (items.length <= 1) {
        yield items;
    } else {
        for (let i = 0; i < items.length; i++) {
            const rest = [...items.slice(0, i), ...items.slice(i + 1)];
            for (const perm of permutations(rest)) {
                yield [items[i], ...perm];
            }
        }
    }
}

const tree: TreeNode<number> = {
    value: 1,
    children: [{ value: 2 }, { value: 3, children: [{ value: 4 }] }]
};
console.log([...traverseTree(tree)]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("traverseTree") || output.contains("fibonacci"),
        "expected output to contain recursive generators. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for recursive generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_lazy_evaluation() {
    let source = r#"function* lazyMap<T, U>(
    source: Iterable<T>,
    fn: (item: T) => U
): Generator<U> {
    for (const item of source) {
        yield fn(item);
    }
}

function* lazyFilter<T>(
    source: Iterable<T>,
    predicate: (item: T) => boolean
): Generator<T> {
    for (const item of source) {
        if (predicate(item)) {
            yield item;
        }
    }
}

function* lazyTakeWhile<T>(
    source: Iterable<T>,
    predicate: (item: T) => boolean
): Generator<T> {
    for (const item of source) {
        if (!predicate(item)) break;
        yield item;
    }
}

function pipe<T>(...generators: ((input: Iterable<T>) => Generator<T>)[]): (input: Iterable<T>) => Generator<T> {
    return function*(input: Iterable<T>): Generator<T> {
        let result: Iterable<T> = input;
        for (const gen of generators) {
            result = gen(result);
        }
        yield* result;
    };
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const result = lazyFilter(
    lazyMap(numbers, x => x * 2),
    x => x > 5
);
console.log([...result]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("lazyMap") || output.contains("lazyFilter"),
        "expected output to contain lazy evaluation generators. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for lazy evaluation generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_comprehensive() {
    let source = r#"// Utility generators
function* range(start: number, end: number): Generator<number> {
    for (let i = start; i < end; i++) yield i;
}

function* map<T, U>(iter: Iterable<T>, fn: (x: T) => U): Generator<U> {
    for (const x of iter) yield fn(x);
}

function* filter<T>(iter: Iterable<T>, pred: (x: T) => boolean): Generator<T> {
    for (const x of iter) if (pred(x)) yield x;
}

// Class with generator methods
class DataStream<T> {
    private data: T[] = [];

    push(...items: T[]): void {
        this.data.push(...items);
    }

    *[Symbol.iterator](): Generator<T> {
        yield* this.data;
    }

    *reversed(): Generator<T> {
        for (let i = this.data.length - 1; i >= 0; i--) {
            yield this.data[i];
        }
    }

    *chunks(size: number): Generator<T[]> {
        for (let i = 0; i < this.data.length; i += size) {
            yield this.data.slice(i, i + size);
        }
    }

    *zip<U>(other: Iterable<U>): Generator<[T, U]> {
        const otherIter = other[Symbol.iterator]();
        for (const item of this.data) {
            const otherResult = otherIter.next();
            if (otherResult.done) break;
            yield [item, otherResult.value];
        }
    }
}

// Async generator for completeness
async function* asyncNumbers(): AsyncGenerator<number> {
    for (let i = 0; i < 5; i++) {
        await new Promise(r => setTimeout(r, 10));
        yield i;
    }
}

// Usage
const stream = new DataStream<number>();
stream.push(1, 2, 3, 4, 5, 6);

const evenDoubled = filter(
    map(stream, x => x * 2),
    x => x % 4 === 0
);

console.log([...evenDoubled]);
console.log([...stream.chunks(2)]);
console.log([...stream.zip(['a', 'b', 'c'])]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataStream"),
        "expected output to contain DataStream class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Class Inheritance ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_class_inheritance_es5_extends_clause() {
    let source = r#"class Animal {
    name: string;

    constructor(name: string) {
        this.name = name;
    }

    speak(): void {
        console.log(`${this.name} makes a sound`);
    }
}

class Dog extends Animal {
    breed: string;

    constructor(name: string, breed: string) {
        super(name);
        this.breed = breed;
    }
}

const dog = new Dog("Buddy", "Labrador");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Animal"),
        "expected output to contain Animal class. output: {output}"
    );
    assert!(
        output.contains("Dog"),
        "expected output to contain Dog class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for extends clause"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_inheritance_es5_super_calls() {
    let source = r#"class Base {
    protected value: number;

    constructor(value: number) {
        this.value = value;
    }

    getValue(): number {
        return this.value;
    }

    protected increment(): void {
        this.value++;
    }
}

class Derived extends Base {
    private multiplier: number;

    constructor(value: number, multiplier: number) {
        super(value);
        this.multiplier = multiplier;
    }

    getValue(): number {
        return super.getValue() * this.multiplier;
    }

    increment(): void {
        super.increment();
        console.log("Incremented to", this.value);
    }
}

const d = new Derived(5, 2);
console.log(d.getValue());
d.increment();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Derived"),
        "expected output to contain Derived class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for super calls"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_inheritance_es5_method_overrides() {
    let source = r#"class Shape {
    protected x: number;
    protected y: number;

    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }

    area(): number {
        return 0;
    }

    perimeter(): number {
        return 0;
    }

    describe(): string {
        return `Shape at (${this.x}, ${this.y})`;
    }
}

class Rectangle extends Shape {
    private width: number;
    private height: number;

    constructor(x: number, y: number, width: number, height: number) {
        super(x, y);
        this.width = width;
        this.height = height;
    }

    area(): number {
        return this.width * this.height;
    }

    perimeter(): number {
        return 2 * (this.width + this.height);
    }

    describe(): string {
        return `Rectangle ${this.width}x${this.height} at (${this.x}, ${this.y})`;
    }
}

class Circle extends Shape {
    private radius: number;

    constructor(x: number, y: number, radius: number) {
        super(x, y);
        this.radius = radius;
    }

    area(): number {
        return Math.PI * this.radius * this.radius;
    }

    perimeter(): number {
        return 2 * Math.PI * this.radius;
    }

    describe(): string {
        return `Circle r=${this.radius} at (${this.x}, ${this.y})`;
    }
}

const shapes: Shape[] = [new Rectangle(0, 0, 10, 5), new Circle(5, 5, 3)];
shapes.forEach(s => console.log(s.describe(), s.area()));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Rectangle"),
        "expected output to contain Rectangle class. output: {output}"
    );
    assert!(
        output.contains("Circle"),
        "expected output to contain Circle class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for method overrides"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_inheritance_es5_multi_level() {
    let source = r#"class Entity {
    id: string;

    constructor(id: string) {
        this.id = id;
    }

    toString(): string {
        return `Entity(${this.id})`;
    }
}

class LivingEntity extends Entity {
    health: number;

    constructor(id: string, health: number) {
        super(id);
        this.health = health;
    }

    isAlive(): boolean {
        return this.health > 0;
    }

    toString(): string {
        return `${super.toString()} HP:${this.health}`;
    }
}

class Character extends LivingEntity {
    name: string;
    level: number;

    constructor(id: string, name: string, health: number, level: number) {
        super(id, health);
        this.name = name;
        this.level = level;
    }

    toString(): string {
        return `${this.name} Lv.${this.level} ${super.toString()}`;
    }
}

class Player extends Character {
    experience: number;

    constructor(id: string, name: string) {
        super(id, name, 100, 1);
        this.experience = 0;
    }

    gainExp(amount: number): void {
        this.experience += amount;
        if (this.experience >= this.level * 100) {
            this.level++;
            this.health += 10;
        }
    }

    toString(): string {
        return `[Player] ${super.toString()} EXP:${this.experience}`;
    }
}

const player = new Player("p1", "Hero");
player.gainExp(150);
console.log(player.toString());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Player"),
        "expected output to contain Player class. output: {output}"
    );
    assert!(
        output.contains("Character"),
        "expected output to contain Character class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multi-level inheritance"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_inheritance_es5_mixin_pattern() {
    let source = r#"type Constructor<T = {}> = new (...args: any[]) => T;

function Timestamped<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        timestamp = Date.now();

        getTimestamp(): number {
            return this.timestamp;
        }
    };
}

function Tagged<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        tag: string = "";

        setTag(tag: string): void {
            this.tag = tag;
        }

        getTag(): string {
            return this.tag;
        }
    };
}

function Serializable<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        serialize(): string {
            return JSON.stringify(this);
        }
    };
}

class BaseEntity {
    id: number;

    constructor(id: number) {
        this.id = id;
    }
}

const MixedEntity = Serializable(Tagged(Timestamped(BaseEntity)));

const entity = new MixedEntity(1);
entity.setTag("important");
console.log(entity.serialize());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Timestamped"),
        "expected output to contain Timestamped mixin. output: {output}"
    );
    assert!(
        output.contains("Tagged"),
        "expected output to contain Tagged mixin. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for mixin pattern"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_inheritance_es5_super_property_access() {
    let source = r#"class Config {
    protected settings: Map<string, any> = new Map();

    get(key: string): any {
        return this.settings.get(key);
    }

    set(key: string, value: any): void {
        this.settings.set(key, value);
    }

    has(key: string): boolean {
        return this.settings.has(key);
    }
}

class AppConfig extends Config {
    private defaults: Map<string, any>;

    constructor(defaults: Record<string, any>) {
        super();
        this.defaults = new Map(Object.entries(defaults));
    }

    get(key: string): any {
        if (super.has(key)) {
            return super.get(key);
        }
        return this.defaults.get(key);
    }

    set(key: string, value: any): void {
        if (this.defaults.has(key)) {
            super.set(key, value);
        } else {
            throw new Error(`Unknown config key: ${key}`);
        }
    }

    reset(key: string): void {
        if (this.defaults.has(key)) {
            super.set(key, this.defaults.get(key));
        }
    }
}

const config = new AppConfig({ debug: false, timeout: 5000 });
config.set("debug", true);
console.log(config.get("debug"), config.get("timeout"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AppConfig"),
        "expected output to contain AppConfig class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for super property access"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_inheritance_es5_static_inheritance() {
    let source = r#"class Database {
    static connectionCount = 0;
    static instances: Database[] = [];

    static create(): Database {
        const db = new Database();
        Database.instances.push(db);
        return db;
    }

    static getConnectionCount(): number {
        return Database.connectionCount;
    }

    constructor() {
        Database.connectionCount++;
    }
}

class PostgresDB extends Database {
    static driver = "pg";

    static create(): PostgresDB {
        const db = new PostgresDB();
        Database.instances.push(db);
        return db;
    }

    static getDriver(): string {
        return PostgresDB.driver;
    }

    query(sql: string): void {
        console.log(`Executing on ${PostgresDB.driver}: ${sql}`);
    }
}

class MySQLDB extends Database {
    static driver = "mysql2";

    static create(): MySQLDB {
        const db = new MySQLDB();
        Database.instances.push(db);
        return db;
    }
}

const pg = PostgresDB.create();
const mysql = MySQLDB.create();
console.log(Database.getConnectionCount());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("PostgresDB"),
        "expected output to contain PostgresDB class. output: {output}"
    );
    assert!(
        output.contains("MySQLDB"),
        "expected output to contain MySQLDB class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static inheritance"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_inheritance_es5_abstract_class() {
    let source = r#"abstract class Transport {
    abstract connect(): Promise<void>;
    abstract disconnect(): Promise<void>;
    abstract send(data: string): Promise<void>;

    protected connected = false;

    isConnected(): boolean {
        return this.connected;
    }

    async sendIfConnected(data: string): Promise<boolean> {
        if (this.connected) {
            await this.send(data);
            return true;
        }
        return false;
    }
}

class WebSocketTransport extends Transport {
    private url: string;
    private ws: any;

    constructor(url: string) {
        super();
        this.url = url;
    }

    async connect(): Promise<void> {
        this.ws = new WebSocket(this.url);
        this.connected = true;
    }

    async disconnect(): Promise<void> {
        this.ws?.close();
        this.connected = false;
    }

    async send(data: string): Promise<void> {
        this.ws?.send(data);
    }
}

class HTTPTransport extends Transport {
    private baseUrl: string;

    constructor(baseUrl: string) {
        super();
        this.baseUrl = baseUrl;
    }

    async connect(): Promise<void> {
        this.connected = true;
    }

    async disconnect(): Promise<void> {
        this.connected = false;
    }

    async send(data: string): Promise<void> {
        await fetch(this.baseUrl, { method: 'POST', body: data });
    }
}

const transports: Transport[] = [
    new WebSocketTransport("ws://localhost:8080"),
    new HTTPTransport("http://api.example.com")
];"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Transport"),
        "expected output to contain Transport class. output: {output}"
    );
    assert!(
        output.contains("WebSocketTransport"),
        "expected output to contain WebSocketTransport class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for abstract class"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_inheritance_es5_interface_implementation() {
    let source = r#"interface Comparable<T> {
    compareTo(other: T): number;
}

interface Hashable {
    hashCode(): number;
}

interface Cloneable<T> {
    clone(): T;
}

class BaseValue {
    protected value: number;

    constructor(value: number) {
        this.value = value;
    }

    getValue(): number {
        return this.value;
    }
}

class ComparableValue extends BaseValue implements Comparable<ComparableValue>, Hashable, Cloneable<ComparableValue> {
    constructor(value: number) {
        super(value);
    }

    compareTo(other: ComparableValue): number {
        return this.value - other.value;
    }

    hashCode(): number {
        return this.value | 0;
    }

    clone(): ComparableValue {
        return new ComparableValue(this.value);
    }
}

const a = new ComparableValue(10);
const b = new ComparableValue(20);
console.log(a.compareTo(b));
console.log(a.hashCode());
const c = a.clone();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ComparableValue"),
        "expected output to contain ComparableValue class. output: {output}"
    );
    assert!(
        output.contains("BaseValue"),
        "expected output to contain BaseValue class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for interface implementation"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_inheritance_es5_comprehensive() {
    let source = r#"// Comprehensive class inheritance test with mixins, abstract classes, and interfaces

type Constructor<T = {}> = new (...args: any[]) => T;

interface Identifiable {
    getId(): string;
}

interface Persistable {
    save(): Promise<void>;
    load(): Promise<void>;
}

function Loggable<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        log(message: string): void {
            console.log(`[${new Date().toISOString()}] ${message}`);
        }
    };
}

function Validatable<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        protected errors: string[] = [];

        validate(): boolean {
            this.errors = [];
            return true;
        }

        getErrors(): string[] {
            return [...this.errors];
        }
    };
}

abstract class Entity implements Identifiable {
    protected id: string;
    protected createdAt: Date;
    protected updatedAt: Date;

    constructor(id?: string) {
        this.id = id || crypto.randomUUID();
        this.createdAt = new Date();
        this.updatedAt = new Date();
    }

    getId(): string {
        return this.id;
    }

    abstract toJSON(): object;
}

abstract class Model extends Entity implements Persistable {
    protected dirty = false;

    markDirty(): void {
        this.dirty = true;
        this.updatedAt = new Date();
    }

    abstract save(): Promise<void>;
    abstract load(): Promise<void>;
}

const ValidatableModel = Validatable(Loggable(class extends Model {
    toJSON(): object {
        return { id: this.id, createdAt: this.createdAt, updatedAt: this.updatedAt };
    }

    async save(): Promise<void> {
        this.log(`Saving entity ${this.id}`);
    }

    async load(): Promise<void> {
        this.log(`Loading entity ${this.id}`);
    }
}));

class User extends ValidatableModel {
    private email: string;
    private name: string;
    private role: "admin" | "user" | "guest";

    constructor(email: string, name: string, role: "admin" | "user" | "guest" = "user") {
        super();
        this.email = email;
        this.name = name;
        this.role = role;
    }

    validate(): boolean {
        super.validate();

        if (!this.email.includes("@")) {
            this.errors.push("Invalid email format");
        }
        if (this.name.length < 2) {
            this.errors.push("Name too short");
        }

        return this.errors.length === 0;
    }

    toJSON(): object {
        return {
            ...super.toJSON(),
            email: this.email,
            name: this.name,
            role: this.role
        };
    }

    async save(): Promise<void> {
        if (!this.validate()) {
            throw new Error(`Validation failed: ${this.getErrors().join(", ")}`);
        }
        await super.save();
        this.dirty = false;
    }

    promote(): void {
        if (this.role === "guest") {
            this.role = "user";
        } else if (this.role === "user") {
            this.role = "admin";
        }
        this.markDirty();
    }
}

class AdminUser extends User {
    private permissions: Set<string>;

    constructor(email: string, name: string, permissions: string[] = []) {
        super(email, name, "admin");
        this.permissions = new Set(permissions);
    }

    hasPermission(permission: string): boolean {
        return this.permissions.has(permission) || this.permissions.has("*");
    }

    grant(permission: string): void {
        this.permissions.add(permission);
        this.markDirty();
    }

    revoke(permission: string): void {
        this.permissions.delete(permission);
        this.markDirty();
    }

    toJSON(): object {
        return {
            ...super.toJSON(),
            permissions: [...this.permissions]
        };
    }
}

// Usage
const admin = new AdminUser("admin@example.com", "Admin", ["users.read", "users.write"]);
admin.grant("settings.read");
admin.validate();
console.log(JSON.stringify(admin.toJSON(), null, 2));

const user = new User("test", "A", "guest");
if (!user.validate()) {
    console.log("Validation errors:", user.getErrors());
}
user.promote();
console.log(JSON.stringify(user.toJSON(), null, 2));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("User"),
        "expected output to contain User class. output: {output}"
    );
    assert!(
        output.contains("AdminUser"),
        "expected output to contain AdminUser class. output: {output}"
    );
    assert!(
        output.contains("Entity"),
        "expected output to contain Entity class. output: {output}"
    );
    assert!(
        output.contains("Loggable"),
        "expected output to contain Loggable mixin. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive class inheritance"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Private Field ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_private_field_es5_instance_field_access() {
    let source = r#"class Counter {
    #count: number = 0;

    increment(): void {
        this.#count++;
    }

    decrement(): void {
        this.#count--;
    }

    getCount(): number {
        return this.#count;
    }

    setCount(value: number): void {
        this.#count = value;
    }

    reset(): void {
        this.#count = 0;
    }
}

const counter = new Counter();
counter.increment();
counter.increment();
console.log(counter.getCount());
counter.setCount(10);
console.log(counter.getCount());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter"),
        "expected output to contain Counter class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private instance field access"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_es5_static_field_access() {
    let source = r#"class IdGenerator {
    static #nextId: number = 1;
    static #prefix: string = "ID_";

    static generate(): string {
        return IdGenerator.#prefix + IdGenerator.#nextId++;
    }

    static reset(): void {
        IdGenerator.#nextId = 1;
    }

    static setPrefix(prefix: string): void {
        IdGenerator.#prefix = prefix;
    }

    static getNextId(): number {
        return IdGenerator.#nextId;
    }
}

console.log(IdGenerator.generate());
console.log(IdGenerator.generate());
IdGenerator.setPrefix("USER_");
console.log(IdGenerator.generate());
console.log(IdGenerator.getNextId());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("IdGenerator"),
        "expected output to contain IdGenerator class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private static field access"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_es5_private_method_calls() {
    let source = r#"class Calculator {
    #value: number = 0;

    #add(n: number): void {
        this.#value += n;
    }

    #subtract(n: number): void {
        this.#value -= n;
    }

    #multiply(n: number): void {
        this.#value *= n;
    }

    #divide(n: number): void {
        if (n !== 0) {
            this.#value /= n;
        }
    }

    #validate(n: number): boolean {
        return typeof n === 'number' && !isNaN(n);
    }

    add(n: number): this {
        if (this.#validate(n)) {
            this.#add(n);
        }
        return this;
    }

    subtract(n: number): this {
        if (this.#validate(n)) {
            this.#subtract(n);
        }
        return this;
    }

    multiply(n: number): this {
        if (this.#validate(n)) {
            this.#multiply(n);
        }
        return this;
    }

    divide(n: number): this {
        if (this.#validate(n)) {
            this.#divide(n);
        }
        return this;
    }

    getValue(): number {
        return this.#value;
    }
}

const calc = new Calculator();
const result = calc.add(10).multiply(2).subtract(5).divide(3).getValue();
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Calculator"),
        "expected output to contain Calculator class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private method calls"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_es5_accessor_patterns() {
    let source = r#"class Person {
    #firstName: string;
    #lastName: string;
    #age: number;

    constructor(firstName: string, lastName: string, age: number) {
        this.#firstName = firstName;
        this.#lastName = lastName;
        this.#age = age;
    }

    get firstName(): string {
        return this.#firstName;
    }

    set firstName(value: string) {
        this.#firstName = value.trim();
    }

    get lastName(): string {
        return this.#lastName;
    }

    set lastName(value: string) {
        this.#lastName = value.trim();
    }

    get fullName(): string {
        return `${this.#firstName} ${this.#lastName}`;
    }

    set fullName(value: string) {
        const parts = value.split(' ');
        this.#firstName = parts[0] || '';
        this.#lastName = parts.slice(1).join(' ') || '';
    }

    get age(): number {
        return this.#age;
    }

    set age(value: number) {
        if (value >= 0 && value <= 150) {
            this.#age = value;
        }
    }
}

const person = new Person("John", "Doe", 30);
console.log(person.fullName);
person.fullName = "Jane Smith";
console.log(person.firstName, person.lastName);
person.age = 25;
console.log(person.age);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Person"),
        "expected output to contain Person class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private accessor patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_es5_derived_class() {
    let source = r#"class Animal {
    #name: string;
    #species: string;

    constructor(name: string, species: string) {
        this.#name = name;
        this.#species = species;
    }

    getName(): string {
        return this.#name;
    }

    getSpecies(): string {
        return this.#species;
    }

    describe(): string {
        return `${this.#name} is a ${this.#species}`;
    }
}

class Dog extends Animal {
    #breed: string;
    #trained: boolean;

    constructor(name: string, breed: string) {
        super(name, "dog");
        this.#breed = breed;
        this.#trained = false;
    }

    getBreed(): string {
        return this.#breed;
    }

    train(): void {
        this.#trained = true;
    }

    isTrained(): boolean {
        return this.#trained;
    }

    describe(): string {
        const base = super.describe();
        return `${base} (${this.#breed}, trained: ${this.#trained})`;
    }
}

class Cat extends Animal {
    #indoor: boolean;

    constructor(name: string, indoor: boolean = true) {
        super(name, "cat");
        this.#indoor = indoor;
    }

    isIndoor(): boolean {
        return this.#indoor;
    }

    describe(): string {
        const base = super.describe();
        return `${base} (${this.#indoor ? "indoor" : "outdoor"})`;
    }
}

const dog = new Dog("Buddy", "Labrador");
dog.train();
console.log(dog.describe());

const cat = new Cat("Whiskers", false);
console.log(cat.describe());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Animal"),
        "expected output to contain Animal class. output: {output}"
    );
    assert!(
        output.contains("Dog"),
        "expected output to contain Dog class. output: {output}"
    );
    assert!(
        output.contains("Cat"),
        "expected output to contain Cat class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private field in derived class"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_es5_weakmap_polyfill() {
    let source = r#"class SecureStorage {
    #data: Map<string, any> = new Map();
    #encryptionKey: string;
    static #instances: WeakMap<object, SecureStorage> = new WeakMap();

    constructor(key: string) {
        this.#encryptionKey = key;
        SecureStorage.#instances.set(this, this);
    }

    #encrypt(value: string): string {
        return btoa(value + this.#encryptionKey);
    }

    #decrypt(value: string): string {
        const decoded = atob(value);
        return decoded.replace(this.#encryptionKey, '');
    }

    set(key: string, value: any): void {
        const encrypted = this.#encrypt(JSON.stringify(value));
        this.#data.set(key, encrypted);
    }

    get(key: string): any {
        const encrypted = this.#data.get(key);
        if (encrypted) {
            return JSON.parse(this.#decrypt(encrypted));
        }
        return undefined;
    }

    has(key: string): boolean {
        return this.#data.has(key);
    }

    delete(key: string): boolean {
        return this.#data.delete(key);
    }

    static getInstance(obj: object): SecureStorage | undefined {
        return SecureStorage.#instances.get(obj);
    }
}

const storage = new SecureStorage("secret123");
storage.set("user", { name: "John", role: "admin" });
console.log(storage.get("user"));
console.log(storage.has("user"));
console.log(SecureStorage.getInstance(storage));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("SecureStorage"),
        "expected output to contain SecureStorage class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for WeakMap polyfill"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_es5_in_check() {
    let source = r#"class BrandedClass {
    #brand: symbol = Symbol("branded");

    static isBranded(obj: any): boolean {
        return #brand in obj;
    }

    getBrand(): symbol {
        return this.#brand;
    }
}

class Container<T> {
    #value: T;
    #initialized: boolean = false;

    constructor(value: T) {
        this.#value = value;
        this.#initialized = true;
    }

    static isContainer(obj: any): boolean {
        return #value in obj && #initialized in obj;
    }

    getValue(): T {
        return this.#value;
    }

    setValue(value: T): void {
        this.#value = value;
    }
}

const branded = new BrandedClass();
console.log(BrandedClass.isBranded(branded));
console.log(BrandedClass.isBranded({}));

const container = new Container<number>(42);
console.log(Container.isContainer(container));
console.log(container.getValue());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("BrandedClass"),
        "expected output to contain BrandedClass. output: {output}"
    );
    assert!(
        output.contains("Container"),
        "expected output to contain Container. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private field in-check"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_es5_static_method() {
    let source = r#"class Singleton {
    static #instance: Singleton | null = null;
    #id: number;

    private constructor() {
        this.#id = Math.random();
    }

    static #createInstance(): Singleton {
        return new Singleton();
    }

    static getInstance(): Singleton {
        if (Singleton.#instance === null) {
            Singleton.#instance = Singleton.#createInstance();
        }
        return Singleton.#instance;
    }

    static #resetInstance(): void {
        Singleton.#instance = null;
    }

    static reset(): void {
        Singleton.#resetInstance();
    }

    getId(): number {
        return this.#id;
    }
}

const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();
console.log(instance1 === instance2);
console.log(instance1.getId());
Singleton.reset();
const instance3 = Singleton.getInstance();
console.log(instance1 === instance3);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Singleton"),
        "expected output to contain Singleton class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private static method"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_field_es5_comprehensive() {
    let source = r#"// Comprehensive private field test with all patterns

class EventEmitter<T extends Record<string, any[]>> {
    #listeners: Map<keyof T, Set<(...args: any[]) => void>> = new Map();
    #maxListeners: number = 10;
    static #globalEmitters: WeakMap<object, EventEmitter<any>> = new WeakMap();

    constructor() {
        EventEmitter.#globalEmitters.set(this, this);
    }

    #getListeners<K extends keyof T>(event: K): Set<(...args: T[K]) => void> {
        let listeners = this.#listeners.get(event);
        if (!listeners) {
            listeners = new Set();
            this.#listeners.set(event, listeners);
        }
        return listeners as Set<(...args: T[K]) => void>;
    }

    #checkMaxListeners(event: keyof T): void {
        const count = this.#getListeners(event).size;
        if (count > this.#maxListeners) {
            console.warn(`Max listeners exceeded for event: ${String(event)}`);
        }
    }

    on<K extends keyof T>(event: K, listener: (...args: T[K]) => void): this {
        this.#getListeners(event).add(listener);
        this.#checkMaxListeners(event);
        return this;
    }

    off<K extends keyof T>(event: K, listener: (...args: T[K]) => void): this {
        this.#getListeners(event).delete(listener);
        return this;
    }

    emit<K extends keyof T>(event: K, ...args: T[K]): boolean {
        const listeners = this.#getListeners(event);
        if (listeners.size === 0) return false;
        listeners.forEach(listener => listener(...args));
        return true;
    }

    get maxListeners(): number {
        return this.#maxListeners;
    }

    set maxListeners(value: number) {
        this.#maxListeners = Math.max(0, value);
    }

    static isEmitter(obj: any): boolean {
        return #listeners in obj;
    }

    static getEmitter(obj: object): EventEmitter<any> | undefined {
        return EventEmitter.#globalEmitters.get(obj);
    }
}

class TypedEventEmitter extends EventEmitter<{
    connect: [host: string, port: number];
    disconnect: [reason: string];
    message: [data: string, timestamp: Date];
}> {
    #connected: boolean = false;
    #host: string = "";
    #port: number = 0;

    async #doConnect(host: string, port: number): Promise<void> {
        await new Promise(r => setTimeout(r, 100));
        this.#host = host;
        this.#port = port;
        this.#connected = true;
    }

    async connect(host: string, port: number): Promise<void> {
        await this.#doConnect(host, port);
        this.emit("connect", host, port);
    }

    disconnect(reason: string): void {
        this.#connected = false;
        this.emit("disconnect", reason);
    }

    send(data: string): void {
        if (this.#connected) {
            this.emit("message", data, new Date());
        }
    }

    get isConnected(): boolean {
        return this.#connected;
    }

    get connectionInfo(): { host: string; port: number } | null {
        if (this.#connected) {
            return { host: this.#host, port: this.#port };
        }
        return null;
    }
}

// Usage
const emitter = new TypedEventEmitter();

emitter.on("connect", (host, port) => {
    console.log(`Connected to ${host}:${port}`);
});

emitter.on("message", (data, timestamp) => {
    console.log(`[${timestamp.toISOString()}] ${data}`);
});

emitter.on("disconnect", (reason) => {
    console.log(`Disconnected: ${reason}`);
});

emitter.connect("localhost", 8080).then(() => {
    emitter.send("Hello, World!");
    emitter.disconnect("User requested");
});

console.log(EventEmitter.isEmitter(emitter));
console.log(EventEmitter.getEmitter(emitter) === emitter);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("EventEmitter"),
        "expected output to contain EventEmitter class. output: {output}"
    );
    assert!(
        output.contains("TypedEventEmitter"),
        "expected output to contain TypedEventEmitter class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive private field"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Symbol-keyed Member ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_symbol_es5_iterator() {
    let source = r#"class Range {
    private start: number;
    private end: number;
    private step: number;

    constructor(start: number, end: number, step: number = 1) {
        this.start = start;
        this.end = end;
        this.step = step;
    }

    *[Symbol.iterator](): Iterator<number> {
        for (let i = this.start; i < this.end; i += this.step) {
            yield i;
        }
    }

    toArray(): number[] {
        return [...this];
    }
}

const range = new Range(0, 10, 2);
for (const n of range) {
    console.log(n);
}
console.log(range.toArray());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Range"),
        "expected output to contain Range class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Symbol.iterator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_symbol_es5_async_iterator() {
    let source = r#"class AsyncQueue<T> {
    private items: T[] = [];
    private resolvers: ((value: IteratorResult<T>) => void)[] = [];
    private done: boolean = false;

    push(item: T): void {
        if (this.resolvers.length > 0) {
            const resolve = this.resolvers.shift()!;
            resolve({ value: item, done: false });
        } else {
            this.items.push(item);
        }
    }

    close(): void {
        this.done = true;
        for (const resolve of this.resolvers) {
            resolve({ value: undefined as any, done: true });
        }
        this.resolvers = [];
    }

    async *[Symbol.asyncIterator](): AsyncIterator<T> {
        while (!this.done || this.items.length > 0) {
            if (this.items.length > 0) {
                yield this.items.shift()!;
            } else if (!this.done) {
                yield await new Promise<T>((resolve) => {
                    this.resolvers.push((result) => {
                        if (!result.done) {
                            resolve(result.value);
                        }
                    });
                });
            }
        }
    }
}

const queue = new AsyncQueue<number>();
queue.push(1);
queue.push(2);
queue.push(3);
queue.close();

(async () => {
    for await (const item of queue) {
        console.log(item);
    }
})();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AsyncQueue"),
        "expected output to contain AsyncQueue class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Symbol.asyncIterator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_symbol_es5_computed_symbol_methods() {
    let source = r#"const customMethod = Symbol("customMethod");
const customGetter = Symbol("customGetter");
const customProperty = Symbol("customProperty");

class SymbolClass {
    [customProperty]: string = "default";

    [customMethod](x: number, y: number): number {
        return x + y;
    }

    get [customGetter](): string {
        return `Value: ${this[customProperty]}`;
    }

    set [customGetter](value: string) {
        this[customProperty] = value;
    }
}

const obj = new SymbolClass();
console.log(obj[customMethod](1, 2));
console.log(obj[customGetter]);
obj[customGetter] = "updated";
console.log(obj[customProperty]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("SymbolClass"),
        "expected output to contain SymbolClass. output: {output}"
    );
    assert!(
        output.contains("customMethod"),
        "expected output to contain customMethod. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for computed Symbol methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_symbol_es5_to_string_tag() {
    let source = r#"class CustomCollection<T> {
    private items: T[] = [];

    get [Symbol.toStringTag](): string {
        return "CustomCollection";
    }

    add(item: T): void {
        this.items.push(item);
    }

    get size(): number {
        return this.items.length;
    }
}

class NamedObject {
    private name: string;

    constructor(name: string) {
        this.name = name;
    }

    get [Symbol.toStringTag](): string {
        return `NamedObject(${this.name})`;
    }
}

const collection = new CustomCollection<number>();
collection.add(1);
collection.add(2);
console.log(Object.prototype.toString.call(collection));

const named = new NamedObject("test");
console.log(Object.prototype.toString.call(named));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("CustomCollection"),
        "expected output to contain CustomCollection class. output: {output}"
    );
    assert!(
        output.contains("NamedObject"),
        "expected output to contain NamedObject class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Symbol.toStringTag"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_symbol_es5_has_instance() {
    let source = r#"class CustomType {
    private value: any;

    constructor(value: any) {
        this.value = value;
    }

    static [Symbol.hasInstance](instance: any): boolean {
        return instance !== null &&
               typeof instance === "object" &&
               "value" in instance;
    }
}

class ExtendedCustomType extends CustomType {
    private extra: string;

    constructor(value: any, extra: string) {
        super(value);
        this.extra = extra;
    }

    static [Symbol.hasInstance](instance: any): boolean {
        return super[Symbol.hasInstance](instance) && "extra" in instance;
    }
}

const obj1 = new CustomType(42);
const obj2 = new ExtendedCustomType(42, "hello");
const obj3 = { value: 10 };

console.log(obj1 instanceof CustomType);
console.log(obj2 instanceof CustomType);
console.log(obj3 instanceof CustomType);
console.log(obj2 instanceof ExtendedCustomType);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("CustomType"),
        "expected output to contain CustomType class. output: {output}"
    );
    assert!(
        output.contains("ExtendedCustomType"),
        "expected output to contain ExtendedCustomType class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Symbol.hasInstance"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_symbol_es5_species() {
    let source = r#"class MyArray<T> extends Array<T> {
    static get [Symbol.species](): ArrayConstructor {
        return Array;
    }

    customMethod(): T | undefined {
        return this[0];
    }
}

class SpecialArray<T> extends Array<T> {
    static get [Symbol.species](): typeof SpecialArray {
        return SpecialArray;
    }

    static create<U>(...items: U[]): SpecialArray<U> {
        const arr = new SpecialArray<U>();
        arr.push(...items);
        return arr;
    }

    double(): SpecialArray<T> {
        return this.concat(this) as SpecialArray<T>;
    }
}

const myArr = new MyArray(1, 2, 3);
const mapped = myArr.map(x => x * 2);
console.log(mapped instanceof MyArray);
console.log(mapped instanceof Array);

const special = SpecialArray.create(1, 2, 3);
const doubled = special.double();
console.log(doubled instanceof SpecialArray);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("MyArray"),
        "expected output to contain MyArray class. output: {output}"
    );
    assert!(
        output.contains("SpecialArray"),
        "expected output to contain SpecialArray class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Symbol.species"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_symbol_es5_to_primitive() {
    let source = r#"class Money {
    private amount: number;
    private currency: string;

    constructor(amount: number, currency: string = "USD") {
        this.amount = amount;
        this.currency = currency;
    }

    [Symbol.toPrimitive](hint: string): string | number {
        if (hint === "number") {
            return this.amount;
        }
        if (hint === "string") {
            return `${this.currency} ${this.amount.toFixed(2)}`;
        }
        return this.amount;
    }

    add(other: Money): Money {
        if (this.currency !== other.currency) {
            throw new Error("Currency mismatch");
        }
        return new Money(this.amount + other.amount, this.currency);
    }
}

const price = new Money(99.99);
const tax = new Money(8.50);
console.log(+price);
console.log(`${price}`);
console.log(price + 0);
const total = price.add(tax);
console.log(`${total}`);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Money"),
        "expected output to contain Money class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Symbol.toPrimitive"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_symbol_es5_is_concat_spreadable() {
    let source = r#"class SpreadableCollection<T> {
    private items: T[];

    constructor(...items: T[]) {
        this.items = items;
    }

    get [Symbol.isConcatSpreadable](): boolean {
        return true;
    }

    get length(): number {
        return this.items.length;
    }

    [index: number]: T;

    *[Symbol.iterator](): Iterator<T> {
        yield* this.items;
    }
}

// Set up indexed access
const createSpreadable = <T>(...items: T[]): SpreadableCollection<T> & T[] => {
    const collection = new SpreadableCollection(...items);
    items.forEach((item, i) => {
        (collection as any)[i] = item;
    });
    return collection as SpreadableCollection<T> & T[];
};

const arr1 = [1, 2, 3];
const spreadable = createSpreadable(4, 5, 6);
const combined = arr1.concat(spreadable);
console.log(combined);
console.log(combined.length);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("SpreadableCollection"),
        "expected output to contain SpreadableCollection class. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Symbol.isConcatSpreadable"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_symbol_es5_comprehensive() {
    let source = r#"// Comprehensive Symbol-keyed member test

const customKey = Symbol("customKey");

class SuperCollection<T> {
    protected items: T[] = [];
    protected name: string;

    constructor(name: string) {
        this.name = name;
    }

    // Symbol.toStringTag
    get [Symbol.toStringTag](): string {
        return `SuperCollection<${this.name}>`;
    }

    // Symbol.iterator
    *[Symbol.iterator](): Iterator<T> {
        yield* this.items;
    }

    // Symbol.toPrimitive
    [Symbol.toPrimitive](hint: string): string | number {
        if (hint === "number") {
            return this.items.length;
        }
        return `[${this.name}: ${this.items.length} items]`;
    }

    // Custom symbol method
    [customKey](multiplier: number): number {
        return this.items.length * multiplier;
    }

    // Symbol.hasInstance
    static [Symbol.hasInstance](instance: any): boolean {
        return instance !== null &&
               typeof instance === "object" &&
               "items" in instance &&
               "name" in instance;
    }

    add(...items: T[]): this {
        this.items.push(...items);
        return this;
    }

    get size(): number {
        return this.items.length;
    }
}

class AsyncSuperCollection<T> extends SuperCollection<T> {
    // Symbol.asyncIterator
    async *[Symbol.asyncIterator](): AsyncIterator<T> {
        for (const item of this.items) {
            await new Promise(r => setTimeout(r, 10));
            yield item;
        }
    }

    // Override Symbol.toStringTag
    get [Symbol.toStringTag](): string {
        return `AsyncSuperCollection<${this.name}>`;
    }

    // Symbol.species
    static get [Symbol.species](): typeof AsyncSuperCollection {
        return AsyncSuperCollection;
    }

    async processAll<U>(fn: (item: T) => Promise<U>): Promise<U[]> {
        const results: U[] = [];
        for await (const item of this) {
            results.push(await fn(item));
        }
        return results;
    }
}

// Usage
const collection = new SuperCollection<number>("Numbers");
collection.add(1, 2, 3, 4, 5);

console.log(Object.prototype.toString.call(collection));
console.log([...collection]);
console.log(+collection);
console.log(`${collection}`);
console.log(collection[customKey](10));
console.log({ items: [], name: "test" } instanceof SuperCollection);

const asyncCollection = new AsyncSuperCollection<string>("Strings");
asyncCollection.add("a", "b", "c");

(async () => {
    for await (const item of asyncCollection) {
        console.log(item);
    }

    const results = await asyncCollection.processAll(async (s) => s.toUpperCase());
    console.log(results);
})();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("SuperCollection"),
        "expected output to contain SuperCollection class. output: {output}"
    );
    assert!(
        output.contains("AsyncSuperCollection"),
        "expected output to contain AsyncSuperCollection class. output: {output}"
    );
    assert!(
        output.contains("customKey"),
        "expected output to contain customKey symbol. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive Symbol-keyed members"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Decorator Metadata ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_decorator_metadata_es5_reflect_metadata() {
    let source = r#"// Simulating reflect-metadata patterns
const metadataKey = Symbol("metadata");

function Metadata(key: string, value: any): ClassDecorator & MethodDecorator & PropertyDecorator {
    return function(target: any, propertyKey?: string | symbol, descriptor?: PropertyDescriptor) {
        if (propertyKey === undefined) {
            // Class decorator
            Reflect.defineMetadata(key, value, target);
        } else {
            // Method or property decorator
            Reflect.defineMetadata(key, value, target, propertyKey);
        }
        return descriptor as any;
    };
}

function getMetadata(key: string, target: any, propertyKey?: string | symbol): any {
    if (propertyKey === undefined) {
        return Reflect.getMetadata(key, target);
    }
    return Reflect.getMetadata(key, target, propertyKey);
}

@Metadata("role", "admin")
@Metadata("version", "1.0")
class UserService {
    @Metadata("column", "user_name")
    name: string = "";

    @Metadata("endpoint", "/users")
    @Metadata("method", "GET")
    getUsers(): string[] {
        return [];
    }
}

const service = new UserService();
console.log(getMetadata("role", UserService));
console.log(getMetadata("column", service, "name"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("UserService"),
        "expected output to contain UserService class. output: {output}"
    );
    assert!(
        output.contains("Metadata"),
        "expected output to contain Metadata decorator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for reflect-metadata"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
#[ignore = "INFINITE LOOP - ES5 class transform with multiple parameter decorators on constructor and methods causes unbounded recursion in ClassES5Emitter."]
fn test_source_map_decorator_metadata_es5_parameter_decorators() {
    let source = r#"const paramMetadata = new Map<string, Map<number, any>>();

function Inject(token: string): ParameterDecorator {
    return function(target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const key = propertyKey ? String(propertyKey) : "constructor";
        if (!paramMetadata.has(key)) {
            paramMetadata.set(key, new Map());
        }
        paramMetadata.get(key)!.set(parameterIndex, { token });
    };
}

function Required(): ParameterDecorator {
    return function(target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const key = propertyKey ? String(propertyKey) : "constructor";
        if (!paramMetadata.has(key)) {
            paramMetadata.set(key, new Map());
        }
        const existing = paramMetadata.get(key)!.get(parameterIndex) || {};
        paramMetadata.get(key)!.set(parameterIndex, { ...existing, required: true });
    };
}

function Validate(validator: (val: any) => boolean): ParameterDecorator {
    return function(target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const key = propertyKey ? String(propertyKey) : "constructor";
        if (!paramMetadata.has(key)) {
            paramMetadata.set(key, new Map());
        }
        const existing = paramMetadata.get(key)!.get(parameterIndex) || {};
        paramMetadata.get(key)!.set(parameterIndex, { ...existing, validator });
    };
}

class ApiController {
    constructor(
        @Inject("HttpClient") private http: any,
        @Inject("Logger") @Required() private logger: any
    ) {}

    fetchData(
        @Required() @Validate(v => typeof v === "string") endpoint: string,
        @Inject("Cache") cache?: any
    ): Promise<any> {
        return this.http.get(endpoint);
    }
}

const controller = new ApiController({}, {});
console.log(paramMetadata);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ApiController"),
        "expected output to contain ApiController class. output: {output}"
    );
    assert!(
        output.contains("Inject"),
        "expected output to contain Inject decorator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for parameter decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_metadata_es5_property_descriptors() {
    let source = r#"function Observable(): PropertyDecorator {
    return function(target: Object, propertyKey: string | symbol) {
        let value: any;
        const getter = function(this: any) {
            console.log(`Getting ${String(propertyKey)}`);
            return value;
        };
        const setter = function(this: any, newVal: any) {
            console.log(`Setting ${String(propertyKey)} to ${newVal}`);
            value = newVal;
        };
        Object.defineProperty(target, propertyKey, {
            get: getter,
            set: setter,
            enumerable: true,
            configurable: true
        });
    };
}

function DefaultValue(defaultVal: any): PropertyDecorator {
    return function(target: Object, propertyKey: string | symbol) {
        let value = defaultVal;
        Object.defineProperty(target, propertyKey, {
            get() { return value; },
            set(newVal) { value = newVal; },
            enumerable: true,
            configurable: true
        });
    };
}

function Readonly(): PropertyDecorator {
    return function(target: Object, propertyKey: string | symbol) {
        Object.defineProperty(target, propertyKey, {
            writable: false,
            configurable: false
        });
    };
}

class Config {
    @Observable()
    @DefaultValue("development")
    environment: string;

    @Observable()
    @DefaultValue(3000)
    port: number;

    @Readonly()
    version: string = "1.0.0";
}

const config = new Config();
console.log(config.environment);
config.port = 8080;
console.log(config.port);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Config"),
        "expected output to contain Config class. output: {output}"
    );
    assert!(
        output.contains("Observable"),
        "expected output to contain Observable decorator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for property descriptors"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_metadata_es5_method_descriptors() {
    let source = r#"function Log(prefix: string): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            console.log(`${prefix} Calling ${String(propertyKey)} with`, args);
            const result = original.apply(this, args);
            console.log(`${prefix} Result:`, result);
            return result;
        };
        return descriptor;
    };
}

function Memoize(): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        const cache = new Map<string, any>();
        descriptor.value = function(...args: any[]) {
            const key = JSON.stringify(args);
            if (cache.has(key)) {
                return cache.get(key);
            }
            const result = original.apply(this, args);
            cache.set(key, result);
            return result;
        };
        return descriptor;
    };
}

function Throttle(ms: number): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        let lastCall = 0;
        descriptor.value = function(...args: any[]) {
            const now = Date.now();
            if (now - lastCall >= ms) {
                lastCall = now;
                return original.apply(this, args);
            }
        };
        return descriptor;
    };
}

class Calculator {
    @Log("[CALC]")
    @Memoize()
    fibonacci(n: number): number {
        if (n <= 1) return n;
        return this.fibonacci(n - 1) + this.fibonacci(n - 2);
    }

    @Log("[CALC]")
    @Throttle(1000)
    expensiveOperation(x: number): number {
        return x * x;
    }
}

const calc = new Calculator();
console.log(calc.fibonacci(10));
console.log(calc.expensiveOperation(5));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Calculator"),
        "expected output to contain Calculator class. output: {output}"
    );
    assert!(
        output.contains("Memoize"),
        "expected output to contain Memoize decorator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for method descriptors"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_metadata_es5_accessor_descriptors() {
    let source = r#"function Enumerable(value: boolean): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
        return descriptor;
    };
}

function Configurable(value: boolean): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        descriptor.configurable = value;
        return descriptor;
    };
}

function ValidateSet(validator: (val: any) => boolean): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        const originalSet = descriptor.set;
        if (originalSet) {
            descriptor.set = function(value: any) {
                if (!validator(value)) {
                    throw new Error(`Invalid value for ${String(propertyKey)}`);
                }
                originalSet.call(this, value);
            };
        }
        return descriptor;
    };
}

class Person {
    private _name: string = "";
    private _age: number = 0;

    @Enumerable(true)
    @Configurable(false)
    get name(): string {
        return this._name;
    }

    @ValidateSet(v => typeof v === "string" && v.length > 0)
    set name(value: string) {
        this._name = value;
    }

    @Enumerable(true)
    get age(): number {
        return this._age;
    }

    @ValidateSet(v => typeof v === "number" && v >= 0 && v <= 150)
    set age(value: number) {
        this._age = value;
    }
}

const person = new Person();
person.name = "John";
person.age = 30;
console.log(person.name, person.age);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Person"),
        "expected output to contain Person class. output: {output}"
    );
    assert!(
        output.contains("ValidateSet"),
        "expected output to contain ValidateSet decorator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for accessor descriptors"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_metadata_es5_class_constructor() {
    let source = r#"interface ClassConstructor<T = any> {
    new (...args: any[]): T;
}

function Injectable(): ClassDecorator {
    return function<T extends ClassConstructor>(target: T) {
        // Mark class as injectable
        (target as any).__injectable__ = true;
        return target;
    };
}

function Singleton(): ClassDecorator {
    return function<T extends ClassConstructor>(target: T) {
        let instance: any = null;
        const original = target;
        const newConstructor: any = function(...args: any[]) {
            if (instance === null) {
                instance = new original(...args);
            }
            return instance;
        };
        newConstructor.prototype = original.prototype;
        Object.setPrototypeOf(newConstructor, original);
        return newConstructor;
    };
}

function Registry(name: string): ClassDecorator {
    return function<T extends ClassConstructor>(target: T) {
        const registry = (globalThis as any).__registry__ || new Map();
        registry.set(name, target);
        (globalThis as any).__registry__ = registry;
        return target;
    };
}

@Injectable()
@Singleton()
@Registry("DatabaseService")
class DatabaseService {
    private connectionString: string;

    constructor(connectionString: string = "default") {
        this.connectionString = connectionString;
        console.log("DatabaseService created");
    }

    query(sql: string): any[] {
        return [];
    }
}

@Injectable()
@Registry("UserRepository")
class UserRepository {
    constructor(private db: DatabaseService) {}

    findAll(): any[] {
        return this.db.query("SELECT * FROM users");
    }
}

const db1 = new DatabaseService("conn1");
const db2 = new DatabaseService("conn2");
console.log(db1 === db2);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DatabaseService"),
        "expected output to contain DatabaseService class. output: {output}"
    );
    assert!(
        output.contains("Singleton"),
        "expected output to contain Singleton decorator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class constructor metadata"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_metadata_es5_design_type() {
    let source = r#"// Simulating design:type, design:paramtypes, design:returntype metadata
const typeMetadata = new WeakMap<Object, Map<string, any>>();

function Type(type: any): PropertyDecorator & ParameterDecorator {
    return function(target: Object, propertyKey?: string | symbol, parameterIndex?: number) {
        if (propertyKey !== undefined) {
            if (!typeMetadata.has(target)) {
                typeMetadata.set(target, new Map());
            }
            typeMetadata.get(target)!.set(String(propertyKey), { type });
        }
    };
}

function ReturnType(type: any): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        if (!typeMetadata.has(target)) {
            typeMetadata.set(target, new Map());
        }
        const existing = typeMetadata.get(target)!.get(String(propertyKey)) || {};
        typeMetadata.get(target)!.set(String(propertyKey), { ...existing, returnType: type });
        return descriptor;
    };
}

function ParamTypes(...types: any[]): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        if (!typeMetadata.has(target)) {
            typeMetadata.set(target, new Map());
        }
        const existing = typeMetadata.get(target)!.get(String(propertyKey)) || {};
        typeMetadata.get(target)!.set(String(propertyKey), { ...existing, paramTypes: types });
        return descriptor;
    };
}

class Entity {
    @Type(String)
    id: string = "";

    @Type(String)
    name: string = "";

    @Type(Number)
    age: number = 0;

    @Type(Boolean)
    active: boolean = true;

    @ReturnType(String)
    @ParamTypes(String, Number)
    format(template: string, precision: number): string {
        return `${this.name} (${this.age})`;
    }
}

const entity = new Entity();
console.log(typeMetadata.get(entity));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Entity"),
        "expected output to contain Entity class. output: {output}"
    );
    assert!(
        output.contains("ReturnType"),
        "expected output to contain ReturnType decorator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for design type metadata"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_metadata_es5_comprehensive() {
    let source = r#"// Comprehensive decorator metadata test combining all patterns

// Type metadata storage
const classMetadata = new WeakMap<Function, Map<string, any>>();
const propertyMetadata = new WeakMap<Object, Map<string | symbol, any>>();
const methodMetadata = new WeakMap<Object, Map<string | symbol, any>>();
const parameterMetadata = new WeakMap<Object, Map<string | symbol, Map<number, any>>>();

// Class decorators
function Controller(path: string): ClassDecorator {
    return function(target: Function) {
        if (!classMetadata.has(target)) {
            classMetadata.set(target, new Map());
        }
        classMetadata.get(target)!.set("path", path);
        classMetadata.get(target)!.set("type", "controller");
    };
}

function Service(): ClassDecorator {
    return function(target: Function) {
        if (!classMetadata.has(target)) {
            classMetadata.set(target, new Map());
        }
        classMetadata.get(target)!.set("type", "service");
        classMetadata.get(target)!.set("injectable", true);
    };
}

// Property decorators
function Column(options?: { type?: string; nullable?: boolean }): PropertyDecorator {
    return function(target: Object, propertyKey: string | symbol) {
        if (!propertyMetadata.has(target)) {
            propertyMetadata.set(target, new Map());
        }
        propertyMetadata.get(target)!.set(propertyKey, { column: true, ...options });
    };
}

// Method decorators
function Get(path: string): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        if (!methodMetadata.has(target)) {
            methodMetadata.set(target, new Map());
        }
        methodMetadata.get(target)!.set(propertyKey, { method: "GET", path });
        return descriptor;
    };
}

function Post(path: string): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        if (!methodMetadata.has(target)) {
            methodMetadata.set(target, new Map());
        }
        methodMetadata.get(target)!.set(propertyKey, { method: "POST", path });
        return descriptor;
    };
}

// Parameter decorators
function Body(): ParameterDecorator {
    return function(target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const key = propertyKey || "constructor";
        if (!parameterMetadata.has(target)) {
            parameterMetadata.set(target, new Map());
        }
        if (!parameterMetadata.get(target)!.has(key)) {
            parameterMetadata.get(target)!.set(key, new Map());
        }
        parameterMetadata.get(target)!.get(key)!.set(parameterIndex, { source: "body" });
    };
}

function Query(name: string): ParameterDecorator {
    return function(target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const key = propertyKey || "constructor";
        if (!parameterMetadata.has(target)) {
            parameterMetadata.set(target, new Map());
        }
        if (!parameterMetadata.get(target)!.has(key)) {
            parameterMetadata.get(target)!.set(key, new Map());
        }
        parameterMetadata.get(target)!.get(key)!.set(parameterIndex, { source: "query", name });
    };
}

// Accessor decorator
function Cached(): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        if (descriptor.get) {
            const originalGet = descriptor.get;
            let cached: any;
            let hasCached = false;
            descriptor.get = function() {
                if (!hasCached) {
                    cached = originalGet.call(this);
                    hasCached = true;
                }
                return cached;
            };
        }
        return descriptor;
    };
}

// Entity class
@Service()
class UserEntity {
    @Column({ type: "uuid" })
    id: string = "";

    @Column({ type: "varchar", nullable: false })
    name: string = "";

    @Column({ type: "varchar", nullable: true })
    email: string = "";

    @Cached()
    get displayName(): string {
        return `${this.name} <${this.email}>`;
    }
}

// Controller class
@Controller("/users")
class UserController {
    constructor(private userService: UserEntity) {}

    @Get("/")
    async getAll(@Query("limit") limit: number): Promise<UserEntity[]> {
        return [];
    }

    @Get("/:id")
    async getOne(@Query("id") id: string): Promise<UserEntity | null> {
        return null;
    }

    @Post("/")
    async create(@Body() data: Partial<UserEntity>): Promise<UserEntity> {
        return new UserEntity();
    }
}

// Usage
const controller = new UserController(new UserEntity());
console.log(classMetadata.get(UserController));
console.log(classMetadata.get(UserEntity));
console.log(methodMetadata.get(UserController.prototype));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("UserController"),
        "expected output to contain UserController class. output: {output}"
    );
    assert!(
        output.contains("UserEntity"),
        "expected output to contain UserEntity class. output: {output}"
    );
    assert!(
        output.contains("Controller"),
        "expected output to contain Controller decorator. output: {output}"
    );
    assert!(
        output.contains("Service"),
        "expected output to contain Service decorator. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive decorator metadata"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Module Bundling ES5 Source Map Tests
// =============================================================================

#[test]
fn test_source_map_module_es5_commonjs_require() {
    let source = r#"// CommonJS require patterns
import { readFile, writeFile } from 'fs';
import * as path from 'path';
import http from 'http';

const express = require('express');
const { Router } = require('express');
const lodash = require('lodash');

export function loadConfig(configPath: string): any {
    const fullPath = path.resolve(configPath);
    const content = readFile(fullPath, 'utf-8');
    return JSON.parse(content as any);
}

export function saveConfig(configPath: string, config: any): void {
    const fullPath = path.resolve(configPath);
    writeFile(fullPath, JSON.stringify(config, null, 2));
}

export class Server {
    private app: any;
    private router: any;

    constructor() {
        this.app = express();
        this.router = Router();
    }

    start(port: number): void {
        this.app.listen(port, () => {
            console.log(`Server running on port ${port}`);
        });
    }
}

const server = new Server();
server.start(3000);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Server"),
        "expected output to contain Server class. output: {output}"
    );
    assert!(
        output.contains("loadConfig"),
        "expected output to contain loadConfig function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for CommonJS require"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_module_es5_dynamic_import() {
    let source = r#"// Dynamic import patterns
async function loadModule(moduleName: string): Promise<any> {
    const module = await import(moduleName);
    return module.default || module;
}

async function loadMultipleModules(names: string[]): Promise<any[]> {
    const modules = await Promise.all(
        names.map(name => import(name))
    );
    return modules.map(m => m.default || m);
}

class PluginLoader {
    private plugins: Map<string, any> = new Map();

    async load(pluginPath: string): Promise<void> {
        const plugin = await import(pluginPath);
        const name = plugin.name || pluginPath;
        this.plugins.set(name, plugin.default || plugin);
    }

    async loadAll(pluginPaths: string[]): Promise<void> {
        await Promise.all(pluginPaths.map(p => this.load(p)));
    }

    get(name: string): any {
        return this.plugins.get(name);
    }
}

// Lazy loading with fallback
async function lazyLoad<T>(
    loader: () => Promise<{ default: T }>,
    fallback: T
): Promise<T> {
    try {
        const module = await loader();
        return module.default;
    } catch {
        return fallback;
    }
}

const loader = new PluginLoader();
loader.loadAll(['./plugin1', './plugin2']).then(() => {
    console.log('Plugins loaded');
});"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("PluginLoader"),
        "expected output to contain PluginLoader class. output: {output}"
    );
    assert!(
        output.contains("loadModule"),
        "expected output to contain loadModule function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for dynamic import"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_module_es5_reexports() {
    let source = r#"// Re-export patterns
export { foo, bar } from './moduleA';
export { default as baz } from './moduleB';
export * from './moduleC';
export * as utils from './utils';
export type { SomeType } from './types';

// Named re-exports with renaming
export { original as renamed } from './moduleD';
export { ClassA as ExportedClass, functionB as exportedFunction } from './moduleE';

// Re-export with local use
import { helper } from './helpers';
export { helper };

function useHelper(): string {
    return helper('test');
}

// Mixed exports
export const localConst = 'local';
export function localFunction(): void {}
export class LocalClass {}

export { useHelper };"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("LocalClass"),
        "expected output to contain LocalClass. output: {output}"
    );
    assert!(
        output.contains("useHelper"),
        "expected output to contain useHelper function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for re-exports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_module_es5_barrel_exports() {
    let source = r#"// Barrel export pattern (index.ts style)

// Components
export { Button } from './components/Button';
export { Input } from './components/Input';
export { Select } from './components/Select';
export { Modal } from './components/Modal';

// Hooks
export { useState } from './hooks/useState';
export { useEffect } from './hooks/useEffect';
export { useCallback } from './hooks/useCallback';

// Utils
export * from './utils/string';
export * from './utils/number';
export * from './utils/date';

// Types
export type { ButtonProps } from './components/Button';
export type { InputProps } from './components/Input';
export type { Config, Options } from './types';

// Default export aggregation
import DefaultComponent from './DefaultComponent';
export default DefaultComponent;

// Re-export with namespace
export * as components from './components';
export * as hooks from './hooks';
export * as utils from './utils';

// Constants
export const VERSION = '1.0.0';
export const API_URL = 'https://api.example.com';"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("VERSION"),
        "expected output to contain VERSION constant. output: {output}"
    );
    assert!(
        output.contains("API_URL"),
        "expected output to contain API_URL constant. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for barrel exports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_module_es5_circular_imports() {
    let source = r#"// Circular import pattern handling
// This simulates moduleA that imports from moduleB which imports from moduleA

import type { BType } from './moduleB';

export interface AType {
    name: string;
    ref?: BType;
}

export class ClassA {
    private data: AType;
    private linked?: import('./moduleB').ClassB;

    constructor(name: string) {
        this.data = { name };
    }

    async link(): Promise<void> {
        const moduleB = await import('./moduleB');
        this.linked = new moduleB.ClassB(this);
    }

    getData(): AType {
        return this.data;
    }

    setRef(ref: BType): void {
        this.data.ref = ref;
    }
}

export function createA(name: string): ClassA {
    return new ClassA(name);
}

// Lazy circular reference resolution
let _classB: typeof import('./moduleB').ClassB | null = null;

export async function getClassB(): Promise<typeof import('./moduleB').ClassB> {
    if (!_classB) {
        const mod = await import('./moduleB');
        _classB = mod.ClassB;
    }
    return _classB;
}

const instance = new ClassA('test');
instance.link().then(() => console.log('Linked'));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ClassA"),
        "expected output to contain ClassA class. output: {output}"
    );
    assert!(
        output.contains("createA"),
        "expected output to contain createA function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for circular imports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_module_es5_conditional_imports() {
    let source = r#"// Conditional import patterns
declare const process: { env: { NODE_ENV: string; PLATFORM: string } };

// Environment-based conditional import
const getLogger = async () => {
    if (process.env.NODE_ENV === 'production') {
        return import('./prodLogger');
    } else {
        return import('./devLogger');
    }
};

// Platform-based conditional import
const getPlatformModule = async () => {
    switch (process.env.PLATFORM) {
        case 'web':
            return import('./platform/web');
        case 'node':
            return import('./platform/node');
        case 'electron':
            return import('./platform/electron');
        default:
            return import('./platform/default');
    }
};

// Feature flag conditional import
interface FeatureFlags {
    newUI: boolean;
    betaFeatures: boolean;
}

async function loadFeatures(flags: FeatureFlags): Promise<any[]> {
    const features: Promise<any>[] = [];

    if (flags.newUI) {
        features.push(import('./features/newUI'));
    }

    if (flags.betaFeatures) {
        features.push(import('./features/beta'));
    }

    return Promise.all(features);
}

// Polyfill conditional import
async function loadPolyfills(): Promise<void> {
    if (typeof globalThis.fetch === 'undefined') {
        await import('whatwg-fetch');
    }

    if (typeof globalThis.Promise === 'undefined') {
        await import('es6-promise');
    }

    if (!Array.prototype.includes) {
        await import('array-includes');
    }
}

// Usage
getLogger().then(logger => logger.default.info('App started'));
loadPolyfills().then(() => console.log('Polyfills loaded'));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getLogger"),
        "expected output to contain getLogger function. output: {output}"
    );
    assert!(
        output.contains("loadPolyfills"),
        "expected output to contain loadPolyfills function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for conditional imports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_module_es5_namespace_imports() {
    let source = r#"// Namespace import patterns
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as _ from 'lodash';
import * as utils from './utils';

// Using namespace imports
const element = React.createElement('div', { className: 'container' },
    React.createElement('h1', null, 'Hello'),
    React.createElement('p', null, 'World')
);

// Lodash namespace usage
const data = [1, 2, 3, 4, 5];
const doubled = _.map(data, (n: number) => n * 2);
const sum = _.reduce(doubled, (acc: number, n: number) => acc + n, 0);
const unique = _.uniq([1, 1, 2, 2, 3]);

// Custom utils namespace
const formatted = utils.formatDate(new Date());
const validated = utils.validateEmail('test@example.com');
const parsed = utils.parseJSON('{"key": "value"}');

// Re-export namespace
export { React, ReactDOM, _ as lodash, utils };

// Namespace with type usage
type ReactElement = React.ReactElement;
type LodashArray = _.LoDashStatic;

export function render(el: ReactElement, container: Element): void {
    ReactDOM.render(el, container);
}

console.log(sum, unique, formatted);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("render"),
        "expected output to contain render function. output: {output}"
    );
    assert!(
        output.contains("doubled"),
        "expected output to contain doubled variable. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for namespace imports"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_module_es5_comprehensive() {
    let source = r#"// Comprehensive module bundling test combining all patterns

// Static imports
import { EventEmitter } from 'events';
import * as fs from 'fs';
import path from 'path';

// CommonJS require
const express = require('express');
const bodyParser = require('body-parser');

// Type-only imports
import type { ServerOptions, RequestHandler } from 'express';

// Re-exports
export { EventEmitter } from 'events';
export * as fsUtils from 'fs';
export type { ServerOptions };

// Dynamic import loader
class ModuleRegistry {
    private modules: Map<string, any> = new Map();
    private loading: Map<string, Promise<any>> = new Map();

    async load(name: string, path: string): Promise<any> {
        if (this.modules.has(name)) {
            return this.modules.get(name);
        }

        if (!this.loading.has(name)) {
            this.loading.set(name, import(path).then(mod => {
                const module = mod.default || mod;
                this.modules.set(name, module);
                this.loading.delete(name);
                return module;
            }));
        }

        return this.loading.get(name);
    }

    get(name: string): any {
        return this.modules.get(name);
    }

    has(name: string): boolean {
        return this.modules.has(name);
    }
}

// Conditional module loading
declare const process: { env: Record<string, string> };

async function loadEnvironmentModules(): Promise<void> {
    const env = process.env.NODE_ENV || 'development';

    // Environment-specific config
    const configModule = await import(`./config/${env}`);
    const config = configModule.default;

    // Conditional feature modules
    if (config.features?.analytics) {
        await import('./modules/analytics');
    }

    if (config.features?.monitoring) {
        await import('./modules/monitoring');
    }

    // Platform-specific modules
    const platform = process.env.PLATFORM || 'node';
    await import(`./platform/${platform}`);
}

// Barrel export simulation
export { Button, Input, Form } from './components';
export { useForm, useValidation } from './hooks';
export * from './utils';

// Main application
export class Application extends EventEmitter {
    private registry: ModuleRegistry;
    private server: any;

    constructor() {
        super();
        this.registry = new ModuleRegistry();
        this.server = express();
        this.server.use(bodyParser.json());
    }

    async initialize(): Promise<void> {
        await loadEnvironmentModules();

        // Load plugins dynamically
        const pluginPaths = ['./plugins/auth', './plugins/api', './plugins/static'];
        await Promise.all(pluginPaths.map(p => this.registry.load(path.basename(p), p)));

        this.emit('initialized');
    }

    async loadPlugin(name: string, pluginPath: string): Promise<void> {
        const plugin = await this.registry.load(name, pluginPath);
        if (plugin.setup) {
            await plugin.setup(this.server);
        }
        this.emit('plugin:loaded', name);
    }

    start(port: number): void {
        this.server.listen(port, () => {
            this.emit('started', port);
            console.log(`Server running on port ${port}`);
        });
    }
}

// Factory export
export function createApp(): Application {
    return new Application();
}

// Default export
export default Application;

// Usage
const app = createApp();
app.initialize().then(() => app.start(3000));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Application"),
        "expected output to contain Application class. output: {output}"
    );
    assert!(
        output.contains("ModuleRegistry"),
        "expected output to contain ModuleRegistry class. output: {output}"
    );
    assert!(
        output.contains("createApp"),
        "expected output to contain createApp function. output: {output}"
    );
    assert!(
        output.contains("loadEnvironmentModules"),
        "expected output to contain loadEnvironmentModules function. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive module bundling"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// JSX ES5 Transform Source Map Tests
// =============================================================================
// Tests for JSX compilation with ES5 target - JSX elements should transform
// to React.createElement calls while preserving source map accuracy.

#[test]
fn test_source_map_jsx_es5_basic_element() {
    // Test basic JSX element transformation to React.createElement
    let source = r#"const element = <div className="container">Hello World</div>;"#;

    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // JSX should be in output (either preserved or transformed)
    assert!(
        output.contains("div") || output.contains("createElement"),
        "expected JSX element in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for JSX element"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_jsx_es5_fragment() {
    // Test JSX fragment transformation
    let source = r#"const fragment = <>
    <span>First</span>
    <span>Second</span>
</>;"#;

    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    // Fragment should be in output
    assert!(
        output.contains("span") || output.contains("Fragment"),
        "expected JSX fragment content in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for JSX fragment"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_jsx_es5_spread_attributes() {
    // Test JSX spread attributes transformation
    let source = r#"const props = { id: "main", className: "container" };
const element = <div {...props} data-testid="test">Content</div>;"#;

    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("props"),
        "expected props reference in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for JSX spread attributes"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_jsx_es5_self_closing() {
    // Test self-closing JSX elements
    let source = r#"const input = <input type="text" placeholder="Enter name" />;
const img = <img src="photo.jpg" alt="Photo" />;
const br = <br />;"#;

    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("input") && output.contains("img"),
        "expected self-closing elements in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for self-closing JSX"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_jsx_es5_nested_elements() {
    // Test nested JSX elements transformation
    let source = r#"const nested = (
    <div className="outer">
        <header>
            <h1>Title</h1>
            <nav>
                <ul>
                    <li>Home</li>
                    <li>About</li>
                </ul>
            </nav>
        </header>
        <main>
            <section>Content</section>
        </main>
    </div>
);"#;

    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("header") && output.contains("nav") && output.contains("main"),
        "expected nested elements in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested JSX"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_jsx_es5_expressions() {
    // Test JSX with embedded expressions
    let source = r#"const name = "World";
const count = 42;
const items = ["a", "b", "c"];
const element = (
    <div>
        <h1>Hello, {name}!</h1>
        <p>Count: {count}</p>
        <ul>{items.map(function(item) { return <li key={item}>{item}</li>; })}</ul>
        <span>{count > 10 ? "Many" : "Few"}</span>
    </div>
);"#;

    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("name") && output.contains("count") && output.contains("items"),
        "expected expression references in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for JSX expressions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_jsx_es5_component_props() {
    // Test JSX component with various prop patterns
    let source = r#"function Button(props: { onClick: () => void; disabled?: boolean; children: any }) {
    return <button onClick={props.onClick} disabled={props.disabled}>{props.children}</button>;
}

function Icon(props: { name: string; size?: number }) {
    return <span className={"icon-" + props.name} style={{ fontSize: props.size || 16 }} />;
}

const app = (
    <div>
        <Button onClick={function() { console.log("clicked"); }} disabled={false}>
            <Icon name="star" size={24} />
            Click Me
        </Button>
    </div>
);"#;

    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Button") && output.contains("Icon"),
        "expected component names in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for JSX components"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_jsx_es5_event_handlers() {
    // Test JSX event handlers with various patterns
    let source = r#"var state = { count: 0 };

function handleClick() {
    state.count++;
}

function handleInput(e: any) {
    console.log(e.target.value);
}

const form = (
    <form onSubmit={function(e) { e.preventDefault(); }}>
        <input type="text" onChange={handleInput} onBlur={function() { console.log("blur"); }} />
        <button type="button" onClick={handleClick}>Increment</button>
        <button type="submit">Submit</button>
    </form>
);"#;

    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("handleClick") && output.contains("handleInput"),
        "expected event handler references in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for JSX event handlers"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_jsx_es5_conditional_rendering() {
    // Test JSX conditional rendering patterns
    let source = r#"var isLoggedIn = true;
var hasPermission = false;
var items: string[] = [];

const element = (
    <div>
        {isLoggedIn ? <span>Welcome</span> : <span>Please login</span>}
        {hasPermission && <button>Admin</button>}
        {items.length > 0 ? (
            <ul>
                {items.map(function(item) { return <li>{item}</li>; })}
            </ul>
        ) : (
            <p>No items</p>
        )}
    </div>
);"#;

    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("isLoggedIn") && output.contains("hasPermission"),
        "expected conditional variables in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for conditional JSX"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_jsx_es5_comprehensive() {
    // Comprehensive JSX ES5 transform test
    let source = r#"// Component definitions
function Header(props: { title: string; subtitle?: string }) {
    return (
        <header className="header">
            <h1>{props.title}</h1>
            {props.subtitle && <h2>{props.subtitle}</h2>}
        </header>
    );
}

function Card(props: { children: any; className?: string }) {
    var baseClass = "card";
    return <div className={baseClass + " " + (props.className || "")}>{props.children}</div>;
}

function List(props: { items: string[]; onSelect: (item: string) => void }) {
    return (
        <ul className="list">
            {props.items.map(function(item, index) {
                return (
                    <li key={index} onClick={function() { props.onSelect(item); }}>
                        {item}
                    </li>
                );
            })}
        </ul>
    );
}

// Main app
var appState = {
    title: "My App",
    items: ["Item 1", "Item 2", "Item 3"],
    selectedItem: null as string | null
};

function handleSelect(item: string) {
    appState.selectedItem = item;
    console.log("Selected:", item);
}

const App = (
    <div className="app">
        <Header title={appState.title} subtitle="Welcome" />
        <main>
            <Card className="content">
                <List items={appState.items} onSelect={handleSelect} />
                {appState.selectedItem && (
                    <p>Selected: {appState.selectedItem}</p>
                )}
            </Card>
        </main>
        <footer>
            <p>&copy; 2024</p>
        </footer>
    </div>
);"#;

    let mut parser = ThinParserState::new("test.tsx".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.tsx");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Header"),
        "expected Header component in output. output: {output}"
    );
    assert!(
        output.contains("Card"),
        "expected Card component in output. output: {output}"
    );
    assert!(
        output.contains("List"),
        "expected List component in output. output: {output}"
    );
    assert!(
        output.contains("handleSelect"),
        "expected handleSelect function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive JSX"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Class Accessor ES5 Transform Source Map Tests
// =============================================================================
// Tests for class accessor (getter/setter) compilation with ES5 target.
// Accessors should transform to Object.defineProperty calls while preserving
// source map accuracy.

#[test]
fn test_source_map_accessor_es5_basic_getter_setter() {
    // Test basic getter/setter transformation
    let source = r#"class Person {
    private _name: string = "";

    get name(): string {
        return this._name;
    }

    set name(value: string) {
        this._name = value;
    }
}

const person = new Person();
person.name = "Alice";
console.log(person.name);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Person"),
        "expected Person class in output. output: {output}"
    );
    assert!(
        output.contains("name"),
        "expected name accessor in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for getter/setter"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_accessor_es5_static_accessors() {
    // Test static getter/setter transformation
    let source = r#"class Counter {
    private static _count: number = 0;

    static get count(): number {
        return Counter._count;
    }

    static set count(value: number) {
        Counter._count = value;
    }

    static increment(): void {
        Counter.count++;
    }
}

Counter.count = 10;
Counter.increment();
console.log(Counter.count);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter"),
        "expected Counter class in output. output: {output}"
    );
    assert!(
        output.contains("count"),
        "expected count accessor in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static accessors"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_accessor_es5_computed_names() {
    // Test computed accessor names transformation
    let source = r#"const propName = "dynamicProp";
const symbolKey = Symbol("mySymbol");

class Dynamic {
    private _values: { [key: string]: any } = {};

    get [propName](): any {
        return this._values[propName];
    }

    set [propName](value: any) {
        this._values[propName] = value;
    }
}

const obj = new Dynamic();
obj[propName] = "test";"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Dynamic"),
        "expected Dynamic class in output. output: {output}"
    );
    assert!(
        output.contains("propName"),
        "expected propName reference in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for computed accessor names"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_accessor_es5_decorator() {
    // Test accessor with decorators transformation
    let source = r#"function readonly(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.writable = false;
    return descriptor;
}

function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.get;
    descriptor.get = function() {
        console.log("Getting " + propertyKey);
        return original?.call(this);
    };
    return descriptor;
}

class Config {
    private _value: string = "default";

    @log
    @readonly
    get value(): string {
        return this._value;
    }
}

const config = new Config();
console.log(config.value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Config"),
        "expected Config class in output. output: {output}"
    );
    assert!(
        output.contains("readonly") || output.contains("log"),
        "expected decorator functions in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for accessor decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_accessor_es5_getter_only() {
    // Test getter-only accessor transformation
    let source = r#"class Rectangle {
    constructor(private width: number, private height: number) {}

    get area(): number {
        return this.width * this.height;
    }

    get perimeter(): number {
        return 2 * (this.width + this.height);
    }

    get diagonal(): number {
        return Math.sqrt(this.width * this.width + this.height * this.height);
    }
}

const rect = new Rectangle(3, 4);
console.log(rect.area, rect.perimeter, rect.diagonal);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Rectangle"),
        "expected Rectangle class in output. output: {output}"
    );
    assert!(
        output.contains("area") && output.contains("perimeter"),
        "expected getter names in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for getter-only accessors"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_accessor_es5_setter_only() {
    // Test setter-only accessor transformation
    let source = r#"class Logger {
    private logs: string[] = [];

    set message(value: string) {
        this.logs.push("[INFO] " + value);
    }

    set warning(value: string) {
        this.logs.push("[WARN] " + value);
    }

    set error(value: string) {
        this.logs.push("[ERROR] " + value);
    }

    getLogs(): string[] {
        return this.logs;
    }
}

const logger = new Logger();
logger.message = "Started";
logger.warning = "Low memory";
logger.error = "Failed";"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Logger"),
        "expected Logger class in output. output: {output}"
    );
    assert!(
        output.contains("message") && output.contains("warning"),
        "expected setter names in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for setter-only accessors"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_accessor_es5_inherited() {
    // Test inherited accessor transformation
    let source = r#"class Base {
    protected _value: number = 0;

    get value(): number {
        return this._value;
    }

    set value(v: number) {
        this._value = v;
    }
}

class Derived extends Base {
    get value(): number {
        return super.value * 2;
    }

    set value(v: number) {
        super.value = v / 2;
    }

    get doubleValue(): number {
        return this._value * 2;
    }
}

const derived = new Derived();
derived.value = 10;
console.log(derived.value, derived.doubleValue);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Base") && output.contains("Derived"),
        "expected Base and Derived classes in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for inherited accessors"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_accessor_es5_validation() {
    // Test accessor with validation logic
    let source = r#"class ValidatedInput {
    private _email: string = "";
    private _age: number = 0;
    private _name: string = "";

    get email(): string {
        return this._email;
    }

    set email(value: string) {
        if (!value.includes("@")) {
            throw new Error("Invalid email");
        }
        this._email = value;
    }

    get age(): number {
        return this._age;
    }

    set age(value: number) {
        if (value < 0 || value > 150) {
            throw new Error("Invalid age");
        }
        this._age = value;
    }

    get name(): string {
        return this._name;
    }

    set name(value: string) {
        if (value.length < 2) {
            throw new Error("Name too short");
        }
        this._name = value.trim();
    }
}

const input = new ValidatedInput();
input.email = "test@example.com";
input.age = 25;
input.name = "Alice";"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ValidatedInput"),
        "expected ValidatedInput class in output. output: {output}"
    );
    assert!(
        output.contains("email") && output.contains("age") && output.contains("name"),
        "expected accessor names in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for validation accessors"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_accessor_es5_lazy_initialization() {
    // Test lazy initialization accessors
    let source = r#"class LazyLoader {
    private _data: string[] | null = null;
    private _config: object | null = null;

    get data(): string[] {
        if (this._data === null) {
            this._data = this.loadData();
        }
        return this._data;
    }

    get config(): object {
        if (this._config === null) {
            this._config = this.loadConfig();
        }
        return this._config;
    }

    private loadData(): string[] {
        return ["item1", "item2", "item3"];
    }

    private loadConfig(): object {
        return { setting: true };
    }
}

const loader = new LazyLoader();
console.log(loader.data);
console.log(loader.config);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("LazyLoader"),
        "expected LazyLoader class in output. output: {output}"
    );
    assert!(
        output.contains("data") && output.contains("config"),
        "expected accessor names in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for lazy initialization accessors"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_accessor_es5_comprehensive() {
    // Comprehensive accessor patterns test
    let source = r#"// Decorator for logging
function track(target: any, key: string, descriptor: PropertyDescriptor) {
    const original = descriptor.get;
    descriptor.get = function() {
        console.log("Accessed: " + key);
        return original?.call(this);
    };
    return descriptor;
}

// Base class with accessors
class Observable {
    private _listeners: Function[] = [];

    protected notify(prop: string, value: any): void {
        this._listeners.forEach(function(fn) { fn(prop, value); });
    }

    subscribe(fn: Function): void {
        this._listeners.push(fn);
    }
}

// Derived class with multiple accessor patterns
class Person extends Observable {
    private _firstName: string = "";
    private _lastName: string = "";
    private _age: number = 0;
    private static _count: number = 0;

    constructor() {
        super();
        Person._count++;
    }

    // Basic getter/setter
    get firstName(): string {
        return this._firstName;
    }

    set firstName(value: string) {
        this._firstName = value;
        this.notify("firstName", value);
    }

    // Getter/setter with validation
    get age(): number {
        return this._age;
    }

    set age(value: number) {
        if (value < 0) throw new Error("Age cannot be negative");
        this._age = value;
        this.notify("age", value);
    }

    // Computed getter
    @track
    get fullName(): string {
        return this._firstName + " " + this._lastName;
    }

    set fullName(value: string) {
        var parts = value.split(" ");
        this._firstName = parts[0] || "";
        this._lastName = parts[1] || "";
    }

    // Static accessor
    static get count(): number {
        return Person._count;
    }

    static set count(value: number) {
        Person._count = value;
    }
}

// Usage
const person = new Person();
person.firstName = "John";
person.age = 30;
console.log(person.fullName);
console.log(Person.count);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Observable"),
        "expected Observable class in output. output: {output}"
    );
    assert!(
        output.contains("Person"),
        "expected Person class in output. output: {output}"
    );
    assert!(
        output.contains("firstName"),
        "expected firstName accessor in output. output: {output}"
    );
    assert!(
        output.contains("fullName"),
        "expected fullName accessor in output. output: {output}"
    );
    assert!(
        output.contains("track"),
        "expected track decorator in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive accessor patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// For-Of/For-In Loop ES5 Transform Source Map Tests
// =============================================================================
// Tests for for-of and for-in loop compilation with ES5 target.
// for-of loops should transform to use iterators while preserving source maps.

#[test]
fn test_source_map_loop_es5_basic_for_of() {
    // Test basic for-of loop transformation
    let source = r#"const items = [1, 2, 3, 4, 5];
let sum = 0;

for (const item of items) {
    sum += item;
}

console.log(sum);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("items"),
        "expected items array in output. output: {output}"
    );
    assert!(
        output.contains("sum"),
        "expected sum variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic for-of"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_loop_es5_basic_for_in() {
    // Test basic for-in loop transformation
    let source = r#"const obj = { a: 1, b: 2, c: 3 };
const keys: string[] = [];

for (const key in obj) {
    keys.push(key);
}

console.log(keys);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("obj"),
        "expected obj object in output. output: {output}"
    );
    assert!(
        output.contains("key"),
        "expected key variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic for-in"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_loop_es5_for_of_destructuring() {
    // Test for-of with destructuring transformation
    let source = r#"const pairs = [[1, "one"], [2, "two"], [3, "three"]];

for (const [num, name] of pairs) {
    console.log(num, name);
}

const entries = [{ id: 1, value: "a" }, { id: 2, value: "b" }];

for (const { id, value } of entries) {
    console.log(id, value);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("pairs") && output.contains("entries"),
        "expected pairs and entries arrays in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-of destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_loop_es5_for_in_destructuring() {
    // Test for-in with object property access
    let source = r#"const config = {
    host: "localhost",
    port: 8080,
    debug: true
};

const settings: { [key: string]: any } = {};

for (const prop in config) {
    if (config.hasOwnProperty(prop)) {
        settings[prop] = config[prop as keyof typeof config];
    }
}

console.log(settings);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("config") && output.contains("settings"),
        "expected config and settings in output. output: {output}"
    );
    assert!(
        output.contains("hasOwnProperty"),
        "expected hasOwnProperty call in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-in destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_loop_es5_for_of_string() {
    // Test for-of with string iteration
    let source = r#"const message = "Hello";
const chars: string[] = [];

for (const char of message) {
    chars.push(char.toUpperCase());
}

console.log(chars.join("-"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("message") && output.contains("chars"),
        "expected message and chars in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-of string"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_loop_es5_for_of_map_set() {
    // Test for-of with Map and Set iteration
    let source = r#"const map = new Map<string, number>();
map.set("a", 1);
map.set("b", 2);

for (const [key, value] of map) {
    console.log(key, value);
}

const set = new Set<number>([1, 2, 3]);

for (const item of set) {
    console.log(item);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Map") && output.contains("Set"),
        "expected Map and Set in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-of Map/Set"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_loop_es5_nested_for_of() {
    // Test nested for-of loops
    let source = r#"const matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
let total = 0;

for (const row of matrix) {
    for (const cell of row) {
        total += cell;
    }
}

const nested = [["a", "b"], ["c", "d"]];

for (const outer of nested) {
    for (const inner of outer) {
        console.log(inner);
    }
}

console.log(total);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("matrix") && output.contains("nested"),
        "expected matrix and nested arrays in output. output: {output}"
    );
    assert!(
        output.contains("total"),
        "expected total variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested for-of"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_loop_es5_for_of_break_continue() {
    // Test for-of with break and continue
    let source = r#"const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let result: number[] = [];

for (const num of numbers) {
    if (num === 3) {
        continue;
    }
    if (num > 7) {
        break;
    }
    result.push(num);
}

outer: for (const x of [1, 2, 3]) {
    for (const y of [4, 5, 6]) {
        if (x === 2 && y === 5) {
            break outer;
        }
        console.log(x, y);
    }
}

console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("numbers") && output.contains("result"),
        "expected numbers and result in output. output: {output}"
    );
    assert!(
        output.contains("break") || output.contains("continue"),
        "expected break/continue in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-of break/continue"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_loop_es5_for_of_iterator() {
    // Test for-of with custom iterator
    let source = r#"class Range {
    constructor(private start: number, private end: number) {}

    *[Symbol.iterator]() {
        for (let i = this.start; i <= this.end; i++) {
            yield i;
        }
    }
}

const range = new Range(1, 5);

for (const num of range) {
    console.log(num);
}

function* generateNumbers() {
    yield 1;
    yield 2;
    yield 3;
}

for (const n of generateNumbers()) {
    console.log(n);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Range"),
        "expected Range class in output. output: {output}"
    );
    assert!(
        output.contains("generateNumbers"),
        "expected generateNumbers function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-of iterator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_loop_es5_comprehensive() {
    // Comprehensive for-of/for-in test
    let source = r#"// Data structures
interface User {
    id: number;
    name: string;
    roles: string[];
}

const users: User[] = [
    { id: 1, name: "Alice", roles: ["admin", "user"] },
    { id: 2, name: "Bob", roles: ["user"] }
];

// for-of with object destructuring
for (const { id, name, roles } of users) {
    console.log("User:", id, name);

    // Nested for-of with array
    for (const role of roles) {
        console.log("  Role:", role);
    }
}

// for-in with property enumeration
const config: { [key: string]: any } = {
    host: "localhost",
    port: 8080,
    debug: true,
    timeout: 5000
};

const configCopy: { [key: string]: any } = {};

for (const key in config) {
    if (Object.prototype.hasOwnProperty.call(config, key)) {
        configCopy[key] = config[key];
    }
}

// for-of with index tracking
const items = ["a", "b", "c"];
let index = 0;

for (const item of items) {
    console.log(index, item);
    index++;
}

// for-of with Map entries
const userMap = new Map<number, string>();
userMap.set(1, "Alice");
userMap.set(2, "Bob");

for (const [userId, userName] of userMap.entries()) {
    console.log("Map entry:", userId, userName);
}

// Labeled for-of with break
search: for (const user of users) {
    for (const role of user.roles) {
        if (role === "admin") {
            console.log("Found admin:", user.name);
            break search;
        }
    }
}

console.log("Config copy:", configCopy);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("users"),
        "expected users array in output. output: {output}"
    );
    assert!(
        output.contains("config"),
        "expected config object in output. output: {output}"
    );
    assert!(
        output.contains("userMap"),
        "expected userMap in output. output: {output}"
    );
    assert!(
        output.contains("hasOwnProperty"),
        "expected hasOwnProperty check in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive for-of/for-in"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Async/Await Transform ES5 Source Map Tests
// =============================================================================
// Tests for async/await compilation with ES5 target focusing on:
// try/catch in async, Promise chain transforms, async arrow functions.

#[test]
fn test_source_map_async_es5_try_catch_basic() {
    // Test basic try/catch in async function
    let source = r#"async function fetchData(url: string): Promise<string> {
    try {
        const response = await fetch(url);
        const data = await response.text();
        return data;
    } catch (error) {
        console.error("Fetch failed:", error);
        return "";
    }
}

fetchData("https://api.example.com/data");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchData"),
        "expected fetchData function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async try/catch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_try_catch_finally() {
    // Test try/catch/finally in async function
    let source = r#"async function processWithCleanup(): Promise<void> {
    let resource: any = null;
    try {
        resource = await acquireResource();
        await processResource(resource);
    } catch (error) {
        console.error("Processing failed:", error);
        throw error;
    } finally {
        if (resource) {
            await releaseResource(resource);
        }
        console.log("Cleanup complete");
    }
}

async function acquireResource() {
    return { id: 1 };
}

async function processResource(r: any) {
    console.log("Processing", r);
}

async function releaseResource(r: any) {
    console.log("Releasing", r);
}

processWithCleanup();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processWithCleanup"),
        "expected processWithCleanup function in output. output: {output}"
    );
    assert!(
        output.contains("acquireResource") && output.contains("releaseResource"),
        "expected resource functions in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async try/catch/finally"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_promise_chain() {
    // Test Promise chain transforms
    let source = r#"function fetchUser(id: number): Promise<{ name: string }> {
    return Promise.resolve({ name: "User" + id });
}

function fetchPosts(userId: number): Promise<string[]> {
    return Promise.resolve(["Post 1", "Post 2"]);
}

async function getUserWithPosts(id: number) {
    const user = await fetchUser(id);
    const posts = await fetchPosts(id);
    return { user, posts };
}

// Promise chain equivalent
function getUserWithPostsChain(id: number) {
    return fetchUser(id)
        .then(function(user) {
            return fetchPosts(id).then(function(posts) {
                return { user: user, posts: posts };
            });
        })
        .catch(function(error) {
            console.error(error);
            return null;
        });
}

getUserWithPosts(1);
getUserWithPostsChain(2);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchUser") && output.contains("fetchPosts"),
        "expected fetch functions in output. output: {output}"
    );
    assert!(
        output.contains("getUserWithPosts"),
        "expected getUserWithPosts function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Promise chain"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_arrow_function() {
    // Test async arrow functions
    let source = r#"const fetchData = async (url: string): Promise<any> => {
    const response = await fetch(url);
    return response.json();
};

const processItems = async (items: number[]): Promise<number[]> => {
    const results: number[] = [];
    for (const item of items) {
        const processed = await processItem(item);
        results.push(processed);
    }
    return results;
};

const processItem = async (item: number): Promise<number> => item * 2;

const shortAsync = async () => "done";

const asyncWithDefault = async (value: number = 10) => value * 2;

fetchData("https://api.example.com");
processItems([1, 2, 3]);
shortAsync();
asyncWithDefault();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchData") && output.contains("processItems"),
        "expected async arrow functions in output. output: {output}"
    );
    assert!(
        output.contains("shortAsync"),
        "expected shortAsync in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async arrow functions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_class_methods() {
    // Test async class methods
    let source = r#"class ApiClient {
    private baseUrl: string;

    constructor(baseUrl: string) {
        this.baseUrl = baseUrl;
    }

    async get(endpoint: string): Promise<any> {
        try {
            const response = await fetch(this.baseUrl + endpoint);
            return await response.json();
        } catch (error) {
            console.error("GET failed:", error);
            throw error;
        }
    }

    async post(endpoint: string, data: any): Promise<any> {
        try {
            const response = await fetch(this.baseUrl + endpoint, {
                method: "POST",
                body: JSON.stringify(data)
            });
            return await response.json();
        } catch (error) {
            console.error("POST failed:", error);
            throw error;
        }
    }

    static async create(url: string): Promise<ApiClient> {
        return new ApiClient(url);
    }
}

const client = new ApiClient("https://api.example.com");
client.get("/users");
client.post("/users", { name: "Alice" });
ApiClient.create("https://api.example.com");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ApiClient"),
        "expected ApiClient class in output. output: {output}"
    );
    assert!(
        output.contains("get") && output.contains("post"),
        "expected get/post methods in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async class methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_iife() {
    // Test async IIFE (Immediately Invoked Function Expression)
    let source = r#"(async function() {
    console.log("Starting async IIFE");
    const result = await Promise.resolve("done");
    console.log("Result:", result);
})();

(async () => {
    const data = await fetchData();
    console.log("Data:", data);
})();

async function fetchData() {
    return { value: 42 };
}

const asyncResult = (async () => {
    return await Promise.all([
        Promise.resolve(1),
        Promise.resolve(2),
        Promise.resolve(3)
    ]);
})();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchData"),
        "expected fetchData function in output. output: {output}"
    );
    assert!(
        output.contains("asyncResult"),
        "expected asyncResult variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async IIFE"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_nested_try_catch() {
    // Test nested try/catch in async functions
    let source = r#"async function complexOperation(): Promise<string> {
    try {
        const first = await step1();
        try {
            const second = await step2(first);
            try {
                const third = await step3(second);
                return third;
            } catch (innerError) {
                console.error("Step 3 failed:", innerError);
                return await fallback3();
            }
        } catch (middleError) {
            console.error("Step 2 failed:", middleError);
            return await fallback2();
        }
    } catch (outerError) {
        console.error("Step 1 failed:", outerError);
        return await fallback1();
    }
}

async function step1() { return "step1"; }
async function step2(input: string) { return input + "-step2"; }
async function step3(input: string) { return input + "-step3"; }
async function fallback1() { return "fallback1"; }
async function fallback2() { return "fallback2"; }
async function fallback3() { return "fallback3"; }

complexOperation();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("complexOperation"),
        "expected complexOperation function in output. output: {output}"
    );
    assert!(
        output.contains("step1") && output.contains("step2") && output.contains("step3"),
        "expected step functions in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested try/catch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_parallel_await() {
    // Test parallel await patterns with Promise.all/race
    let source = r#"async function fetchAllData(): Promise<[any, any, any]> {
    const [users, posts, comments] = await Promise.all([
        fetchUsers(),
        fetchPosts(),
        fetchComments()
    ]);
    return [users, posts, comments];
}

async function fetchFirstResponse(): Promise<any> {
    try {
        const result = await Promise.race([
            fetchFast(),
            fetchSlow(),
            timeout(5000)
        ]);
        return result;
    } catch (error) {
        return null;
    }
}

async function fetchUsers() { return [{ id: 1 }]; }
async function fetchPosts() { return [{ id: 1 }]; }
async function fetchComments() { return [{ id: 1 }]; }
async function fetchFast() { return "fast"; }
async function fetchSlow() { return "slow"; }
function timeout(ms: number): Promise<never> {
    return new Promise(function(_, reject) {
        setTimeout(function() { reject(new Error("Timeout")); }, ms);
    });
}

fetchAllData();
fetchFirstResponse();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchAllData"),
        "expected fetchAllData function in output. output: {output}"
    );
    assert!(
        output.contains("Promise"),
        "expected Promise in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for parallel await"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_error_rethrow() {
    // Test error rethrowing patterns in async
    let source = r#"class CustomError extends Error {
    constructor(message: string, public code: number) {
        super(message);
        this.name = "CustomError";
    }
}

async function processWithRetry(maxRetries: number): Promise<string> {
    let lastError: Error | null = null;

    for (let i = 0; i < maxRetries; i++) {
        try {
            return await attemptOperation();
        } catch (error) {
            lastError = error as Error;
            console.log("Attempt " + (i + 1) + " failed, retrying...");
        }
    }

    throw lastError || new Error("All retries failed");
}

async function attemptOperation(): Promise<string> {
    if (Math.random() < 0.5) {
        throw new CustomError("Random failure", 500);
    }
    return "success";
}

async function wrapError(): Promise<void> {
    try {
        await processWithRetry(3);
    } catch (error) {
        throw new CustomError("Wrapped: " + (error as Error).message, 400);
    }
}

processWithRetry(3);
wrapError();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("CustomError"),
        "expected CustomError class in output. output: {output}"
    );
    assert!(
        output.contains("processWithRetry"),
        "expected processWithRetry function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for error rethrow"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_async_es5_transform_comprehensive() {
    // Comprehensive async/await transform test
    let source = r#"// Types
interface ApiResponse<T> {
    data: T;
    status: number;
}

// Async arrow with type parameters
const fetchTyped = async <T>(url: string): Promise<ApiResponse<T>> => {
    try {
        const response = await fetch(url);
        const data = await response.json();
        return { data: data as T, status: response.status };
    } catch (error) {
        throw new Error("Fetch failed: " + (error as Error).message);
    }
};

// Class with async methods and try/catch
class DataService {
    private cache: Map<string, any> = new Map();

    async fetchWithCache(key: string): Promise<any> {
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }

        try {
            const data = await this.fetchRemote(key);
            this.cache.set(key, data);
            return data;
        } catch (error) {
            console.error("Cache miss and fetch failed:", error);
            throw error;
        }
    }

    private async fetchRemote(key: string): Promise<any> {
        return { key: key, value: "data" };
    }

    async batchFetch(keys: string[]): Promise<any[]> {
        const promises = keys.map(async (key) => {
            try {
                return await this.fetchWithCache(key);
            } catch {
                return null;
            }
        });
        return Promise.all(promises);
    }
}

// Async generator simulation with try/catch
async function* asyncGenerator(): AsyncGenerator<number> {
    for (let i = 0; i < 5; i++) {
        try {
            yield await Promise.resolve(i);
        } catch {
            yield -1;
        }
    }
}

// IIFE with complex async flow
const initApp = (async () => {
    try {
        console.log("Initializing...");
        const service = new DataService();
        const data = await service.batchFetch(["a", "b", "c"]);
        console.log("Data loaded:", data);
        return { success: true, data: data };
    } catch (error) {
        console.error("Init failed:", error);
        return { success: false, error: error };
    } finally {
        console.log("Init complete");
    }
})();

// Usage
fetchTyped<{ name: string }>("/api/user");
const service = new DataService();
service.fetchWithCache("test");
initApp.then(function(result) { console.log(result); });"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchTyped"),
        "expected fetchTyped function in output. output: {output}"
    );
    assert!(
        output.contains("DataService"),
        "expected DataService class in output. output: {output}"
    );
    assert!(
        output.contains("fetchWithCache"),
        "expected fetchWithCache method in output. output: {output}"
    );
    assert!(
        output.contains("batchFetch"),
        "expected batchFetch method in output. output: {output}"
    );
    assert!(
        output.contains("initApp"),
        "expected initApp variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive async/await"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// Generator Transform ES5 Source Map Tests
// =============================================================================
// Tests for generator function compilation with ES5 target focusing on:
// yield expressions, generator delegation (yield*).

#[test]
fn test_source_map_generator_es5_basic_yield() {
    // Test basic yield expressions
    let source = r#"function* simpleGenerator() {
    yield 1;
    yield 2;
    yield 3;
}

const gen = simpleGenerator();
console.log(gen.next().value);
console.log(gen.next().value);
console.log(gen.next().value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("simpleGenerator"),
        "expected simpleGenerator function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic yield"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_yield_with_values() {
    // Test yield with computed values
    let source = r#"function* valueGenerator(start: number) {
    let current = start;
    while (current < start + 5) {
        yield current * 2;
        current++;
    }
}

function* expressionYield() {
    const a = 10;
    const b = 20;
    yield a + b;
    yield a * b;
    yield Math.max(a, b);
}

const gen1 = valueGenerator(1);
const gen2 = expressionYield();

for (const val of gen1) {
    console.log(val);
}

console.log(gen2.next().value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("valueGenerator") && output.contains("expressionYield"),
        "expected generator functions in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for yield with values"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_delegation() {
    // Test generator delegation (yield*)
    let source = r#"function* innerGenerator() {
    yield "a";
    yield "b";
    yield "c";
}

function* anotherInner() {
    yield 1;
    yield 2;
}

function* outerGenerator() {
    yield "start";
    yield* innerGenerator();
    yield "middle";
    yield* anotherInner();
    yield "end";
}

const gen = outerGenerator();
for (const value of gen) {
    console.log(value);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("innerGenerator") && output.contains("outerGenerator"),
        "expected generator functions in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator delegation"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_return_value() {
    // Test generator with return values
    let source = r#"function* generatorWithReturn(): Generator<number, string, unknown> {
    yield 1;
    yield 2;
    yield 3;
    return "done";
}

function* conditionalReturn(shouldStop: boolean): Generator<number, string, unknown> {
    yield 1;
    if (shouldStop) {
        return "stopped early";
    }
    yield 2;
    yield 3;
    return "completed";
}

const gen1 = generatorWithReturn();
let result = gen1.next();
while (!result.done) {
    console.log("Value:", result.value);
    result = gen1.next();
}
console.log("Return:", result.value);

const gen2 = conditionalReturn(true);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("generatorWithReturn") && output.contains("conditionalReturn"),
        "expected generator functions in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator return"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_try_catch() {
    // Test generator with try/catch
    let source = r#"function* safeGenerator(): Generator<number, void, unknown> {
    try {
        yield 1;
        yield 2;
        throw new Error("Generator error");
    } catch (error) {
        console.error("Caught:", error);
        yield -1;
    } finally {
        console.log("Generator cleanup");
    }
}

function* generatorWithFinally(): Generator<string, void, unknown> {
    try {
        yield "start";
        yield "middle";
    } finally {
        yield "cleanup";
    }
}

const gen1 = safeGenerator();
for (const val of gen1) {
    console.log(val);
}

const gen2 = generatorWithFinally();
console.log(gen2.next().value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("safeGenerator") && output.contains("generatorWithFinally"),
        "expected generator functions in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator try/catch"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_infinite() {
    // Test infinite generator patterns
    let source = r#"function* infiniteCounter(): Generator<number, never, unknown> {
    let count = 0;
    while (true) {
        yield count++;
    }
}

function* fibonacci(): Generator<number, never, unknown> {
    let a = 0;
    let b = 1;
    while (true) {
        yield a;
        const temp = a;
        a = b;
        b = temp + b;
    }
}

function* idGenerator(prefix: string): Generator<string, never, unknown> {
    let id = 0;
    while (true) {
        yield prefix + "-" + (id++);
    }
}

const counter = infiniteCounter();
console.log(counter.next().value);
console.log(counter.next().value);

const fib = fibonacci();
for (let i = 0; i < 10; i++) {
    console.log(fib.next().value);
}

const ids = idGenerator("user");
console.log(ids.next().value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("infiniteCounter") && output.contains("fibonacci"),
        "expected generator functions in output. output: {output}"
    );
    assert!(
        output.contains("idGenerator"),
        "expected idGenerator function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for infinite generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_class_iterator() {
    // Test generator implementing iterator protocol
    let source = r#"class Range {
    constructor(private start: number, private end: number) {}

    *[Symbol.iterator](): Generator<number, void, unknown> {
        for (let i = this.start; i <= this.end; i++) {
            yield i;
        }
    }
}

class Tree<T> {
    constructor(
        public value: T,
        public left?: Tree<T>,
        public right?: Tree<T>
    ) {}

    *inOrder(): Generator<T, void, unknown> {
        if (this.left) {
            yield* this.left.inOrder();
        }
        yield this.value;
        if (this.right) {
            yield* this.right.inOrder();
        }
    }
}

const range = new Range(1, 5);
for (const num of range) {
    console.log(num);
}

const tree = new Tree(2, new Tree(1), new Tree(3));
for (const val of tree.inOrder()) {
    console.log(val);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Range") && output.contains("Tree"),
        "expected Range and Tree classes in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for iterator protocol"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_class_methods() {
    // Test generator methods in classes
    let source = r#"class DataProcessor {
    private data: number[] = [];

    constructor(data: number[]) {
        this.data = data;
    }

    *processAll(): Generator<number, void, unknown> {
        for (const item of this.data) {
            yield this.process(item);
        }
    }

    *processFiltered(predicate: (n: number) => boolean): Generator<number, void, unknown> {
        for (const item of this.data) {
            if (predicate(item)) {
                yield this.process(item);
            }
        }
    }

    private process(item: number): number {
        return item * 2;
    }

    static *range(start: number, end: number): Generator<number, void, unknown> {
        for (let i = start; i <= end; i++) {
            yield i;
        }
    }
}

const processor = new DataProcessor([1, 2, 3, 4, 5]);
for (const result of processor.processAll()) {
    console.log(result);
}

for (const result of processor.processFiltered(function(n) { return n > 2; })) {
    console.log(result);
}

for (const n of DataProcessor.range(1, 10)) {
    console.log(n);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataProcessor"),
        "expected DataProcessor class in output. output: {output}"
    );
    assert!(
        output.contains("processAll") && output.contains("processFiltered"),
        "expected generator methods in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class generator methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_async_generator() {
    // Test async generator patterns
    let source = r#"async function* asyncDataFetcher(urls: string[]): AsyncGenerator<any, void, unknown> {
    for (const url of urls) {
        const data = await fetch(url).then(function(r) { return r.json(); });
        yield data;
    }
}

async function* timedGenerator(interval: number): AsyncGenerator<number, void, unknown> {
    let count = 0;
    while (count < 5) {
        await new Promise(function(resolve) { setTimeout(resolve, interval); });
        yield count++;
    }
}

async function* paginatedFetch(baseUrl: string): AsyncGenerator<any[], void, unknown> {
    let page = 1;
    let hasMore = true;

    while (hasMore) {
        const response = await fetch(baseUrl + "?page=" + page);
        const data = await response.json();
        yield data.items;
        hasMore = data.hasMore;
        page++;
    }
}

async function processAsync() {
    const fetcher = asyncDataFetcher(["url1", "url2"]);
    for await (const data of fetcher) {
        console.log(data);
    }
}

processAsync();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("asyncDataFetcher") && output.contains("timedGenerator"),
        "expected async generator functions in output. output: {output}"
    );
    assert!(
        output.contains("paginatedFetch"),
        "expected paginatedFetch function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async generators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_generator_es5_transform_comprehensive() {
    // Comprehensive generator transform test
    let source = r#"// Utility generators
function* take<T>(iterable: Iterable<T>, count: number): Generator<T, void, unknown> {
    let i = 0;
    for (const item of iterable) {
        if (i >= count) return;
        yield item;
        i++;
    }
}

function* map<T, U>(iterable: Iterable<T>, fn: (item: T) => U): Generator<U, void, unknown> {
    for (const item of iterable) {
        yield fn(item);
    }
}

function* filter<T>(iterable: Iterable<T>, predicate: (item: T) => boolean): Generator<T, void, unknown> {
    for (const item of iterable) {
        if (predicate(item)) {
            yield item;
        }
    }
}

// Complex generator with delegation
function* pipeline<T>(
    source: Iterable<T>,
    ...transforms: ((items: Iterable<T>) => Iterable<T>)[]
): Generator<T, void, unknown> {
    let current: Iterable<T> = source;
    for (const transform of transforms) {
        current = transform(current);
    }
    yield* current as Generator<T>;
}

// Class with generator methods
class LazyCollection<T> {
    constructor(private items: T[]) {}

    *[Symbol.iterator](): Generator<T, void, unknown> {
        yield* this.items;
    }

    *map<U>(fn: (item: T) => U): Generator<U, void, unknown> {
        for (const item of this.items) {
            yield fn(item);
        }
    }

    *filter(predicate: (item: T) => boolean): Generator<T, void, unknown> {
        for (const item of this.items) {
            if (predicate(item)) {
                yield item;
            }
        }
    }

    *flatMap<U>(fn: (item: T) => Iterable<U>): Generator<U, void, unknown> {
        for (const item of this.items) {
            yield* fn(item);
        }
    }
}

// Usage
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Using take
for (const n of take(numbers, 3)) {
    console.log("Take:", n);
}

// Using map
for (const n of map(numbers, function(x) { return x * 2; })) {
    console.log("Map:", n);
}

// Using filter
for (const n of filter(numbers, function(x) { return x % 2 === 0; })) {
    console.log("Filter:", n);
}

// Using LazyCollection
const collection = new LazyCollection(numbers);
for (const n of collection.filter(function(x) { return x > 5; })) {
    console.log("Collection:", n);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("take"),
        "expected take function in output. output: {output}"
    );
    assert!(
        output.contains("map"),
        "expected map function in output. output: {output}"
    );
    assert!(
        output.contains("filter"),
        "expected filter function in output. output: {output}"
    );
    assert!(
        output.contains("LazyCollection"),
        "expected LazyCollection class in output. output: {output}"
    );
    assert!(
        output.contains("pipeline"),
        "expected pipeline function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// ES5 Destructuring Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_destructuring_es5_array_basic() {
    let source = r#"const numbers = [1, 2, 3, 4, 5];
const [first, second, third] = numbers;
console.log(first, second, third);

const [a, b, c, d, e] = [10, 20, 30, 40, 50];
console.log(a + b + c + d + e);

let [x, y] = [100, 200];
[x, y] = [y, x];
console.log(x, y);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("first"),
        "expected first variable in output. output: {output}"
    );
    assert!(
        output.contains("second"),
        "expected second variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for array destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_es5_object_basic() {
    let source = r#"const person = { name: "Alice", age: 30, city: "NYC" };
const { name, age, city } = person;
console.log(name, age, city);

const { name: personName, age: personAge } = person;
console.log(personName, personAge);

const config = { host: "localhost", port: 8080 };
const { host, port } = config;
console.log(host + ":" + port);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("name"),
        "expected name property in output. output: {output}"
    );
    assert!(
        output.contains("personName"),
        "expected personName alias in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for object destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_es5_nested_array() {
    let source = r#"const matrix = [[1, 2], [3, 4], [5, 6]];
const [[a, b], [c, d], [e, f]] = matrix;
console.log(a, b, c, d, e, f);

const deep = [[[1, 2]], [[3, 4]]];
const [[[x, y]], [[z, w]]] = deep;
console.log(x + y + z + w);

const mixed = [1, [2, [3, [4]]]];
const [one, [two, [three, [four]]]] = mixed;
console.log(one, two, three, four);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("matrix"),
        "expected matrix variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested array destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_es5_nested_object() {
    let source = r#"const user = {
    profile: {
        name: "Bob",
        address: {
            city: "Boston",
            zip: "02101"
        }
    },
    settings: {
        theme: "dark",
        notifications: true
    }
};

const { profile: { name, address: { city, zip } } } = user;
console.log(name, city, zip);

const { settings: { theme, notifications } } = user;
console.log(theme, notifications);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("user"),
        "expected user variable in output. output: {output}"
    );
    assert!(
        output.contains("profile"),
        "expected profile property in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested object destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_es5_mixed() {
    let source = r#"const data = {
    users: [
        { id: 1, name: "Alice" },
        { id: 2, name: "Bob" }
    ],
    metadata: {
        count: 2,
        tags: ["admin", "user"]
    }
};

const { users: [first, second], metadata: { count, tags: [tag1, tag2] } } = data;
console.log(first.name, second.name, count, tag1, tag2);

const response = { items: [[1, 2], [3, 4]], status: { code: 200 } };
const { items: [[a, b], [c, d]], status: { code } } = response;
console.log(a, b, c, d, code);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("users"),
        "expected users array in output. output: {output}"
    );
    assert!(
        output.contains("metadata"),
        "expected metadata object in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for mixed destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_es5_defaults() {
    let source = r#"const [a = 1, b = 2, c = 3] = [10];
console.log(a, b, c);

const { name = "Unknown", age = 0, active = true } = { name: "Alice" };
console.log(name, age, active);

const { config: { timeout = 5000, retries = 3 } = {} } = {};
console.log(timeout, retries);

function process({ value = 0, label = "default" } = {}) {
    return label + ": " + value;
}
console.log(process({ value: 42 }));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("process"),
        "expected process function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for destructuring with defaults"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_es5_function_params() {
    let source = r#"function processUser({ name, age, email }: { name: string; age: number; email: string }) {
    console.log(name, age, email);
}

function processCoords([x, y, z]: number[]) {
    return x + y + z;
}

const greet = ({ firstName, lastName }: { firstName: string; lastName: string }) => {
    return "Hello, " + firstName + " " + lastName;
};

class Handler {
    handle({ type, payload }: { type: string; payload: any }) {
        console.log(type, payload);
    }
}

processUser({ name: "Alice", age: 30, email: "alice@example.com" });
console.log(processCoords([1, 2, 3]));
console.log(greet({ firstName: "John", lastName: "Doe" }));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processUser"),
        "expected processUser function in output. output: {output}"
    );
    assert!(
        output.contains("processCoords"),
        "expected processCoords function in output. output: {output}"
    );
    assert!(
        output.contains("greet"),
        "expected greet function in output. output: {output}"
    );
    assert!(
        output.contains("Handler"),
        "expected Handler class in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for function parameter destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_es5_rest_patterns() {
    let source = r#"const [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first, second, rest);

const { name, ...others } = { name: "Alice", age: 30, city: "NYC" };
console.log(name, others);

function processItems([head, ...tail]: number[]) {
    console.log("Head:", head);
    console.log("Tail:", tail);
    return tail.reduce((a, b) => a + b, head);
}

const { a, b, ...remaining } = { a: 1, b: 2, c: 3, d: 4, e: 5 };
console.log(a, b, remaining);

console.log(processItems([10, 20, 30, 40]));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("rest"),
        "expected rest variable in output. output: {output}"
    );
    assert!(
        output.contains("processItems"),
        "expected processItems function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for rest pattern destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_es5_loop_patterns() {
    let source = r#"const pairs = [[1, "one"], [2, "two"], [3, "three"]];
for (const [num, word] of pairs) {
    console.log(num + ": " + word);
}

const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
    { id: 3, name: "Charlie" }
];
for (const { id, name } of users) {
    console.log(id + " - " + name);
}

const entries = new Map([["a", 1], ["b", 2], ["c", 3]]);
for (const [key, value] of entries) {
    console.log(key + " => " + value);
}

const matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
for (const [a, b, c] of matrix) {
    console.log(a + b + c);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("pairs"),
        "expected pairs array in output. output: {output}"
    );
    assert!(
        output.contains("users"),
        "expected users array in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for loop destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_destructuring_es5_comprehensive() {
    let source = r#"// Comprehensive destructuring patterns for ES5 transform testing

// Basic array and object destructuring
const [x, y, z] = [1, 2, 3];
const { name, age } = { name: "Alice", age: 30 };

// Nested destructuring
const {
    user: {
        profile: { firstName, lastName },
        settings: { theme }
    }
} = {
    user: {
        profile: { firstName: "John", lastName: "Doe" },
        settings: { theme: "dark" }
    }
};

// Destructuring with defaults
const [a = 1, b = 2] = [10];
const { timeout = 5000, retries = 3 } = {};

// Rest patterns
const [head, ...tail] = [1, 2, 3, 4, 5];
const { id, ...metadata } = { id: 1, type: "user", active: true };

// Function parameter destructuring
function processConfig({
    server: { host = "localhost", port = 8080 },
    database: { name: dbName, pool = 10 }
}: {
    server: { host?: string; port?: number };
    database: { name: string; pool?: number };
}) {
    return host + ":" + port + " -> " + dbName + " (pool: " + pool + ")";
}

// Arrow function with destructuring
const formatUser = ({ name, email }: { name: string; email: string }) =>
    name + " <" + email + ">";

// Class with destructuring in methods
class DataProcessor {
    private data: any[];

    constructor(data: any[]) {
        this.data = data;
    }

    process() {
        return this.data.map(({ value, label }) => label + ": " + value);
    }

    *iterate() {
        for (const { id, ...rest } of this.data) {
            yield { id, processed: true, ...rest };
        }
    }
}

// Destructuring in loops
const pairs: [string, number][] = [["a", 1], ["b", 2], ["c", 3]];
for (const [key, val] of pairs) {
    console.log(key + " = " + val);
}

// Complex nested array/object mix
const response = {
    data: {
        users: [
            { id: 1, info: { name: "Alice", scores: [90, 85, 92] } },
            { id: 2, info: { name: "Bob", scores: [88, 91, 87] } }
        ]
    },
    meta: { total: 2, page: 1 }
};

const {
    data: { users: [{ info: { name: user1Name, scores: [score1] } }] },
    meta: { total }
} = response;

// Swap using destructuring
let m = 1, n = 2;
[m, n] = [n, m];

// Computed property names with destructuring
const key = "dynamicKey";
const { [key]: dynamicValue } = { dynamicKey: "found!" };

// Usage
console.log(x, y, z, name, age);
console.log(firstName, lastName, theme);
console.log(a, b, timeout, retries);
console.log(head, tail, id, metadata);
console.log(processConfig({
    server: { host: "api.example.com" },
    database: { name: "mydb" }
}));
console.log(formatUser({ name: "Test", email: "test@example.com" }));

const processor = new DataProcessor([
    { id: 1, value: 10, label: "A" },
    { id: 2, value: 20, label: "B" }
]);
console.log(processor.process());

console.log(user1Name, score1, total);
console.log(m, n);
console.log(dynamicValue);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processConfig"),
        "expected processConfig function in output. output: {output}"
    );
    assert!(
        output.contains("formatUser"),
        "expected formatUser function in output. output: {output}"
    );
    assert!(
        output.contains("DataProcessor"),
        "expected DataProcessor class in output. output: {output}"
    );
    assert!(
        output.contains("dynamicValue"),
        "expected dynamicValue variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive destructuring"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// ES5 Spread/Rest Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_spread_rest_es5_array_spread_basic() {
    let source = r#"const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];
console.log(combined);

const numbers = [10, 20, 30];
const expanded = [...numbers];
console.log(expanded);

const nested = [[1, 2], [3, 4]];
const flat = [...nested[0], ...nested[1]];
console.log(flat);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("arr1"),
        "expected arr1 in output. output: {output}"
    );
    assert!(
        output.contains("combined"),
        "expected combined in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for array spread"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_rest_es5_object_spread_basic() {
    let source = r#"const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj2 };
console.log(merged);

const defaults = { theme: "light", lang: "en" };
const settings = { ...defaults, theme: "dark" };
console.log(settings);

const person = { name: "Alice", age: 30 };
const updated = { ...person, age: 31 };
console.log(updated);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("obj1"),
        "expected obj1 in output. output: {output}"
    );
    assert!(
        output.contains("merged"),
        "expected merged in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for object spread"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_rest_es5_function_call_spread() {
    let source = r#"function sum(a: number, b: number, c: number): number {
    return a + b + c;
}

const args = [1, 2, 3] as const;
const result = sum(...args);
console.log(result);

function log(...items: any[]): void {
    console.log(...items);
}

const messages = ["hello", "world"];
log(...messages);

Math.max(...[1, 5, 3, 9, 2]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("sum"),
        "expected sum function in output. output: {output}"
    );
    assert!(
        output.contains("log"),
        "expected log function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for function call spread"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_rest_es5_array_with_elements() {
    let source = r#"const middle = [3, 4, 5];
const full = [1, 2, ...middle, 6, 7];
console.log(full);

const prefix = [0];
const suffix = [9, 10];
const range = [...prefix, 1, 2, ...middle, 8, ...suffix];
console.log(range);

const items = ["b", "c"];
const alphabet = ["a", ...items, "d", "e"];
console.log(alphabet);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("middle"),
        "expected middle in output. output: {output}"
    );
    assert!(
        output.contains("full"),
        "expected full in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for array spread with elements"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_rest_es5_object_with_properties() {
    let source = r#"const base = { x: 1, y: 2 };
const extended = { z: 3, ...base, w: 4 };
console.log(extended);

const config = { debug: false };
const options = { verbose: true, ...config, timeout: 5000 };
console.log(options);

const user = { name: "Bob" };
const profile = { id: 1, ...user, role: "admin", ...{ active: true } };
console.log(profile);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("base"),
        "expected base in output. output: {output}"
    );
    assert!(
        output.contains("extended"),
        "expected extended in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for object spread with properties"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_rest_es5_rest_parameters() {
    let source = r#"function collect(...items: number[]): number[] {
    return items;
}

function processAll(first: string, ...rest: string[]): string {
    return first + ": " + rest.join(", ");
}

const formatItems = (prefix: string, ...values: any[]) => {
    return prefix + values.map(v => String(v)).join("");
};

class Handler {
    handle(action: string, ...args: any[]): void {
        console.log(action, args);
    }
}

console.log(collect(1, 2, 3, 4, 5));
console.log(processAll("Items", "a", "b", "c"));
console.log(formatItems("Values: ", 1, 2, 3));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("collect"),
        "expected collect function in output. output: {output}"
    );
    assert!(
        output.contains("processAll"),
        "expected processAll function in output. output: {output}"
    );
    assert!(
        output.contains("Handler"),
        "expected Handler class in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for rest parameters"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_rest_es5_array_rest_elements() {
    let source = r#"const [first, ...remaining] = [1, 2, 3, 4, 5];
console.log(first, remaining);

const [head, second, ...tail] = [10, 20, 30, 40, 50];
console.log(head, second, tail);

function processArray([a, b, ...rest]: number[]): void {
    console.log(a, b, rest);
}

const numbers = [100, 200, 300, 400];
const [x, ...others] = numbers;
console.log(x, others);

processArray([1, 2, 3, 4, 5]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("first"),
        "expected first in output. output: {output}"
    );
    assert!(
        output.contains("remaining"),
        "expected remaining in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for array rest elements"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_rest_es5_object_rest_properties() {
    let source = r#"const { name, ...rest } = { name: "Alice", age: 30, city: "NYC" };
console.log(name, rest);

const { id, type, ...metadata } = { id: 1, type: "user", active: true, role: "admin" };
console.log(id, type, metadata);

function extractUser({ username, ...props }: { username: string; [key: string]: any }): void {
    console.log(username, props);
}

const config = { host: "localhost", port: 8080, debug: true };
const { host, ...serverConfig } = config;
console.log(host, serverConfig);

extractUser({ username: "bob", email: "bob@example.com", verified: true });"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("name"),
        "expected name in output. output: {output}"
    );
    assert!(
        output.contains("rest"),
        "expected rest in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for object rest properties"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_rest_es5_nested_patterns() {
    let source = r#"const data = {
    users: [
        { id: 1, name: "Alice", scores: [90, 85, 92] },
        { id: 2, name: "Bob", scores: [88, 91, 87] }
    ],
    metadata: { count: 2, page: 1 }
};

const { users: [first, ...otherUsers], ...restData } = data;
console.log(first, otherUsers, restData);

const nested = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
const [[a, ...row1Rest], ...otherRows] = nested;
console.log(a, row1Rest, otherRows);

function process({ items: [head, ...tail], ...options }: { items: number[]; [key: string]: any }) {
    console.log(head, tail, options);
}

process({ items: [1, 2, 3], debug: true, verbose: false });"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("data"),
        "expected data in output. output: {output}"
    );
    assert!(
        output.contains("nested"),
        "expected nested in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested spread/rest patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_spread_rest_es5_comprehensive() {
    let source = r#"// Comprehensive spread/rest patterns for ES5 transform testing

// Array spread
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];
const withElements = [0, ...arr1, 10, ...arr2, 20];

// Object spread
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj2 };
const withProps = { prefix: "start", ...obj1, middle: true, ...obj2, suffix: "end" };

// Function call spread
function sum(...nums: number[]): number {
    return nums.reduce((a, b) => a + b, 0);
}
const numbers = [1, 2, 3, 4, 5];
const total = sum(...numbers);

// Rest parameters with different positions
function processArgs(first: string, second: number, ...rest: any[]): void {
    console.log(first, second, rest);
}

// Array rest elements
const [head, ...tail] = [1, 2, 3, 4, 5];
const [a, b, ...remaining] = numbers;

// Object rest properties
const { name, age, ...metadata } = { name: "Alice", age: 30, city: "NYC", country: "USA" };

// Nested patterns
const data = {
    users: [{ id: 1, ...obj1 }, { id: 2, ...obj2 }],
    settings: { ...merged, extra: true }
};
const { users: [firstUser, ...otherUsers], ...restData } = data;

// Class with spread/rest
class DataCollector {
    private items: any[];

    constructor(...initialItems: any[]) {
        this.items = [...initialItems];
    }

    add(...newItems: any[]): void {
        this.items = [...this.items, ...newItems];
    }

    getAll(): any[] {
        return [...this.items];
    }

    extract(): { first: any; rest: any[] } {
        const [first, ...rest] = this.items;
        return { first, rest };
    }
}

// Arrow functions with rest
const collectRest = (...items: any[]) => [...items];
const processRest = (first: any, ...rest: any[]) => ({ first, rest });

// Spread in new expression
class Point {
    constructor(public x: number, public y: number, public z?: number) {}
}
const coords = [10, 20, 30] as const;
const point = new Point(...coords);

// Usage
console.log(combined, withElements);
console.log(merged, withProps);
console.log(total);
processArgs("hello", 42, true, "extra", 123);
console.log(head, tail, a, b, remaining);
console.log(name, age, metadata);
console.log(firstUser, otherUsers, restData);

const collector = new DataCollector(1, 2, 3);
collector.add(4, 5);
console.log(collector.getAll());
console.log(collector.extract());

console.log(collectRest(1, 2, 3));
console.log(processRest("first", "a", "b", "c"));
console.log(point);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("sum"),
        "expected sum function in output. output: {output}"
    );
    assert!(
        output.contains("processArgs"),
        "expected processArgs function in output. output: {output}"
    );
    assert!(
        output.contains("DataCollector"),
        "expected DataCollector class in output. output: {output}"
    );
    assert!(
        output.contains("Point"),
        "expected Point class in output. output: {output}"
    );
    assert!(
        output.contains("collectRest"),
        "expected collectRest function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive spread/rest"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// ES5 Class Expression Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_class_expr_es5_anonymous() {
    let source = r#"const MyClass = class {
    constructor(public value: number) {}

    getValue(): number {
        return this.value;
    }
};

const instance = new MyClass(42);
console.log(instance.getValue());

const factory = function() {
    return class {
        name: string = "default";
        greet() { return "Hello, " + this.name; }
    };
};

const Created = factory();
const obj = new Created();
console.log(obj.greet());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("MyClass"),
        "expected MyClass in output. output: {output}"
    );
    assert!(
        output.contains("getValue"),
        "expected getValue in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for anonymous class expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expr_es5_named() {
    let source = r##"const MyClass = class NamedClass {
    static className = "NamedClass";

    constructor(public id: number) {}

    describe(): string {
        return NamedClass.className + "#" + this.id;
    }
};

const instance = new MyClass(1);
console.log(instance.describe());

const Container = class InnerClass {
    static create() {
        return new InnerClass();
    }

    value = 100;
};

const created = Container.create();
console.log(created.value);"##;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("MyClass"),
        "expected MyClass in output. output: {output}"
    );
    assert!(
        output.contains("describe"),
        "expected describe method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for named class expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expr_es5_in_return() {
    let source = r#"function createCounter(initial: number) {
    return class {
        private count: number = initial;

        increment(): number {
            return ++this.count;
        }

        decrement(): number {
            return --this.count;
        }

        getCount(): number {
            return this.count;
        }
    };
}

const Counter = createCounter(10);
const counter = new Counter();
console.log(counter.increment());
console.log(counter.decrement());

function makeLogger(prefix: string) {
    return class Logger {
        log(message: string): void {
            console.log(prefix + ": " + message);
        }
    };
}

const PrefixedLogger = makeLogger("[INFO]");
const logger = new PrefixedLogger();
logger.log("Hello");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createCounter"),
        "expected createCounter in output. output: {output}"
    );
    assert!(
        output.contains("increment"),
        "expected increment method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression in return"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expr_es5_with_extends() {
    let source = r#"class Base {
    constructor(public name: string) {}

    greet(): string {
        return "Hello, " + this.name;
    }
}

const Extended = class extends Base {
    constructor(name: string, public age: number) {
        super(name);
    }

    greet(): string {
        return super.greet() + ", age " + this.age;
    }
};

const instance = new Extended("Alice", 30);
console.log(instance.greet());

function createDerived(base: typeof Base) {
    return class extends base {
        extra = "additional";

        getExtra(): string {
            return this.extra;
        }
    };
}

const Derived = createDerived(Base);
const derived = new Derived("Bob");
console.log(derived.greet());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Base"),
        "expected Base class in output. output: {output}"
    );
    assert!(
        output.contains("Extended"),
        "expected Extended in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression with extends"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expr_es5_with_static() {
    let source = r#"const Singleton = class {
    private static instance: any;
    private value: number;

    private constructor(value: number) {
        this.value = value;
    }

    static getInstance(): any {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton(42);
        }
        return Singleton.instance;
    }

    getValue(): number {
        return this.value;
    }
};

const Registry = class {
    static items: Map<string, any> = new Map();

    static register(key: string, value: any): void {
        Registry.items.set(key, value);
    }

    static get(key: string): any {
        return Registry.items.get(key);
    }
};

Registry.register("test", { data: 123 });
console.log(Registry.get("test"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Singleton"),
        "expected Singleton in output. output: {output}"
    );
    assert!(
        output.contains("Registry"),
        "expected Registry in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression with static"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expr_es5_in_variable() {
    let source = r#"let DynamicClass = class {
    value = 1;
};

DynamicClass = class {
    value = 2;
    double() { return this.value * 2; }
};

const instance = new DynamicClass();
console.log(instance.double());

var ReassignableClass = class First {
    type = "first";
};

ReassignableClass = class Second {
    type = "second";
    getType() { return this.type; }
};

const obj = new ReassignableClass();
console.log(obj.getType());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DynamicClass"),
        "expected DynamicClass in output. output: {output}"
    );
    assert!(
        output.contains("ReassignableClass"),
        "expected ReassignableClass in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression in variable"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expr_es5_in_array() {
    let source = r#"const classes = [
    class Alpha {
        name = "Alpha";
        greet() { return "I am " + this.name; }
    },
    class Beta {
        name = "Beta";
        greet() { return "I am " + this.name; }
    },
    class Gamma {
        name = "Gamma";
        greet() { return "I am " + this.name; }
    }
];

for (const Cls of classes) {
    const instance = new Cls();
    console.log(instance.greet());
}

const handlers = [
    class { handle(x: number) { return x * 2; } },
    class { handle(x: number) { return x + 10; } },
    class { handle(x: number) { return x - 5; } }
];

const value = 10;
handlers.forEach(Handler => {
    const h = new Handler();
    console.log(h.handle(value));
});"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("classes"),
        "expected classes array in output. output: {output}"
    );
    assert!(
        output.contains("handlers"),
        "expected handlers array in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression in array"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expr_es5_in_object() {
    let source = r#"const components = {
    Button: class {
        label: string;
        constructor(label: string) { this.label = label; }
        render() { return "<button>" + this.label + "</button>"; }
    },
    Input: class {
        placeholder: string;
        constructor(placeholder: string) { this.placeholder = placeholder; }
        render() { return "<input placeholder=\"" + this.placeholder + "\">"; }
    },
    Label: class {
        text: string;
        constructor(text: string) { this.text = text; }
        render() { return "<label>" + this.text + "</label>"; }
    }
};

const btn = new components.Button("Click me");
console.log(btn.render());

const registry = {
    handlers: {
        click: class { execute() { console.log("click"); } },
        hover: class { execute() { console.log("hover"); } }
    }
};

const clickHandler = new registry.handlers.click();
clickHandler.execute();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("components"),
        "expected components object in output. output: {output}"
    );
    assert!(
        output.contains("registry"),
        "expected registry object in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression in object"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expr_es5_with_methods() {
    let source = r#"const Calculator = class {
    private result: number = 0;

    constructor(initial: number = 0) {
        this.result = initial;
    }

    add(value: number): this {
        this.result += value;
        return this;
    }

    subtract(value: number): this {
        this.result -= value;
        return this;
    }

    multiply(value: number): this {
        this.result *= value;
        return this;
    }

    divide(value: number): this {
        if (value !== 0) {
            this.result /= value;
        }
        return this;
    }

    getResult(): number {
        return this.result;
    }

    reset(): this {
        this.result = 0;
        return this;
    }
};

const calc = new Calculator(10);
const result = calc.add(5).multiply(2).subtract(10).getResult();
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Calculator"),
        "expected Calculator in output. output: {output}"
    );
    assert!(
        output.contains("add"),
        "expected add method in output. output: {output}"
    );
    assert!(
        output.contains("multiply"),
        "expected multiply method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class expression with methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_expr_es5_comprehensive() {
    let source = r#"// Comprehensive class expression patterns for ES5 transform testing

// Anonymous class expression
const Anonymous = class {
    value = 42;
    getValue() { return this.value; }
};

// Named class expression
const Named = class InnerName {
    static type = "Named";
    describe() { return InnerName.type; }
};

// Class expression with extends
class BaseClass {
    name: string;
    constructor(name: string) { this.name = name; }
}

const Derived = class extends BaseClass {
    extra = "derived";
    constructor(name: string) {
        super(name);
    }
    getInfo() { return this.name + " - " + this.extra; }
};

// Class expression with static members
const WithStatic = class {
    static count = 0;
    id: number;

    constructor() {
        WithStatic.count++;
        this.id = WithStatic.count;
    }

    static getCount() { return WithStatic.count; }
};

// Factory function returning class expression
function createClass<T>(defaultValue: T) {
    return class {
        value: T = defaultValue;
        getValue(): T { return this.value; }
        setValue(v: T): void { this.value = v; }
    };
}

const StringClass = createClass("hello");
const NumberClass = createClass(123);

// Class expressions in array
const classArray = [
    class { type = "A"; },
    class { type = "B"; },
    class { type = "C"; }
];

// Class expressions in object
const classMap = {
    first: class First { id = 1; },
    second: class Second { id = 2; },
    third: class Third { id = 3; }
};

// IIFE with class expression
const IIFEClass = (function() {
    const privateData = "secret";
    return class {
        getPrivate() { return privateData; }
    };
})();

// Class expression with accessors
const WithAccessors = class {
    private _value: number = 0;

    get value(): number { return this._value; }
    set value(v: number) { this._value = v; }

    get doubled(): number { return this._value * 2; }
};

// Usage
const anon = new Anonymous();
console.log(anon.getValue());

const named = new Named();
console.log(named.describe());

const derived = new Derived("test");
console.log(derived.getInfo());

new WithStatic();
new WithStatic();
console.log(WithStatic.getCount());

const strInstance = new StringClass();
console.log(strInstance.getValue());

const numInstance = new NumberClass();
console.log(numInstance.getValue());

for (const Cls of classArray) {
    console.log(new Cls().type);
}

console.log(new classMap.first().id);

const iifeInstance = new IIFEClass();
console.log(iifeInstance.getPrivate());

const accessorInstance = new WithAccessors();
accessorInstance.value = 21;
console.log(accessorInstance.doubled);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Anonymous"),
        "expected Anonymous in output. output: {output}"
    );
    assert!(
        output.contains("Named"),
        "expected Named in output. output: {output}"
    );
    assert!(
        output.contains("Derived"),
        "expected Derived in output. output: {output}"
    );
    assert!(
        output.contains("WithStatic"),
        "expected WithStatic in output. output: {output}"
    );
    assert!(
        output.contains("createClass"),
        "expected createClass function in output. output: {output}"
    );
    assert!(
        output.contains("WithAccessors"),
        "expected WithAccessors in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive class expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// ============================================================================
// ES5 Arrow Function Transform Source Map Tests
// ============================================================================

#[test]
fn test_source_map_arrow_es5_expression_body() {
    let source = r#"const add = (a: number, b: number) => a + b;
const square = (x: number) => x * x;
const identity = <T>(x: T) => x;

const double = (n: number) => n * 2;
const negate = (n: number) => -n;
const toString = (x: any) => String(x);

console.log(add(1, 2));
console.log(square(5));
console.log(double(10));
console.log(negate(5));
console.log(toString(42));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("add"),
        "expected add in output. output: {output}"
    );
    assert!(
        output.contains("square"),
        "expected square in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow expression body"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_es5_block_body() {
    let source = r#"const processData = (data: number[]) => {
    const filtered = data.filter(x => x > 0);
    const doubled = filtered.map(x => x * 2);
    return doubled.reduce((a, b) => a + b, 0);
};

const validateInput = (input: string) => {
    if (!input) {
        throw new Error("Invalid input");
    }
    const trimmed = input.trim();
    if (trimmed.length === 0) {
        return null;
    }
    return trimmed.toUpperCase();
};

const factorial = (n: number): number => {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
};

console.log(processData([1, -2, 3, -4, 5]));
console.log(validateInput("  hello  "));
console.log(factorial(5));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processData"),
        "expected processData in output. output: {output}"
    );
    assert!(
        output.contains("validateInput"),
        "expected validateInput in output. output: {output}"
    );
    assert!(
        output.contains("factorial"),
        "expected factorial in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow block body"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_es5_this_binding() {
    let source = r#"class Counter {
    count = 0;

    increment = () => {
        this.count++;
        return this.count;
    };

    decrement = () => {
        this.count--;
        return this.count;
    };

    addMultiple = (n: number) => {
        for (let i = 0; i < n; i++) {
            this.increment();
        }
        return this.count;
    };
}

class EventHandler {
    name = "Handler";

    handleClick = () => {
        console.log(this.name + " clicked");
    };

    handleHover = () => {
        console.log(this.name + " hovered");
    };
}

const counter = new Counter();
console.log(counter.increment());
console.log(counter.addMultiple(5));

const handler = new EventHandler();
handler.handleClick();
handler.handleHover();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter"),
        "expected Counter class in output. output: {output}"
    );
    assert!(
        output.contains("EventHandler"),
        "expected EventHandler class in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow this binding"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_es5_rest_params() {
    let source = r#"const sum = (...numbers: number[]) => numbers.reduce((a, b) => a + b, 0);

const concat = (...strings: string[]) => strings.join("");

const first = <T>(first: T, ...rest: T[]) => first;

const last = <T>(...items: T[]) => items[items.length - 1];

const collect = (prefix: string, ...values: any[]) => {
    return prefix + ": " + values.join(", ");
};

const spread = (...args: number[]) => {
    const [head, ...tail] = args;
    return { head, tail };
};

console.log(sum(1, 2, 3, 4, 5));
console.log(concat("a", "b", "c"));
console.log(first(1, 2, 3));
console.log(last(1, 2, 3, 4));
console.log(collect("Items", 1, 2, 3));
console.log(spread(10, 20, 30, 40));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("sum"),
        "expected sum in output. output: {output}"
    );
    assert!(
        output.contains("concat"),
        "expected concat in output. output: {output}"
    );
    assert!(
        output.contains("collect"),
        "expected collect in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow rest params"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_es5_default_params() {
    let source = r#"const greet = (name: string = "World") => "Hello, " + name;

const power = (base: number, exp: number = 2) => Math.pow(base, exp);

const configure = (host: string = "localhost", port: number = 8080) => {
    return { host, port };
};

const format = (value: number, prefix: string = "$", suffix: string = "") => {
    return prefix + value.toFixed(2) + suffix;
};

const createUser = (name: string, age: number = 0, active: boolean = true) => ({
    name,
    age,
    active
});

console.log(greet());
console.log(greet("Alice"));
console.log(power(2));
console.log(power(2, 10));
console.log(configure());
console.log(format(123.456));
console.log(createUser("Bob"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("greet"),
        "expected greet in output. output: {output}"
    );
    assert!(
        output.contains("power"),
        "expected power in output. output: {output}"
    );
    assert!(
        output.contains("configure"),
        "expected configure in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow default params"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_es5_destructuring_params() {
    let source = r#"const getFullName = ({ first, last }: { first: string; last: string }) =>
    first + " " + last;

const getCoords = ([x, y]: [number, number]) => ({ x, y });

const processUser = ({ name, age = 0 }: { name: string; age?: number }) => {
    return name + " is " + age + " years old";
};

const extractValues = ({ a, b, ...rest }: { a: number; b: number; [key: string]: number }) => {
    return { sum: a + b, rest };
};

const handleEvent = ({ type, target: { id } }: { type: string; target: { id: string } }) => {
    console.log(type + " on " + id);
};

console.log(getFullName({ first: "John", last: "Doe" }));
console.log(getCoords([10, 20]));
console.log(processUser({ name: "Alice" }));
console.log(extractValues({ a: 1, b: 2, c: 3, d: 4 }));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getFullName"),
        "expected getFullName in output. output: {output}"
    );
    assert!(
        output.contains("processUser"),
        "expected processUser in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow destructuring params"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_es5_class_property() {
    let source = r#"class Calculator {
    add = (a: number, b: number) => a + b;
    subtract = (a: number, b: number) => a - b;
    multiply = (a: number, b: number) => a * b;
    divide = (a: number, b: number) => b !== 0 ? a / b : 0;
}

class Formatter {
    prefix: string;
    suffix: string;

    constructor(prefix: string = "", suffix: string = "") {
        this.prefix = prefix;
        this.suffix = suffix;
    }

    format = (value: any) => this.prefix + String(value) + this.suffix;
    formatNumber = (n: number) => this.format(n.toFixed(2));
}

class Logger {
    static log = (message: string) => console.log("[LOG] " + message);
    static warn = (message: string) => console.warn("[WARN] " + message);
    static error = (message: string) => console.error("[ERROR] " + message);
}

const calc = new Calculator();
console.log(calc.add(1, 2));
console.log(calc.multiply(3, 4));

const fmt = new Formatter("$", " USD");
console.log(fmt.formatNumber(123.456));

Logger.log("Test message");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Calculator"),
        "expected Calculator in output. output: {output}"
    );
    assert!(
        output.contains("Formatter"),
        "expected Formatter in output. output: {output}"
    );
    assert!(
        output.contains("Logger"),
        "expected Logger in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow class property"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_es5_higher_order() {
    let source = r#"const createAdder = (n: number) => (x: number) => x + n;

const createMultiplier = (factor: number) => (x: number) => x * factor;

const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (x: A) => f(g(x));

const pipe = <T>(...fns: ((x: T) => T)[]) => (x: T) => fns.reduce((v, f) => f(v), x);

const curry = (fn: (a: number, b: number) => number) => (a: number) => (b: number) => fn(a, b);

const memoize = <T, R>(fn: (arg: T) => R) => {
    const cache = new Map<T, R>();
    return (arg: T) => {
        if (cache.has(arg)) return cache.get(arg)!;
        const result = fn(arg);
        cache.set(arg, result);
        return result;
    };
};

const add5 = createAdder(5);
const double = createMultiplier(2);
const addThenDouble = compose(double, add5);

console.log(add5(10));
console.log(double(7));
console.log(addThenDouble(3));

const increment = (x: number) => x + 1;
const triple = (x: number) => x * 3;
const pipeline = pipe(increment, double, triple);
console.log(pipeline(2));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createAdder"),
        "expected createAdder in output. output: {output}"
    );
    assert!(
        output.contains("compose"),
        "expected compose in output. output: {output}"
    );
    assert!(
        output.contains("memoize"),
        "expected memoize in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for higher order arrows"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_es5_callbacks() {
    let source = r#"const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
const sum = numbers.reduce((acc, n) => acc + n, 0);
const found = numbers.find(n => n > 5);
const allPositive = numbers.every(n => n > 0);
const hasNegative = numbers.some(n => n < 0);

const sorted = [...numbers].sort((a, b) => b - a);

const users = [
    { name: "Alice", age: 30 },
    { name: "Bob", age: 25 },
    { name: "Charlie", age: 35 }
];

const names = users.map(u => u.name);
const adults = users.filter(u => u.age >= 18);
const totalAge = users.reduce((sum, u) => sum + u.age, 0);
const youngest = users.reduce((min, u) => u.age < min.age ? u : min);

setTimeout(() => console.log("delayed"), 0);
Promise.resolve(42).then(n => n * 2).then(n => console.log(n));

console.log(doubled, evens, sum, found);
console.log(names, adults, totalAge, youngest);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("doubled"),
        "expected doubled in output. output: {output}"
    );
    assert!(
        output.contains("users"),
        "expected users in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for arrow callbacks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_arrow_es5_comprehensive() {
    let source = r#"// Comprehensive arrow function patterns for ES5 transform testing

// Expression body
const add = (a: number, b: number) => a + b;
const identity = <T>(x: T) => x;

// Block body
const process = (data: number[]) => {
    const result = data.map(x => x * 2);
    return result.filter(x => x > 5);
};

// Default parameters
const greet = (name: string = "World") => "Hello, " + name;
const configure = (host: string = "localhost", port: number = 8080) => ({ host, port });

// Rest parameters
const sum = (...nums: number[]) => nums.reduce((a, b) => a + b, 0);
const collect = (first: string, ...rest: string[]) => [first, ...rest];

// Destructuring parameters
const getPoint = ({ x, y }: { x: number; y: number }) => x + y;
const getFirst = ([a, b]: [number, number]) => a;

// This binding in class
class Timer {
    seconds = 0;

    tick = () => {
        this.seconds++;
        return this.seconds;
    };

    reset = () => {
        this.seconds = 0;
    };
}

// Higher-order functions
const createMultiplier = (factor: number) => (x: number) => x * factor;
const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (x: A) => f(g(x));

// Callbacks
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
const total = numbers.reduce((acc, n) => acc + n, 0);

// Async arrows
const fetchData = async (url: string) => {
    const response = await fetch(url);
    return response.json();
};

// Arrow IIFE
const result = ((x: number) => x * x)(5);

// Nested arrows
const outer = (a: number) => (b: number) => (c: number) => a + b + c;

// Arrow returning object
const createUser = (name: string, age: number) => ({ name, age, active: true });

// Generic arrow
const mapArray = <T, U>(arr: T[], fn: (x: T) => U) => arr.map(fn);

// Usage
console.log(add(1, 2));
console.log(process([1, 2, 3, 4, 5, 6]));
console.log(greet());
console.log(sum(1, 2, 3, 4, 5));
console.log(getPoint({ x: 10, y: 20 }));

const timer = new Timer();
console.log(timer.tick());
timer.reset();

const triple = createMultiplier(3);
console.log(triple(4));

console.log(doubled, evens, total);
console.log(result);
console.log(outer(1)(2)(3));
console.log(createUser("Alice", 30));
console.log(mapArray([1, 2, 3], x => x * 2));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("add"),
        "expected add in output. output: {output}"
    );
    assert!(
        output.contains("process"),
        "expected process in output. output: {output}"
    );
    assert!(
        output.contains("Timer"),
        "expected Timer class in output. output: {output}"
    );
    assert!(
        output.contains("createMultiplier"),
        "expected createMultiplier in output. output: {output}"
    );
    assert!(
        output.contains("fetchData"),
        "expected fetchData in output. output: {output}"
    );
    assert!(
        output.contains("mapArray"),
        "expected mapArray in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive arrow functions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 Template Literal Transform Source Map Tests
// =============================================================================

#[test]
fn test_source_map_template_literal_es5_basic() {
    let source = r#"const greeting = `Hello, World!`;
const simple = `Just a string`;
const empty = ``;
const withNewline = `Line 1
Line 2`;
console.log(greeting, simple, empty, withNewline);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("greeting"),
        "expected greeting in output. output: {output}"
    );
    assert!(
        output.contains("Hello"),
        "expected Hello in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic template literals"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_es5_expression() {
    let source = r#"const name = "Alice";
const age = 30;
const message = `Hello, ${name}!`;
const info = `${name} is ${age} years old`;
const calc = `Result: ${2 + 3 * 4}`;
const nested = `Outer ${`Inner ${name}`}`;
console.log(message, info, calc, nested);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("name"),
        "expected name in output. output: {output}"
    );
    assert!(
        output.contains("message"),
        "expected message in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for template expressions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_es5_nested() {
    let source = r#"const a = 1;
const b = 2;
const c = 3;
const deep = `Level 1: ${`Level 2: ${`Level 3: ${a + b + c}`}`}`;
const complex = `A=${a}, B=${b}, Sum=${a + b}, Product=${a * b}`;
const conditional = `Value: ${a > 0 ? `positive ${a}` : `negative ${a}`}`;
console.log(deep, complex, conditional);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("deep"),
        "expected deep in output. output: {output}"
    );
    assert!(
        output.contains("complex"),
        "expected complex in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested templates"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_es5_tagged() {
    let source = r#"function highlight(strings: TemplateStringsArray, ...values: any[]) {
    return strings.reduce((acc, str, i) => acc + str + (values[i] || ""), "");
}

function sql(strings: TemplateStringsArray, ...values: any[]) {
    return { query: strings.join("?"), params: values };
}

const name = "Bob";
const age = 25;

const highlighted = highlight`Name: ${name}, Age: ${age}`;
const query = sql`SELECT * FROM users WHERE name = ${name} AND age > ${age}`;

console.log(highlighted, query);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("highlight"),
        "expected highlight in output. output: {output}"
    );
    assert!(
        output.contains("sql"),
        "expected sql in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for tagged templates"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_es5_multiline() {
    let source = r#"const html = `
<div>
    <h1>Title</h1>
    <p>Content here</p>
</div>
`;

const code = `function example() {
    return 42;
}`;

const json = `{
    "name": "test",
    "value": 123
}`;

console.log(html, code, json);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("html"),
        "expected html in output. output: {output}"
    );
    assert!(
        output.contains("code"),
        "expected code in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiline templates"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_es5_function_call() {
    let source = r#"function getName(): string {
    return "Charlie";
}

function getAge(): number {
    return 28;
}

function format(s: string): string {
    return s.toUpperCase();
}

const msg1 = `Hello, ${getName()}!`;
const msg2 = `Age: ${getAge().toString()}`;
const msg3 = `Name: ${format(getName())}`;
const msg4 = `Combined: ${getName()} is ${getAge()}`;

console.log(msg1, msg2, msg3, msg4);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getName"),
        "expected getName in output. output: {output}"
    );
    assert!(
        output.contains("getAge"),
        "expected getAge in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for templates with function calls"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_es5_method_chain() {
    let source = r#"const str = "hello";
const arr = [1, 2, 3];

const msg1 = `Upper: ${str.toUpperCase()}`;
const msg2 = `Length: ${str.length}`;
const msg3 = `Replaced: ${str.replace("l", "L")}`;
const msg4 = `Joined: ${arr.join(", ")}`;
const msg5 = `Mapped: ${arr.map(x => x * 2).join("-")}`;
const msg6 = `Chained: ${str.toUpperCase().split("").reverse().join("")}`;

console.log(msg1, msg2, msg3, msg4, msg5, msg6);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("str"),
        "expected str in output. output: {output}"
    );
    assert!(
        output.contains("toUpperCase"),
        "expected toUpperCase in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for templates with method chains"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_es5_conditional() {
    let source = r#"const x = 10;
const y = 5;
const active = true;
const name: string | null = "David";

const msg1 = `Status: ${active ? "active" : "inactive"}`;
const msg2 = `Max: ${x > y ? x : y}`;
const msg3 = `Name: ${name || "Unknown"}`;
const msg4 = `Sign: ${x > 0 ? "positive" : x < 0 ? "negative" : "zero"}`;
const msg5 = `Check: ${x && y ? `Both truthy: ${x}, ${y}` : "Not both truthy"}`;

console.log(msg1, msg2, msg3, msg4, msg5);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("active"),
        "expected active in output. output: {output}"
    );
    assert!(
        output.contains("msg1"),
        "expected msg1 in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for templates with conditionals"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_es5_complex_expressions() {
    let source = r#"const items = [1, 2, 3, 4, 5];
const obj = { x: 10, y: 20 };

const msg1 = `Sum: ${items.reduce((a, b) => a + b, 0)}`;
const msg2 = `Total: ${obj.x + obj.y}`;
const msg3 = `Array: [${items.map(i => i * 2)}]`;
const msg4 = `Object: {x: ${obj.x}, y: ${obj.y}}`;
const msg5 = `Complex: ${items.filter(i => i > 2).map(i => i * 3).join(", ")}`;
const msg6 = `Spread: ${[...items, 6, 7].length}`;
const msg7 = `Destructured: ${(({ x, y }) => x + y)(obj)}`;

console.log(msg1, msg2, msg3, msg4, msg5, msg6, msg7);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("items"),
        "expected items in output. output: {output}"
    );
    assert!(
        output.contains("reduce"),
        "expected reduce in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for templates with complex expressions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_template_literal_es5_comprehensive() {
    let source = r#"// Comprehensive template literal patterns for ES5 transform testing

// Basic literals
const greeting = `Hello, World!`;
const empty = ``;

// Expression interpolation
const name = "Eve";
const age = 35;
const intro = `My name is ${name} and I am ${age} years old`;

// Multiple expressions
const a = 10;
const b = 20;
const math = `${a} + ${b} = ${a + b}, ${a} * ${b} = ${a * b}`;

// Nested templates
const nested = `Outer: ${`Inner: ${name.toUpperCase()}`}`;
const deepNested = `L1: ${`L2: ${`L3: ${a + b + 30}`}`}`;

// Tagged templates
function css(strings: TemplateStringsArray, ...values: any[]) {
    return strings.reduce((result, str, i) => result + str + (values[i] || ""), "");
}

function html(strings: TemplateStringsArray, ...values: any[]) {
    return strings.map((s, i) => s + (values[i] !== undefined ? values[i] : "")).join("");
}

const styles = css`
    .container {
        width: ${100}%;
        padding: ${10}px;
    }
`;

const markup = html`<div class="${"wrapper"}"><span>${name}</span></div>`;

// Multiline
const multiline = `
    This is a
    multiline
    template
`;

// Function calls in templates
function getTitle(): string { return "Dr."; }
function formatName(n: string): string { return n.toUpperCase(); }

const formal = `${getTitle()} ${formatName(name)}`;

// Method chains
const str = "hello world";
const processed = `Original: ${str}, Upper: ${str.toUpperCase()}, Length: ${str.length}`;

// Arrays and objects
const items = [1, 2, 3];
const obj = { x: 5, y: 10 };

const arrTemplate = `Items: ${items.join(", ")}, Sum: ${items.reduce((s, i) => s + i, 0)}`;
const objTemplate = `Point: (${obj.x}, ${obj.y})`;

// Conditionals
const status = true;
const conditional = `Status: ${status ? "active" : "inactive"}`;

// Class with template methods
class Formatter {
    prefix = ">>>";

    format(value: string) {
        return `${this.prefix} ${value}`;
    }

    wrap(value: string) {
        return `[${value}]`;
    }
}

const formatter = new Formatter();

// IIFE in template
const iife = `Result: ${((x: number) => x * x)(7)}`;

// Usage
console.log(greeting, intro, math);
console.log(nested, deepNested);
console.log(styles, markup);
console.log(multiline);
console.log(formal, processed);
console.log(arrTemplate, objTemplate);
console.log(conditional);
console.log(formatter.format("test"));
console.log(iife);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("greeting"),
        "expected greeting in output. output: {output}"
    );
    assert!(
        output.contains("intro"),
        "expected intro in output. output: {output}"
    );
    assert!(
        output.contains("css"),
        "expected css tagged template in output. output: {output}"
    );
    assert!(
        output.contains("html"),
        "expected html tagged template in output. output: {output}"
    );
    assert!(
        output.contains("Formatter"),
        "expected Formatter class in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive template literals"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 Class Static Block Transform Source Map Tests
// =============================================================================

#[test]
fn test_source_map_class_static_block_es5_basic() {
    let source = r#"class Counter {
    static count = 0;

    static {
        Counter.count = 10;
        console.log("Counter initialized");
    }

    increment() {
        Counter.count++;
    }
}

console.log(Counter.count);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter"),
        "expected Counter in output. output: {output}"
    );
    assert!(
        output.contains("count"),
        "expected count in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic static block"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_static_block_es5_multiple() {
    let source = r#"class Config {
    static host: string;
    static port: number;
    static protocol: string;

    static {
        Config.host = "localhost";
    }

    static {
        Config.port = 8080;
    }

    static {
        Config.protocol = "https";
    }

    static getUrl() {
        return Config.protocol + "://" + Config.host + ":" + Config.port;
    }
}

console.log(Config.getUrl());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Config"),
        "expected Config in output. output: {output}"
    );
    assert!(
        output.contains("host"),
        "expected host in output. output: {output}"
    );
    assert!(
        output.contains("port"),
        "expected port in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple static blocks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_static_block_es5_init_order() {
    let source = r#"const log: string[] = [];

class InitOrder {
    static a = (log.push("field a"), 1);

    static {
        log.push("block 1");
    }

    static b = (log.push("field b"), 2);

    static {
        log.push("block 2");
    }

    static c = (log.push("field c"), 3);

    static {
        log.push("block 3");
        console.log("Final order:", log.join(", "));
    }
}

console.log(InitOrder.a, InitOrder.b, InitOrder.c);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("InitOrder"),
        "expected InitOrder in output. output: {output}"
    );
    assert!(
        output.contains("log"),
        "expected log in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for init order static blocks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_static_block_es5_private_access() {
    let source = r#"class SecretHolder {
    static #secret = "initial";
    static #counter = 0;

    static {
        SecretHolder.#secret = "configured";
        SecretHolder.#counter = 100;
    }

    static getSecret() {
        return SecretHolder.#secret;
    }

    static getCounter() {
        return SecretHolder.#counter;
    }
}

console.log(SecretHolder.getSecret(), SecretHolder.getCounter());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("SecretHolder"),
        "expected SecretHolder in output. output: {output}"
    );
    assert!(
        output.contains("getSecret"),
        "expected getSecret in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private access static blocks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_static_block_es5_super_access() {
    let source = r#"class Base {
    static baseValue = 10;

    static getBaseValue() {
        return Base.baseValue;
    }
}

class Derived extends Base {
    static derivedValue: number;

    static {
        Derived.derivedValue = Derived.baseValue * 2;
        console.log("Derived initialized with:", Derived.derivedValue);
    }

    static getCombined() {
        return Derived.baseValue + Derived.derivedValue;
    }
}

console.log(Derived.getCombined());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Base"),
        "expected Base in output. output: {output}"
    );
    assert!(
        output.contains("Derived"),
        "expected Derived in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for super access static blocks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_static_block_es5_static_field_init() {
    let source = r#"class Database {
    static connection: any;
    static config: { host: string; port: number };
    static ready = false;

    static {
        Database.config = {
            host: "localhost",
            port: 5432
        };
    }

    static {
        Database.connection = {
            config: Database.config,
            connected: false
        };
    }

    static {
        Database.ready = true;
        console.log("Database ready:", Database.config.host);
    }

    static connect() {
        if (Database.ready) {
            Database.connection.connected = true;
        }
    }
}

Database.connect();
console.log(Database.connection);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Database"),
        "expected Database in output. output: {output}"
    );
    assert!(
        output.contains("connection"),
        "expected connection in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static field init blocks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_static_block_es5_computed_props() {
    let source = r#"const KEY1 = "config1";
const KEY2 = "config2";

class ConfigMap {
    static [KEY1]: string;
    static [KEY2]: number;
    static data: Record<string, any> = {};

    static {
        ConfigMap[KEY1] = "value1";
        ConfigMap[KEY2] = 42;
        ConfigMap.data[KEY1] = ConfigMap[KEY1];
        ConfigMap.data[KEY2] = ConfigMap[KEY2];
    }

    static get(key: string) {
        return ConfigMap.data[key];
    }
}

console.log(ConfigMap.get(KEY1), ConfigMap.get(KEY2));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ConfigMap"),
        "expected ConfigMap in output. output: {output}"
    );
    assert!(
        output.contains("KEY1"),
        "expected KEY1 in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for computed props static blocks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_static_block_es5_async_patterns() {
    let source = r#"class AsyncLoader {
    static data: any[] = [];
    static initialized = false;

    static {
        const init = async () => {
            AsyncLoader.data = [1, 2, 3];
            AsyncLoader.initialized = true;
        };
        init();
    }

    static async load() {
        if (!AsyncLoader.initialized) {
            await new Promise(r => setTimeout(r, 100));
        }
        return AsyncLoader.data;
    }
}

class EventEmitter {
    static handlers: Map<string, Function[]> = new Map();

    static {
        EventEmitter.handlers.set("init", []);
        EventEmitter.handlers.set("load", []);
    }

    static on(event: string, handler: Function) {
        const handlers = EventEmitter.handlers.get(event) || [];
        handlers.push(handler);
        EventEmitter.handlers.set(event, handlers);
    }
}

console.log(AsyncLoader.data, EventEmitter.handlers);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AsyncLoader"),
        "expected AsyncLoader in output. output: {output}"
    );
    assert!(
        output.contains("EventEmitter"),
        "expected EventEmitter in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async patterns static blocks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_static_block_es5_error_handling() {
    let source = r#"class SafeInit {
    static value: number;
    static error: Error | null = null;

    static {
        try {
            SafeInit.value = parseInt("42");
            if (isNaN(SafeInit.value)) {
                throw new Error("Invalid number");
            }
        } catch (e) {
            SafeInit.error = e as Error;
            SafeInit.value = 0;
        }
    }

    static getValue() {
        if (SafeInit.error) {
            console.error("Initialization failed:", SafeInit.error.message);
            return null;
        }
        return SafeInit.value;
    }
}

class Validator {
    static rules: Map<string, Function> = new Map();
    static errors: string[] = [];

    static {
        try {
            Validator.rules.set("required", (v: any) => v != null);
            Validator.rules.set("minLength", (v: string) => v.length >= 3);
        } catch (e) {
            Validator.errors.push("Failed to initialize rules");
        }
    }
}

console.log(SafeInit.getValue(), Validator.rules.size);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("SafeInit"),
        "expected SafeInit in output. output: {output}"
    );
    assert!(
        output.contains("Validator"),
        "expected Validator in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for error handling static blocks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_class_static_block_es5_comprehensive() {
    let source = r#"// Comprehensive class static block patterns for ES5 transform testing

// Basic static block
class Counter {
    static count = 0;

    static {
        Counter.count = 100;
    }
}

// Multiple blocks with init order
const initLog: string[] = [];

class MultiBlock {
    static a = (initLog.push("a"), 1);

    static {
        initLog.push("block1");
    }

    static b = (initLog.push("b"), 2);

    static {
        initLog.push("block2");
    }
}

// Private field access
class PrivateAccess {
    static #privateValue = 0;

    static {
        PrivateAccess.#privateValue = 42;
    }

    static getValue() {
        return PrivateAccess.#privateValue;
    }
}

// Inheritance
class Parent {
    static parentValue = 10;
}

class Child extends Parent {
    static childValue: number;

    static {
        Child.childValue = Child.parentValue * 2;
    }
}

// Complex initialization
class ComplexInit {
    static config: { host: string; port: number };
    static connections: Map<string, any>;
    static ready = false;

    static {
        ComplexInit.config = {
            host: "localhost",
            port: 3000
        };
    }

    static {
        ComplexInit.connections = new Map();
        ComplexInit.connections.set("default", ComplexInit.config);
    }

    static {
        ComplexInit.ready = true;
        console.log("ComplexInit ready");
    }
}

// Error handling
class SafeLoader {
    static data: any[] = [];
    static error: Error | null = null;

    static {
        try {
            SafeLoader.data = [1, 2, 3];
        } catch (e) {
            SafeLoader.error = e as Error;
        }
    }
}

// Async initialization pattern
class AsyncInit {
    static promise: Promise<void>;

    static {
        AsyncInit.promise = (async () => {
            await Promise.resolve();
            console.log("Async init complete");
        })();
    }
}

// Computed property access
const KEY = "dynamicKey";

class DynamicClass {
    static [KEY]: string;

    static {
        DynamicClass[KEY] = "dynamic value";
    }
}

// Usage
console.log(Counter.count);
console.log(initLog);
console.log(PrivateAccess.getValue());
console.log(Child.childValue);
console.log(ComplexInit.ready);
console.log(SafeLoader.data);
console.log(DynamicClass[KEY]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter"),
        "expected Counter in output. output: {output}"
    );
    assert!(
        output.contains("MultiBlock"),
        "expected MultiBlock in output. output: {output}"
    );
    assert!(
        output.contains("PrivateAccess"),
        "expected PrivateAccess in output. output: {output}"
    );
    assert!(
        output.contains("Parent"),
        "expected Parent in output. output: {output}"
    );
    assert!(
        output.contains("Child"),
        "expected Child in output. output: {output}"
    );
    assert!(
        output.contains("ComplexInit"),
        "expected ComplexInit in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive static blocks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 Decorator Composition Transform Source Map Tests
// =============================================================================

#[test]
fn test_source_map_decorator_composition_es5_chained() {
    let source = r#"function log(target: any, key: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        console.log("Calling:", key);
        return original.apply(this, args);
    };
    return descriptor;
}

function measure(target: any, key: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        const start = Date.now();
        const result = original.apply(this, args);
        console.log("Duration:", Date.now() - start);
        return result;
    };
    return descriptor;
}

function validate(target: any, key: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        if (args.some(a => a == null)) throw new Error("Invalid args");
        return original.apply(this, args);
    };
    return descriptor;
}

class Service {
    @log
    @measure
    @validate
    process(data: string) {
        return data.toUpperCase();
    }
}

const service = new Service();
console.log(service.process("test"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Service"),
        "expected Service in output. output: {output}"
    );
    assert!(
        output.contains("process"),
        "expected process in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for chained decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_composition_es5_factory() {
    let source = r#"function log(prefix: string) {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            console.log(prefix, key, args);
            return original.apply(this, args);
        };
        return descriptor;
    };
}

function retry(times: number) {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = async function(...args: any[]) {
            for (let i = 0; i < times; i++) {
                try {
                    return await original.apply(this, args);
                } catch (e) {
                    if (i === times - 1) throw e;
                }
            }
        };
        return descriptor;
    };
}

function cache(ttl: number) {
    const store = new Map<string, { value: any; expires: number }>();
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            const cacheKey = JSON.stringify(args);
            const cached = store.get(cacheKey);
            if (cached && cached.expires > Date.now()) return cached.value;
            const result = original.apply(this, args);
            store.set(cacheKey, { value: result, expires: Date.now() + ttl });
            return result;
        };
        return descriptor;
    };
}

class Api {
    @log("[API]")
    @retry(3)
    @cache(5000)
    async fetchData(id: number) {
        return { id, data: "result" };
    }
}

const api = new Api();
api.fetchData(1).then(console.log);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Api"),
        "expected Api in output. output: {output}"
    );
    assert!(
        output.contains("fetchData"),
        "expected fetchData in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for factory decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_composition_es5_metadata() {
    let source = r#"const metadata = new Map<any, Map<string, any>>();

function setMetadata(key: string, value: any) {
    return function(target: any, propertyKey?: string) {
        let targetMeta = metadata.get(target) || new Map();
        targetMeta.set(key, value);
        metadata.set(target, targetMeta);
    };
}

function getMetadata(key: string, target: any): any {
    const targetMeta = metadata.get(target);
    return targetMeta?.get(key);
}

@setMetadata("version", "1.0.0")
@setMetadata("author", "Team")
class Component {
    @setMetadata("required", true)
    name: string = "";

    @setMetadata("type", "handler")
    @setMetadata("async", true)
    async handleEvent(event: any) {
        console.log(event);
    }
}

const comp = new Component();
console.log(getMetadata("version", Component));
console.log(getMetadata("author", Component));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Component"),
        "expected Component in output. output: {output}"
    );
    assert!(
        output.contains("metadata"),
        "expected metadata in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for metadata decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
#[ignore = "INFINITE LOOP - ES5 class transform with chained parameter decorators on method parameters causes unbounded recursion in ClassES5Emitter."]
fn test_source_map_decorator_composition_es5_method_params() {
    let source = r#"const paramMetadata = new Map<any, Map<string, any[]>>();

function param(name: string) {
    return function(target: any, methodKey: string, paramIndex: number) {
        let methodMeta = paramMetadata.get(target) || new Map();
        let params = methodMeta.get(methodKey) || [];
        params[paramIndex] = name;
        methodMeta.set(methodKey, params);
        paramMetadata.set(target, methodMeta);
    };
}

function inject(token: string) {
    return function(target: any, methodKey: string, paramIndex: number) {
        console.log("Inject", token, "at index", paramIndex);
    };
}

function validate(schema: any) {
    return function(target: any, methodKey: string, paramIndex: number) {
        console.log("Validate param", paramIndex, "with schema");
    };
}

class UserService {
    createUser(
        @param("name") @validate({ type: "string" }) name: string,
        @param("email") @validate({ type: "email" }) email: string,
        @param("age") @validate({ type: "number" }) age: number
    ) {
        return { name, email, age };
    }

    findUser(@inject("db") db: any, @param("id") id: number) {
        return db.find(id);
    }
}

const userService = new UserService();
console.log(userService.createUser("John", "john@example.com", 30));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("UserService"),
        "expected UserService in output. output: {output}"
    );
    assert!(
        output.contains("createUser"),
        "expected createUser in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for method param decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_composition_es5_accessor() {
    let source = r#"function observable(target: any, key: string, descriptor: PropertyDescriptor) {
    const getter = descriptor.get;
    const setter = descriptor.set;

    if (setter) {
        descriptor.set = function(value: any) {
            console.log("Setting", key, "to", value);
            setter.call(this, value);
        };
    }

    if (getter) {
        descriptor.get = function() {
            const value = getter.call(this);
            console.log("Getting", key, "=", value);
            return value;
        };
    }

    return descriptor;
}

function lazy(target: any, key: string, descriptor: PropertyDescriptor) {
    const getter = descriptor.get;
    const cacheKey = Symbol(key);

    descriptor.get = function() {
        if (!(this as any)[cacheKey]) {
            (this as any)[cacheKey] = getter?.call(this);
        }
        return (this as any)[cacheKey];
    };

    return descriptor;
}

class Config {
    private _value = 0;

    @observable
    @lazy
    get computedValue() {
        return this._value * 2;
    }

    @observable
    set value(v: number) {
        this._value = v;
    }

    get value() {
        return this._value;
    }
}

const config = new Config();
config.value = 5;
console.log(config.computedValue);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Config"),
        "expected Config in output. output: {output}"
    );
    assert!(
        output.contains("observable"),
        "expected observable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for accessor decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_composition_es5_multiple_targets() {
    let source = r#"function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}

function enumerable(value: boolean) {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
        return descriptor;
    };
}

function readonly(target: any, key: string) {
    Object.defineProperty(target, key, { writable: false });
}

@sealed
class Person {
    @readonly
    id: number = 1;

    name: string = "";

    @enumerable(false)
    get fullInfo() {
        return this.id + ": " + this.name;
    }

    @enumerable(true)
    greet() {
        return "Hello, " + this.name;
    }
}

const person = new Person();
person.name = "Alice";
console.log(person.greet());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Person"),
        "expected Person in output. output: {output}"
    );
    assert!(
        output.contains("sealed"),
        "expected sealed in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple target decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_composition_es5_conditional() {
    let source = r#"const isProduction = false;
const enableLogging = true;

function conditionalLog(target: any, key: string, descriptor: PropertyDescriptor) {
    if (!enableLogging) return descriptor;

    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        console.log("Calling:", key);
        return original.apply(this, args);
    };
    return descriptor;
}

function devOnly(target: any, key: string, descriptor: PropertyDescriptor) {
    if (isProduction) {
        descriptor.value = function() {
            throw new Error("Not available in production");
        };
    }
    return descriptor;
}

function deprecated(message: string) {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            console.warn("Deprecated:", message);
            return original.apply(this, args);
        };
        return descriptor;
    };
}

class FeatureService {
    @conditionalLog
    @devOnly
    debugInfo() {
        return { env: "development", debug: true };
    }

    @conditionalLog
    @deprecated("Use newMethod instead")
    oldMethod() {
        return "old";
    }

    @conditionalLog
    newMethod() {
        return "new";
    }
}

const service = new FeatureService();
console.log(service.debugInfo());
console.log(service.newMethod());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("FeatureService"),
        "expected FeatureService in output. output: {output}"
    );
    assert!(
        output.contains("deprecated"),
        "expected deprecated in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for conditional decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_composition_es5_generic() {
    let source = r#"function typed<T>(type: new () => T) {
    return function(target: any, key: string) {
        console.log("Property", key, "is typed as", type.name);
    };
}

function transform<T, U>(fn: (value: T) => U) {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = function(input: T): U {
            const result = original.call(this, input);
            return fn(result);
        };
        return descriptor;
    };
}

function collect<T>() {
    const items: T[] = [];
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = function(...args: any[]): T {
            const result = original.apply(this, args);
            items.push(result);
            return result;
        };
        return descriptor;
    };
}

class DataProcessor {
    @typed(String)
    name: string = "";

    @transform((x: number) => x.toString())
    @collect<string>()
    process(value: number) {
        return value * 2;
    }
}

const processor = new DataProcessor();
console.log(processor.process(5));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataProcessor"),
        "expected DataProcessor in output. output: {output}"
    );
    assert!(
        output.contains("transform"),
        "expected transform in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generic decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_decorator_composition_es5_inheritance() {
    let source = r#"function logMethod(target: any, key: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        console.log("Method:", key, "called on", this.constructor.name);
        return original.apply(this, args);
    };
    return descriptor;
}

function track(target: any, key: string) {
    console.log("Tracking property:", key);
}

abstract class BaseEntity {
    @track
    id: number = 0;

    @logMethod
    save() {
        console.log("Saving entity", this.id);
    }
}

class User extends BaseEntity {
    @track
    name: string = "";

    @logMethod
    save() {
        console.log("Saving user", this.name);
        super.save();
    }

    @logMethod
    validate() {
        return this.name.length > 0;
    }
}

class Admin extends User {
    @track
    role: string = "admin";

    @logMethod
    save() {
        console.log("Saving admin with role", this.role);
        super.save();
    }
}

const admin = new Admin();
admin.name = "John";
admin.save();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("BaseEntity"),
        "expected BaseEntity in output. output: {output}"
    );
    assert!(
        output.contains("User"),
        "expected User in output. output: {output}"
    );
    assert!(
        output.contains("Admin"),
        "expected Admin in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for inheritance decorators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
#[ignore = "INFINITE LOOP - ES5 class transform with complex decorator patterns causes unbounded recursion in ClassES5Emitter. Issue involves async methods with parameter decorators and accessor decorators with observable patterns. Likely in emit_expression/emit_statement mutual recursion path."]
fn test_source_map_decorator_composition_es5_comprehensive() {
    let source = r#"// Comprehensive decorator composition patterns for ES5 transform testing

// Metadata storage
const metadata = new Map<any, Map<string, any>>();

// Basic decorators
function log(target: any, key: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        console.log("Call:", key);
        return original.apply(this, args);
    };
    return descriptor;
}

function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}

// Factory decorators
function prefix(p: string) {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            return p + original.apply(this, args);
        };
        return descriptor;
    };
}

function retry(times: number) {
    return function(target: any, key: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = async function(...args: any[]) {
            for (let i = 0; i < times; i++) {
                try { return await original.apply(this, args); }
                catch (e) { if (i === times - 1) throw e; }
            }
        };
        return descriptor;
    };
}

// Metadata decorators
function setMeta(key: string, value: any) {
    return function(target: any) {
        let targetMeta = metadata.get(target) || new Map();
        targetMeta.set(key, value);
        metadata.set(target, targetMeta);
    };
}

// Property decorator
function track(target: any, key: string) {
    console.log("Tracking:", key);
}

// Parameter decorator
function param(name: string) {
    return function(target: any, methodKey: string, index: number) {
        console.log("Param", name, "at", index);
    };
}

// Accessor decorator
function observable(target: any, key: string, descriptor: PropertyDescriptor) {
    const getter = descriptor.get;
    descriptor.get = function() {
        console.log("Access:", key);
        return getter?.call(this);
    };
    return descriptor;
}

// Comprehensive class with all decorator types
@sealed
@setMeta("version", "1.0")
@setMeta("author", "Team")
class ComplexService {
    @track
    id: number = 0;

    @track
    name: string = "";

    private _status = "idle";

    @observable
    get status() {
        return this._status;
    }

    set status(v: string) {
        this._status = v;
    }

    @log
    @prefix("[INFO] ")
    getMessage() {
        return "Hello from " + this.name;
    }

    @log
    @retry(3)
    async fetchData(@param("url") url: string) {
        return { url, data: "result" };
    }

    @log
    process(
        @param("input") input: string,
        @param("options") options: any
    ) {
        return input.toUpperCase();
    }
}

// Inheritance with decorators
abstract class BaseService {
    @track
    baseId: number = 0;

    @log
    init() {
        console.log("Init base");
    }
}

class ChildService extends BaseService {
    @track
    childId: number = 0;

    @log
    init() {
        super.init();
        console.log("Init child");
    }
}

// Usage
const service = new ComplexService();
service.name = "Test";
console.log(service.getMessage());
console.log(service.status);

const child = new ChildService();
child.init();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ComplexService"),
        "expected ComplexService in output. output: {output}"
    );
    assert!(
        output.contains("BaseService"),
        "expected BaseService in output. output: {output}"
    );
    assert!(
        output.contains("ChildService"),
        "expected ChildService in output. output: {output}"
    );
    assert!(
        output.contains("log"),
        "expected log decorator in output. output: {output}"
    );
    assert!(
        output.contains("sealed"),
        "expected sealed decorator in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive decorator composition"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 Private Method Transform Source Map Tests
// =============================================================================

#[test]
fn test_source_map_private_method_es5_instance_basic() {
    let source = r#"class Calculator {
    #add(a: number, b: number): number {
        return a + b;
    }

    #subtract(a: number, b: number): number {
        return a - b;
    }

    #multiply(a: number, b: number): number {
        return a * b;
    }

    calculate(op: string, a: number, b: number): number {
        switch (op) {
            case "+": return this.#add(a, b);
            case "-": return this.#subtract(a, b);
            case "*": return this.#multiply(a, b);
            default: return 0;
        }
    }
}

const calc = new Calculator();
console.log(calc.calculate("+", 5, 3));
console.log(calc.calculate("-", 10, 4));
console.log(calc.calculate("*", 6, 7));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Calculator"),
        "expected Calculator in output. output: {output}"
    );
    assert!(
        output.contains("calculate"),
        "expected calculate in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic private methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_method_es5_static() {
    let source = r#"class IdGenerator {
    static #counter = 0;

    static #generateId(): string {
        IdGenerator.#counter++;
        return "id_" + IdGenerator.#counter;
    }

    static #formatId(id: string): string {
        return "[" + id + "]";
    }

    static #validateId(id: string): boolean {
        return id.startsWith("id_");
    }

    static createId(): string {
        const id = IdGenerator.#generateId();
        if (IdGenerator.#validateId(id)) {
            return IdGenerator.#formatId(id);
        }
        return "";
    }

    static getCount(): number {
        return IdGenerator.#counter;
    }
}

console.log(IdGenerator.createId());
console.log(IdGenerator.createId());
console.log(IdGenerator.getCount());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("IdGenerator"),
        "expected IdGenerator in output. output: {output}"
    );
    assert!(
        output.contains("createId"),
        "expected createId in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static private methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_method_es5_accessor() {
    let source = r#"class SecureData {
    #data: string = "";
    #accessCount = 0;

    get #internalData(): string {
        this.#accessCount++;
        return this.#data;
    }

    set #internalData(value: string) {
        this.#data = value.trim();
    }

    get value(): string {
        return this.#internalData;
    }

    set value(v: string) {
        this.#internalData = v;
    }

    get accessCount(): number {
        return this.#accessCount;
    }
}

class CachedValue {
    #cache: Map<string, any> = new Map();

    get #cacheSize(): number {
        return this.#cache.size;
    }

    #getCached(key: string): any {
        return this.#cache.get(key);
    }

    #setCached(key: string, value: any): void {
        this.#cache.set(key, value);
    }

    store(key: string, value: any): void {
        this.#setCached(key, value);
    }

    retrieve(key: string): any {
        return this.#getCached(key);
    }

    get size(): number {
        return this.#cacheSize;
    }
}

const data = new SecureData();
data.value = "  hello  ";
console.log(data.value);
console.log(data.accessCount);

const cache = new CachedValue();
cache.store("key1", "value1");
console.log(cache.retrieve("key1"));
console.log(cache.size);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("SecureData"),
        "expected SecureData in output. output: {output}"
    );
    assert!(
        output.contains("CachedValue"),
        "expected CachedValue in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private accessor methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_method_es5_inheritance() {
    let source = r#"class BaseLogger {
    #prefix = "[BASE]";

    #formatMessage(msg: string): string {
        return this.#prefix + " " + msg;
    }

    log(msg: string): void {
        console.log(this.#formatMessage(msg));
    }
}

class ChildLogger extends BaseLogger {
    #childPrefix = "[CHILD]";

    #formatChildMessage(msg: string): string {
        return this.#childPrefix + " " + msg;
    }

    logChild(msg: string): void {
        console.log(this.#formatChildMessage(msg));
    }

    logBoth(msg: string): void {
        this.log(msg);
        this.logChild(msg);
    }
}

class GrandchildLogger extends ChildLogger {
    #level = "DEBUG";

    #addLevel(msg: string): string {
        return "[" + this.#level + "] " + msg;
    }

    debug(msg: string): void {
        const formatted = this.#addLevel(msg);
        this.logBoth(formatted);
    }
}

const logger = new GrandchildLogger();
logger.debug("Test message");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("BaseLogger"),
        "expected BaseLogger in output. output: {output}"
    );
    assert!(
        output.contains("ChildLogger"),
        "expected ChildLogger in output. output: {output}"
    );
    assert!(
        output.contains("GrandchildLogger"),
        "expected GrandchildLogger in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private methods with inheritance"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_method_es5_async() {
    let source = r#"class AsyncService {
    #baseUrl = "https://api.example.com";

    async #fetch(endpoint: string): Promise<any> {
        const url = this.#baseUrl + endpoint;
        const response = await fetch(url);
        return response.json();
    }

    async #processData(data: any): Promise<any> {
        await new Promise(r => setTimeout(r, 100));
        return { processed: true, data };
    }

    async #validate(data: any): Promise<boolean> {
        return data != null;
    }

    async getData(endpoint: string): Promise<any> {
        const raw = await this.#fetch(endpoint);
        if (await this.#validate(raw)) {
            return this.#processData(raw);
        }
        return null;
    }
}

class AsyncQueue {
    #queue: Promise<void> = Promise.resolve();

    async #runTask(task: () => Promise<void>): Promise<void> {
        await task();
    }

    async enqueue(task: () => Promise<void>): Promise<void> {
        this.#queue = this.#queue.then(() => this.#runTask(task));
        await this.#queue;
    }
}

const service = new AsyncService();
service.getData("/users").then(console.log);

const queue = new AsyncQueue();
queue.enqueue(async () => console.log("Task 1"));
queue.enqueue(async () => console.log("Task 2"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AsyncService"),
        "expected AsyncService in output. output: {output}"
    );
    assert!(
        output.contains("AsyncQueue"),
        "expected AsyncQueue in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async private methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_method_es5_generator() {
    let source = r#"class NumberGenerator {
    #start: number;
    #end: number;

    constructor(start: number, end: number) {
        this.#start = start;
        this.#end = end;
    }

    *#range(): Generator<number> {
        for (let i = this.#start; i <= this.#end; i++) {
            yield i;
        }
    }

    *#evens(): Generator<number> {
        for (const n of this.#range()) {
            if (n % 2 === 0) yield n;
        }
    }

    *#odds(): Generator<number> {
        for (const n of this.#range()) {
            if (n % 2 !== 0) yield n;
        }
    }

    getEvens(): number[] {
        return [...this.#evens()];
    }

    getOdds(): number[] {
        return [...this.#odds()];
    }

    getAll(): number[] {
        return [...this.#range()];
    }
}

const gen = new NumberGenerator(1, 10);
console.log(gen.getAll());
console.log(gen.getEvens());
console.log(gen.getOdds());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("NumberGenerator"),
        "expected NumberGenerator in output. output: {output}"
    );
    assert!(
        output.contains("getEvens"),
        "expected getEvens in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator private methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_method_es5_with_fields() {
    let source = r#"class BankAccount {
    #balance: number = 0;
    #transactions: string[] = [];
    #accountId: string;

    constructor(id: string, initial: number) {
        this.#accountId = id;
        this.#balance = initial;
        this.#logTransaction("INIT", initial);
    }

    #logTransaction(type: string, amount: number): void {
        this.#transactions.push(type + ": " + amount);
    }

    #validateAmount(amount: number): boolean {
        return amount > 0;
    }

    #canWithdraw(amount: number): boolean {
        return this.#balance >= amount;
    }

    deposit(amount: number): boolean {
        if (!this.#validateAmount(amount)) return false;
        this.#balance += amount;
        this.#logTransaction("DEP", amount);
        return true;
    }

    withdraw(amount: number): boolean {
        if (!this.#validateAmount(amount)) return false;
        if (!this.#canWithdraw(amount)) return false;
        this.#balance -= amount;
        this.#logTransaction("WTH", amount);
        return true;
    }

    getBalance(): number {
        return this.#balance;
    }

    getHistory(): string[] {
        return [...this.#transactions];
    }
}

const account = new BankAccount("ACC001", 100);
account.deposit(50);
account.withdraw(30);
console.log(account.getBalance());
console.log(account.getHistory());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("BankAccount"),
        "expected BankAccount in output. output: {output}"
    );
    assert!(
        output.contains("deposit"),
        "expected deposit in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private methods with fields"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_method_es5_chained_calls() {
    let source = r#"class StringBuilder {
    #value = "";

    #append(str: string): this {
        this.#value += str;
        return this;
    }

    #prepend(str: string): this {
        this.#value = str + this.#value;
        return this;
    }

    #wrap(prefix: string, suffix: string): this {
        this.#value = prefix + this.#value + suffix;
        return this;
    }

    #transform(fn: (s: string) => string): this {
        this.#value = fn(this.#value);
        return this;
    }

    add(str: string): this {
        return this.#append(str);
    }

    addBefore(str: string): this {
        return this.#prepend(str);
    }

    surround(prefix: string, suffix: string): this {
        return this.#wrap(prefix, suffix);
    }

    apply(fn: (s: string) => string): this {
        return this.#transform(fn);
    }

    build(): string {
        return this.#value;
    }
}

const result = new StringBuilder()
    .add("Hello")
    .add(" ")
    .add("World")
    .surround("[", "]")
    .apply(s => s.toUpperCase())
    .build();

console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("StringBuilder"),
        "expected StringBuilder in output. output: {output}"
    );
    assert!(
        output.contains("build"),
        "expected build in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for chained private method calls"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_method_es5_parameters() {
    let source = r#"class ParameterHandler {
    #processDefaults(a: number = 0, b: string = "default"): string {
        return b + ": " + a;
    }

    #processRest(...items: number[]): number {
        return items.reduce((sum, n) => sum + n, 0);
    }

    #processDestructured({ x, y }: { x: number; y: number }): number {
        return x + y;
    }

    #processArrayDestructured([first, second]: [string, string]): string {
        return first + " and " + second;
    }

    #processGeneric<T>(value: T, transform: (v: T) => string): string {
        return transform(value);
    }

    withDefaults(a?: number, b?: string): string {
        return this.#processDefaults(a, b);
    }

    withRest(...nums: number[]): number {
        return this.#processRest(...nums);
    }

    withObject(obj: { x: number; y: number }): number {
        return this.#processDestructured(obj);
    }

    withArray(arr: [string, string]): string {
        return this.#processArrayDestructured(arr);
    }

    withGeneric<T>(val: T, fn: (v: T) => string): string {
        return this.#processGeneric(val, fn);
    }
}

const handler = new ParameterHandler();
console.log(handler.withDefaults());
console.log(handler.withDefaults(42, "custom"));
console.log(handler.withRest(1, 2, 3, 4, 5));
console.log(handler.withObject({ x: 10, y: 20 }));
console.log(handler.withArray(["hello", "world"]));
console.log(handler.withGeneric(123, n => n.toString()));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ParameterHandler"),
        "expected ParameterHandler in output. output: {output}"
    );
    assert!(
        output.contains("withDefaults"),
        "expected withDefaults in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private methods with parameters"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

#[test]
fn test_source_map_private_method_es5_comprehensive() {
    let source = r#"// Comprehensive private method patterns for ES5 transform testing

// Basic instance private methods
class Counter {
    #count = 0;

    #increment(): void {
        this.#count++;
    }

    #decrement(): void {
        this.#count--;
    }

    inc(): void { this.#increment(); }
    dec(): void { this.#decrement(); }
    get value(): number { return this.#count; }
}

// Static private methods
class Utils {
    static #formatNumber(n: number): string {
        return n.toFixed(2);
    }

    static #validateInput(input: any): boolean {
        return input != null;
    }

    static format(n: number): string {
        return Utils.#formatNumber(n);
    }

    static isValid(input: any): boolean {
        return Utils.#validateInput(input);
    }
}

// Private accessors
class Config {
    #settings: Map<string, any> = new Map();

    get #size(): number {
        return this.#settings.size;
    }

    #get(key: string): any {
        return this.#settings.get(key);
    }

    #set(key: string, value: any): void {
        this.#settings.set(key, value);
    }

    set(key: string, value: any): void {
        this.#set(key, value);
    }

    get(key: string): any {
        return this.#get(key);
    }

    get count(): number {
        return this.#size;
    }
}

// Async private methods
class DataLoader {
    #cache: Map<string, any> = new Map();

    async #fetchFromApi(url: string): Promise<any> {
        return { url, data: "mock" };
    }

    async #processResponse(response: any): Promise<any> {
        return { processed: true, ...response };
    }

    async load(url: string): Promise<any> {
        if (this.#cache.has(url)) {
            return this.#cache.get(url);
        }
        const response = await this.#fetchFromApi(url);
        const processed = await this.#processResponse(response);
        this.#cache.set(url, processed);
        return processed;
    }
}

// Private methods with inheritance
class Animal {
    #name: string;

    constructor(name: string) {
        this.#name = name;
    }

    #formatName(): string {
        return "[" + this.#name + "]";
    }

    describe(): string {
        return "Animal: " + this.#formatName();
    }
}

class Dog extends Animal {
    #breed: string;

    constructor(name: string, breed: string) {
        super(name);
        this.#breed = breed;
    }

    #formatBreed(): string {
        return "(" + this.#breed + ")";
    }

    describe(): string {
        return super.describe() + " " + this.#formatBreed();
    }
}

// Usage
const counter = new Counter();
counter.inc();
counter.inc();
console.log(counter.value);

console.log(Utils.format(3.14159));
console.log(Utils.isValid("test"));

const config = new Config();
config.set("key", "value");
console.log(config.get("key"));
console.log(config.count);

const loader = new DataLoader();
loader.load("/api/data").then(console.log);

const dog = new Dog("Rex", "German Shepherd");
console.log(dog.describe());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter"),
        "expected Counter in output. output: {output}"
    );
    assert!(
        output.contains("Utils"),
        "expected Utils in output. output: {output}"
    );
    assert!(
        output.contains("Config"),
        "expected Config in output. output: {output}"
    );
    assert!(
        output.contains("DataLoader"),
        "expected DataLoader in output. output: {output}"
    );
    assert!(
        output.contains("Animal"),
        "expected Animal in output. output: {output}"
    );
    assert!(
        output.contains("Dog"),
        "expected Dog in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive private methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS - ASYNC GENERATOR PATTERNS
// =============================================================================
// Tests for async generator patterns with ES5 target to verify source maps
// work correctly with async generator transforms.

/// Test basic async generator function with ES5 target
#[test]
fn test_source_map_async_generator_es5_basic() {
    let source = r#"async function* generateNumbers() {
    yield 1;
    yield 2;
    yield 3;
}

async function consume() {
    for await (const num of generateNumbers()) {
        console.log(num);
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("generateNumbers"),
        "expected generateNumbers in output. output: {output}"
    );
    assert!(
        output.contains("consume"),
        "expected consume in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic async generator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test async generator with yield* delegation and ES5 target
#[test]
fn test_source_map_async_generator_es5_yield_delegation() {
    let source = r#"async function* innerGenerator() {
    yield "a";
    yield "b";
}

async function* outerGenerator() {
    yield "start";
    yield* innerGenerator();
    yield "end";
}

async function main() {
    for await (const value of outerGenerator()) {
        console.log(value);
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("innerGenerator"),
        "expected innerGenerator in output. output: {output}"
    );
    assert!(
        output.contains("outerGenerator"),
        "expected outerGenerator in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for yield delegation"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test async generator with await expressions and ES5 target
#[test]
fn test_source_map_async_generator_es5_await_expressions() {
    let source = r#"async function fetchData(id: number): Promise<string> {
    return `data-${id}`;
}

async function* fetchSequence(ids: number[]) {
    for (const id of ids) {
        const data = await fetchData(id);
        yield data;
    }
}

async function process() {
    const ids = [1, 2, 3];
    for await (const data of fetchSequence(ids)) {
        console.log(data);
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchData"),
        "expected fetchData in output. output: {output}"
    );
    assert!(
        output.contains("fetchSequence"),
        "expected fetchSequence in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for await expressions"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test async generator with for-await-of loops and ES5 target
#[test]
fn test_source_map_async_generator_es5_for_await_of() {
    let source = r#"async function* createStream(): AsyncGenerator<number> {
    yield 1;
    yield 2;
    yield 3;
}

async function processStream() {
    const stream = createStream();
    let total = 0;

    for await (const value of stream) {
        total += value;
    }

    return total;
}

async function nestedForAwait() {
    const streams = [createStream(), createStream()];
    for (const stream of streams) {
        for await (const value of stream) {
            console.log(value);
        }
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createStream"),
        "expected createStream in output. output: {output}"
    );
    assert!(
        output.contains("processStream"),
        "expected processStream in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for for-await-of"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test async generator with error handling and ES5 target
#[test]
fn test_source_map_async_generator_es5_error_handling() {
    let source = r#"async function* riskyGenerator() {
    try {
        yield 1;
        throw new Error("oops");
        yield 2;
    } catch (e) {
        yield "caught";
    } finally {
        yield "cleanup";
    }
}

async function handleErrors() {
    try {
        for await (const value of riskyGenerator()) {
            console.log(value);
        }
    } catch (e) {
        console.error(e);
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("riskyGenerator"),
        "expected riskyGenerator in output. output: {output}"
    );
    assert!(
        output.contains("handleErrors"),
        "expected handleErrors in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for error handling"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test async generator as class methods with ES5 target
#[test]
fn test_source_map_async_generator_es5_class_methods() {
    let source = r#"class DataSource {
    private items: string[] = ["a", "b", "c"];

    async *iterate() {
        for (const item of this.items) {
            yield item;
        }
    }

    async *transform(fn: (s: string) => string) {
        for (const item of this.items) {
            yield fn(item);
        }
    }
}

class Pipeline {
    async *chain(sources: DataSource[]) {
        for (const source of sources) {
            yield* source.iterate();
        }
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataSource"),
        "expected DataSource in output. output: {output}"
    );
    assert!(
        output.contains("Pipeline"),
        "expected Pipeline in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test async generator with multiple yields and awaits interleaved with ES5 target
#[test]
fn test_source_map_async_generator_es5_interleaved() {
    let source = r#"async function delay(ms: number): Promise<void> {
    return new Promise(r => setTimeout(r, ms));
}

async function* interleaved() {
    yield "starting";
    await delay(100);
    yield "step 1";
    await delay(100);
    yield "step 2";
    await delay(100);
    yield "step 3";
    await delay(100);
    yield "done";
}

async function run() {
    const results: string[] = [];
    for await (const step of interleaved()) {
        results.push(step);
    }
    return results;
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("delay"),
        "expected delay in output. output: {output}"
    );
    assert!(
        output.contains("interleaved"),
        "expected interleaved in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for interleaved"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test async generator with return values and ES5 target
#[test]
fn test_source_map_async_generator_es5_return_values() {
    let source = r#"async function* withReturn(): AsyncGenerator<number, string, void> {
    yield 1;
    yield 2;
    return "completed";
}

async function* earlyReturn(condition: boolean) {
    yield "start";
    if (condition) {
        return "early exit";
    }
    yield "middle";
    yield "end";
    return "normal exit";
}

async function collectResults() {
    const gen = withReturn();
    let result: IteratorResult<number, string>;
    while (!(result = await gen.next()).done) {
        console.log(result.value);
    }
    console.log("Return value:", result.value);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("withReturn"),
        "expected withReturn in output. output: {output}"
    );
    assert!(
        output.contains("earlyReturn"),
        "expected earlyReturn in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for return values"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test nested async generators with ES5 target
#[test]
fn test_source_map_async_generator_es5_nested() {
    let source = r#"async function* outerAsync() {
    async function* innerAsync() {
        yield "inner 1";
        yield "inner 2";
    }

    yield "outer start";
    yield* innerAsync();
    yield "outer end";
}

async function* recursiveGen(depth: number): AsyncGenerator<string> {
    yield `depth ${depth}`;
    if (depth > 0) {
        yield* recursiveGen(depth - 1);
    }
}

async function consume() {
    for await (const value of outerAsync()) {
        console.log(value);
    }
    for await (const value of recursiveGen(3)) {
        console.log(value);
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("outerAsync"),
        "expected outerAsync in output. output: {output}"
    );
    assert!(
        output.contains("recursiveGen"),
        "expected recursiveGen in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested generators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Comprehensive test for async generator patterns with ES5 target
#[test]
fn test_source_map_async_generator_es5_comprehensive() {
    let source = r#"// Utility types and interfaces
interface AsyncIterable<T> {
    [Symbol.asyncIterator](): AsyncIterator<T>;
}

// Async event emitter
class AsyncEventEmitter {
    private events: Map<string, Function[]> = new Map();

    on(event: string, handler: Function) {
        if (!this.events.has(event)) {
            this.events.set(event, []);
        }
        this.events.get(event)!.push(handler);
    }

    async *subscribe(event: string): AsyncGenerator<any> {
        const queue: any[] = [];
        let resolve: ((value: any) => void) | null = null;

        this.on(event, (data: any) => {
            if (resolve) {
                resolve(data);
                resolve = null;
            } else {
                queue.push(data);
            }
        });

        while (true) {
            if (queue.length > 0) {
                yield queue.shift();
            } else {
                yield await new Promise(r => { resolve = r; });
            }
        }
    }
}

// Data processing pipeline
class DataPipeline<T> {
    constructor(private source: AsyncGenerator<T>) {}

    async *map<U>(fn: (item: T) => U | Promise<U>): AsyncGenerator<U> {
        for await (const item of this.source) {
            yield await fn(item);
        }
    }

    async *filter(predicate: (item: T) => boolean | Promise<boolean>): AsyncGenerator<T> {
        for await (const item of this.source) {
            if (await predicate(item)) {
                yield item;
            }
        }
    }

    async *take(count: number): AsyncGenerator<T> {
        let taken = 0;
        for await (const item of this.source) {
            if (taken >= count) break;
            yield item;
            taken++;
        }
    }

    async *batch(size: number): AsyncGenerator<T[]> {
        let batch: T[] = [];
        for await (const item of this.source) {
            batch.push(item);
            if (batch.length >= size) {
                yield batch;
                batch = [];
            }
        }
        if (batch.length > 0) {
            yield batch;
        }
    }
}

// Async iterator utilities
async function* merge<T>(...generators: AsyncGenerator<T>[]): AsyncGenerator<T> {
    const pending = generators.map(async (gen, i) => {
        const result = await gen.next();
        return { index: i, result };
    });

    while (pending.length > 0) {
        const { index, result } = await Promise.race(pending);
        if (!result.done) {
            yield result.value;
            pending[index] = (async () => {
                const res = await generators[index].next();
                return { index, result: res };
            })();
        }
    }
}

async function* range(start: number, end: number): AsyncGenerator<number> {
    for (let i = start; i < end; i++) {
        yield i;
    }
}

async function* fromPromises<T>(promises: Promise<T>[]): AsyncGenerator<T> {
    for (const promise of promises) {
        yield await promise;
    }
}

// Usage example
async function main() {
    const numbers = range(0, 100);
    const pipeline = new DataPipeline(numbers);

    const processed = pipeline
        .filter(n => n % 2 === 0)
        .map(n => n * 2)
        .take(10);

    for await (const num of processed) {
        console.log(num);
    }

    const emitter = new AsyncEventEmitter();
    const subscription = emitter.subscribe("data");

    setTimeout(() => {
        for (let i = 0; i < 5; i++) {
            emitter.on("data", () => i);
        }
    }, 100);
}

main().catch(console.error);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AsyncEventEmitter"),
        "expected AsyncEventEmitter in output. output: {output}"
    );
    assert!(
        output.contains("DataPipeline"),
        "expected DataPipeline in output. output: {output}"
    );
    assert!(
        output.contains("merge"),
        "expected merge in output. output: {output}"
    );
    assert!(
        output.contains("range"),
        "expected range in output. output: {output}"
    );
    assert!(
        output.contains("fromPromises"),
        "expected fromPromises in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive async generators"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS - OPTIONAL CHAINING PATTERNS
// =============================================================================
// Tests for optional chaining patterns with ES5 target to verify source maps
// work correctly with optional chaining transforms.

/// Test basic optional chaining property access with ES5 target
#[test]
fn test_source_map_optional_chaining_es5_property_access() {
    let source = r#"interface User {
    name?: string;
    address?: {
        city?: string;
        zip?: string;
    };
}

function getUserCity(user: User | null) {
    return user?.address?.city;
}

const user: User = { name: "Alice" };
const city = user?.address?.city;
const name = user?.name;
console.log(city, name);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getUserCity"),
        "expected getUserCity in output. output: {output}"
    );
    assert!(
        output.contains("user"),
        "expected user in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for property access"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test optional chaining method call with ES5 target
#[test]
fn test_source_map_optional_chaining_es5_method_call() {
    let source = r#"interface Service {
    getData?(): string;
    process?(data: string): void;
}

function callService(service: Service | undefined) {
    const data = service?.getData?.();
    service?.process?.(data ?? "default");
    return data;
}

class Api {
    client?: {
        fetch?(url: string): Promise<any>;
    };

    async request(url: string) {
        const result = await this.client?.fetch?.(url);
        return result;
    }
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("callService"),
        "expected callService in output. output: {output}"
    );
    assert!(
        output.contains("Api"),
        "expected Api in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for method call"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test optional chaining element access with ES5 target
#[test]
fn test_source_map_optional_chaining_es5_element_access() {
    let source = r#"interface Data {
    items?: string[];
    matrix?: number[][];
    records?: Record<string, any>;
}

function getItem(data: Data | null, index: number) {
    return data?.items?.[index];
}

function getMatrixCell(data: Data, row: number, col: number) {
    return data?.matrix?.[row]?.[col];
}

function getRecord(data: Data, key: string) {
    return data?.records?.[key];
}

const data: Data = { items: ["a", "b", "c"] };
const first = data?.items?.[0];
const dynamic = data?.records?.["dynamic-key"];"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getItem"),
        "expected getItem in output. output: {output}"
    );
    assert!(
        output.contains("getMatrixCell"),
        "expected getMatrixCell in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for element access"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test nested optional chaining with ES5 target
#[test]
fn test_source_map_optional_chaining_es5_nested() {
    let source = r#"interface DeepNested {
    level1?: {
        level2?: {
            level3?: {
                level4?: {
                    value?: string;
                };
            };
        };
    };
}

function getDeepValue(obj: DeepNested | null): string | undefined {
    return obj?.level1?.level2?.level3?.level4?.value;
}

const nested: DeepNested = {};
const deep = nested?.level1?.level2?.level3?.level4?.value;
const partial = nested?.level1?.level2;
console.log(deep, partial);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getDeepValue"),
        "expected getDeepValue in output. output: {output}"
    );
    assert!(
        output.contains("nested"),
        "expected nested in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested chaining"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test optional chaining with nullish coalescing with ES5 target
#[test]
fn test_source_map_optional_chaining_es5_with_nullish() {
    let source = r#"interface Config {
    settings?: {
        theme?: string;
        timeout?: number;
    };
}

function getTheme(config: Config | null): string {
    return config?.settings?.theme ?? "default";
}

function getTimeout(config: Config): number {
    return config?.settings?.timeout ?? 5000;
}

const config: Config = {};
const theme = config?.settings?.theme ?? "light";
const timeout = config?.settings?.timeout ?? 3000;
const nested = config?.settings?.theme ?? config?.settings?.timeout ?? "fallback";
console.log(theme, timeout, nested);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getTheme"),
        "expected getTheme in output. output: {output}"
    );
    assert!(
        output.contains("getTimeout"),
        "expected getTimeout in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nullish coalescing"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test optional chaining in function context with ES5 target
#[test]
fn test_source_map_optional_chaining_es5_function_context() {
    let source = r#"interface Handler {
    callback?: (data: string) => void;
    transform?: (input: number) => number;
}

function invokeHandler(handler: Handler | undefined, data: string) {
    handler?.callback?.(data);
}

function transformValue(handler: Handler, value: number): number | undefined {
    return handler?.transform?.(value);
}

const handlers: Handler[] = [];
const result = handlers[0]?.callback?.("test");
const mapped = handlers.map(h => h?.transform?.(42));

function chainedCalls(handler: Handler | null) {
    const fn = handler?.transform;
    return fn?.(100);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("invokeHandler"),
        "expected invokeHandler in output. output: {output}"
    );
    assert!(
        output.contains("transformValue"),
        "expected transformValue in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for function context"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test optional chaining with chained methods with ES5 target
#[test]
fn test_source_map_optional_chaining_es5_chained_methods() {
    let source = r#"interface Builder {
    setName?(name: string): Builder;
    setValue?(value: number): Builder;
    build?(): object;
}

function buildObject(builder: Builder | null) {
    return builder?.setName?.("test")?.setValue?.(42)?.build?.();
}

class FluentApi {
    private data: any;

    with?(key: string): FluentApi | undefined {
        return this;
    }

    get?(): any {
        return this.data;
    }
}

const api = new FluentApi();
const result = api?.with?.("key")?.get?.();
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("buildObject"),
        "expected buildObject in output. output: {output}"
    );
    assert!(
        output.contains("FluentApi"),
        "expected FluentApi in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for chained methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test optional chaining with delete operator with ES5 target
#[test]
fn test_source_map_optional_chaining_es5_delete() {
    let source = r#"interface Obj {
    prop?: {
        nested?: string;
    };
    items?: string[];
}

function deleteProp(obj: Obj | null) {
    delete obj?.prop?.nested;
}

function deleteElement(obj: Obj | undefined, index: number) {
    delete obj?.items?.[index];
}

const obj: Obj = { prop: { nested: "value" } };
delete obj?.prop?.nested;
delete obj?.items?.[0];
console.log(obj);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("deleteProp"),
        "expected deleteProp in output. output: {output}"
    );
    assert!(
        output.contains("deleteElement"),
        "expected deleteElement in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for delete operator"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test optional chaining with call expression with ES5 target
#[test]
fn test_source_map_optional_chaining_es5_call_expression() {
    let source = r#"type Callback = ((value: number) => void) | undefined;

function invokeCallback(cb: Callback, value: number) {
    cb?.(value);
}

const callbacks: Callback[] = [undefined, (v) => console.log(v)];
callbacks[0]?.(1);
callbacks[1]?.(2);

interface EventEmitter {
    on?: (event: string, handler: Function) => void;
    emit?: (event: string, ...args: any[]) => void;
}

function setupEmitter(emitter: EventEmitter | null) {
    emitter?.on?.("data", console.log);
    emitter?.emit?.("ready");
}

const maybeFunc: (() => number) | null = null;
const result = maybeFunc?.();
console.log(result);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("invokeCallback"),
        "expected invokeCallback in output. output: {output}"
    );
    assert!(
        output.contains("setupEmitter"),
        "expected setupEmitter in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for call expression"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Comprehensive test for optional chaining patterns with ES5 target
#[test]
fn test_source_map_optional_chaining_es5_comprehensive() {
    let source = r#"// Complex optional chaining scenarios
interface User {
    id: number;
    name?: string;
    profile?: {
        avatar?: string;
        settings?: {
            theme?: string;
            notifications?: boolean;
        };
    };
    friends?: User[];
    getFriendById?(id: number): User | undefined;
}

interface AppState {
    currentUser?: User;
    users?: Map<number, User>;
    cache?: {
        get?(key: string): any;
        set?(key: string, value: any): void;
    };
}

class UserService {
    private state: AppState;

    constructor(state: AppState) {
        this.state = state;
    }

    getCurrentUserName(): string {
        return this.state?.currentUser?.name ?? "Anonymous";
    }

    getUserAvatar(): string | undefined {
        return this.state?.currentUser?.profile?.avatar;
    }

    getUserTheme(): string {
        return this.state?.currentUser?.profile?.settings?.theme ?? "light";
    }

    getNotificationsEnabled(): boolean {
        return this.state?.currentUser?.profile?.settings?.notifications ?? true;
    }

    getFriendName(index: number): string | undefined {
        return this.state?.currentUser?.friends?.[index]?.name;
    }

    findFriend(userId: number, friendId: number): User | undefined {
        const user = this.state?.users?.get(userId);
        return user?.getFriendById?.(friendId);
    }

    getCachedValue(key: string): any {
        return this.state?.cache?.get?.(key);
    }

    setCachedValue(key: string, value: any): void {
        this.state?.cache?.set?.(key, value);
    }
}

// Utility functions with optional chaining
function safeAccess<T, K extends keyof T>(obj: T | null | undefined, key: K): T[K] | undefined {
    return obj?.[key];
}

function safeCall<T, R>(fn: ((arg: T) => R) | undefined, arg: T): R | undefined {
    return fn?.(arg);
}

function deepGet(obj: any, ...keys: string[]): any {
    let current = obj;
    for (const key of keys) {
        current = current?.[key];
        if (current === undefined) break;
    }
    return current;
}

// Usage examples
const appState: AppState = {
    currentUser: {
        id: 1,
        name: "Alice",
        profile: {
            avatar: "avatar.png",
            settings: {
                theme: "dark"
            }
        },
        friends: [
            { id: 2, name: "Bob" },
            { id: 3, name: "Charlie" }
        ]
    }
};

const service = new UserService(appState);
console.log(service.getCurrentUserName());
console.log(service.getUserAvatar());
console.log(service.getUserTheme());
console.log(service.getNotificationsEnabled());
console.log(service.getFriendName(0));

// Edge cases
const nullUser: User | null = null;
const undefinedFriends = nullUser?.friends?.[0]?.name;
const chainedMethods = nullUser?.getFriendById?.(1)?.getFriendById?.(2);
const mixedAccess = appState?.currentUser?.friends?.[0]?.profile?.settings?.theme ?? "default";"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("UserService"),
        "expected UserService in output. output: {output}"
    );
    assert!(
        output.contains("safeAccess"),
        "expected safeAccess in output. output: {output}"
    );
    assert!(
        output.contains("safeCall"),
        "expected safeCall in output. output: {output}"
    );
    assert!(
        output.contains("deepGet"),
        "expected deepGet in output. output: {output}"
    );
    assert!(
        output.contains("appState"),
        "expected appState in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive optional chaining"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS - NULLISH COALESCING PATTERNS
// =============================================================================
// Tests for nullish coalescing patterns with ES5 target to verify source maps
// work correctly with nullish coalescing transforms.

/// Test basic nullish coalescing with ES5 target
#[test]
fn test_source_map_nullish_coalescing_es5_basic() {
    let source = r#"const value1: string | null = null;
const value2: string | undefined = undefined;
const value3: string | null | undefined = "hello";

const result1 = value1 ?? "default1";
const result2 = value2 ?? "default2";
const result3 = value3 ?? "default3";

console.log(result1, result2, result3);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("result1"),
        "expected result1 in output. output: {output}"
    );
    assert!(
        output.contains("result2"),
        "expected result2 in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic nullish coalescing"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test nullish coalescing with null values with ES5 target
#[test]
fn test_source_map_nullish_coalescing_es5_with_null() {
    let source = r#"function getValueOrDefault(input: string | null): string {
    return input ?? "fallback";
}

const nullValue: string | null = null;
const nonNullValue: string | null = "actual";

const result1 = nullValue ?? "was null";
const result2 = nonNullValue ?? "was null";
const result3 = getValueOrDefault(null);
const result4 = getValueOrDefault("test");

console.log(result1, result2, result3, result4);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getValueOrDefault"),
        "expected getValueOrDefault in output. output: {output}"
    );
    assert!(
        output.contains("nullValue"),
        "expected nullValue in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for null values"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test nullish coalescing with undefined values with ES5 target
#[test]
fn test_source_map_nullish_coalescing_es5_with_undefined() {
    let source = r#"function getOrUndefined(): string | undefined {
    return undefined;
}

function getOrValue(): string | undefined {
    return "value";
}

const undefinedValue: string | undefined = undefined;
const definedValue: string | undefined = "defined";

const result1 = undefinedValue ?? "was undefined";
const result2 = definedValue ?? "was undefined";
const result3 = getOrUndefined() ?? "fallback";
const result4 = getOrValue() ?? "fallback";

console.log(result1, result2, result3, result4);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getOrUndefined"),
        "expected getOrUndefined in output. output: {output}"
    );
    assert!(
        output.contains("getOrValue"),
        "expected getOrValue in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for undefined values"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test chained nullish coalescing with ES5 target
#[test]
fn test_source_map_nullish_coalescing_es5_chained() {
    let source = r#"const first: string | null = null;
const second: string | undefined = undefined;
const third: string | null = null;
const fourth: string = "found";

const result1 = first ?? second ?? third ?? fourth;
const result2 = first ?? second ?? "early default";
const result3 = first ?? "immediate default" ?? second;

function chainedDefaults(
    a: string | null,
    b: string | undefined,
    c: string | null
): string {
    return a ?? b ?? c ?? "final fallback";
}

const chainResult = chainedDefaults(null, undefined, "c-value");
console.log(result1, result2, result3, chainResult);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("first"),
        "expected first in output. output: {output}"
    );
    assert!(
        output.contains("chainedDefaults"),
        "expected chainedDefaults in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for chained nullish coalescing"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test nullish coalescing with function calls with ES5 target
#[test]
fn test_source_map_nullish_coalescing_es5_function_call() {
    let source = r#"function maybeGetValue(): string | null {
    return Math.random() > 0.5 ? "value" : null;
}

function getDefault(): string {
    return "default from function";
}

const result1 = maybeGetValue() ?? "inline default";
const result2 = maybeGetValue() ?? getDefault();

class DataProvider {
    getValue(): string | undefined {
        return undefined;
    }

    getDefault(): string {
        return "class default";
    }

    getResult(): string {
        return this.getValue() ?? this.getDefault();
    }
}

const provider = new DataProvider();
const classResult = provider.getResult();
console.log(result1, result2, classResult);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("maybeGetValue"),
        "expected maybeGetValue in output. output: {output}"
    );
    assert!(
        output.contains("DataProvider"),
        "expected DataProvider in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for function call"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test nullish coalescing in assignments with ES5 target
#[test]
fn test_source_map_nullish_coalescing_es5_assignment() {
    let source = r#"let value: string | null = null;
let result: string;

result = value ?? "assigned default";

function assignWithDefault(input: number | undefined): number {
    let output: number;
    output = input ?? 0;
    return output;
}

class Container {
    private data: string | null = null;

    setData(value: string | null): void {
        this.data = value ?? "container default";
    }

    getData(): string {
        return this.data ?? "no data";
    }
}

const container = new Container();
container.setData(null);
const containerData = container.getData();
console.log(result, containerData);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("assignWithDefault"),
        "expected assignWithDefault in output. output: {output}"
    );
    assert!(
        output.contains("Container"),
        "expected Container in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for assignment"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test nullish coalescing in conditionals with ES5 target
#[test]
fn test_source_map_nullish_coalescing_es5_conditional() {
    let source = r#"function processValue(input: string | null): string {
    if ((input ?? "default") === "default") {
        return "was nullish";
    }
    return input ?? "unreachable";
}

const value: number | undefined = undefined;
const condition = (value ?? 0) > 10;

const ternaryResult = (value ?? 0) > 5 ? "big" : "small";

function conditionalChain(a: boolean | null, b: boolean | undefined): boolean {
    return (a ?? false) && (b ?? true);
}

const chainResult = conditionalChain(null, undefined);
console.log(condition, ternaryResult, chainResult);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processValue"),
        "expected processValue in output. output: {output}"
    );
    assert!(
        output.contains("conditionalChain"),
        "expected conditionalChain in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for conditional"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test nullish coalescing with objects with ES5 target
#[test]
fn test_source_map_nullish_coalescing_es5_objects() {
    let source = r#"interface Config {
    name?: string;
    count?: number;
    enabled?: boolean;
}

const config: Config | null = null;
const defaultConfig: Config = { name: "default", count: 0, enabled: true };

const finalConfig = config ?? defaultConfig;

function mergeConfigs(base: Config | undefined, override: Config | null): Config {
    return override ?? base ?? { name: "fallback", count: -1, enabled: false };
}

const merged = mergeConfigs(undefined, null);

const partialConfig: Config = {
    name: (config ?? defaultConfig).name ?? "unnamed",
    count: (config ?? defaultConfig).count ?? 0,
    enabled: (config ?? defaultConfig).enabled ?? false
};

console.log(finalConfig, merged, partialConfig);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("finalConfig"),
        "expected finalConfig in output. output: {output}"
    );
    assert!(
        output.contains("mergeConfigs"),
        "expected mergeConfigs in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for objects"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test nullish coalescing with optional chaining with ES5 target
#[test]
fn test_source_map_nullish_coalescing_es5_with_optional_chaining() {
    let source = r#"interface User {
    name?: string;
    profile?: {
        email?: string;
        settings?: {
            theme?: string;
            language?: string;
        };
    };
}

function getUserTheme(user: User | null): string {
    return user?.profile?.settings?.theme ?? "light";
}

function getUserLanguage(user: User | undefined): string {
    return user?.profile?.settings?.language ?? "en";
}

const user: User | null = null;
const theme = user?.profile?.settings?.theme ?? "default-theme";
const language = user?.profile?.settings?.language ?? "default-lang";
const email = user?.profile?.email ?? "no-email@example.com";

class UserService {
    private user: User | null = null;

    getTheme(): string {
        return this.user?.profile?.settings?.theme ?? "system";
    }

    getDisplayName(): string {
        return this.user?.name ?? "Guest";
    }
}

const service = new UserService();
console.log(theme, language, email, service.getTheme());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getUserTheme"),
        "expected getUserTheme in output. output: {output}"
    );
    assert!(
        output.contains("UserService"),
        "expected UserService in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for optional chaining"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Comprehensive test for nullish coalescing patterns with ES5 target
#[test]
fn test_source_map_nullish_coalescing_es5_comprehensive() {
    let source = r#"// Comprehensive nullish coalescing scenarios
interface AppConfig {
    apiUrl?: string;
    timeout?: number;
    retries?: number;
    headers?: Record<string, string>;
    features?: {
        darkMode?: boolean;
        notifications?: boolean;
        analytics?: boolean;
    };
}

interface User {
    id: number;
    name?: string;
    email?: string;
    preferences?: AppConfig;
}

class ConfigManager {
    private defaultConfig: AppConfig = {
        apiUrl: "https://api.example.com",
        timeout: 5000,
        retries: 3,
        features: {
            darkMode: false,
            notifications: true,
            analytics: true
        }
    };

    private userConfig: AppConfig | null = null;

    setUserConfig(config: AppConfig | null): void {
        this.userConfig = config;
    }

    getApiUrl(): string {
        return this.userConfig?.apiUrl ?? this.defaultConfig.apiUrl ?? "https://fallback.com";
    }

    getTimeout(): number {
        return this.userConfig?.timeout ?? this.defaultConfig.timeout ?? 1000;
    }

    getRetries(): number {
        return this.userConfig?.retries ?? this.defaultConfig.retries ?? 0;
    }

    isDarkModeEnabled(): boolean {
        return this.userConfig?.features?.darkMode ?? this.defaultConfig.features?.darkMode ?? false;
    }

    areNotificationsEnabled(): boolean {
        return this.userConfig?.features?.notifications ?? this.defaultConfig.features?.notifications ?? true;
    }
}

class UserManager {
    private users: Map<number, User> = new Map();

    addUser(user: User): void {
        this.users.set(user.id, user);
    }

    getUserName(id: number): string {
        return this.users.get(id)?.name ?? "Unknown User";
    }

    getUserEmail(id: number): string {
        return this.users.get(id)?.email ?? "no-reply@example.com";
    }

    getUserApiUrl(id: number): string {
        const user = this.users.get(id);
        return user?.preferences?.apiUrl ?? "https://default-api.com";
    }
}

// Utility functions
function coalesce<T>(value: T | null | undefined, defaultValue: T): T {
    return value ?? defaultValue;
}

function coalesceMany<T>(...values: (T | null | undefined)[]): T | undefined {
    for (const value of values) {
        if (value !== null && value !== undefined) {
            return value;
        }
    }
    return undefined;
}

function getNestedValue<T>(
    obj: any,
    path: string[],
    defaultValue: T
): T {
    let current = obj;
    for (const key of path) {
        current = current?.[key];
        if (current === null || current === undefined) {
            return defaultValue;
        }
    }
    return current ?? defaultValue;
}

// Usage
const configManager = new ConfigManager();
const userManager = new UserManager();

userManager.addUser({ id: 1, name: "Alice" });
userManager.addUser({ id: 2, email: "bob@example.com" });

console.log(configManager.getApiUrl());
console.log(configManager.getTimeout());
console.log(configManager.isDarkModeEnabled());
console.log(userManager.getUserName(1));
console.log(userManager.getUserEmail(2));

const maybeValue: string | null = null;
const result = coalesce(maybeValue, "fallback");
const multiResult = coalesceMany<string>(null, undefined, "found", "ignored");

console.log(result, multiResult);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ConfigManager"),
        "expected ConfigManager in output. output: {output}"
    );
    assert!(
        output.contains("UserManager"),
        "expected UserManager in output. output: {output}"
    );
    assert!(
        output.contains("coalesce"),
        "expected coalesce in output. output: {output}"
    );
    assert!(
        output.contains("coalesceMany"),
        "expected coalesceMany in output. output: {output}"
    );
    assert!(
        output.contains("getNestedValue"),
        "expected getNestedValue in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive nullish coalescing"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS - LOGICAL ASSIGNMENT PATTERNS
// =============================================================================
// Tests for logical assignment patterns (&&=, ||=, ??=) with ES5 target to verify
// source maps work correctly with logical assignment transforms.

/// Test &&= logical AND assignment with ES5 target
#[test]
fn test_source_map_logical_assignment_es5_and_assign() {
    let source = r#"let value1: string | null = "hello";
let value2: string | null = null;

value1 &&= "updated";
value2 &&= "updated";

function updateIfTruthy(input: string | null): string | null {
    let result = input;
    result &&= "modified";
    return result;
}

const result1 = updateIfTruthy("test");
const result2 = updateIfTruthy(null);
console.log(value1, value2, result1, result2);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("value1"),
        "expected value1 in output. output: {output}"
    );
    assert!(
        output.contains("updateIfTruthy"),
        "expected updateIfTruthy in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for &&= assignment"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test ||= logical OR assignment with ES5 target
#[test]
fn test_source_map_logical_assignment_es5_or_assign() {
    let source = r#"let value1: string | null = null;
let value2: string | null = "existing";

value1 ||= "default";
value2 ||= "default";

function setDefault(input: string | null): string {
    let result: string | null = input;
    result ||= "fallback";
    return result;
}

const result1 = setDefault(null);
const result2 = setDefault("provided");
console.log(value1, value2, result1, result2);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("value1"),
        "expected value1 in output. output: {output}"
    );
    assert!(
        output.contains("setDefault"),
        "expected setDefault in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ||= assignment"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test ??= nullish coalescing assignment with ES5 target
#[test]
fn test_source_map_logical_assignment_es5_nullish_assign() {
    let source = r#"let value1: string | null = null;
let value2: string | undefined = undefined;
let value3: string | null = "existing";

value1 ??= "default1";
value2 ??= "default2";
value3 ??= "default3";

function ensureValue(input: number | undefined): number {
    let result = input;
    result ??= 0;
    return result;
}

const result1 = ensureValue(undefined);
const result2 = ensureValue(42);
console.log(value1, value2, value3, result1, result2);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("value1"),
        "expected value1 in output. output: {output}"
    );
    assert!(
        output.contains("ensureValue"),
        "expected ensureValue in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ??= assignment"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test logical assignment with object properties with ES5 target
#[test]
fn test_source_map_logical_assignment_es5_object_property() {
    let source = r#"interface Config {
    name: string | null;
    count: number | undefined;
    enabled: boolean;
}

const config: Config = {
    name: null,
    count: undefined,
    enabled: false
};

config.name ||= "default-name";
config.count ??= 0;
config.enabled &&= true;

function updateConfig(cfg: Config): void {
    cfg.name ??= "unnamed";
    cfg.count ||= 1;
}

updateConfig(config);
console.log(config);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("config"),
        "expected config in output. output: {output}"
    );
    assert!(
        output.contains("updateConfig"),
        "expected updateConfig in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for object property"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test logical assignment with element access with ES5 target
#[test]
fn test_source_map_logical_assignment_es5_element_access() {
    let source = r#"const arr: (string | null)[] = [null, "existing", null];
const obj: Record<string, number | undefined> = { a: undefined, b: 10 };

arr[0] ||= "default0";
arr[1] ||= "default1";
arr[2] ??= "default2";

obj["a"] ??= 0;
obj["b"] &&= 20;
obj["c"] ??= 30;

function updateArray(items: (string | null)[], index: number): void {
    items[index] ??= "fallback";
}

updateArray(arr, 0);
console.log(arr, obj);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("arr"),
        "expected arr in output. output: {output}"
    );
    assert!(
        output.contains("updateArray"),
        "expected updateArray in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for element access"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test chained logical assignments with ES5 target
#[test]
fn test_source_map_logical_assignment_es5_chained() {
    let source = r#"let a: string | null = null;
let b: string | null = null;
let c: string | null = null;

a ||= "a-default";
b ??= a;
c &&= b;

interface ChainedConfig {
    primary: string | null;
    secondary: string | null;
    tertiary: string | null;
}

function chainedAssignments(cfg: ChainedConfig): void {
    cfg.primary ??= "primary-default";
    cfg.secondary ||= cfg.primary;
    cfg.tertiary &&= cfg.secondary;
}

const cfg: ChainedConfig = { primary: null, secondary: null, tertiary: "exists" };
chainedAssignments(cfg);
console.log(a, b, c, cfg);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("chainedAssignments"),
        "expected chainedAssignments in output. output: {output}"
    );
    assert!(
        output.contains("cfg"),
        "expected cfg in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for chained assignments"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test logical assignment in function context with ES5 target
#[test]
fn test_source_map_logical_assignment_es5_function_context() {
    let source = r#"function processWithDefaults(
    name: string | null,
    count: number | undefined,
    enabled: boolean
): { name: string; count: number; enabled: boolean } {
    let n = name;
    let c = count;
    let e = enabled;

    n ??= "anonymous";
    c ||= 1;
    e &&= true;

    return { name: n, count: c, enabled: e };
}

const arrowWithAssign = (val: string | null): string => {
    let result = val;
    result ??= "arrow-default";
    return result;
};

function nestedFunction(): string {
    let outer: string | null = null;

    function inner(): void {
        outer ??= "from-inner";
    }

    inner();
    return outer ?? "never";
}

console.log(processWithDefaults(null, undefined, true));
console.log(arrowWithAssign(null));
console.log(nestedFunction());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("processWithDefaults"),
        "expected processWithDefaults in output. output: {output}"
    );
    assert!(
        output.contains("arrowWithAssign"),
        "expected arrowWithAssign in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for function context"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test logical assignment in class methods with ES5 target
#[test]
fn test_source_map_logical_assignment_es5_class_methods() {
    let source = r#"class DataManager {
    private data: string | null = null;
    private count: number | undefined = undefined;
    private active: boolean = true;

    ensureData(): string {
        this.data ??= "default-data";
        return this.data;
    }

    ensureCount(): number {
        this.count ||= 0;
        return this.count;
    }

    updateActive(value: boolean): boolean {
        this.active &&= value;
        return this.active;
    }

    reset(): void {
        this.data = null;
        this.count = undefined;
        this.active = true;
    }
}

class CacheManager {
    private cache: Map<string, string | null> = new Map();

    getOrSet(key: string, defaultValue: string): string {
        let value = this.cache.get(key);
        value ??= defaultValue;
        this.cache.set(key, value);
        return value;
    }
}

const manager = new DataManager();
console.log(manager.ensureData());
console.log(manager.ensureCount());
console.log(manager.updateActive(false));

const cache = new CacheManager();
console.log(cache.getOrSet("key", "value"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataManager"),
        "expected DataManager in output. output: {output}"
    );
    assert!(
        output.contains("CacheManager"),
        "expected CacheManager in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for class methods"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test logical assignment with side effects with ES5 target
#[test]
fn test_source_map_logical_assignment_es5_side_effects() {
    let source = r#"let callCount = 0;

function getSideEffect(): string {
    callCount++;
    return "side-effect-value";
}

let value1: string | null = null;
let value2: string | null = "existing";

value1 ??= getSideEffect();
value2 ??= getSideEffect();

console.log("Call count:", callCount);

const obj = {
    _value: null as string | null,
    get value(): string | null {
        console.log("getter called");
        return this._value;
    },
    set value(v: string | null) {
        console.log("setter called");
        this._value = v;
    }
};

obj.value ??= "default";

function conditionalSideEffect(condition: boolean): string | null {
    if (condition) {
        return "truthy";
    }
    return null;
}

let sideEffectResult: string | null = null;
sideEffectResult ||= conditionalSideEffect(true);
console.log(value1, value2, sideEffectResult);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getSideEffect"),
        "expected getSideEffect in output. output: {output}"
    );
    assert!(
        output.contains("callCount"),
        "expected callCount in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for side effects"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Comprehensive test for logical assignment patterns with ES5 target
#[test]
fn test_source_map_logical_assignment_es5_comprehensive() {
    let source = r#"// Comprehensive logical assignment scenarios
interface User {
    id: number;
    name: string | null;
    email: string | undefined;
    preferences: {
        theme: string | null;
        language: string | undefined;
        notifications: boolean;
    } | null;
}

class UserService {
    private users: Map<number, User> = new Map();

    createUser(id: number): User {
        const user: User = {
            id,
            name: null,
            email: undefined,
            preferences: null
        };
        this.users.set(id, user);
        return user;
    }

    ensureUserName(id: number): string {
        const user = this.users.get(id);
        if (user) {
            user.name ??= "Anonymous";
            return user.name;
        }
        return "Unknown";
    }

    ensureUserEmail(id: number, defaultEmail: string): string {
        const user = this.users.get(id);
        if (user) {
            user.email ||= defaultEmail;
            return user.email;
        }
        return defaultEmail;
    }

    ensurePreferences(id: number): void {
        const user = this.users.get(id);
        if (user) {
            user.preferences ??= {
                theme: null,
                language: undefined,
                notifications: true
            };
            user.preferences.theme ??= "light";
            user.preferences.language ||= "en";
            user.preferences.notifications &&= true;
        }
    }
}

class ConfigStore {
    private config: Record<string, any> = {};

    get<T>(key: string, defaultValue: T): T {
        let value = this.config[key] as T | undefined;
        value ??= defaultValue;
        return value;
    }

    set<T>(key: string, value: T): void {
        this.config[key] = value;
    }

    update<T>(key: string, updater: (val: T | undefined) => T): T {
        let current = this.config[key] as T | undefined;
        current ??= undefined as any;
        const updated = updater(current);
        this.config[key] = updated;
        return updated;
    }
}

// Utility functions
function ensureArray<T>(arr: T[] | null, defaultItems: T[]): T[] {
    let result = arr;
    result ??= defaultItems;
    return result;
}

function conditionalUpdate<T>(
    value: T | null,
    condition: boolean,
    newValue: T
): T | null {
    let result = value;
    if (condition) {
        result &&= newValue;
    } else {
        result ||= newValue;
    }
    return result;
}

// Usage
const userService = new UserService();
const user = userService.createUser(1);
console.log(userService.ensureUserName(1));
console.log(userService.ensureUserEmail(1, "default@example.com"));
userService.ensurePreferences(1);

const store = new ConfigStore();
console.log(store.get("theme", "dark"));
store.set("theme", "light");
console.log(store.get("theme", "dark"));

const items = ensureArray<string>(null, ["default"]);
console.log(items);

const updated = conditionalUpdate<string>("existing", true, "new");
console.log(updated);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("UserService"),
        "expected UserService in output. output: {output}"
    );
    assert!(
        output.contains("ConfigStore"),
        "expected ConfigStore in output. output: {output}"
    );
    assert!(
        output.contains("ensureArray"),
        "expected ensureArray in output. output: {output}"
    );
    assert!(
        output.contains("conditionalUpdate"),
        "expected conditionalUpdate in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive logical assignment"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS - CLASS STATIC BLOCK PATTERNS (INIT ORDER, PRIVATE ACCESS)
// =============================================================================
// Tests for class static block patterns with ES5 target to verify source maps
// work correctly with static block transforms, focusing on init order and private access.

/// Test basic class static block with ES5 target
#[test]
fn test_source_map_static_block_es5_basic() {
    let source = r#"class Counter {
    static count: number;

    static {
        Counter.count = 0;
        console.log("Counter initialized");
    }

    static increment(): number {
        return ++Counter.count;
    }
}

console.log(Counter.increment());
console.log(Counter.increment());
console.log(Counter.count);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter"),
        "expected Counter in output. output: {output}"
    );
    assert!(
        output.contains("increment"),
        "expected increment in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic static block"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test class static block initialization order with ES5 target
#[test]
fn test_source_map_static_block_es5_init_order() {
    let source = r#"const log: string[] = [];

class InitOrder {
    static a = (log.push("field a"), "a");

    static {
        log.push("block 1");
    }

    static b = (log.push("field b"), "b");

    static {
        log.push("block 2");
    }

    static c = (log.push("field c"), "c");

    static {
        log.push("block 3");
        console.log("Init order:", log.join(", "));
    }
}

console.log(InitOrder.a, InitOrder.b, InitOrder.c);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("InitOrder"),
        "expected InitOrder in output. output: {output}"
    );
    assert!(
        output.contains("log"),
        "expected log in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for init order"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test multiple class static blocks with ES5 target
#[test]
fn test_source_map_static_block_es5_multiple() {
    let source = r#"class MultiBlock {
    static config: Record<string, any> = {};

    static {
        MultiBlock.config.name = "app";
    }

    static {
        MultiBlock.config.version = "1.0.0";
    }

    static {
        MultiBlock.config.debug = false;
    }

    static {
        MultiBlock.config.features = ["a", "b", "c"];
        console.log("Config complete:", MultiBlock.config);
    }

    static getConfig(): Record<string, any> {
        return MultiBlock.config;
    }
}

console.log(MultiBlock.getConfig());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("MultiBlock"),
        "expected MultiBlock in output. output: {output}"
    );
    assert!(
        output.contains("getConfig"),
        "expected getConfig in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple blocks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test static block with private field access with ES5 target
#[test]
fn test_source_map_static_block_es5_private_field_access() {
    let source = r#"class PrivateFields {
    static #secret: string;
    static #counter: number;

    static {
        PrivateFields.#secret = "hidden-value";
        PrivateFields.#counter = 0;
    }

    static getSecret(): string {
        return PrivateFields.#secret;
    }

    static incrementCounter(): number {
        return ++PrivateFields.#counter;
    }

    static {
        console.log("Private fields initialized");
        console.log("Secret length:", PrivateFields.#secret.length);
    }
}

console.log(PrivateFields.getSecret());
console.log(PrivateFields.incrementCounter());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("PrivateFields"),
        "expected PrivateFields in output. output: {output}"
    );
    assert!(
        output.contains("getSecret"),
        "expected getSecret in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private field access"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test static block with private method access with ES5 target
#[test]
fn test_source_map_static_block_es5_private_method_access() {
    let source = r#"class PrivateMethods {
    static #initialize(): void {
        console.log("Initializing...");
    }

    static #validate(value: string): boolean {
        return value.length > 0;
    }

    static #format(value: string): string {
        return value.toUpperCase();
    }

    static {
        PrivateMethods.#initialize();
        const valid = PrivateMethods.#validate("test");
        console.log("Validation:", valid);
    }

    static process(input: string): string {
        if (PrivateMethods.#validate(input)) {
            return PrivateMethods.#format(input);
        }
        return "";
    }
}

console.log(PrivateMethods.process("hello"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("PrivateMethods"),
        "expected PrivateMethods in output. output: {output}"
    );
    assert!(
        output.contains("process"),
        "expected process in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private method access"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test static block with static field initialization with ES5 target
#[test]
fn test_source_map_static_block_es5_static_field_init() {
    let source = r#"class StaticInit {
    static readonly API_URL: string;
    static readonly TIMEOUT: number;
    static readonly HEADERS: Record<string, string>;

    static {
        const env = { api: "https://api.example.com", timeout: 5000 };
        StaticInit.API_URL = env.api;
        StaticInit.TIMEOUT = env.timeout;
        StaticInit.HEADERS = {
            "Content-Type": "application/json",
            "Accept": "application/json"
        };
    }

    static fetch(endpoint: string): Promise<any> {
        console.log(`Fetching ${StaticInit.API_URL}/${endpoint}`);
        return Promise.resolve({});
    }
}

console.log(StaticInit.API_URL);
console.log(StaticInit.TIMEOUT);
StaticInit.fetch("users");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("StaticInit"),
        "expected StaticInit in output. output: {output}"
    );
    assert!(
        output.contains("fetch"),
        "expected fetch in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for static field init"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test static block with computed property names with ES5 target
#[test]
fn test_source_map_static_block_es5_computed_props() {
    let source = r#"const KEY1 = "dynamicKey1";
const KEY2 = "dynamicKey2";

class ComputedProps {
    static [KEY1]: string;
    static [KEY2]: number;
    static computed: Record<string, any> = {};

    static {
        ComputedProps[KEY1] = "dynamic-value-1";
        ComputedProps[KEY2] = 42;
        ComputedProps.computed[KEY1] = "nested-dynamic";
    }

    static get(key: string): any {
        return ComputedProps.computed[key];
    }
}

console.log(ComputedProps[KEY1]);
console.log(ComputedProps[KEY2]);
console.log(ComputedProps.get(KEY1));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ComputedProps"),
        "expected ComputedProps in output. output: {output}"
    );
    assert!(
        output.contains("KEY1"),
        "expected KEY1 in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for computed props"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test static block with async patterns with ES5 target
#[test]
fn test_source_map_static_block_es5_async_patterns() {
    let source = r#"class AsyncInit {
    static data: any;
    static ready: Promise<void>;

    static {
        AsyncInit.ready = (async () => {
            await new Promise(r => setTimeout(r, 100));
            AsyncInit.data = { loaded: true };
            console.log("Async init complete");
        })();
    }

    static async getData(): Promise<any> {
        await AsyncInit.ready;
        return AsyncInit.data;
    }
}

class LazyLoader {
    static #cache: Map<string, any> = new Map();

    static {
        console.log("LazyLoader initialized");
    }

    static async load(key: string): Promise<any> {
        if (!LazyLoader.#cache.has(key)) {
            const data = await fetch(key);
            LazyLoader.#cache.set(key, data);
        }
        return LazyLoader.#cache.get(key);
    }
}

AsyncInit.getData().then(console.log);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AsyncInit"),
        "expected AsyncInit in output. output: {output}"
    );
    assert!(
        output.contains("LazyLoader"),
        "expected LazyLoader in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async patterns"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test static block with error handling with ES5 target
#[test]
fn test_source_map_static_block_es5_error_handling() {
    let source = r#"class ErrorHandling {
    static config: any;
    static error: Error | null = null;

    static {
        try {
            const raw = '{"valid": true}';
            ErrorHandling.config = JSON.parse(raw);
            console.log("Config loaded successfully");
        } catch (e) {
            ErrorHandling.error = e as Error;
            ErrorHandling.config = { fallback: true };
            console.error("Failed to load config:", e);
        } finally {
            console.log("Init complete");
        }
    }

    static isValid(): boolean {
        return ErrorHandling.error === null;
    }
}

class SafeInit {
    static #initialized = false;

    static {
        try {
            SafeInit.#initialized = true;
        } catch {
            SafeInit.#initialized = false;
        }
    }

    static isReady(): boolean {
        return SafeInit.#initialized;
    }
}

console.log(ErrorHandling.isValid());
console.log(SafeInit.isReady());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ErrorHandling"),
        "expected ErrorHandling in output. output: {output}"
    );
    assert!(
        output.contains("SafeInit"),
        "expected SafeInit in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for error handling"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Comprehensive test for class static block patterns with ES5 target
#[test]
fn test_source_map_static_block_es5_comprehensive() {
    let source = r#"// Comprehensive static block scenarios
class Registry {
    static #instances: Map<string, any> = new Map();
    static #initialized = false;

    static {
        Registry.#initialized = true;
        console.log("Registry initialized");
    }

    static register<T>(key: string, instance: T): void {
        Registry.#instances.set(key, instance);
    }

    static get<T>(key: string): T | undefined {
        return Registry.#instances.get(key) as T | undefined;
    }

    static isInitialized(): boolean {
        return Registry.#initialized;
    }
}

class ConfigManager {
    static readonly defaults: Record<string, any>;
    static #config: Record<string, any>;

    static {
        ConfigManager.defaults = {
            theme: "light",
            language: "en",
            timeout: 5000
        };
        ConfigManager.#config = { ...ConfigManager.defaults };
    }

    static get<T>(key: string): T {
        return ConfigManager.#config[key] as T;
    }

    static set<T>(key: string, value: T): void {
        ConfigManager.#config[key] = value;
    }

    static reset(): void {
        ConfigManager.#config = { ...ConfigManager.defaults };
    }
}

class EventBus {
    static #handlers: Map<string, Function[]> = new Map();
    static #eventCount = 0;

    static {
        EventBus.#handlers = new Map();
        console.log("EventBus ready");
    }

    static on(event: string, handler: Function): void {
        if (!EventBus.#handlers.has(event)) {
            EventBus.#handlers.set(event, []);
        }
        EventBus.#handlers.get(event)!.push(handler);
    }

    static emit(event: string, ...args: any[]): void {
        EventBus.#eventCount++;
        const handlers = EventBus.#handlers.get(event) || [];
        handlers.forEach(h => h(...args));
    }

    static getEventCount(): number {
        return EventBus.#eventCount;
    }
}

class DependencyInjector {
    static #container: Map<string, () => any> = new Map();

    static {
        DependencyInjector.#container.set("logger", () => console);
        DependencyInjector.#container.set("config", () => ConfigManager);
    }

    static {
        DependencyInjector.#container.set("events", () => EventBus);
        console.log("DI container configured");
    }

    static resolve<T>(key: string): T {
        const factory = DependencyInjector.#container.get(key);
        if (!factory) throw new Error(`No provider for ${key}`);
        return factory() as T;
    }

    static register<T>(key: string, factory: () => T): void {
        DependencyInjector.#container.set(key, factory);
    }
}

// Usage
Registry.register("app", { name: "MyApp" });
console.log(Registry.get("app"));
console.log(Registry.isInitialized());

ConfigManager.set("theme", "dark");
console.log(ConfigManager.get("theme"));
ConfigManager.reset();

EventBus.on("test", (msg: string) => console.log(msg));
EventBus.emit("test", "Hello!");
console.log(EventBus.getEventCount());

const logger = DependencyInjector.resolve<Console>("logger");
logger.log("DI working!");"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Registry"),
        "expected Registry in output. output: {output}"
    );
    assert!(
        output.contains("ConfigManager"),
        "expected ConfigManager in output. output: {output}"
    );
    assert!(
        output.contains("EventBus"),
        "expected EventBus in output. output: {output}"
    );
    assert!(
        output.contains("DependencyInjector"),
        "expected DependencyInjector in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive static blocks"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS - ASYNC/CLASS INTEGRATION PATTERNS
// =============================================================================
// Tests for async/class integration patterns with ES5 target to verify source maps
// work correctly with combined async and class transforms.

/// Test async method in derived class with super call
#[test]
fn test_source_map_async_class_integration_es5_derived_super_call() {
    let source = r#"class BaseService {
    protected baseUrl: string = "https://api.example.com";

    async fetchData(endpoint: string): Promise<any> {
        const response = await fetch(this.baseUrl + endpoint);
        return response.json();
    }

    async validate(data: any): Promise<boolean> {
        return data !== null && data !== undefined;
    }
}

class UserService extends BaseService {
    private userId: string;

    constructor(userId: string) {
        super();
        this.userId = userId;
    }

    async getUser(): Promise<any> {
        const data = await super.fetchData(`/users/${this.userId}`);
        const isValid = await super.validate(data);
        if (!isValid) {
            throw new Error("Invalid user data");
        }
        return data;
    }

    async updateUser(updates: any): Promise<any> {
        const currentData = await super.fetchData(`/users/${this.userId}`);
        const merged = { ...currentData, ...updates };
        return merged;
    }
}

const service = new UserService("123");
service.getUser().then(console.log);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("UserService"),
        "expected UserService in output. output: {output}"
    );
    assert!(
        output.contains("BaseService"),
        "expected BaseService in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async derived class with super"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test async arrow field initializer with ES5 target
#[test]
fn test_source_map_async_class_integration_es5_arrow_field_initializer() {
    let source = r#"class EventHandler {
    private name: string;
    private count: number = 0;

    // Async arrow as class field - captures 'this' lexically
    handleClick = async (event: any): Promise<void> => {
        this.count++;
        console.log(`${this.name} clicked ${this.count} times`);
        await this.processEvent(event);
    };

    handleHover = async (): Promise<string> => {
        return `Hovering over ${this.name}`;
    };

    handleSubmit = async (data: any): Promise<boolean> => {
        const result = await this.validate(data);
        if (result) {
            await this.save(data);
        }
        return result;
    };

    constructor(name: string) {
        this.name = name;
    }

    private async processEvent(event: any): Promise<void> {
        console.log("Processing:", event);
    }

    private async validate(data: any): Promise<boolean> {
        return data !== null;
    }

    private async save(data: any): Promise<void> {
        console.log("Saving:", data);
    }
}

const handler = new EventHandler("Button");
handler.handleClick({ type: "click" });"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("EventHandler"),
        "expected EventHandler in output. output: {output}"
    );
    assert!(
        output.contains("handleClick"),
        "expected handleClick in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async arrow field initializer"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test async static method with this capture
#[test]
fn test_source_map_async_class_integration_es5_static_this_capture() {
    let source = r#"class ConfigManager {
    private static instance: ConfigManager | null = null;
    private static config: Map<string, any> = new Map();
    private static initialized: boolean = false;

    static async initialize(): Promise<void> {
        if (this.initialized) {
            return;
        }
        await this.loadConfig();
        this.initialized = true;
    }

    private static async loadConfig(): Promise<void> {
        // Simulate async config loading
        const data = await fetch("/config.json");
        const json = await data.json();
        for (const [key, value] of Object.entries(json)) {
            this.config.set(key, value);
        }
    }

    static async get(key: string): Promise<any> {
        if (!this.initialized) {
            await this.initialize();
        }
        return this.config.get(key);
    }

    static async set(key: string, value: any): Promise<void> {
        if (!this.initialized) {
            await this.initialize();
        }
        this.config.set(key, value);
        await this.persist();
    }

    private static async persist(): Promise<void> {
        const data = Object.fromEntries(this.config);
        console.log("Persisting config:", data);
    }

    static async getInstance(): Promise<ConfigManager> {
        if (!this.instance) {
            await this.initialize();
            this.instance = new ConfigManager();
        }
        return this.instance;
    }
}

ConfigManager.initialize().then(() => console.log("Config ready"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ConfigManager"),
        "expected ConfigManager in output. output: {output}"
    );
    assert!(
        output.contains("initialize"),
        "expected initialize in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async static with this capture"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test async generator class method with ES5 target
#[test]
fn test_source_map_async_class_integration_es5_generator_method() {
    let source = r#"class DataStream {
    private items: string[] = [];
    private batchSize: number;

    constructor(items: string[], batchSize: number = 10) {
        this.items = items;
        this.batchSize = batchSize;
    }

    async *stream(): AsyncGenerator<string[], void, unknown> {
        for (let i = 0; i < this.items.length; i += this.batchSize) {
            const batch = this.items.slice(i, i + this.batchSize);
            await this.processBatch(batch);
            yield batch;
        }
    }

    async *filter(predicate: (item: string) => boolean): AsyncGenerator<string, void, unknown> {
        for await (const batch of this.stream()) {
            for (const item of batch) {
                if (predicate(item)) {
                    yield item;
                }
            }
        }
    }

    async *map<T>(transform: (item: string) => T): AsyncGenerator<T, void, unknown> {
        for await (const batch of this.stream()) {
            for (const item of batch) {
                yield transform(item);
            }
        }
    }

    private async processBatch(batch: string[]): Promise<void> {
        console.log(`Processing batch of ${batch.length} items`);
    }
}

const stream = new DataStream(["a", "b", "c", "d", "e"]);
(async () => {
    for await (const batch of stream.stream()) {
        console.log("Batch:", batch);
    }
})();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataStream"),
        "expected DataStream in output. output: {output}"
    );
    assert!(
        output.contains("stream"),
        "expected stream method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async generator class method"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test async constructor simulation pattern
#[test]
fn test_source_map_async_class_integration_es5_constructor_simulation() {
    let source = r#"class AsyncDatabase {
    private connection: any = null;
    private ready: boolean = false;

    private constructor() {
        // Private constructor - use create() instead
    }

    private async init(connectionString: string): Promise<void> {
        this.connection = await this.connect(connectionString);
        await this.runMigrations();
        this.ready = true;
    }

    private async connect(connectionString: string): Promise<any> {
        console.log("Connecting to:", connectionString);
        return { connected: true };
    }

    private async runMigrations(): Promise<void> {
        console.log("Running migrations...");
    }

    static async create(connectionString: string): Promise<AsyncDatabase> {
        const instance = new AsyncDatabase();
        await instance.init(connectionString);
        return instance;
    }

    async query(sql: string): Promise<any[]> {
        if (!this.ready) {
            throw new Error("Database not initialized");
        }
        console.log("Executing:", sql);
        return [];
    }

    async close(): Promise<void> {
        if (this.connection) {
            console.log("Closing connection");
            this.connection = null;
            this.ready = false;
        }
    }
}

// Factory pattern with async initialization
class AsyncService {
    private db: AsyncDatabase | null = null;

    private constructor() {}

    private async initialize(): Promise<void> {
        this.db = await AsyncDatabase.create("postgres://localhost/mydb");
    }

    static async create(): Promise<AsyncService> {
        const service = new AsyncService();
        await service.initialize();
        return service;
    }

    async getData(): Promise<any[]> {
        return this.db!.query("SELECT * FROM data");
    }
}

AsyncService.create().then(service => service.getData());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("AsyncDatabase"),
        "expected AsyncDatabase in output. output: {output}"
    );
    assert!(
        output.contains("AsyncService"),
        "expected AsyncService in output. output: {output}"
    );
    assert!(
        output.contains("create"),
        "expected create factory in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for async constructor simulation"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test combined async/class source map patterns
#[test]
fn test_source_map_async_class_integration_es5_comprehensive() {
    let source = r#"// Comprehensive async/class integration test
abstract class BaseRepository<T> {
    protected items: Map<string, T> = new Map();

    abstract validate(item: T): Promise<boolean>;

    async findById(id: string): Promise<T | undefined> {
        return this.items.get(id);
    }

    async save(id: string, item: T): Promise<void> {
        const isValid = await this.validate(item);
        if (!isValid) {
            throw new Error("Validation failed");
        }
        this.items.set(id, item);
    }
}

interface User {
    id: string;
    name: string;
    email: string;
}

class UserRepository extends BaseRepository<User> {
    private static instance: UserRepository;

    // Async arrow field
    validateEmail = async (email: string): Promise<boolean> => {
        return email.includes("@");
    };

    async validate(user: User): Promise<boolean> {
        const emailValid = await this.validateEmail(user.email);
        return emailValid && user.name.length > 0;
    }

    // Async generator for streaming users
    async *streamUsers(): AsyncGenerator<User, void, unknown> {
        for (const user of this.items.values()) {
            yield user;
        }
    }

    // Static async factory
    static async getInstance(): Promise<UserRepository> {
        if (!this.instance) {
            this.instance = new UserRepository();
            await this.instance.initialize();
        }
        return this.instance;
    }

    private async initialize(): Promise<void> {
        console.log("Initializing UserRepository");
    }

    // Async method with super call
    async save(id: string, user: User): Promise<void> {
        console.log(`Saving user: ${user.name}`);
        await super.save(id, user);
    }
}

class UserService {
    private repo: UserRepository | null = null;

    // Multiple async arrow fields
    getUser = async (id: string): Promise<User | undefined> => {
        const repo = await this.getRepo();
        return repo.findById(id);
    };

    createUser = async (user: User): Promise<void> => {
        const repo = await this.getRepo();
        await repo.save(user.id, user);
    };

    private async getRepo(): Promise<UserRepository> {
        if (!this.repo) {
            this.repo = await UserRepository.getInstance();
        }
        return this.repo;
    }
}

// Usage
const service = new UserService();
(async () => {
    await service.createUser({ id: "1", name: "John", email: "john@example.com" });
    const user = await service.getUser("1");
    console.log(user);

    const repo = await UserRepository.getInstance();
    for await (const u of repo.streamUsers()) {
        console.log("Streaming user:", u.name);
    }
})();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("BaseRepository"),
        "expected BaseRepository in output. output: {output}"
    );
    assert!(
        output.contains("UserRepository"),
        "expected UserRepository in output. output: {output}"
    );
    assert!(
        output.contains("UserService"),
        "expected UserService in output. output: {output}"
    );
    assert!(
        output.contains("validateEmail"),
        "expected validateEmail in output. output: {output}"
    );
    assert!(
        output.contains("streamUsers"),
        "expected streamUsers in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive async/class integration"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS - GENERATOR TRANSFORM PATTERNS
// =============================================================================
// Tests for generator transform patterns with ES5 target to verify source maps
// work correctly with generator state machine transforms.

/// Test generator function basic yield mapping with typed parameters
#[test]
fn test_source_map_generator_transform_es5_basic_yield_mapping() {
    let source = r#"function* numberSequence(start: number, end: number): Generator<number, void, unknown> {
    for (let i = start; i <= end; i++) {
        yield i;
    }
}

function* alphabetGenerator(): Generator<string, void, unknown> {
    const letters = "abcdefghijklmnopqrstuvwxyz";
    for (const letter of letters) {
        yield letter;
    }
}

// Using the generators
const numbers = numberSequence(1, 5);
for (const n of numbers) {
    console.log("Number:", n);
}

const alphabet = alphabetGenerator();
console.log(alphabet.next().value);
console.log(alphabet.next().value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("numberSequence"),
        "expected numberSequence in output. output: {output}"
    );
    assert!(
        output.contains("alphabetGenerator"),
        "expected alphabetGenerator in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for basic yield mapping"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test generator with multiple yields and complex expressions
#[test]
fn test_source_map_generator_transform_es5_multiple_yields() {
    let source = r#"function* dataProcessor(items: string[]): Generator<{ index: number; value: string; processed: boolean }, number, unknown> {
    let processedCount = 0;

    for (let i = 0; i < items.length; i++) {
        const item = items[i];

        // Yield before processing
        yield { index: i, value: item, processed: false };

        // Simulate processing
        const processed = item.toUpperCase();
        processedCount++;

        // Yield after processing
        yield { index: i, value: processed, processed: true };
    }

    // Final yield with count
    yield { index: -1, value: `Total: ${processedCount}`, processed: true };

    return processedCount;
}

const processor = dataProcessor(["hello", "world", "test"]);
let result = processor.next();
while (!result.done) {
    console.log(result.value);
    result = processor.next();
}
console.log("Final count:", result.value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("dataProcessor"),
        "expected dataProcessor in output. output: {output}"
    );
    assert!(
        output.contains("processedCount"),
        "expected processedCount in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple yields"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test generator delegation with yield*
#[test]
fn test_source_map_generator_transform_es5_delegation() {
    let source = r#"function* innerGenerator(prefix: string): Generator<string, void, unknown> {
    yield `${prefix}-1`;
    yield `${prefix}-2`;
    yield `${prefix}-3`;
}

function* middleGenerator(): Generator<string, void, unknown> {
    yield "start";
    yield* innerGenerator("middle");
    yield "end";
}

function* outerGenerator(): Generator<string, void, unknown> {
    yield "outer-start";
    yield* middleGenerator();
    yield* innerGenerator("outer");
    yield "outer-end";
}

// Test chained delegation
function* chainedDelegation(): Generator<number, void, unknown> {
    const arrays = [[1, 2], [3, 4], [5, 6]];
    for (const arr of arrays) {
        yield* arr;
    }
}

const outer = outerGenerator();
for (const value of outer) {
    console.log(value);
}

const chained = chainedDelegation();
console.log([...chained]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("innerGenerator"),
        "expected innerGenerator in output. output: {output}"
    );
    assert!(
        output.contains("outerGenerator"),
        "expected outerGenerator in output. output: {output}"
    );
    assert!(
        output.contains("chainedDelegation"),
        "expected chainedDelegation in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator delegation"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test generator in class method with instance access
#[test]
fn test_source_map_generator_transform_es5_class_method() {
    let source = r#"class DataIterator {
    private data: number[];
    private name: string;

    constructor(name: string, data: number[]) {
        this.name = name;
        this.data = data;
    }

    *iterate(): Generator<number, void, unknown> {
        console.log(`Starting iteration for ${this.name}`);
        for (const item of this.data) {
            yield item;
        }
        console.log(`Finished iteration for ${this.name}`);
    }

    *iterateWithIndex(): Generator<[number, number], void, unknown> {
        for (let i = 0; i < this.data.length; i++) {
            yield [i, this.data[i]];
        }
    }

    *filter(predicate: (n: number) => boolean): Generator<number, void, unknown> {
        for (const item of this.data) {
            if (predicate(item)) {
                yield item;
            }
        }
    }

    static *range(start: number, end: number): Generator<number, void, unknown> {
        for (let i = start; i <= end; i++) {
            yield i;
        }
    }
}

const iterator = new DataIterator("test", [1, 2, 3, 4, 5]);
for (const num of iterator.iterate()) {
    console.log("Value:", num);
}

for (const [idx, val] of iterator.iterateWithIndex()) {
    console.log(`Index ${idx}: ${val}`);
}

for (const even of iterator.filter(n => n % 2 === 0)) {
    console.log("Even:", even);
}

for (const n of DataIterator.range(10, 15)) {
    console.log("Range:", n);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataIterator"),
        "expected DataIterator in output. output: {output}"
    );
    assert!(
        output.contains("iterate"),
        "expected iterate method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator class method"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test generator with try/finally for cleanup
#[test]
fn test_source_map_generator_transform_es5_try_finally() {
    let source = r#"function* resourceManager(): Generator<string, void, unknown> {
    console.log("Acquiring resource");
    try {
        yield "resource acquired";

        console.log("Using resource");
        yield "resource in use";

        console.log("Still using resource");
        yield "still in use";
    } finally {
        console.log("Releasing resource (cleanup)");
    }
}

function* nestedTryFinally(): Generator<number, void, unknown> {
    try {
        yield 1;
        try {
            yield 2;
            try {
                yield 3;
            } finally {
                console.log("Inner cleanup");
            }
            yield 4;
        } finally {
            console.log("Middle cleanup");
        }
        yield 5;
    } finally {
        console.log("Outer cleanup");
    }
}

function* tryCatchFinally(): Generator<string, void, unknown> {
    try {
        yield "before";
        throw new Error("test error");
    } catch (e) {
        yield `caught: ${(e as Error).message}`;
    } finally {
        yield "finally block";
    }
}

// Test resource management pattern
const rm = resourceManager();
rm.next();
rm.next();
rm.return(); // Early termination triggers finally

// Test nested cleanup
const nested = nestedTryFinally();
for (const n of nested) {
    console.log("Nested value:", n);
}

// Test full try/catch/finally
const tcf = tryCatchFinally();
for (const s of tcf) {
    console.log("TCF:", s);
}"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("resourceManager"),
        "expected resourceManager in output. output: {output}"
    );
    assert!(
        output.contains("nestedTryFinally"),
        "expected nestedTryFinally in output. output: {output}"
    );
    assert!(
        output.contains("tryCatchFinally"),
        "expected tryCatchFinally in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generator try/finally"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test combined generator source map patterns
#[test]
fn test_source_map_generator_transform_es5_comprehensive() {
    let source = r#"// Comprehensive generator transform test
interface Task {
    id: number;
    name: string;
    status: "pending" | "running" | "completed";
}

class TaskQueue {
    private tasks: Task[] = [];
    private idCounter = 0;

    add(name: string): Task {
        const task: Task = {
            id: this.idCounter++,
            name,
            status: "pending"
        };
        this.tasks.push(task);
        return task;
    }

    *pending(): Generator<Task, void, unknown> {
        for (const task of this.tasks) {
            if (task.status === "pending") {
                yield task;
            }
        }
    }

    *all(): Generator<Task, void, unknown> {
        yield* this.tasks;
    }

    *process(): Generator<Task, number, unknown> {
        let processed = 0;
        for (const task of this.tasks) {
            if (task.status === "pending") {
                task.status = "running";
                yield task;
                task.status = "completed";
                processed++;
            }
        }
        return processed;
    }
}

function* pipeline<T, U>(
    source: Generator<T, void, unknown>,
    transform: (item: T) => U
): Generator<U, void, unknown> {
    for (const item of source) {
        yield transform(item);
    }
}

function* take<T>(source: Generator<T, void, unknown>, count: number): Generator<T, void, unknown> {
    let taken = 0;
    for (const item of source) {
        if (taken >= count) break;
        yield item;
        taken++;
    }
}

function* infiniteCounter(start: number = 0): Generator<number, never, unknown> {
    let count = start;
    while (true) {
        yield count++;
    }
}

// Usage
const queue = new TaskQueue();
queue.add("Task 1");
queue.add("Task 2");
queue.add("Task 3");

// Iterator over pending tasks
for (const task of queue.pending()) {
    console.log("Pending:", task.name);
}

// Pipeline with transform
const taskNames = pipeline(queue.all(), task => task.name.toUpperCase());
for (const name of taskNames) {
    console.log("Name:", name);
}

// Take from infinite sequence
const firstFive = take(infiniteCounter(100), 5);
console.log([...firstFive]);

// Process tasks
const processor = queue.process();
let result = processor.next();
while (!result.done) {
    console.log("Processing:", (result.value as Task).name);
    result = processor.next();
}
console.log("Total processed:", result.value);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("TaskQueue"),
        "expected TaskQueue in output. output: {output}"
    );
    assert!(
        output.contains("pipeline"),
        "expected pipeline in output. output: {output}"
    );
    assert!(
        output.contains("infiniteCounter"),
        "expected infiniteCounter in output. output: {output}"
    );
    assert!(
        output.contains("pending"),
        "expected pending method in output. output: {output}"
    );
    assert!(
        output.contains("process"),
        "expected process method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive generator transform"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS: PRIVATE CLASS FEATURES TRANSFORM
// =============================================================================

/// Test source map generation for private field read access in ES5 output.
/// Validates that reading private fields (#field) generates proper source mappings.
#[test]
fn test_source_map_private_field_read_es5() {
    let source = r#"class Counter {
    #count = 0;

    getCount() {
        return this.#count;
    }
}

const counter = new Counter();
console.log(counter.getCount());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter"),
        "expected Counter class in output. output: {output}"
    );
    assert!(
        output.contains("getCount"),
        "expected getCount method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private field read"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for private field write access in ES5 output.
/// Validates that writing to private fields (#field = value) generates proper source mappings.
#[test]
fn test_source_map_private_field_write_es5() {
    let source = r#"class Counter {
    #count = 0;

    increment() {
        this.#count = this.#count + 1;
    }

    reset() {
        this.#count = 0;
    }
}

const counter = new Counter();
counter.increment();
counter.reset();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Counter"),
        "expected Counter class in output. output: {output}"
    );
    assert!(
        output.contains("increment"),
        "expected increment method in output. output: {output}"
    );
    assert!(
        output.contains("reset"),
        "expected reset method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private field write"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for private method calls in ES5 output.
/// Validates that calling private methods (#method()) generates proper source mappings.
#[test]
fn test_source_map_private_method_call_es5() {
    let source = r#"class Calculator {
    #validate(n: number): boolean {
        return n >= 0;
    }

    #compute(a: number, b: number): number {
        return a * b;
    }

    multiply(x: number, y: number): number {
        if (this.#validate(x) && this.#validate(y)) {
            return this.#compute(x, y);
        }
        return 0;
    }
}

const calc = new Calculator();
console.log(calc.multiply(5, 3));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Calculator"),
        "expected Calculator class in output. output: {output}"
    );
    assert!(
        output.contains("multiply"),
        "expected multiply method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private method call"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for private accessors (get/set) in ES5 output.
/// Validates that private getters and setters generate proper source mappings.
#[test]
fn test_source_map_private_accessor_es5() {
    let source = r#"class Temperature {
    #celsius = 0;

    get #fahrenheit(): number {
        return this.#celsius * 9/5 + 32;
    }

    set #fahrenheit(value: number) {
        this.#celsius = (value - 32) * 5/9;
    }

    setFahrenheit(f: number) {
        this.#fahrenheit = f;
    }

    getFahrenheit(): number {
        return this.#fahrenheit;
    }
}

const temp = new Temperature();
temp.setFahrenheit(98.6);
console.log(temp.getFahrenheit());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Temperature"),
        "expected Temperature class in output. output: {output}"
    );
    assert!(
        output.contains("setFahrenheit"),
        "expected setFahrenheit method in output. output: {output}"
    );
    assert!(
        output.contains("getFahrenheit"),
        "expected getFahrenheit method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private accessor"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for private static members in ES5 output.
/// Validates that static private fields and methods generate proper source mappings.
#[test]
fn test_source_map_private_static_members_es5() {
    let source = r#"class IdGenerator {
    static #nextId = 1;

    static #generateId(): number {
        return IdGenerator.#nextId++;
    }

    static create(): number {
        return IdGenerator.#generateId();
    }

    static reset(): void {
        IdGenerator.#nextId = 1;
    }
}

console.log(IdGenerator.create());
console.log(IdGenerator.create());
IdGenerator.reset();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("IdGenerator"),
        "expected IdGenerator class in output. output: {output}"
    );
    assert!(
        output.contains("create"),
        "expected create static method in output. output: {output}"
    );
    assert!(
        output.contains("reset"),
        "expected reset static method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for private static members"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Comprehensive test combining multiple private class feature patterns.
/// Tests private fields, methods, accessors, and static members together.
#[test]
fn test_source_map_private_features_es5_comprehensive() {
    let source = r#"class BankAccount {
    static #accountCount = 0;
    #balance = 0;
    #transactions: string[] = [];

    #log(message: string): void {
        this.#transactions.push(message);
    }

    get #formattedBalance(): string {
        return `$${this.#balance.toFixed(2)}`;
    }

    static #validateAmount(amount: number): boolean {
        return amount > 0 && isFinite(amount);
    }

    constructor(initialBalance: number) {
        if (BankAccount.#validateAmount(initialBalance)) {
            this.#balance = initialBalance;
            this.#log(`Account opened with ${this.#formattedBalance}`);
        }
        BankAccount.#accountCount++;
    }

    deposit(amount: number): boolean {
        if (BankAccount.#validateAmount(amount)) {
            this.#balance += amount;
            this.#log(`Deposited: $${amount}`);
            return true;
        }
        return false;
    }

    withdraw(amount: number): boolean {
        if (BankAccount.#validateAmount(amount) && amount <= this.#balance) {
            this.#balance -= amount;
            this.#log(`Withdrew: $${amount}`);
            return true;
        }
        return false;
    }

    getBalance(): string {
        return this.#formattedBalance;
    }

    getHistory(): string[] {
        return [...this.#transactions];
    }

    static getAccountCount(): number {
        return BankAccount.#accountCount;
    }
}

const account = new BankAccount(100);
account.deposit(50);
account.withdraw(25);
console.log(account.getBalance());
console.log(account.getHistory());
console.log(BankAccount.getAccountCount());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("BankAccount"),
        "expected BankAccount class in output. output: {output}"
    );
    assert!(
        output.contains("deposit"),
        "expected deposit method in output. output: {output}"
    );
    assert!(
        output.contains("withdraw"),
        "expected withdraw method in output. output: {output}"
    );
    assert!(
        output.contains("getBalance"),
        "expected getBalance method in output. output: {output}"
    );
    assert!(
        output.contains("getHistory"),
        "expected getHistory method in output. output: {output}"
    );
    assert!(
        output.contains("getAccountCount"),
        "expected getAccountCount static method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive private features"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS: TYPE PARAMETER CONSTRAINTS
// =============================================================================

/// Test source map generation for generic function with type parameter constraint in ES5 output.
/// Validates that generic functions with extends constraints generate proper source mappings.
#[test]
fn test_source_map_type_constraint_generic_function_es5() {
    let source = r#"interface HasLength {
    length: number;
}

function getLength<T extends HasLength>(item: T): number {
    return item.length;
}

function first<T extends any[]>(arr: T): T[0] {
    return arr[0];
}

const strLen = getLength("hello");
const arrLen = getLength([1, 2, 3]);
const firstItem = first([1, 2, 3]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getLength"),
        "expected getLength function in output. output: {output}"
    );
    assert!(
        output.contains("first"),
        "expected first function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generic function with constraint"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for generic class with type parameter constraint in ES5 output.
/// Validates that generic classes with extends constraints generate proper source mappings.
#[test]
fn test_source_map_type_constraint_generic_class_es5() {
    let source = r#"interface Comparable<T> {
    compareTo(other: T): number;
}

class SortedList<T extends Comparable<T>> {
    private items: T[] = [];

    add(item: T): void {
        this.items.push(item);
        this.items.sort((a, b) => a.compareTo(b));
    }

    get(index: number): T {
        return this.items[index];
    }

    getAll(): T[] {
        return [...this.items];
    }
}

class NumberWrapper implements Comparable<NumberWrapper> {
    constructor(public value: number) {}

    compareTo(other: NumberWrapper): number {
        return this.value - other.value;
    }
}

const list = new SortedList<NumberWrapper>();
list.add(new NumberWrapper(5));
list.add(new NumberWrapper(2));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("SortedList"),
        "expected SortedList class in output. output: {output}"
    );
    assert!(
        output.contains("NumberWrapper"),
        "expected NumberWrapper class in output. output: {output}"
    );
    assert!(
        output.contains("compareTo"),
        "expected compareTo method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generic class with constraint"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for generic interface with type parameter constraint in ES5 output.
/// Validates that generic interfaces with extends constraints generate proper source mappings.
#[test]
fn test_source_map_type_constraint_generic_interface_es5() {
    let source = r#"interface Entity {
    id: number;
    createdAt: Date;
}

interface Repository<T extends Entity> {
    findById(id: number): T | undefined;
    findAll(): T[];
    save(entity: T): T;
    delete(id: number): boolean;
}

interface User extends Entity {
    name: string;
    email: string;
}

class UserRepository implements Repository<User> {
    private users: User[] = [];

    findById(id: number): User | undefined {
        return this.users.find(u => u.id === id);
    }

    findAll(): User[] {
        return [...this.users];
    }

    save(user: User): User {
        this.users.push(user);
        return user;
    }

    delete(id: number): boolean {
        const index = this.users.findIndex(u => u.id === id);
        if (index >= 0) {
            this.users.splice(index, 1);
            return true;
        }
        return false;
    }
}

const repo = new UserRepository();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("UserRepository"),
        "expected UserRepository class in output. output: {output}"
    );
    assert!(
        output.contains("findById"),
        "expected findById method in output. output: {output}"
    );
    assert!(
        output.contains("findAll"),
        "expected findAll method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for generic interface with constraint"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for multiple type parameters with constraints in ES5 output.
/// Validates that functions with multiple constrained type parameters generate proper source mappings.
#[test]
fn test_source_map_type_constraint_multiple_params_es5() {
    let source = r#"interface Serializable {
    serialize(): string;
}

interface Deserializable<T> {
    deserialize(data: string): T;
}

function transform<
    TInput extends Serializable,
    TOutput,
    TTransformer extends { transform(input: TInput): TOutput }
>(input: TInput, transformer: TTransformer): TOutput {
    return transformer.transform(input);
}

function merge<T extends object, U extends object>(first: T, second: U): T & U {
    return { ...first, ...second };
}

function pick<T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
    const result = {} as Pick<T, K>;
    for (const key of keys) {
        result[key] = obj[key];
    }
    return result;
}

const merged = merge({ a: 1 }, { b: 2 });
const picked = pick({ x: 1, y: 2, z: 3 }, ["x", "z"]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("transform"),
        "expected transform function in output. output: {output}"
    );
    assert!(
        output.contains("merge"),
        "expected merge function in output. output: {output}"
    );
    assert!(
        output.contains("pick"),
        "expected pick function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for multiple type parameter constraints"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for constraint extends union type in ES5 output.
/// Validates that type parameters constrained by union types generate proper source mappings.
#[test]
fn test_source_map_type_constraint_union_es5() {
    let source = r#"type Primitive = string | number | boolean;

function formatPrimitive<T extends Primitive>(value: T): string {
    return String(value);
}

type JsonValue = string | number | boolean | null | JsonArray | JsonObject;
interface JsonArray extends Array<JsonValue> {}
interface JsonObject { [key: string]: JsonValue; }

function stringify<T extends JsonValue>(value: T): string {
    return JSON.stringify(value);
}

type EventType = "click" | "hover" | "focus" | "blur";

function addEventListener<T extends EventType>(
    type: T,
    handler: (event: T) => void
): void {
    console.log(`Adding listener for ${type}`);
}

const formatted = formatPrimitive(42);
const json = stringify({ key: "value" });
addEventListener("click", (e) => console.log(e));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("formatPrimitive"),
        "expected formatPrimitive function in output. output: {output}"
    );
    assert!(
        output.contains("stringify"),
        "expected stringify function in output. output: {output}"
    );
    assert!(
        output.contains("addEventListener"),
        "expected addEventListener function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for union type constraints"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Comprehensive test combining multiple type parameter constraint patterns.
/// Tests generic functions, classes, interfaces with various constraint types.
#[test]
fn test_source_map_type_constraint_es5_comprehensive() {
    let source = r#"// Base interfaces for constraints
interface Identifiable {
    id: string;
}

interface Timestamped {
    createdAt: Date;
    updatedAt: Date;
}

interface Validatable {
    validate(): boolean;
}

// Generic class with multiple constraints
class DataStore<T extends Identifiable & Timestamped> {
    private data: Map<string, T> = new Map();

    save(item: T): void {
        this.data.set(item.id, item);
    }

    find(id: string): T | undefined {
        return this.data.get(id);
    }

    findRecent(since: Date): T[] {
        return Array.from(this.data.values())
            .filter(item => item.updatedAt > since);
    }
}

// Generic function with constraint referencing another type parameter
function createValidator<
    T extends Validatable,
    TResult extends { valid: boolean; errors: string[] }
>(item: T, resultFactory: () => TResult): TResult {
    const result = resultFactory();
    result.valid = item.validate();
    return result;
}

// Class with constrained method type parameters
class Mapper<TSource extends object> {
    map<TTarget extends object>(
        source: TSource,
        mapper: (s: TSource) => TTarget
    ): TTarget {
        return mapper(source);
    }

    mapArray<TTarget extends object>(
        sources: TSource[],
        mapper: (s: TSource) => TTarget
    ): TTarget[] {
        return sources.map(mapper);
    }
}

// Conditional constraint pattern
type Constructor<T> = new (...args: any[]) => T;

function mixin<TBase extends Constructor<{}>>(Base: TBase) {
    return class extends Base {
        mixinProp = "mixed";
    };
}

// Usage
interface User extends Identifiable, Timestamped {
    name: string;
    email: string;
}

const store = new DataStore<User>();
const mapper = new Mapper<{ x: number }>();
const result = mapper.map({ x: 1 }, (s) => ({ y: s.x * 2 }));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("DataStore"),
        "expected DataStore class in output. output: {output}"
    );
    assert!(
        output.contains("createValidator"),
        "expected createValidator function in output. output: {output}"
    );
    assert!(
        output.contains("Mapper"),
        "expected Mapper class in output. output: {output}"
    );
    assert!(
        output.contains("mixin"),
        "expected mixin function in output. output: {output}"
    );
    assert!(
        output.contains("findRecent"),
        "expected findRecent method in output. output: {output}"
    );
    assert!(
        output.contains("mapArray"),
        "expected mapArray method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive type constraints"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS: CONDITIONAL TYPE EXPRESSIONS
// =============================================================================

/// Test source map generation for conditional types with infer keyword in ES5 output.
/// Validates that infer patterns generate proper source mappings.
#[test]
fn test_source_map_conditional_type_infer_es5() {
    let source = r#"// Infer return type
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

// Infer parameter types
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

// Infer array element type
type ElementType<T> = T extends (infer E)[] ? E : never;

// Infer promise resolved type
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;

// Function using inferred types
function getReturnType<T extends (...args: any[]) => any>(
    fn: T
): ReturnType<T> | undefined {
    try {
        return fn() as ReturnType<T>;
    } catch {
        return undefined;
    }
}

function callWithArgs<T extends (...args: any[]) => any>(
    fn: T,
    ...args: Parameters<T>
): ReturnType<T> {
    return fn(...args);
}

const add = (a: number, b: number) => a + b;
const result = callWithArgs(add, 1, 2);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getReturnType"),
        "expected getReturnType function in output. output: {output}"
    );
    assert!(
        output.contains("callWithArgs"),
        "expected callWithArgs function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for conditional type with infer"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for distributive conditional types in ES5 output.
/// Validates that distributive conditional patterns generate proper source mappings.
#[test]
fn test_source_map_conditional_type_distributive_es5() {
    let source = r#"// Distributive conditional type
type ToArray<T> = T extends any ? T[] : never;

// Non-nullable extraction
type NonNullable<T> = T extends null | undefined ? never : T;

// Extract types from union
type Extract<T, U> = T extends U ? T : never;

// Exclude types from union
type Exclude<T, U> = T extends U ? never : T;

// Practical usage
type StringOrNumber = string | number | null | undefined;
type NonNullStringOrNumber = NonNullable<StringOrNumber>;
type OnlyStrings = Extract<StringOrNumber, string>;
type NoStrings = Exclude<StringOrNumber, string>;

function filterNonNull<T>(items: (T | null | undefined)[]): NonNullable<T>[] {
    return items.filter((item): item is NonNullable<T> => item != null);
}

function extractStrings(items: (string | number)[]): string[] {
    return items.filter((item): item is string => typeof item === "string");
}

const mixed = [1, "hello", null, 2, "world", undefined];
const nonNull = filterNonNull(mixed);
const strings = extractStrings([1, "a", 2, "b"]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("filterNonNull"),
        "expected filterNonNull function in output. output: {output}"
    );
    assert!(
        output.contains("extractStrings"),
        "expected extractStrings function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for distributive conditional type"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for nested conditional types in ES5 output.
/// Validates that deeply nested conditional patterns generate proper source mappings.
#[test]
fn test_source_map_conditional_type_nested_es5() {
    let source = r#"// Nested conditional types
type DeepReadonly<T> = T extends (infer U)[]
    ? ReadonlyArray<DeepReadonly<U>>
    : T extends object
    ? { readonly [K in keyof T]: DeepReadonly<T[K]> }
    : T;

// Type classification
type TypeName<T> = T extends string
    ? "string"
    : T extends number
    ? "number"
    : T extends boolean
    ? "boolean"
    : T extends undefined
    ? "undefined"
    : T extends Function
    ? "function"
    : "object";

// Flatten nested arrays
type Flatten<T> = T extends Array<infer U>
    ? U extends Array<any>
        ? Flatten<U>
        : U
    : T;

function getTypeName<T>(value: T): TypeName<T> {
    return typeof value as TypeName<T>;
}

function flatten<T>(arr: T[][]): Flatten<T[][]>[] {
    return arr.reduce((acc, val) => acc.concat(val), [] as Flatten<T[][]>[]);
}

const typeName = getTypeName("hello");
const flat = flatten([[1, 2], [3, 4]]);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getTypeName"),
        "expected getTypeName function in output. output: {output}"
    );
    assert!(
        output.contains("flatten"),
        "expected flatten function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for nested conditional types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for conditional types in function returns in ES5 output.
/// Validates that conditional return types generate proper source mappings.
#[test]
fn test_source_map_conditional_type_function_return_es5() {
    let source = r#"// Conditional return based on input type
type StringOrNumberResult<T> = T extends string ? string[] : number[];

function process<T extends string | number>(
    input: T
): StringOrNumberResult<T> {
    if (typeof input === "string") {
        return input.split("") as StringOrNumberResult<T>;
    }
    return [input] as StringOrNumberResult<T>;
}

// Conditional async return
type AsyncResult<T> = T extends Promise<infer U> ? U : Promise<T>;

async function ensureAsync<T>(value: T): Promise<AsyncResult<T>> {
    if (value instanceof Promise) {
        return value as unknown as AsyncResult<T>;
    }
    return value as AsyncResult<T>;
}

// Method overload simulation with conditional
type MethodResult<T, K extends keyof T> = T[K] extends (...args: any[]) => infer R
    ? R
    : T[K];

function invoke<T extends object, K extends keyof T>(
    obj: T,
    key: K
): MethodResult<T, K> {
    const prop = obj[key];
    if (typeof prop === "function") {
        return (prop as Function).call(obj) as MethodResult<T, K>;
    }
    return prop as MethodResult<T, K>;
}

const strResult = process("hello");
const numResult = process(42);
const asyncVal = ensureAsync(123);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("process"),
        "expected process function in output. output: {output}"
    );
    assert!(
        output.contains("ensureAsync"),
        "expected ensureAsync function in output. output: {output}"
    );
    assert!(
        output.contains("invoke"),
        "expected invoke function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for conditional function return types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for conditional types with unions in ES5 output.
/// Validates that union conditional patterns generate proper source mappings.
#[test]
fn test_source_map_conditional_type_union_es5() {
    let source = r#"// Union in conditional check
type IsUnion<T, U = T> = T extends U
    ? [U] extends [T]
        ? false
        : true
    : never;

// Conditional with union result
type Result<T, E> = T extends Error ? { ok: false; error: E } : { ok: true; value: T };

// Union narrowing conditional
type UnwrapPromise<T> = T extends Promise<infer U>
    ? U
    : T extends PromiseLike<infer U>
    ? U
    : T;

// Handler type based on event
type EventHandler<T> = T extends "click"
    ? (e: MouseEvent) => void
    : T extends "keypress"
    ? (e: KeyboardEvent) => void
    : T extends "submit"
    ? (e: Event) => void
    : never;

function createHandler<T extends "click" | "keypress" | "submit">(
    eventType: T,
    handler: EventHandler<T>
): void {
    document.addEventListener(eventType, handler as EventListener);
}

function wrapResult<T>(value: T): Result<T, Error> {
    if (value instanceof Error) {
        return { ok: false, error: value } as Result<T, Error>;
    }
    return { ok: true, value } as Result<T, Error>;
}

const wrapped = wrapResult(42);
const errorWrapped = wrapResult(new Error("oops"));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createHandler"),
        "expected createHandler function in output. output: {output}"
    );
    assert!(
        output.contains("wrapResult"),
        "expected wrapResult function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for conditional type with union"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Comprehensive test combining multiple conditional type expression patterns.
/// Tests infer, distributive, nested, and union conditional types together.
#[test]
fn test_source_map_conditional_type_es5_comprehensive() {
    let source = r#"// Complex conditional type utility library

// Extract constructor parameters
type ConstructorParameters<T> = T extends new (...args: infer P) => any ? P : never;

// Instance type from constructor
type InstanceType<T> = T extends new (...args: any[]) => infer R ? R : never;

// Readonly deep with conditional
type DeepPartial<T> = T extends object
    ? { [P in keyof T]?: DeepPartial<T[P]> }
    : T;

// Property types extraction
type PropertyType<T, K> = K extends keyof T ? T[K] : never;

// Function property keys
type FunctionKeys<T> = {
    [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];

// Non-function property keys
type DataKeys<T> = {
    [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];

// Class using conditional types
class TypedRegistry<T extends object> {
    private items: Map<string, T> = new Map();

    register(id: string, item: T): void {
        this.items.set(id, item);
    }

    get<K extends keyof T>(id: string, key: K): PropertyType<T, K> | undefined {
        const item = this.items.get(id);
        if (item) {
            return item[key] as PropertyType<T, K>;
        }
        return undefined;
    }

    update(id: string, partial: DeepPartial<T>): boolean {
        const item = this.items.get(id);
        if (item) {
            Object.assign(item, partial);
            return true;
        }
        return false;
    }

    callMethod<K extends FunctionKeys<T>>(
        id: string,
        method: K,
        ...args: T[K] extends (...args: infer P) => any ? P : never[]
    ): T[K] extends (...args: any[]) => infer R ? R : undefined {
        const item = this.items.get(id);
        if (item && typeof item[method] === "function") {
            return (item[method] as Function).apply(item, args);
        }
        return undefined as any;
    }
}

// Factory with conditional return
function createInstance<T extends new (...args: any[]) => any>(
    ctor: T,
    ...args: ConstructorParameters<T>
): InstanceType<T> {
    return new ctor(...args);
}

interface User {
    name: string;
    age: number;
    greet(): string;
}

const registry = new TypedRegistry<User>();
registry.register("user1", { name: "Alice", age: 30, greet: () => "Hello" });
const userName = registry.get("user1", "name");
registry.update("user1", { age: 31 });"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("TypedRegistry"),
        "expected TypedRegistry class in output. output: {output}"
    );
    assert!(
        output.contains("register"),
        "expected register method in output. output: {output}"
    );
    assert!(
        output.contains("update"),
        "expected update method in output. output: {output}"
    );
    assert!(
        output.contains("callMethod"),
        "expected callMethod method in output. output: {output}"
    );
    assert!(
        output.contains("createInstance"),
        "expected createInstance function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive conditional types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS: IMPORT/EXPORT ALIASES
// =============================================================================

/// Test source map generation for named imports with aliases in ES5 output.
/// Validates that `import { foo as bar }` generates proper source mappings.
#[test]
fn test_source_map_import_named_alias_es5() {
    let source = r#"// Named import with alias
import { useState as useStateHook } from "react";
import { Component as ReactComponent, createElement as h } from "react";
import { map as arrayMap, filter as arrayFilter, reduce as arrayReduce } from "lodash";

// Using aliased imports
function MyComponent() {
    const [count, setCount] = useStateHook(0);
    return h("div", null, count);
}

const numbers = [1, 2, 3, 4, 5];
const doubled = arrayMap(numbers, (n: number) => n * 2);
const evens = arrayFilter(numbers, (n: number) => n % 2 === 0);
const sum = arrayReduce(numbers, (acc: number, n: number) => acc + n, 0);

console.log(doubled, evens, sum);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("MyComponent"),
        "expected MyComponent function in output. output: {output}"
    );
    assert!(
        output.contains("doubled"),
        "expected doubled variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for named import aliases"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for named exports with aliases in ES5 output.
/// Validates that `export { foo as bar }` generates proper source mappings.
#[test]
fn test_source_map_export_named_alias_es5() {
    let source = r#"// Internal implementations
function internalAdd(a: number, b: number): number {
    return a + b;
}

function internalSubtract(a: number, b: number): number {
    return a - b;
}

const internalPI = 3.14159;
const internalE = 2.71828;

class InternalCalculator {
    add(a: number, b: number): number {
        return internalAdd(a, b);
    }

    subtract(a: number, b: number): number {
        return internalSubtract(a, b);
    }
}

// Export with aliases
export { internalAdd as add };
export { internalSubtract as subtract };
export { internalPI as PI, internalE as E };
export { InternalCalculator as Calculator };

// Also export with different alias
export { internalAdd as sum, internalSubtract as difference };"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("internalAdd"),
        "expected internalAdd function in output. output: {output}"
    );
    assert!(
        output.contains("InternalCalculator"),
        "expected InternalCalculator class in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for named export aliases"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for re-exports with aliases in ES5 output.
/// Validates that `export { foo as bar } from "module"` generates proper source mappings.
#[test]
fn test_source_map_reexport_alias_es5() {
    let source = r#"// Re-export with aliases from other modules
export { useState as useStateHook } from "react";
export { Component as ReactComponent } from "react";
export { map as lodashMap, filter as lodashFilter } from "lodash";

// Re-export default as named
export { default as axios } from "axios";
export { default as express } from "express";

// Mixed re-exports with and without aliases
export { readFile as readFileAsync, writeFile as writeFileAsync } from "fs/promises";

// Re-export everything with namespace alias handled separately
// export * as utils from "./utils";

// Local function that uses re-exports conceptually
function useLibraries(): void {
    console.log("Libraries configured");
}

export { useLibraries };"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("useLibraries"),
        "expected useLibraries function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for re-export aliases"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for default import aliases in ES5 output.
/// Validates that `import MyAlias from "module"` generates proper source mappings.
#[test]
fn test_source_map_import_default_alias_es5() {
    let source = r#"// Default imports (which are essentially aliases for the default export)
import React from "react";
import Express from "express";
import Lodash from "lodash";

// Using default imports
const app = Express();
const element = React.createElement("div", null, "Hello");
const sorted = Lodash.sortBy([3, 1, 2]);

// Default import with named imports
import Axios, { AxiosResponse, AxiosError } from "axios";

async function fetchData(): Promise<AxiosResponse> {
    try {
        return await Axios.get("/api/data");
    } catch (error) {
        throw error as AxiosError;
    }
}

// Re-assigning default imports
const MyReact = React;
const MyExpress = Express;

console.log(app, element, sorted);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("fetchData"),
        "expected fetchData function in output. output: {output}"
    );
    assert!(
        output.contains("MyReact"),
        "expected MyReact variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for default import aliases"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for namespace import aliases in ES5 output.
/// Validates that `import * as ns from "module"` generates proper source mappings.
#[test]
fn test_source_map_import_namespace_alias_es5() {
    let source = r#"// Namespace imports
import * as React from "react";
import * as ReactDOM from "react-dom";
import * as Lodash from "lodash";
import * as Utils from "./utils";

// Using namespace imports
const element = React.createElement("div", { className: "container" }, "Hello");
const root = ReactDOM.createRoot(document.getElementById("root")!);

// Destructuring from namespace
const { map, filter, reduce } = Lodash;
const { formatDate, parseDate } = Utils;

// Using destructured values
const doubled = map([1, 2, 3], (n: number) => n * 2);
const evens = filter([1, 2, 3, 4], (n: number) => n % 2 === 0);

// Aliasing namespace members
const lodashMap = Lodash.map;
const lodashFilter = Lodash.filter;

function renderApp(): void {
    root.render(element);
}

console.log(doubled, evens);
renderApp();"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("renderApp"),
        "expected renderApp function in output. output: {output}"
    );
    assert!(
        output.contains("doubled"),
        "expected doubled variable in output. output: {output}"
    );
    assert!(
        output.contains("lodashMap"),
        "expected lodashMap variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for namespace import aliases"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Comprehensive test combining multiple import/export alias patterns.
/// Tests named, default, namespace imports and exports with various alias combinations.
#[test]
fn test_source_map_import_export_alias_es5_comprehensive() {
    let source = r#"// Comprehensive import/export alias patterns

// Namespace imports
import * as path from "path";
import * as fs from "fs";

// Default imports
import express from "express";
import cors from "cors";

// Named imports with aliases
import { readFile as readFileAsync, writeFile as writeFileAsync } from "fs/promises";
import { join as joinPath, resolve as resolvePath, dirname as getDirname } from "path";

// Mixed default and named with aliases
import axios, { AxiosInstance as HttpClient, AxiosResponse as HttpResponse } from "axios";

// Internal implementations
class ApiClient {
    private client: HttpClient;
    private basePath: string;

    constructor(baseUrl: string) {
        this.client = axios.create({ baseURL: baseUrl });
        this.basePath = resolvePath(getDirname(""), "api");
    }

    async get<T>(endpoint: string): Promise<HttpResponse<T>> {
        const fullPath = joinPath(this.basePath, endpoint);
        console.log(`Fetching from: ${fullPath}`);
        return this.client.get(endpoint);
    }

    async loadConfig(configPath: string): Promise<string> {
        const absolutePath = path.resolve(configPath);
        const content = await readFileAsync(absolutePath, "utf-8");
        return content;
    }

    async saveConfig(configPath: string, data: string): Promise<void> {
        const absolutePath = path.resolve(configPath);
        await writeFileAsync(absolutePath, data, "utf-8");
    }
}

// Create app with middleware
const app = express();
app.use(cors());

// Export with aliases
export { ApiClient as Client };
export { app as application };

// Re-export with aliases
export { readFileAsync as readFile, writeFileAsync as writeFile };
export { joinPath, resolvePath, getDirname };

// Export default with alias pattern
const defaultClient = new ApiClient("https://api.example.com");
export { defaultClient as default };"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ApiClient"),
        "expected ApiClient class in output. output: {output}"
    );
    assert!(
        output.contains("loadConfig"),
        "expected loadConfig method in output. output: {output}"
    );
    assert!(
        output.contains("saveConfig"),
        "expected saveConfig method in output. output: {output}"
    );
    assert!(
        output.contains("defaultClient"),
        "expected defaultClient variable in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive import/export aliases"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS: MAPPED TYPE EXPRESSIONS
// =============================================================================

/// Test source map generation for Partial<T> mapped type in ES5 output.
/// Validates that Partial utility type generates proper source mappings.
#[test]
fn test_source_map_mapped_type_partial_es5() {
    let source = r#"// Custom Partial implementation
type MyPartial<T> = {
    [P in keyof T]?: T[P];
};

interface User {
    id: number;
    name: string;
    email: string;
    age: number;
}

// Function using Partial
function updateUser(user: User, updates: Partial<User>): User {
    return { ...user, ...updates };
}

function patchUser(user: User, patch: MyPartial<User>): User {
    return { ...user, ...patch };
}

// Creating partial objects
const fullUser: User = { id: 1, name: "Alice", email: "alice@example.com", age: 30 };
const partialUpdate: Partial<User> = { name: "Alicia" };
const updatedUser = updateUser(fullUser, partialUpdate);

// Nested partial
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

interface Config {
    database: { host: string; port: number };
    cache: { enabled: boolean; ttl: number };
}

function mergeConfig(base: Config, override: DeepPartial<Config>): Config {
    return { ...base, ...override } as Config;
}

console.log(updatedUser);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("updateUser"),
        "expected updateUser function in output. output: {output}"
    );
    assert!(
        output.contains("patchUser"),
        "expected patchUser function in output. output: {output}"
    );
    assert!(
        output.contains("mergeConfig"),
        "expected mergeConfig function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Partial mapped type"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for Required<T> mapped type in ES5 output.
/// Validates that Required utility type generates proper source mappings.
#[test]
fn test_source_map_mapped_type_required_es5() {
    let source = r#"// Custom Required implementation
type MyRequired<T> = {
    [P in keyof T]-?: T[P];
};

interface PartialUser {
    id?: number;
    name?: string;
    email?: string;
}

// Function requiring all properties
function createUser(data: Required<PartialUser>): PartialUser {
    return {
        id: data.id,
        name: data.name,
        email: data.email
    };
}

function validateUser(data: MyRequired<PartialUser>): boolean {
    return data.id > 0 && data.name.length > 0 && data.email.includes("@");
}

// Builder pattern with Required
class UserBuilder {
    private data: Partial<PartialUser> = {};

    setId(id: number): this {
        this.data.id = id;
        return this;
    }

    setName(name: string): this {
        this.data.name = name;
        return this;
    }

    setEmail(email: string): this {
        this.data.email = email;
        return this;
    }

    build(): Required<PartialUser> {
        if (!this.data.id || !this.data.name || !this.data.email) {
            throw new Error("All fields required");
        }
        return this.data as Required<PartialUser>;
    }
}

const builder = new UserBuilder();
const user = builder.setId(1).setName("Bob").setEmail("bob@example.com").build();
console.log(validateUser(user));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createUser"),
        "expected createUser function in output. output: {output}"
    );
    assert!(
        output.contains("validateUser"),
        "expected validateUser function in output. output: {output}"
    );
    assert!(
        output.contains("UserBuilder"),
        "expected UserBuilder class in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Required mapped type"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for Readonly<T> mapped type in ES5 output.
/// Validates that Readonly utility type generates proper source mappings.
#[test]
fn test_source_map_mapped_type_readonly_es5() {
    let source = r#"// Custom Readonly implementation
type MyReadonly<T> = {
    readonly [P in keyof T]: T[P];
};

interface MutableState {
    count: number;
    items: string[];
    lastUpdated: Date;
}

// Frozen state pattern
function freezeState<T extends object>(state: T): Readonly<T> {
    return Object.freeze({ ...state });
}

function getImmutableState(state: MutableState): MyReadonly<MutableState> {
    return state;
}

// Deep readonly
type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

interface AppState {
    user: { name: string; settings: { theme: string } };
    data: { items: number[] };
}

function getAppState(): DeepReadonly<AppState> {
    return {
        user: { name: "Alice", settings: { theme: "dark" } },
        data: { items: [1, 2, 3] }
    };
}

// Working with readonly
class StateManager {
    private state: MutableState = { count: 0, items: [], lastUpdated: new Date() };

    getState(): Readonly<MutableState> {
        return this.state;
    }

    increment(): void {
        this.state.count++;
        this.state.lastUpdated = new Date();
    }
}

const manager = new StateManager();
const readonlyState = manager.getState();
console.log(readonlyState.count);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("freezeState"),
        "expected freezeState function in output. output: {output}"
    );
    assert!(
        output.contains("getAppState"),
        "expected getAppState function in output. output: {output}"
    );
    assert!(
        output.contains("StateManager"),
        "expected StateManager class in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Readonly mapped type"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for Pick<T, K> mapped type in ES5 output.
/// Validates that Pick utility type generates proper source mappings.
#[test]
fn test_source_map_mapped_type_pick_es5() {
    let source = r#"// Custom Pick implementation
type MyPick<T, K extends keyof T> = {
    [P in K]: T[P];
};

interface FullUser {
    id: number;
    name: string;
    email: string;
    password: string;
    createdAt: Date;
    updatedAt: Date;
}

// Pick specific properties
type PublicUser = Pick<FullUser, "id" | "name" | "email">;
type UserCredentials = MyPick<FullUser, "email" | "password">;

function getPublicProfile(user: FullUser): PublicUser {
    return {
        id: user.id,
        name: user.name,
        email: user.email
    };
}

function extractCredentials(user: FullUser): UserCredentials {
    return {
        email: user.email,
        password: user.password
    };
}

// Generic pick function
function pick<T extends object, K extends keyof T>(
    obj: T,
    keys: K[]
): Pick<T, K> {
    const result = {} as Pick<T, K>;
    for (const key of keys) {
        result[key] = obj[key];
    }
    return result;
}

const fullUser: FullUser = {
    id: 1,
    name: "Alice",
    email: "alice@example.com",
    password: "secret",
    createdAt: new Date(),
    updatedAt: new Date()
};

const publicUser = getPublicProfile(fullUser);
const picked = pick(fullUser, ["id", "name"]);
console.log(publicUser, picked);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getPublicProfile"),
        "expected getPublicProfile function in output. output: {output}"
    );
    assert!(
        output.contains("extractCredentials"),
        "expected extractCredentials function in output. output: {output}"
    );
    assert!(
        output.contains("pick"),
        "expected pick function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Pick mapped type"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for Record<K, T> mapped type in ES5 output.
/// Validates that Record utility type generates proper source mappings.
#[test]
fn test_source_map_mapped_type_record_es5() {
    let source = r#"// Custom Record implementation
type MyRecord<K extends keyof any, T> = {
    [P in K]: T;
};

// Record with string keys
type UserRoles = Record<string, boolean>;
type CountryCode = "US" | "UK" | "CA" | "AU";
type CountryNames = Record<CountryCode, string>;

function createUserRoles(): UserRoles {
    return {
        admin: true,
        editor: false,
        viewer: true
    };
}

function getCountryNames(): CountryNames {
    return {
        US: "United States",
        UK: "United Kingdom",
        CA: "Canada",
        AU: "Australia"
    };
}

// Record with number keys
type IndexedData = Record<number, string>;

function createIndexedData(items: string[]): IndexedData {
    const result: IndexedData = {};
    items.forEach((item, index) => {
        result[index] = item;
    });
    return result;
}

// Nested Record
type NestedRecord = Record<string, Record<string, number>>;

function createNestedRecord(): NestedRecord {
    return {
        users: { count: 100, active: 50 },
        posts: { count: 500, published: 450 }
    };
}

// Generic record creator
function createRecord<K extends string, T>(
    keys: K[],
    value: T
): MyRecord<K, T> {
    const result = {} as MyRecord<K, T>;
    for (const key of keys) {
        result[key] = value;
    }
    return result;
}

const roles = createUserRoles();
const countries = getCountryNames();
const indexed = createIndexedData(["a", "b", "c"]);
console.log(roles, countries, indexed);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("createUserRoles"),
        "expected createUserRoles function in output. output: {output}"
    );
    assert!(
        output.contains("getCountryNames"),
        "expected getCountryNames function in output. output: {output}"
    );
    assert!(
        output.contains("createNestedRecord"),
        "expected createNestedRecord function in output. output: {output}"
    );
    assert!(
        output.contains("createRecord"),
        "expected createRecord function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Record mapped type"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Comprehensive test combining multiple mapped type patterns.
/// Tests Partial, Required, Readonly, Pick, Record, and custom mapped types together.
#[test]
fn test_source_map_mapped_type_es5_comprehensive() {
    let source = r#"// Comprehensive mapped type utility library

// Standard mapped types
type Partial<T> = { [P in keyof T]?: T[P] };
type Required<T> = { [P in keyof T]-?: T[P] };
type Readonly<T> = { readonly [P in keyof T]: T[P] };
type Pick<T, K extends keyof T> = { [P in K]: T[P] };
type Record<K extends keyof any, T> = { [P in K]: T };
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

// Custom mapped types
type Mutable<T> = { -readonly [P in keyof T]: T[P] };
type Nullable<T> = { [P in keyof T]: T[P] | null };
type NonNullableProps<T> = { [P in keyof T]: NonNullable<T[P]> };

// Key remapping
type Getters<T> = {
    [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

type Setters<T> = {
    [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void;
};

// Entity interface
interface Entity {
    id: number;
    name: string;
    createdAt: Date;
    updatedAt: Date | null;
}

// Repository using mapped types
class Repository<T extends Entity> {
    private items: Map<number, T> = new Map();

    create(data: Omit<T, "id" | "createdAt" | "updatedAt">): T {
        const now = new Date();
        const id = this.items.size + 1;
        const entity = {
            ...data,
            id,
            createdAt: now,
            updatedAt: null
        } as T;
        this.items.set(id, entity);
        return entity;
    }

    update(id: number, data: Partial<Omit<T, "id" | "createdAt">>): T | undefined {
        const entity = this.items.get(id);
        if (entity) {
            const updated = { ...entity, ...data, updatedAt: new Date() };
            this.items.set(id, updated);
            return updated;
        }
        return undefined;
    }

    findById(id: number): Readonly<T> | undefined {
        return this.items.get(id);
    }

    findAll(): ReadonlyArray<Readonly<T>> {
        return Array.from(this.items.values());
    }

    getFields<K extends keyof T>(id: number, fields: K[]): Pick<T, K> | undefined {
        const entity = this.items.get(id);
        if (entity) {
            const result = {} as Pick<T, K>;
            for (const field of fields) {
                result[field] = entity[field];
            }
            return result;
        }
        return undefined;
    }
}

// Form state using mapped types
type FormState<T> = {
    values: T;
    errors: Partial<Record<keyof T, string>>;
    touched: Partial<Record<keyof T, boolean>>;
    dirty: boolean;
};

function createFormState<T>(initial: T): FormState<T> {
    return {
        values: initial,
        errors: {},
        touched: {},
        dirty: false
    };
}

interface User extends Entity {
    email: string;
    role: "admin" | "user";
}

const userRepo = new Repository<User>();
const newUser = userRepo.create({ name: "Alice", email: "alice@example.com", role: "user" });
const formState = createFormState({ name: "", email: "" });
console.log(newUser, formState);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("Repository"),
        "expected Repository class in output. output: {output}"
    );
    assert!(
        output.contains("create"),
        "expected create method in output. output: {output}"
    );
    assert!(
        output.contains("update"),
        "expected update method in output. output: {output}"
    );
    assert!(
        output.contains("findById"),
        "expected findById method in output. output: {output}"
    );
    assert!(
        output.contains("getFields"),
        "expected getFields method in output. output: {output}"
    );
    assert!(
        output.contains("createFormState"),
        "expected createFormState function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive mapped types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

// =============================================================================
// ES5 SOURCE MAP TESTS: UTILITY TYPES
// =============================================================================

/// Test source map generation for ReturnType<T> utility type in ES5 output.
/// Validates that ReturnType extraction generates proper source mappings.
#[test]
fn test_source_map_utility_type_return_type_es5() {
    let source = r#"// Custom ReturnType implementation
type MyReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : never;

// Functions to extract return types from
function getString(): string {
    return "hello";
}

function getNumber(): number {
    return 42;
}

async function getAsyncData(): Promise<{ id: number; name: string }> {
    return { id: 1, name: "test" };
}

function getCallback(): (x: number) => boolean {
    return (x) => x > 0;
}

// Using ReturnType
type StringResult = ReturnType<typeof getString>;
type NumberResult = ReturnType<typeof getNumber>;
type AsyncResult = ReturnType<typeof getAsyncData>;
type CallbackResult = MyReturnType<typeof getCallback>;

// Functions that use extracted types
function processString(value: StringResult): void {
    console.log(value.toUpperCase());
}

function processNumber(value: NumberResult): void {
    console.log(value.toFixed(2));
}

// Generic wrapper using ReturnType
function wrapResult<T extends (...args: any[]) => any>(
    fn: T
): { result: ReturnType<T>; timestamp: Date } | null {
    try {
        return { result: fn(), timestamp: new Date() };
    } catch {
        return null;
    }
}

const wrapped = wrapResult(getString);
processString("test");
processNumber(123);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("getString"),
        "expected getString function in output. output: {output}"
    );
    assert!(
        output.contains("wrapResult"),
        "expected wrapResult function in output. output: {output}"
    );
    assert!(
        output.contains("processString"),
        "expected processString function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ReturnType utility"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for Parameters<T> utility type in ES5 output.
/// Validates that Parameters extraction generates proper source mappings.
#[test]
fn test_source_map_utility_type_parameters_es5() {
    let source = r#"// Custom Parameters implementation
type MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : never;

// Functions with various parameter signatures
function simpleFunc(a: string, b: number): void {
    console.log(a, b);
}

function optionalFunc(required: string, optional?: number): boolean {
    return optional !== undefined;
}

function restFunc(first: string, ...rest: number[]): number {
    return rest.reduce((sum, n) => sum + n, 0);
}

function complexFunc(
    config: { host: string; port: number },
    callback: (err: Error | null, result: string) => void
): void {
    callback(null, `${config.host}:${config.port}`);
}

// Using Parameters
type SimpleParams = Parameters<typeof simpleFunc>;
type OptionalParams = Parameters<typeof optionalFunc>;
type RestParams = MyParameters<typeof restFunc>;
type ComplexParams = Parameters<typeof complexFunc>;

// Function that forwards parameters
function forward<T extends (...args: any[]) => any>(
    fn: T,
    ...args: Parameters<T>
): ReturnType<T> {
    return fn(...args);
}

// Partial application using Parameters
function partial<T extends (...args: any[]) => any>(
    fn: T,
    firstArg: Parameters<T>[0]
): (...rest: Parameters<T> extends [any, ...infer R] ? R : never[]) => ReturnType<T> {
    return (...rest) => fn(firstArg, ...rest);
}

const forwardedResult = forward(simpleFunc, "hello", 42);
const partialSimple = partial(simpleFunc, "fixed");
partialSimple(123);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("simpleFunc"),
        "expected simpleFunc function in output. output: {output}"
    );
    assert!(
        output.contains("forward"),
        "expected forward function in output. output: {output}"
    );
    assert!(
        output.contains("partial"),
        "expected partial function in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for Parameters utility"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for ConstructorParameters<T> utility type in ES5 output.
/// Validates that ConstructorParameters extraction generates proper source mappings.
#[test]
fn test_source_map_utility_type_constructor_params_es5() {
    let source = r#"// Custom ConstructorParameters implementation
type MyConstructorParameters<T extends abstract new (...args: any) => any> =
    T extends abstract new (...args: infer P) => any ? P : never;

// Classes with various constructor signatures
class SimpleClass {
    constructor(public name: string, public age: number) {}
}

class ConfigurableClass {
    constructor(
        public config: { host: string; port: number },
        public options?: { timeout?: number; retries?: number }
    ) {}
}

class VariadicClass {
    public items: string[];
    constructor(first: string, ...rest: string[]) {
        this.items = [first, ...rest];
    }
}

// Using ConstructorParameters
type SimpleCtorParams = ConstructorParameters<typeof SimpleClass>;
type ConfigCtorParams = ConstructorParameters<typeof ConfigurableClass>;
type VariadicCtorParams = MyConstructorParameters<typeof VariadicClass>;

// Factory function using ConstructorParameters
function createInstance<T extends new (...args: any[]) => any>(
    ctor: T,
    ...args: ConstructorParameters<T>
): InstanceType<T> {
    return new ctor(...args);
}

// Builder pattern with ConstructorParameters
class Factory<T extends new (...args: any[]) => any> {
    private args: ConstructorParameters<T> | null = null;

    constructor(private ctor: T) {}

    withArgs(...args: ConstructorParameters<T>): this {
        this.args = args;
        return this;
    }

    build(): InstanceType<T> {
        if (!this.args) throw new Error("Args not set");
        return new this.ctor(...this.args);
    }
}

const simple = createInstance(SimpleClass, "Alice", 30);
const factory = new Factory(ConfigurableClass);
const configured = factory.withArgs({ host: "localhost", port: 8080 }).build();
console.log(simple, configured);"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("SimpleClass"),
        "expected SimpleClass in output. output: {output}"
    );
    assert!(
        output.contains("createInstance"),
        "expected createInstance function in output. output: {output}"
    );
    assert!(
        output.contains("Factory"),
        "expected Factory class in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ConstructorParameters utility"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for InstanceType<T> utility type in ES5 output.
/// Validates that InstanceType extraction generates proper source mappings.
#[test]
fn test_source_map_utility_type_instance_type_es5() {
    let source = r#"// Custom InstanceType implementation
type MyInstanceType<T extends abstract new (...args: any) => any> =
    T extends abstract new (...args: any) => infer R ? R : never;

// Various classes
class User {
    constructor(public id: number, public name: string) {}

    greet(): string {
        return `Hello, ${this.name}`;
    }
}

class Product {
    constructor(
        public sku: string,
        public price: number,
        public inStock: boolean
    ) {}

    getDisplayPrice(): string {
        return `$${this.price.toFixed(2)}`;
    }
}

abstract class Entity {
    abstract getId(): string;
}

class ConcreteEntity extends Entity {
    constructor(private id: string) {
        super();
    }

    getId(): string {
        return this.id;
    }
}

// Using InstanceType
type UserInstance = InstanceType<typeof User>;
type ProductInstance = InstanceType<typeof Product>;
type EntityInstance = MyInstanceType<typeof ConcreteEntity>;

// Registry using InstanceType
class Registry<T extends new (...args: any[]) => any> {
    private instances: Map<string, InstanceType<T>> = new Map();

    register(key: string, instance: InstanceType<T>): void {
        this.instances.set(key, instance);
    }

    get(key: string): InstanceType<T> | undefined {
        return this.instances.get(key);
    }

    getAll(): InstanceType<T>[] {
        return Array.from(this.instances.values());
    }
}

const userRegistry = new Registry<typeof User>();
userRegistry.register("user1", new User(1, "Alice"));
userRegistry.register("user2", new User(2, "Bob"));

const users = userRegistry.getAll();
console.log(users.map(u => u.greet()));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("User"),
        "expected User class in output. output: {output}"
    );
    assert!(
        output.contains("Product"),
        "expected Product class in output. output: {output}"
    );
    assert!(
        output.contains("Registry"),
        "expected Registry class in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for InstanceType utility"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Test source map generation for ThisParameterType<T> utility type in ES5 output.
/// Validates that ThisParameterType extraction generates proper source mappings.
#[test]
fn test_source_map_utility_type_this_parameter_es5() {
    let source = r#"// Custom ThisParameterType implementation
type MyThisParameterType<T> = T extends (this: infer U, ...args: any[]) => any ? U : unknown;

// Custom OmitThisParameter implementation
type MyOmitThisParameter<T> = unknown extends ThisParameterType<T>
    ? T
    : T extends (...args: infer A) => infer R
    ? (...args: A) => R
    : T;

// Functions with explicit this parameter
function greet(this: { name: string }): string {
    return `Hello, ${this.name}`;
}

function calculate(this: { multiplier: number }, value: number): number {
    return value * this.multiplier;
}

function processItems(
    this: { prefix: string },
    items: string[]
): string[] {
    return items.map(item => `${this.prefix}: ${item}`);
}

// Using ThisParameterType
type GreetThis = ThisParameterType<typeof greet>;
type CalculateThis = ThisParameterType<typeof calculate>;
type ProcessThis = MyThisParameterType<typeof processItems>;

// Binding functions with correct this
function bindThis<T, A extends any[], R>(
    fn: (this: T, ...args: A) => R,
    thisArg: T
): (...args: A) => R {
    return fn.bind(thisArg);
}

const context = { name: "Alice", multiplier: 2, prefix: "Item" };
const boundGreet = bindThis(greet, context);
const boundCalculate = bindThis(calculate, context);

// Method extraction with this handling
class Counter {
    count = 0;

    increment(this: Counter): void {
        this.count++;
    }

    getCount(this: Counter): number {
        return this.count;
    }
}

const counter = new Counter();
const incrementFn: MyOmitThisParameter<typeof counter.increment> = counter.increment.bind(counter);
incrementFn();

console.log(boundGreet(), boundCalculate(5), counter.getCount());"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("greet"),
        "expected greet function in output. output: {output}"
    );
    assert!(
        output.contains("bindThis"),
        "expected bindThis function in output. output: {output}"
    );
    assert!(
        output.contains("Counter"),
        "expected Counter class in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for ThisParameterType utility"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}

/// Comprehensive test combining multiple utility type patterns.
/// Tests ReturnType, Parameters, ConstructorParameters, InstanceType, and ThisParameterType together.
#[test]
fn test_source_map_utility_type_es5_comprehensive() {
    let source = r#"// Comprehensive utility type patterns

// All utility types defined
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : never;
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;
type ConstructorParameters<T extends abstract new (...args: any) => any> =
    T extends abstract new (...args: infer P) => any ? P : never;
type InstanceType<T extends abstract new (...args: any) => any> =
    T extends abstract new (...args: any) => infer R ? R : never;
type ThisParameterType<T> = T extends (this: infer U, ...args: any[]) => any ? U : unknown;
type OmitThisParameter<T> = unknown extends ThisParameterType<T>
    ? T
    : T extends (...args: infer A) => infer R ? (...args: A) => R : T;

// Service class using utility types
class ApiService {
    private baseUrl: string;

    constructor(baseUrl: string, private timeout: number = 5000) {
        this.baseUrl = baseUrl;
    }

    async fetch<T>(endpoint: string): Promise<T> {
        const response = await fetch(`${this.baseUrl}${endpoint}`);
        return response.json();
    }

    post<T, R>(endpoint: string, data: T): Promise<R> {
        return fetch(`${this.baseUrl}${endpoint}`, {
            method: "POST",
            body: JSON.stringify(data)
        }).then(r => r.json());
    }
}

// Dependency injection container using utility types
class Container {
    private factories: Map<string, (...args: any[]) => any> = new Map();
    private instances: Map<string, any> = new Map();

    register<T extends new (...args: any[]) => any>(
        key: string,
        ctor: T,
        ...args: ConstructorParameters<T>
    ): void {
        this.factories.set(key, () => new ctor(...args));
    }

    resolve<T extends new (...args: any[]) => any>(key: string): InstanceType<T> {
        if (!this.instances.has(key)) {
            const factory = this.factories.get(key);
            if (factory) {
                this.instances.set(key, factory());
            }
        }
        return this.instances.get(key);
    }
}

// Function composition using Parameters and ReturnType
function compose<
    F extends (...args: any[]) => any,
    G extends (arg: ReturnType<F>) => any
>(f: F, g: G): (...args: Parameters<F>) => ReturnType<G> {
    return (...args) => g(f(...args));
}

// Method decorator factory using utility types
function logMethod<T extends (...args: any[]) => any>(
    target: any,
    propertyKey: string,
    descriptor: TypedPropertyDescriptor<T>
): void {
    const original = descriptor.value!;
    descriptor.value = function(this: ThisParameterType<T>, ...args: Parameters<T>): ReturnType<T> {
        console.log(`Calling ${propertyKey} with`, args);
        return original.apply(this, args);
    } as T;
}

// Event handler with proper typing
interface EventMap {
    click: { x: number; y: number };
    keypress: { key: string; code: number };
    submit: { data: Record<string, string> };
}

class EventEmitter<T extends Record<string, any>> {
    private handlers: Map<keyof T, ((event: any) => void)[]> = new Map();

    on<K extends keyof T>(
        event: K,
        handler: (event: T[K]) => void
    ): void {
        if (!this.handlers.has(event)) {
            this.handlers.set(event, []);
        }
        this.handlers.get(event)!.push(handler);
    }

    emit<K extends keyof T>(event: K, data: T[K]): void {
        const handlers = this.handlers.get(event) || [];
        handlers.forEach(h => h(data));
    }
}

// Usage
const container = new Container();
container.register("api", ApiService, "https://api.example.com", 3000);
const api = container.resolve<typeof ApiService>("api");

const double = (x: number) => x * 2;
const stringify = (x: number) => x.toString();
const doubleAndStringify = compose(double, stringify);

const emitter = new EventEmitter<EventMap>();
emitter.on("click", (e) => console.log(e.x, e.y));
emitter.emit("click", { x: 10, y: 20 });

console.log(api, doubleAndStringify(21));"#;

    let mut parser = ThinParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = ThinPrinter::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_map_text(parser.get_source_text());
    printer.enable_source_map("test.js", "test.ts");
    printer.emit(root);

    let output = printer.get_output().to_string();
    let map_json = printer.generate_source_map_json().expect("source map");
    let map_value: Value = serde_json::from_str(&map_json).expect("parse source map");

    let mappings = map_value
        .get("mappings")
        .and_then(|v| v.as_str())
        .unwrap_or("");

    let decoded = decode_mappings(mappings);

    assert!(
        output.contains("ApiService"),
        "expected ApiService class in output. output: {output}"
    );
    assert!(
        output.contains("Container"),
        "expected Container class in output. output: {output}"
    );
    assert!(
        output.contains("compose"),
        "expected compose function in output. output: {output}"
    );
    assert!(
        output.contains("EventEmitter"),
        "expected EventEmitter class in output. output: {output}"
    );
    assert!(
        output.contains("register"),
        "expected register method in output. output: {output}"
    );
    assert!(
        output.contains("resolve"),
        "expected resolve method in output. output: {output}"
    );
    assert!(
        !decoded.is_empty(),
        "expected non-empty source mappings for comprehensive utility types"
    );
    let has_source_mapping = decoded.iter().any(|entry| entry.source_index == 0);
    assert!(
        has_source_mapping,
        "expected mappings to reference source file"
    );
}
