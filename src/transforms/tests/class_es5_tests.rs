use crate::emit_context::EmitContext;
use crate::emitter::{Printer, PrinterOptions, ScriptTarget};
use crate::lowering_pass::LoweringPass;
use crate::parser::ParserState;
use crate::transforms::class_es5::ClassES5Emitter;

#[test]
fn test_class_es5_emits_param_and_static_properties() {
    let source = "class Foo { constructor(public x) {} y = 1; static bar = 2; }";
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    assert!(
        output.contains("this.x = x;"),
        "Expected parameter property assignment in ES5 output: {}",
        output
    );
    assert!(
        output.contains("this.y = 1;"),
        "Expected instance property initializer in ES5 output: {}",
        output
    );
    assert!(
        output.contains("Foo.bar = 2;"),
        "Expected static property assignment in ES5 output: {}",
        output
    );
}

#[test]
fn test_class_es5_static_field_arrow_keeps_this() {
    let source = "class Foo { static field = () => this.value; }";
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    assert!(
        output.contains("Foo.field = function"),
        "Expected static field initializer to emit a function expression: {}",
        output
    );
    assert!(
        output.contains("return this.value;"),
        "Expected static field arrow to preserve `this`: {}",
        output
    );
    assert!(
        !output.contains("_this"),
        "Did not expect static field arrow to capture `_this`: {}",
        output
    );
}

#[test]
fn test_class_es5_async_method_emits_awaiter() {
    let source = "class Foo { async bar() { await baz(); return 1; } }";
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    assert!(
        output.contains("Foo.prototype.bar = function"),
        "Expected method assignment in ES5 output: {}",
        output
    );
    assert!(
        output.contains("__awaiter(this, void 0, void 0, function () {"),
        "Expected __awaiter wrapper in ES5 output: {}",
        output
    );
    assert!(
        output.contains("__generator"),
        "Expected __generator usage in ES5 output: {}",
        output
    );
    assert!(
        !output.contains("async bar"),
        "Expected async keyword to be downleveled: {}",
        output
    );
}

#[test]
fn test_class_es5_preserves_pre_super_statement_order() {
    let source = "class Base {} class Derived extends Base { y = 1; constructor() { prep(); super(); post(); } }";
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    let prep_pos = output.find("prep()").expect("expected prep() call");
    let super_pos = output
        .find("_super.call(this")
        .expect("expected super call assignment");
    let init_pos = output
        .find("_this.y = 1")
        .expect("expected instance property initializer");
    let post_pos = output.find("post()").expect("expected post() call");

    assert!(
        prep_pos < super_pos,
        "Expected prep() before super call: {}",
        output
    );
    assert!(
        super_pos < init_pos,
        "Expected property initializer after super call: {}",
        output
    );
    assert!(
        init_pos < post_pos,
        "Expected post() after property initializer: {}",
        output
    );
}

#[test]
fn test_class_es5_default_derived_constructor_orders_super_and_props() {
    let source = "class Base {} class Derived extends Base { y = 1; }";
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    let super_pos = output
        .find("_super.apply(this, arguments)")
        .expect("expected super apply call");
    let init_pos = output.find("_this.y = 1").expect("expected initializer");
    let return_pos = output.find("return _this").expect("expected return _this");

    assert!(
        super_pos < init_pos,
        "Expected super call before property initializer: {}",
        output
    );
    assert!(
        init_pos < return_pos,
        "Expected return after property initializer: {}",
        output
    );
}

#[test]
fn test_class_es5_computed_super_arrow_in_field_initializer() {
    let source = r#"
class Base { m(x) { return x; } }
class Derived extends Base {
    field = () => super["m"](this.x);
    constructor() {
        super();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    assert!(
        output.contains("_super.prototype[\"m\"].call(_this"),
        "Expected computed super call to lower with lexical this: {}",
        output
    );
    assert!(
        output.contains("_this.x"),
        "Expected arrow to capture this in field initializer: {}",
        output
    );
    assert!(
        !output.contains("super[\"m\"]"),
        "Expected computed super access to be downleveled: {}",
        output
    );
}

#[test]
fn test_class_es5_computed_super_in_field_arrow_uses_this_capture() {
    let source = r#"
        const key = "m";
        class Base { [key]() {} }
        class Derived extends Base {
            field = () => super[key]();
            constructor() { super(); }
        }
    "#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(2)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    assert!(
        output.contains("_super.prototype[key].call(_this)"),
        "Expected computed super call to bind _this: {}",
        output
    );
    assert!(
        !output.contains("super["),
        "Expected computed super to be lowered in ES5 output: {}",
        output
    );
}

#[test]
fn test_class_es5_computed_field_does_not_change_super_ordering() {
    let source = r#"
        const key = "z";
        class Base {}
        class Derived extends Base {
            [key] = prepField();
            y = 1;
            constructor() {
                prep();
                super();
                post();
            }
        }
    "#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(2)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    let prep_pos = output.find("prep()").expect("expected prep() call");
    let super_pos = output
        .find("_super.call(this")
        .expect("expected super call assignment");
    let init_pos = output
        .find("_this.y = 1")
        .expect("expected instance property initializer");
    let post_pos = output.find("post()").expect("expected post() call");

    assert!(
        prep_pos < super_pos,
        "Expected prep() before super call: {}",
        output
    );
    assert!(
        super_pos < init_pos,
        "Expected property initializer after super call: {}",
        output
    );
    assert!(
        init_pos < post_pos,
        "Expected post() after property initializer: {}",
        output
    );
}

#[test]
fn test_class_es5_synthesized_ctor_captures_this_in_field_initializers() {
    let source = r#"
class Base { m() { return 1; } }
class Derived extends Base {
    field = this.value;
    fromSuper = super.m();
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    assert!(
        output.contains("_this.field = _this.value"),
        "Expected synthesized ctor to use _this in initializer: {}",
        output
    );
    assert!(
        output.contains("_this.fromSuper = _super.prototype.m.call(_this"),
        "Expected super call to use _this in initializer: {}",
        output
    );
}

#[test]
fn test_class_es5_private_field_initializer_uses_this_capture() {
    let source = r#"
class Base {}
class Derived extends Base {
    #count = this.value;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    assert!(
        output.contains("__classPrivateFieldSet(_this, _Derived_count, _this.value"),
        "Expected private field initializer to use _this in derived class: {}",
        output
    );
}

#[test]
fn test_class_es5_computed_property_field_initializer_emitted() {
    let source = r#"
const key = "z";
class Foo {
    [key] = 42;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    assert!(
        output.contains("this[key] = 42"),
        "Expected computed property initializer to be emitted: {}",
        output
    );
}

#[test]
fn test_class_es5_derived_computed_property_field_initializer_emitted() {
    let source = r#"
const key = "z";
class Base {}
class Derived extends Base {
    [key] = 42;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(2)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    assert!(
        output.contains("_this[key] = 42"),
        "Expected computed property initializer with _this in derived class: {}",
        output
    );
}

#[test]
fn test_class_es5_derived_with_explicit_ctor_computed_property_field() {
    let source = r#"
const key = "z";
class Base {}
class Derived extends Base {
    [key] = 42;
    constructor() {
        super();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(2)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    assert!(
        output.contains("_this[key] = 42"),
        "Expected computed property initializer with _this in derived class with explicit ctor: {}",
        output
    );

    // Verify ordering: super() should come before property initializer
    let super_pos = output
        .find("_super.call(this")
        .expect("expected super call");
    let init_pos = output
        .find("_this[key] = 42")
        .expect("expected initializer");
    assert!(
        super_pos < init_pos,
        "Expected super call before computed property initializer: {}",
        output
    );
}

#[test]
fn test_class_es5_static_field_async_arrow() {
    let source =
        "class Foo { static handler = async () => { await fetch(); return this.value; }; }";
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should emit __awaiter for async
    assert!(
        output.contains("__awaiter"),
        "Expected static async arrow to use __awaiter: {}",
        output
    );

    // Should preserve `this` (not capture to _this) for static field
    assert!(
        output.contains("this.value"),
        "Expected static async arrow to preserve `this`: {}",
        output
    );
}

#[test]
fn test_class_es5_private_field_access_in_async_method() {
    let source = r#"
class Foo {
    #value = 1;
    async getValue() {
        await fetch();
        return this.#value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should emit __awaiter for async method
    assert!(
        output.contains("__awaiter"),
        "Expected async method to use __awaiter: {}",
        output
    );

    // Should emit __classPrivateFieldGet for private field access
    assert!(
        output.contains("__classPrivateFieldGet"),
        "Expected private field access to use __classPrivateFieldGet: {}",
        output
    );

    // Should emit WeakMap for private field storage
    assert!(
        output.contains("_Foo_value"),
        "Expected private field WeakMap name: {}",
        output
    );
}

#[test]
fn test_class_es5_super_property_in_static_block() {
    let source = r#"
class Base {
    static value = 1;
}
class Derived extends Base {
    static {
        console.log(super.value);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Static block should be emitted as an IIFE after the class
    assert!(
        output.contains("console.log"),
        "Expected static block content to be emitted: {}",
        output
    );

    // Super property access should be transformed to Base.value or similar
    assert!(
        output.contains("Base.value") || output.contains("_super.value"),
        "Expected super.value to be transformed: {}",
        output
    );
}

#[test]
fn test_class_es5_nested_async_arrow_in_constructor_with_field() {
    let source = r#"
class Foo {
    field = 1;
    constructor() {
        this.handler = async () => {
            const inner = async () => {
                return this.field;
            };
            return await inner();
        };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Field initializer should use _this
    assert!(
        output.contains("_this.field = 1"),
        "Expected field initializer to use _this: {}",
        output
    );

    // Async arrow in constructor should use __awaiter
    assert!(
        output.contains("__awaiter"),
        "Expected async arrow to use __awaiter: {}",
        output
    );

    // Nested async arrow should capture _this.field
    assert!(
        output.contains("_this.field") && output.matches("_this.field").count() >= 2,
        "Expected nested async arrow to capture _this.field: {}",
        output
    );

    // Handler assignment should use _this
    assert!(
        output.contains("_this.handler"),
        "Expected handler assignment to use _this: {}",
        output
    );
}

#[test]
fn test_class_es5_computed_method_name_with_async_body() {
    let source = r#"
const methodName = "doWork";
class Foo {
    value = 42;
    async [methodName]() {
        await fetch();
        return this.value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Computed method should use bracket notation
    assert!(
        output.contains(".prototype[methodName]") || output.contains(".prototype[\"doWork\"]"),
        "Expected computed method to use bracket notation: {}",
        output
    );

    // Async body should use __awaiter
    assert!(
        output.contains("__awaiter"),
        "Expected async method to use __awaiter: {}",
        output
    );

    // Async body should use __generator
    assert!(
        output.contains("__generator"),
        "Expected async method to use __generator: {}",
        output
    );

    // this.value should be preserved or captured properly
    assert!(
        output.contains("this.value") || output.contains("_this.value"),
        "Expected this.value reference: {}",
        output
    );
}

#[test]
fn test_class_es5_spread_element_in_array_literal() {
    let source = r#"
class Foo {
    items = [1, 2, 3];

    getAll() {
        const extra = [4, 5];
        return [...this.items, ...extra, 6];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should NOT contain spread syntax (ES5 doesn't support it)
    assert!(
        !output.contains("...this.items") && !output.contains("...extra"),
        "Expected spread to be transformed, not raw spread syntax: {}",
        output
    );

    // Should use __spreadArray or concat for ES5 spread
    assert!(
        output.contains("__spreadArray")
            || output.contains(".concat(")
            || output.contains("slice.call"),
        "Expected ES5 spread transformation using __spreadArray or concat: {}",
        output
    );
}

#[test]
fn test_class_es5_object_spread_in_method() {
    let source = r#"
class Foo {
    defaults = { a: 1, b: 2 };

    merge(extra: object) {
        return { ...this.defaults, ...extra, c: 3 };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should NOT contain spread syntax (ES5 doesn't support it)
    assert!(
        !output.contains("...this.defaults") && !output.contains("...extra"),
        "Expected object spread to be transformed, not raw spread syntax: {}",
        output
    );

    // Should use Object.assign for ES5 object spread
    assert!(
        output.contains("Object.assign"),
        "Expected ES5 object spread transformation using Object.assign: {}",
        output
    );

    // The c: 3 property should still be present (emitted as assignment _a.c = 3)
    assert!(
        output.contains(".c = 3") || output.contains("c = 3"),
        "Expected property c: 3 to be preserved as assignment: {}",
        output
    );
}

#[test]
fn test_class_es5_for_of_loop_in_method() {
    let source = r#"
class Foo {
    items = [1, 2, 3];

    sum() {
        let total = 0;
        for (const item of this.items) {
            total += item;
        }
        return total;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should NOT contain for-of syntax (ES5 doesn't support it)
    assert!(
        !output.contains("for (const item of") && !output.contains("for (var item of"),
        "Expected for-of to be transformed, not raw for-of syntax: {}",
        output
    );

    // Should use __values helper for ES5 iterator
    assert!(
        output.contains("__values("),
        "Expected ES5 for-of transformation using __values helper: {}",
        output
    );

    // Should use try/catch/finally for iterator cleanup
    assert!(
        output.contains("try {") && output.contains("finally {"),
        "Expected for-of to use try/finally for iterator cleanup: {}",
        output
    );

    // Should use .next() for iteration
    assert!(
        output.contains(".next()"),
        "Expected for-of to use .next() for iteration: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_iterator_method() {
    let source = r#"
class Foo {
    items = [1, 2, 3];

    *[Symbol.iterator]() {
        for (const item of this.items) {
            yield item;
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should emit Symbol.iterator as computed property name
    assert!(
        output.contains("[Symbol.iterator]"),
        "Expected Symbol.iterator to be preserved as computed property: {}",
        output
    );

    // Should emit on prototype since it's an instance method
    assert!(
        output.contains(".prototype[Symbol.iterator]"),
        "Expected Symbol.iterator method to be on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_super_with_spread_args_and_field_init() {
    // Edge case: super() with spread arguments in derived class with field initializers
    let source = r#"
class Base {
    constructor(...args: number[]) {}
}
class Derived extends Base {
    value = 42;
    constructor(first: number, ...rest: number[]) {
        super(first, ...rest);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should have super call with spread converted to .apply() or __spreadArray
    assert!(
        output.contains("_super") || output.contains("__extends"),
        "Expected ES5 super mechanism in output: {}",
        output
    );

    // Field initializer should be present
    assert!(
        output.contains("value") && output.contains("42"),
        "Expected field initializer value = 42 in output: {}",
        output
    );

    // Field init should come after super call
    if let (Some(super_pos), Some(value_pos)) = (
        output.find("_super").or_else(|| output.find("__extends")),
        output.find("42"),
    ) {
        assert!(
            super_pos < value_pos,
            "Expected super call before field initializer: {}",
            output
        );
    }
}

#[test]
fn test_class_es5_template_literal_in_method() {
    let source = r#"
class Greeter {
    name = "World";

    greet() {
        return `Hello, ${this.name}!`;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should NOT contain template literal backticks (ES5 doesn't support them)
    assert!(
        !output.contains('`'),
        "Expected template literal to be transformed, not raw backticks: {}",
        output
    );

    // Should use string concatenation for ES5
    assert!(
        output.contains("+") || output.contains("concat"),
        "Expected ES5 template literal to use string concatenation: {}",
        output
    );

    // Should preserve the literal parts
    assert!(
        output.contains("Hello") && output.contains("!"),
        "Expected template literal parts to be preserved: {}",
        output
    );
}

#[test]
fn test_class_es5_destructuring_in_method() {
    let source = r#"
class Parser {
    parse(input: { text: string, line: number }) {
        const { text, line } = input;
        return `${text} at line ${line}`;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should NOT contain destructuring syntax (ES5 doesn't support it)
    assert!(
        !output.contains("{ text, line }") && !output.contains("{text, line}"),
        "Expected destructuring to be transformed, not raw destructuring syntax: {}",
        output
    );

    // Should extract properties individually for ES5
    assert!(
        output.contains(".text") && output.contains(".line"),
        "Expected ES5 destructuring to access properties individually: {}",
        output
    );

    // Variables should be assigned
    assert!(
        output.contains("text") && output.contains("line"),
        "Expected destructured variables to be present: {}",
        output
    );
}

#[test]
fn test_class_es5_default_parameters_in_method() {
    let source = r#"
class Calculator {
    add(a: number, b: number = 0, c: number = 1) {
        return a + b + c;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should have parameter default handling (void 0 check or === undefined)
    assert!(
        output.contains("void 0") || output.contains("undefined"),
        "Expected ES5 default parameter check using void 0 or undefined: {}",
        output
    );

    // Should contain the default values
    assert!(
        output.contains("0") && output.contains("1"),
        "Expected default values 0 and 1 in output: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.add") || output.contains("prototype[\"add\"]"),
        "Expected add method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_rest_parameters_in_method() {
    let source = r#"
class Logger {
    log(prefix: string, ...messages: string[]) {
        return prefix + ": " + messages.join(", ");
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should NOT contain rest parameter syntax (ES5 doesn't support it)
    assert!(
        !output.contains("...messages"),
        "Expected rest parameters to be transformed, not raw ...messages: {}",
        output
    );

    // Should use Array.prototype.slice or similar for rest params
    assert!(
        output.contains("slice") || output.contains("arguments"),
        "Expected ES5 rest parameter to use slice or arguments: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.log") || output.contains("prototype[\"log\"]"),
        "Expected log method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_shorthand_properties_in_method() {
    let source = r#"
class Point {
    x = 10;
    y = 20;

    toObject() {
        const x = this.x;
        const y = this.y;
        return { x, y };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should have explicit property assignments (x: x, y: y) for ES5
    // or the shorthand should be preserved if the emitter handles it
    assert!(
        output.contains("x:")
            || output.contains("x :")
            || output.contains("{ x, y }")
            || output.contains("{x, y}"),
        "Expected object with x property in output: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.toObject") || output.contains("prototype[\"toObject\"]"),
        "Expected toObject method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_getter_setter_accessors() {
    let source = r#"
class Counter {
    private _count = 0;

    get count() {
        return this._count;
    }

    set count(value: number) {
        this._count = value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should use Object.defineProperty for getters/setters in ES5
    assert!(
        output.contains("Object.defineProperty") || output.contains("defineProperty"),
        "Expected ES5 getter/setter to use Object.defineProperty: {}",
        output
    );

    // Should have get and set in the property descriptor
    assert!(
        output.contains("get:") || output.contains("get :") || output.contains("\"get\""),
        "Expected getter in property descriptor: {}",
        output
    );

    assert!(
        output.contains("set:") || output.contains("set :") || output.contains("\"set\""),
        "Expected setter in property descriptor: {}",
        output
    );
}

#[test]
fn test_class_es5_arrow_function_this_binding() {
    let source = r#"
class Handler {
    name = "handler";

    getCallback() {
        return () => {
            return this.name;
        };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should NOT contain arrow function syntax (ES5 doesn't support it)
    assert!(
        !output.contains("=>"),
        "Expected arrow function to be transformed, not raw => syntax: {}",
        output
    );

    // Should capture this for arrow function (var _this = this or similar)
    assert!(
        output.contains("_this") || output.contains("self") || output.contains("that"),
        "Expected this capture for arrow function (_this, self, or that): {}",
        output
    );

    // Should use function keyword instead of arrow
    assert!(
        output.contains("function"),
        "Expected arrow to be converted to function keyword: {}",
        output
    );
}

#[test]
fn test_class_es5_static_method() {
    let source = r#"
class MathUtils {
    static add(a: number, b: number) {
        return a + b;
    }

    static PI = 3.14159;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Static method should be on constructor, not prototype
    assert!(
        output.contains("MathUtils.add") || output.contains(".add ="),
        "Expected static method on constructor function: {}",
        output
    );

    // Static property should be on constructor
    assert!(
        output.contains("MathUtils.PI") || output.contains(".PI ="),
        "Expected static property on constructor function: {}",
        output
    );

    // Should contain the PI value
    assert!(
        output.contains("3.14159"),
        "Expected PI value 3.14159 in output: {}",
        output
    );
}

#[test]
fn test_class_es5_computed_property_in_object_literal() {
    let source = r#"
class DynamicObject {
    createObject(key: string, value: number) {
        return { [key]: value };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should NOT contain computed property syntax in object literal (ES5 doesn't support it)
    assert!(
        !output.contains("[key]:") && !output.contains("[key] :"),
        "Expected computed property to be transformed, not raw [key]: syntax: {}",
        output
    );

    // Should use bracket notation assignment or temp variable pattern
    assert!(
        output.contains("[key]") || output.contains("_a"),
        "Expected ES5 computed property to use bracket notation or temp var: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.createObject")
            || output.contains("prototype[\"createObject\"]"),
        "Expected createObject method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_inheritance_extends() {
    let source = r#"
class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    speak() {
        return this.name;
    }
}
class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }
    speak() {
        return "Woof! " + super.speak();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected Dog class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should use __extends helper for inheritance
    assert!(
        output.contains("__extends") || output.contains("extends"),
        "Expected __extends helper for ES5 inheritance: {}",
        output
    );

    // Should call super constructor
    assert!(
        output.contains("_super") || output.contains(".call("),
        "Expected super constructor call pattern: {}",
        output
    );

    // Should have Dog function
    assert!(
        output.contains("function Dog") || output.contains("Dog ="),
        "Expected Dog constructor function: {}",
        output
    );
}

#[test]
fn test_class_es5_nullish_coalescing() {
    let source = r#"
class Config {
    getValue(input: string | null | undefined) {
        return input ?? "default";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should NOT contain ?? operator (ES5 doesn't support it)
    assert!(
        !output.contains("??"),
        "Expected nullish coalescing to be transformed, not raw ?? syntax: {}",
        output
    );

    // Should preserve the default value
    assert!(
        output.contains("default"),
        "Expected default value to be preserved: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.getValue") || output.contains("prototype[\"getValue\"]"),
        "Expected getValue method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_optional_chaining() {
    let source = r#"
class DataProcessor {
    process(data: { value?: { nested?: string } } | null) {
        return data?.value?.nested;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should NOT contain ?. operator (ES5 doesn't support it)
    assert!(
        !output.contains("?."),
        "Expected optional chaining to be transformed, not raw ?. syntax: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.process") || output.contains("prototype[\"process\"]"),
        "Expected process method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_nested_arrow_in_async_method_captures_this() {
    // Test nested arrow function in async method captures _this correctly
    let source = r#"
class Handler {
    value = 42;
    async process() {
        const callback = () => {
            return this.value;
        };
        return await Promise.resolve(callback());
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Arrow inside async method should capture _this
    assert!(
        output.contains("_this.value"),
        "Expected nested arrow in async method to capture _this.value: {}",
        output
    );

    // Should use __awaiter for async method
    assert!(
        output.contains("__awaiter"),
        "Expected async method to use __awaiter: {}",
        output
    );
}

#[test]
fn test_class_es5_deeply_nested_arrows_in_async_method() {
    // Test deeply nested arrows (3 levels) in async method
    let source = r#"
class DeepNest {
    data = [1, 2, 3];
    async processDeep() {
        const outer = () => {
            const middle = () => {
                const inner = () => {
                    return this.data;
                };
                return inner();
            };
            return middle();
        };
        return await Promise.resolve(outer());
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Deeply nested arrow should still capture _this.data
    assert!(
        output.contains("_this.data"),
        "Expected deeply nested arrow to capture _this.data: {}",
        output
    );
}

#[test]
fn test_class_es5_arrow_in_async_method_with_array_callback() {
    // Test arrow in async method with array callbacks using this
    let source = r#"
class Processor {
    multiplier = 2;
    async transform(items: number[]) {
        const mapped = items.map(x => x * this.multiplier);
        const filtered = mapped.filter(x => x > this.multiplier);
        return await Promise.resolve(filtered);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Arrow callbacks in async method should capture _this.multiplier
    assert!(
        output.contains("_this.multiplier"),
        "Expected arrow callbacks to capture _this.multiplier: {}",
        output
    );

    // Should have multiple references to _this.multiplier
    assert!(
        output.matches("_this.multiplier").count() >= 2,
        "Expected at least 2 references to _this.multiplier: {}",
        output
    );
}

#[test]
fn test_class_es5_arrow_returning_arrow_in_async_method() {
    // Test arrow returning another arrow that uses this
    let source = r#"
class Factory {
    prefix = "item-";
    async createFormatter() {
        const formatter = () => (value: string) => this.prefix + value;
        return await Promise.resolve(formatter());
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Returned arrow should capture _this.prefix
    assert!(
        output.contains("_this.prefix"),
        "Expected returned arrow to capture _this.prefix: {}",
        output
    );
}

#[test]
fn test_class_es5_multiple_arrows_same_level_in_async_method() {
    // Test multiple arrows at the same level in async method
    let source = r#"
class Multi {
    a = 1;
    b = 2;
    c = 3;
    async compute() {
        const getA = () => this.a;
        const getB = () => this.b;
        const getC = () => this.c;
        return await Promise.resolve(getA() + getB() + getC());
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // All arrows should capture _this for their respective properties
    assert!(
        output.contains("_this.a"),
        "Expected getA arrow to capture _this.a: {}",
        output
    );
    assert!(
        output.contains("_this.b"),
        "Expected getB arrow to capture _this.b: {}",
        output
    );
    assert!(
        output.contains("_this.c"),
        "Expected getC arrow to capture _this.c: {}",
        output
    );
}

#[test]
fn test_class_es5_arrow_after_await_in_async_method() {
    // Test arrow defined after await still captures this correctly
    let source = r#"
class Sequential {
    state = "ready";
    async run() {
        await this.prepare();
        const check = () => this.state;
        return check();
    }
    async prepare() {
        this.state = "prepared";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Arrow after await should still capture _this.state
    assert!(
        output.contains("_this.state"),
        "Expected arrow after await to capture _this.state: {}",
        output
    );
}

#[test]
fn test_class_es5_arrow_with_this_method_call_in_async() {
    // Test arrow that calls this.method() in async context
    let source = r#"
class Caller {
    value = 10;
    getValue() { return this.value; }
    async process() {
        const callMethod = () => this.getValue();
        const result = await Promise.resolve(callMethod());
        return result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Arrow should capture _this.getValue
    assert!(
        output.contains("_this.getValue"),
        "Expected arrow to capture _this.getValue(): {}",
        output
    );
}

#[test]
fn test_class_es5_generator_method() {
    // Tests generator method structure on ES5 class
    // Note: Full generator transform uses __generator helper
    let source = r#"
class DataStream {
    *getItems() {
        return [1, 2, 3];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should emit as a function (ES5 class pattern)
    assert!(
        output.contains("function DataStream"),
        "Expected DataStream constructor function: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.getItems") || output.contains("prototype[\"getItems\"]"),
        "Expected getItems method on prototype: {}",
        output
    );

    // Should return the array
    assert!(
        output.contains("return")
            && (output.contains("[1, 2, 3]") || output.contains("1") || output.contains("2")),
        "Expected return statement with values: {}",
        output
    );
}

#[test]
fn test_class_es5_super_property_in_static_method() {
    // Test super property access in a static method
    let source = r#"
class Base {
    static config = { debug: true };
    static getVersion() { return "1.0"; }
}
class Derived extends Base {
    static init() {
        const cfg = super.config;
        const ver = super.getVersion();
        return { cfg, ver };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Static method should access super as Base (the parent class)
    // super.config (property read) becomes _super.config
    assert!(
        output.contains("_super.config"),
        "Expected super.config in static method to reference _super.config: {}",
        output
    );
    // super.getVersion() (method call) becomes _super.prototype.getVersion.call(this)
    assert!(
        output.contains("_super.prototype.getVersion.call"),
        "Expected super.getVersion() in static method to use prototype.call pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_computed_super_property_read() {
    // Test computed super property read (not call) - super[key] as property access
    let source = r#"
class Base {
    data = { x: 1, y: 2 };
}
class Derived extends Base {
    getProperty(key: string) {
        return super[key];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Computed super property read should be transformed
    // For instance method super[key] property read, it becomes _super[key] or _super.prototype[key]
    assert!(
        output.contains("_super[key]") || output.contains("_super.prototype[key]"),
        "Expected computed super property read to be lowered: {}",
        output
    );
    // The raw super[key] should not appear (should be _super[key])
    // Note: super[key] becomes _super[key] in the output
    assert!(
        !output.contains("super[key]") || output.contains("_super[key]"),
        "Expected super[key] property access to be lowered in ES5 output: {}",
        output
    );
}

#[test]
fn test_class_es5_computed_super_property_in_static_method() {
    // Test computed super property access in a static method
    let source = r#"
class Base {
    static values = { a: 1, b: 2 };
}
class Derived extends Base {
    static getValue(key: string) {
        return super[key];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected derived class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Static method computed super should reference parent class
    assert!(
        output.contains("Base[key]") || output.contains("_super[key]"),
        "Expected static computed super property to reference parent class: {}",
        output
    );
}

#[test]
fn test_class_es5_try_catch_finally() {
    let source = r#"
class ErrorHandler {
    safeExecute(fn: () => void) {
        try {
            fn();
            return true;
        } catch (error) {
            console.error(error);
            return false;
        } finally {
            console.log("done");
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Should emit as a function (ES5 class pattern)
    assert!(
        output.contains("function ErrorHandler"),
        "Expected ErrorHandler constructor function: {}",
        output
    );

    // Should have try/catch/finally blocks
    assert!(
        output.contains("try"),
        "Expected try block in output: {}",
        output
    );
    assert!(
        output.contains("catch"),
        "Expected catch block in output: {}",
        output
    );
    assert!(
        output.contains("finally"),
        "Expected finally block in output: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.safeExecute") || output.contains("prototype[\"safeExecute\"]"),
        "Expected safeExecute method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_abstract_class_lowering() {
    // Test abstract class is properly lowered to ES5
    let source = r#"
abstract class Shape {
    abstract getArea(): number;

    describe(): string {
        return "A shape with area: " + this.getArea();
    }
}

class Circle extends Shape {
    constructor(public radius: number) {
        super();
    }

    getArea(): number {
        return Math.PI * this.radius * this.radius;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Get the abstract class (first class)
    let abstract_class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected abstract class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(abstract_class_idx);

    // Abstract class should still emit as a function
    assert!(
        output.contains("function Shape"),
        "Expected abstract class to emit as function: {}",
        output
    );

    // Concrete method should be on prototype
    assert!(
        output.contains(".prototype.describe") || output.contains("prototype[\"describe\"]"),
        "Expected concrete method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_class_with_index_signature() {
    // Test class with index signature is properly lowered
    let source = r#"
class Dictionary {
    [key: string]: number;

    set(key: string, value: number) {
        this[key] = value;
    }

    get(key: string): number {
        return this[key];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Dictionary"),
        "Expected class with index signature to emit as function: {}",
        output
    );

    // Methods should be on prototype
    assert!(
        output.contains(".prototype.set") || output.contains("prototype[\"set\"]"),
        "Expected set method on prototype: {}",
        output
    );
    assert!(
        output.contains(".prototype.get") || output.contains("prototype[\"get\"]"),
        "Expected get method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_class_expression() {
    // Test class expression (not declaration) is properly lowered
    let source = r#"
const MyClass = class {
    value = 10;
    getValue() {
        return this.value;
    }
};
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // The class expression is inside a variable declaration
    // We need to find it differently - for now just verify parse succeeds
    assert!(
        !source_file.statements.nodes.is_empty(),
        "Expected at least one statement"
    );
}

#[test]
fn test_class_es5_symbol_keyed_methods() {
    // Test class with Symbol-keyed methods (computed property with Symbol)
    let source = r#"
class IterableCollection<T> {
    private items: T[] = [];

    [Symbol.iterator]() {
        let index = 0;
        const items = this.items;
        return {
            next() {
                if (index < items.length) {
                    return { value: items[index++], done: false };
                }
                return { value: undefined, done: true };
            }
        };
    }

    [Symbol.toStringTag]() {
        return "IterableCollection";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function IterableCollection"),
        "Expected class to emit as function: {}",
        output
    );

    // Symbol-keyed methods should be on prototype with computed property syntax
    assert!(
        output.contains("[Symbol.iterator]") || output.contains("Symbol.iterator"),
        "Expected Symbol.iterator method in output: {}",
        output
    );
    assert!(
        output.contains("[Symbol.toStringTag]") || output.contains("Symbol.toStringTag"),
        "Expected Symbol.toStringTag method in output: {}",
        output
    );

    // Should have prototype assignment pattern
    assert!(
        output.contains(".prototype[Symbol") || output.contains("prototype[Symbol"),
        "Expected Symbol-keyed methods to be assigned to prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_private_method_in_async_method() {
    // Test private method called from async method
    let source = r#"
class Counter {
    #count = 0;

    #increment() {
        this.#count++;
    }

    async addMultiple(times: number) {
        for (let i = 0; i < times; i++) {
            await delay(10);
            this.#increment();
        }
        return this.#count;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Counter"),
        "Expected class to emit as function: {}",
        output
    );

    // Private method call should use _this capture inside async/generator context
    // The async method body is transformed and needs proper this capture
    assert!(
        output.contains("__awaiter") || output.contains("__generator") || output.contains("_this"),
        "Expected async transform with this capture for private method call: {}",
        output
    );
}

#[test]
fn test_class_es5_static_private_method() {
    // Test static private method
    let source = r#"
class Validator {
    static #validate(value: string): boolean {
        return value.length > 0;
    }

    static isValid(input: string): boolean {
        return Validator.#validate(input);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Validator"),
        "Expected class to emit as function: {}",
        output
    );

    // Static method isValid should be on Validator directly
    assert!(
        output.contains("Validator.isValid") || output.contains("Validator.prototype"),
        "Expected static method on class: {}",
        output
    );
}

#[test]
fn test_class_es5_private_accessors() {
    // Test private getter and setter accessors
    let source = r#"
class Temperature {
    #celsius = 0;

    get #value(): number {
        return this.#celsius;
    }

    set #value(v: number) {
        this.#celsius = v;
    }

    setFahrenheit(f: number) {
        this.#value = (f - 32) * 5 / 9;
    }

    getFahrenheit(): number {
        return this.#value * 9 / 5 + 32;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Temperature"),
        "Expected class to emit as function: {}",
        output
    );

    // Public methods should be on prototype
    assert!(
        output.contains("setFahrenheit") && output.contains("getFahrenheit"),
        "Expected public methods in output: {}",
        output
    );
}

#[test]
fn test_class_es5_switch_case_statement() {
    // Test class method with switch/case statement
    let source = r#"
class Router {
    route(action: string): string {
        switch (action) {
            case "home":
                return "/";
            case "about":
                return "/about";
            case "contact":
                return "/contact";
            default:
                return "/404";
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Router"),
        "Expected class to emit as function: {}",
        output
    );

    // Should preserve switch statement
    assert!(
        output.contains("switch"),
        "Expected switch statement in output: {}",
        output
    );

    // Should preserve case clauses
    assert!(
        output.contains("case \"home\"") || output.contains("case 'home'"),
        "Expected case clause for home: {}",
        output
    );

    // Should preserve default clause
    assert!(
        output.contains("default"),
        "Expected default clause in output: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.route"),
        "Expected route method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_while_do_while_loops() {
    // Test class method with while and do-while loops
    let source = r#"
class Counter {
    countUp(max: number): number[] {
        const results: number[] = [];
        let i = 0;
        while (i < max) {
            results.push(i);
            i++;
        }
        return results;
    }

    countDown(start: number): number[] {
        const results: number[] = [];
        let j = start;
        do {
            results.push(j);
            j--;
        } while (j >= 0);
        return results;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Counter"),
        "Expected class to emit as function: {}",
        output
    );

    // Should preserve while loop
    assert!(
        output.contains("while"),
        "Expected while loop in output: {}",
        output
    );

    // Should preserve do keyword for do-while
    assert!(
        output.contains("do {") || output.contains("do{"),
        "Expected do-while loop in output: {}",
        output
    );

    // Methods should be on prototype
    assert!(
        output.contains(".prototype.countUp"),
        "Expected countUp method on prototype: {}",
        output
    );
    assert!(
        output.contains(".prototype.countDown"),
        "Expected countDown method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_ternary_expression() {
    // Test class method with ternary/conditional expressions
    let source = r#"
class Validator {
    isValid(value: number): boolean {
        return value >= 0 ? true : false;
    }

    getStatus(score: number): string {
        return score >= 90 ? "excellent" : score >= 70 ? "good" : score >= 50 ? "pass" : "fail";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Validator"),
        "Expected class to emit as function: {}",
        output
    );

    // Should preserve ternary expressions (? and :)
    assert!(
        output.contains("?") && output.contains(":"),
        "Expected ternary expression in output: {}",
        output
    );

    // Methods should be on prototype
    assert!(
        output.contains(".prototype.isValid"),
        "Expected isValid method on prototype: {}",
        output
    );
    assert!(
        output.contains(".prototype.getStatus"),
        "Expected getStatus method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_method_overloads() {
    // Test class with TypeScript method overloads
    let source = r#"
class Calculator {
    add(a: number, b: number): number;
    add(a: string, b: string): string;
    add(a: any, b: any): any {
        return a + b;
    }

    multiply(a: number, b: number): number;
    multiply(a: number, b: number, c: number): number;
    multiply(...args: number[]): number {
        return args.reduce((acc, val) => acc * val, 1);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Calculator should emit as function
    assert!(
        output.contains("function Calculator"),
        "Expected Calculator class to emit as function: {}",
        output
    );

    // Only the implementation should be emitted, not the overload signatures
    // There should be exactly one add method on prototype
    let add_count =
        output.matches("prototype.add").count() + output.matches("prototype[\"add\"]").count();
    assert!(
        add_count == 1,
        "Expected exactly one add method (implementation only), found {}: {}",
        add_count,
        output
    );

    // There should be exactly one multiply method on prototype
    let multiply_count = output.matches("prototype.multiply").count()
        + output.matches("prototype[\"multiply\"]").count();
    assert!(
        multiply_count == 1,
        "Expected exactly one multiply method (implementation only), found {}: {}",
        multiply_count,
        output
    );
}

#[test]
fn test_class_es5_computed_method_names() {
    // Test class with computed method names from variables
    let source = r#"
const methodName = "dynamicMethod";
const prefix = "get";

class DynamicClass {
    [methodName]() {
        return "called dynamic method";
    }

    [prefix + "Value"]() {
        return 42;
    }

    static [methodName.toUpperCase()]() {
        return "static dynamic";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Get the class (third statement after two const declarations)
    let class_idx = *source_file
        .statements
        .nodes
        .last()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // DynamicClass should emit as function
    assert!(
        output.contains("function DynamicClass"),
        "Expected DynamicClass to emit as function: {}",
        output
    );

    // Should have computed property access patterns
    assert!(
        output.contains("[methodName]") || output.contains("methodName"),
        "Expected computed method name reference: {}",
        output
    );

    // Note: Static computed properties currently have a bug where the computed name
    // is not properly emitted (outputs "DynamicClass. = function")
    // The instance methods with computed names work correctly
    assert!(
        output.contains("DynamicClass.prototype[methodName]"),
        "Expected instance computed method with methodName: {}",
        output
    );
}

#[test]
fn test_class_es5_optional_and_readonly_properties() {
    // Test class with optional and readonly properties
    let source = r#"
class Config {
    readonly version: string = "1.0.0";
    readonly buildDate: Date;
    name?: string;
    description?: string = "Default description";

    constructor(buildDate: Date) {
        this.buildDate = buildDate;
    }

    getVersion(): string {
        return this.version;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Config should emit as function
    assert!(
        output.contains("function Config"),
        "Expected Config class to emit as function: {}",
        output
    );

    // readonly properties with initializers should be emitted
    assert!(
        output.contains("this.version = \"1.0.0\""),
        "Expected readonly version property with initializer: {}",
        output
    );

    // buildDate should be assigned in constructor
    assert!(
        output.contains("this.buildDate"),
        "Expected readonly buildDate property assignment: {}",
        output
    );

    // optional property with default should be emitted
    assert!(
        output.contains("this.description = \"Default description\""),
        "Expected optional description property with default: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.getVersion") || output.contains("prototype[\"getVersion\"]"),
        "Expected getVersion method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_constructor_overloads() {
    // Test class with constructor overloads
    let source = r#"
class Point {
    x: number;
    y: number;

    constructor();
    constructor(x: number, y: number);
    constructor(point: { x: number; y: number });
    constructor(xOrPoint?: number | { x: number; y: number }, y?: number) {
        if (typeof xOrPoint === 'object') {
            this.x = xOrPoint.x;
            this.y = xOrPoint.y;
        } else {
            this.x = xOrPoint ?? 0;
            this.y = y ?? 0;
        }
    }

    distanceTo(other: Point): number {
        return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Point should emit as function
    assert!(
        output.contains("function Point"),
        "Expected Point class to emit as function: {}",
        output
    );

    // Only one constructor implementation should be emitted
    let function_point_count = output.matches("function Point").count();
    assert!(
        function_point_count == 1,
        "Expected exactly one Point constructor, found {}: {}",
        function_point_count,
        output
    );

    // Constructor body should have the implementation logic
    assert!(
        output.contains("this.x") && output.contains("this.y"),
        "Expected x and y property assignments: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.distanceTo") || output.contains("prototype[\"distanceTo\"]"),
        "Expected distanceTo method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_async_static_field_with_await_chain() {
    // Test static async field initializer with chained await expressions
    let source = r#"
class DataLoader {
    static loader = async () => {
        const response = await fetch("/api/data");
        const json = await response.json();
        const processed = await processData(json);
        return processed;
    };
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function DataLoader"),
        "Expected DataLoader class to emit as function: {}",
        output
    );

    // Static async arrow should use __awaiter
    assert!(
        output.contains("__awaiter"),
        "Expected static async arrow with await chain to use __awaiter: {}",
        output
    );

    // Should be assigned to class, not prototype
    assert!(
        output.contains("DataLoader.loader"),
        "Expected static field on class, not prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_async_static_field_with_conditional() {
    // Test static async field with conditional/ternary expressions inside async body
    let source = r#"
class ConfigLoader {
    static loadConfig = async (env: string) => {
        const baseUrl = env === "production"
            ? "https://api.prod.com"
            : env === "staging"
                ? "https://api.staging.com"
                : "http://localhost:3000";
        const result = await fetch(baseUrl + "/config");
        return result.ok ? await result.json() : null;
    };
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function ConfigLoader"),
        "Expected ConfigLoader class to emit as function: {}",
        output
    );

    // Should use __awaiter for async
    assert!(
        output.contains("__awaiter"),
        "Expected static async field with conditionals to use __awaiter: {}",
        output
    );

    // Static field assignment
    assert!(
        output.contains("ConfigLoader.loadConfig"),
        "Expected static loadConfig field on class: {}",
        output
    );

    // Async body structure should include generator pattern
    assert!(
        output.contains("__generator"),
        "Expected __generator pattern in async body: {}",
        output
    );
}

#[test]
fn test_class_es5_async_static_field_with_try_catch() {
    // Test static async field with try/catch error handling
    let source = r#"
class SafeLoader {
    static safeFetch = async (url: string) => {
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error("HTTP " + response.status);
            }
            return await response.json();
        } catch (error) {
            console.error("Fetch failed:", error);
            return null;
        } finally {
            console.log("Fetch completed for:", url);
        }
    };
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function SafeLoader"),
        "Expected SafeLoader class to emit as function: {}",
        output
    );

    // Should use __awaiter for async
    assert!(
        output.contains("__awaiter"),
        "Expected static async field with try/catch to use __awaiter: {}",
        output
    );

    // Static field assignment
    assert!(
        output.contains("SafeLoader.safeFetch"),
        "Expected static safeFetch field on class: {}",
        output
    );

    // Async body structure should include generator pattern
    assert!(
        output.contains("__generator"),
        "Expected __generator pattern in async body: {}",
        output
    );
}

#[test]
fn test_class_es5_async_static_field_with_promise_all() {
    // Test static async field with Promise.all for parallel operations
    let source = r#"
class ParallelLoader {
    static loadAll = async (urls: string[]) => {
        const promises = urls.map(url => fetch(url));
        const responses = await Promise.all(promises);
        const data = await Promise.all(responses.map(r => r.json()));
        return data;
    };
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function ParallelLoader"),
        "Expected ParallelLoader class to emit as function: {}",
        output
    );

    // Should use __awaiter for async
    assert!(
        output.contains("__awaiter"),
        "Expected static async field with Promise.all to use __awaiter: {}",
        output
    );

    // Should preserve Promise.all calls
    assert!(
        output.contains("Promise.all"),
        "Expected Promise.all calls in async body: {}",
        output
    );

    // Static field assignment
    assert!(
        output.contains("ParallelLoader.loadAll"),
        "Expected static loadAll field on class: {}",
        output
    );
}

#[test]
fn test_class_es5_async_static_field_with_loop_and_await() {
    // Test static async field with for loop containing await
    let source = r#"
class SequentialLoader {
    static loadSequentially = async (items: string[]) => {
        const results: any[] = [];
        for (let i = 0; i < items.length; i++) {
            const result = await processItem(items[i]);
            results.push(result);
        }
        return results;
    };
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function SequentialLoader"),
        "Expected SequentialLoader class to emit as function: {}",
        output
    );

    // Should use __awaiter for async
    assert!(
        output.contains("__awaiter"),
        "Expected static async field with loop/await to use __awaiter: {}",
        output
    );

    // Static field assignment
    assert!(
        output.contains("SequentialLoader.loadSequentially"),
        "Expected static loadSequentially field on class: {}",
        output
    );

    // Async body structure should include generator pattern
    assert!(
        output.contains("__generator"),
        "Expected __generator pattern in async body: {}",
        output
    );
}

#[test]
fn test_class_es5_async_static_field_with_object_destructuring() {
    // Test static async field with object destructuring from await result
    let source = r#"
class ApiClient {
    static getUser = async (id: number) => {
        const { data, status, headers } = await api.get("/users/" + id);
        const { name, email, role } = data;
        return { name, email, role, status };
    };
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function ApiClient"),
        "Expected ApiClient class to emit as function: {}",
        output
    );

    // Should use __awaiter for async
    assert!(
        output.contains("__awaiter"),
        "Expected static async field with destructuring to use __awaiter: {}",
        output
    );

    // Static field assignment
    assert!(
        output.contains("ApiClient.getUser"),
        "Expected static getUser field on class: {}",
        output
    );
}

#[test]
fn test_class_es5_async_static_field_with_nested_async_calls() {
    // Test static async field that calls other async functions with nested awaits
    let source = r#"
class DataProcessor {
    static process = async (input: any) => {
        const validated = await validate(input);
        const transformed = await transform(validated, {
            format: await getFormat(),
            options: await getOptions()
        });
        const result = await save(transformed);
        return result;
    };
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function DataProcessor"),
        "Expected DataProcessor class to emit as function: {}",
        output
    );

    // Should use __awaiter for async
    assert!(
        output.contains("__awaiter"),
        "Expected static async field with nested awaits to use __awaiter: {}",
        output
    );

    // Static field assignment
    assert!(
        output.contains("DataProcessor.process"),
        "Expected static process field on class: {}",
        output
    );
}

#[test]
fn test_class_es5_async_static_field_with_switch_case() {
    // Test static async field with switch/case inside async body
    let source = r#"
class ActionHandler {
    static handle = async (action: string) => {
        switch (action) {
            case "fetch":
                return await fetchData();
            case "save":
                return await saveData();
            case "delete":
                return await deleteData();
            default:
                throw new Error("Unknown action: " + action);
        }
    };
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function ActionHandler"),
        "Expected ActionHandler class to emit as function: {}",
        output
    );

    // Should use __awaiter for async
    assert!(
        output.contains("__awaiter"),
        "Expected static async field with switch/case to use __awaiter: {}",
        output
    );

    // Static field assignment
    assert!(
        output.contains("ActionHandler.handle"),
        "Expected static handle field on class: {}",
        output
    );

    // Async body structure should include generator pattern
    assert!(
        output.contains("__generator"),
        "Expected __generator pattern in async body: {}",
        output
    );
}

#[test]
fn test_class_es5_multiple_private_fields() {
    // Test class with multiple private fields of different types
    let source = r#"
class SecureData {
    #id: number;
    #name: string;
    #active: boolean = true;
    #metadata: object = {};

    constructor(id: number, name: string) {
        this.#id = id;
        this.#name = name;
    }

    getId(): number {
        return this.#id;
    }

    getName(): string {
        return this.#name;
    }

    isActive(): boolean {
        return this.#active;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function SecureData"),
        "Expected SecureData class to emit as function: {}",
        output
    );

    // Should have WeakMap for private fields
    assert!(
        output.contains("WeakMap")
            || output.contains("__classPrivateFieldSet")
            || output.contains("__classPrivateFieldGet"),
        "Expected private field mechanism in output: {}",
        output
    );

    // Methods should be on prototype
    assert!(
        output.contains(".prototype.getId") || output.contains("prototype[\"getId\"]"),
        "Expected getId method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_mixed_static_instance_async() {
    // Test class with both static and instance async methods
    let source = r#"
class DataService {
    static async fetchAll(): Promise<any[]> {
        return await api.getAll();
    }

    async fetchOne(id: number): Promise<any> {
        return await api.get(id);
    }

    static async create(data: any): Promise<any> {
        return await api.post(data);
    }

    async update(id: number, data: any): Promise<any> {
        return await api.put(id, data);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function DataService"),
        "Expected DataService class to emit as function: {}",
        output
    );

    // Should use __awaiter for async methods
    assert!(
        output.contains("__awaiter"),
        "Expected __awaiter for async methods: {}",
        output
    );

    // Static methods should be on class
    assert!(
        output.contains("DataService.fetchAll") || output.contains("DataService.create"),
        "Expected static async methods on class: {}",
        output
    );

    // Instance methods should be on prototype
    assert!(
        output.contains(".prototype.fetchOne") || output.contains(".prototype.update"),
        "Expected instance async methods on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_property_initializers_with_method_calls() {
    // Test class with property initializers that call methods
    let source = r#"
class Config {
    baseUrl: string = this.getDefaultUrl();
    timeout: number = Config.getDefaultTimeout();
    headers: object = this.createHeaders();

    getDefaultUrl(): string {
        return "https://api.example.com";
    }

    static getDefaultTimeout(): number {
        return 5000;
    }

    createHeaders(): object {
        return { "Content-Type": "application/json" };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Config"),
        "Expected Config class to emit as function: {}",
        output
    );

    // Property initializers should reference this
    assert!(
        output.contains("this.baseUrl")
            || output.contains("this.timeout")
            || output.contains("this.headers"),
        "Expected property assignments in constructor: {}",
        output
    );

    // Methods should be on prototype
    assert!(
        output.contains(".prototype.getDefaultUrl")
            || output.contains("prototype[\"getDefaultUrl\"]"),
        "Expected getDefaultUrl method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_labeled_statements_in_method() {
    // Test class method with labeled statements and break/continue
    let source = r#"
class SearchEngine {
    search(items: any[][], query: string): any | null {
        outer: for (let i = 0; i < items.length; i++) {
            inner: for (let j = 0; j < items[i].length; j++) {
                if (items[i][j] === query) {
                    return items[i][j];
                }
                if (items[i][j] === null) {
                    continue outer;
                }
            }
        }
        return null;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function SearchEngine"),
        "Expected SearchEngine class to emit as function: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.search") || output.contains("prototype[\"search\"]"),
        "Expected search method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_new_target_meta_property() {
    // Test class constructor with new.target (verifies class emits, meta property handling is a TODO)
    let source = r#"
class BaseClass {
    constructor() {
        if (new.target === BaseClass) {
            throw new Error("Cannot instantiate abstract class");
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function BaseClass"),
        "Expected BaseClass class to emit as function: {}",
        output
    );

    // Throw statement should be preserved
    assert!(
        output.contains("throw new Error"),
        "Expected throw statement in output: {}",
        output
    );
}

#[test]
fn test_class_es5_method_with_this_type_parameter() {
    // Test class method returning this type
    let source = r#"
class Builder {
    private value: string = "";

    append(text: string): this {
        this.value += text;
        return this;
    }

    prepend(text: string): this {
        this.value = text + this.value;
        return this;
    }

    build(): string {
        return this.value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Builder"),
        "Expected Builder class to emit as function: {}",
        output
    );

    // Methods should return this
    assert!(
        output.contains("return this"),
        "Expected 'return this' in fluent methods: {}",
        output
    );

    // All methods should be on prototype
    assert!(
        output.contains(".prototype.append")
            && output.contains(".prototype.prepend")
            && output.contains(".prototype.build"),
        "Expected all methods on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_async_method_decorator_pattern() {
    // Test class with async methods that would have decorator metadata
    // Similar to NestJS controller with @Get/@Post decorators on async handlers
    let source = r#"
class ApiController {
    static __routes__ = [
        { method: "GET", path: "/users", handler: "getUsers" },
        { method: "POST", path: "/users", handler: "createUser" }
    ];

    private db: any;

    constructor(db: any) {
        this.db = db;
    }

    async getUsers(): Promise<any[]> {
        return await this.db.query("SELECT * FROM users");
    }

    async createUser(data: any): Promise<any> {
        return await this.db.insert("users", data);
    }

    async deleteUser(id: number): Promise<void> {
        await this.db.delete("users", id);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // ApiController should emit as function
    assert!(
        output.contains("function ApiController"),
        "Expected ApiController to emit as function: {}",
        output
    );

    // Static routes metadata
    assert!(
        output.contains("ApiController.__routes__"),
        "Expected static __routes__ property: {}",
        output
    );

    // Async methods should be on prototype
    assert!(
        output.contains(".prototype.getUsers") || output.contains("prototype[\"getUsers\"]"),
        "Expected getUsers method on prototype: {}",
        output
    );
    assert!(
        output.contains(".prototype.createUser") || output.contains("prototype[\"createUser\"]"),
        "Expected createUser method on prototype: {}",
        output
    );
    assert!(
        output.contains(".prototype.deleteUser") || output.contains("prototype[\"deleteUser\"]"),
        "Expected deleteUser method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_async_lifecycle_decorator_pattern() {
    // Test class with async lifecycle methods that would have decorators
    // Similar to Angular component with @OnInit, @OnDestroy on async methods
    let source = r#"
class LifecycleComponent {
    static __lifecycle__ = ["onInit", "onDestroy"];

    private subscription: any = null;
    private data: any[] = [];

    async onInit(): Promise<void> {
        this.subscription = await this.subscribe();
        this.data = await this.loadInitialData();
    }

    async onDestroy(): Promise<void> {
        if (this.subscription) {
            await this.subscription.unsubscribe();
        }
        this.data = [];
    }

    private async subscribe(): Promise<any> {
        return { unsubscribe: async () => {} };
    }

    private async loadInitialData(): Promise<any[]> {
        return [];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // LifecycleComponent should emit as function
    assert!(
        output.contains("function LifecycleComponent"),
        "Expected LifecycleComponent to emit as function: {}",
        output
    );

    // Static lifecycle metadata
    assert!(
        output.contains("LifecycleComponent.__lifecycle__"),
        "Expected static __lifecycle__ property: {}",
        output
    );

    // Instance fields should be initialized
    assert!(
        output.contains("this.subscription = null"),
        "Expected subscription field initialization: {}",
        output
    );

    // Async lifecycle methods should be on prototype
    assert!(
        output.contains(".prototype.onInit") || output.contains("prototype[\"onInit\"]"),
        "Expected onInit method on prototype: {}",
        output
    );
    assert!(
        output.contains(".prototype.onDestroy") || output.contains("prototype[\"onDestroy\"]"),
        "Expected onDestroy method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_async_event_handler_decorator_pattern() {
    // Test class with async event handlers that would have decorator metadata
    // Similar to event-driven architecture with @EventHandler decorators
    let source = r#"
class EventProcessor {
    static __events__ = {
        "user.created": "handleUserCreated",
        "user.updated": "handleUserUpdated",
        "user.deleted": "handleUserDeleted"
    };
    static __retryPolicy__ = { maxRetries: 3, delay: 1000 };

    private eventBus: any;
    private logger: any;

    constructor(eventBus: any, logger: any) {
        this.eventBus = eventBus;
        this.logger = logger;
    }

    async handleUserCreated(event: any): Promise<void> {
        this.logger.info("User created:", event);
        await this.eventBus.publish("notifications", event);
    }

    async handleUserUpdated(event: any): Promise<void> {
        this.logger.info("User updated:", event);
        await this.eventBus.publish("sync", event);
    }

    async handleUserDeleted(event: any): Promise<void> {
        this.logger.warn("User deleted:", event);
        await this.eventBus.publish("cleanup", event);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // EventProcessor should emit as function
    assert!(
        output.contains("function EventProcessor"),
        "Expected EventProcessor to emit as function: {}",
        output
    );

    // Static event metadata
    assert!(
        output.contains("EventProcessor.__events__"),
        "Expected static __events__ property: {}",
        output
    );
    assert!(
        output.contains("EventProcessor.__retryPolicy__"),
        "Expected static __retryPolicy__ property: {}",
        output
    );

    // Constructor should assign dependencies
    assert!(
        output.contains("this.eventBus = eventBus"),
        "Expected eventBus assignment: {}",
        output
    );
    assert!(
        output.contains("this.logger = logger"),
        "Expected logger assignment: {}",
        output
    );

    // Async event handlers should be on prototype
    assert!(
        output.contains(".prototype.handleUserCreated")
            || output.contains("prototype[\"handleUserCreated\"]"),
        "Expected handleUserCreated method on prototype: {}",
        output
    );
    assert!(
        output.contains(".prototype.handleUserUpdated")
            || output.contains("prototype[\"handleUserUpdated\"]"),
        "Expected handleUserUpdated method on prototype: {}",
        output
    );
    assert!(
        output.contains(".prototype.handleUserDeleted")
            || output.contains("prototype[\"handleUserDeleted\"]"),
        "Expected handleUserDeleted method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_constructor_param_inject_decorator() {
    // Test class with constructor parameter injection metadata
    // Similar to Angular's @Inject decorator for DI
    let source = r#"
class UserService {
    static __paramtypes__ = ["HttpClient", "Logger", "Config"];
    static __inject__ = [0, 1, 2];

    private http: any;
    private logger: any;
    private config: any;

    constructor(http: any, logger: any, config: any) {
        this.http = http;
        this.logger = logger;
        this.config = config;
    }

    getUser(id: number): any {
        this.logger.log("Fetching user:", id);
        return this.http.get("/users/" + id);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // UserService should emit as function
    assert!(
        output.contains("function UserService"),
        "Expected UserService to emit as function: {}",
        output
    );

    // Static parameter type metadata
    assert!(
        output.contains("UserService.__paramtypes__"),
        "Expected static __paramtypes__ property: {}",
        output
    );
    assert!(
        output.contains("UserService.__inject__"),
        "Expected static __inject__ property: {}",
        output
    );

    // Constructor should assign all injected dependencies
    assert!(
        output.contains("this.http = http"),
        "Expected http assignment: {}",
        output
    );
    assert!(
        output.contains("this.logger = logger"),
        "Expected logger assignment: {}",
        output
    );
    assert!(
        output.contains("this.config = config"),
        "Expected config assignment: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.getUser") || output.contains("prototype[\"getUser\"]"),
        "Expected getUser method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_constructor_param_optional_decorator() {
    // Test class with optional constructor parameter metadata
    // Similar to Angular's @Optional decorator
    let source = r#"
class ConfigurableService {
    static __paramtypes__ = ["RequiredDep", "OptionalDep", "AnotherOptional"];
    static __optional__ = [1, 2];

    private required: any;
    private optional: any;
    private another: any;

    constructor(required: any, optional: any, another: any) {
        this.required = required;
        this.optional = optional || null;
        this.another = another || { default: true };
    }

    hasOptional(): boolean {
        return this.optional !== null;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // ConfigurableService should emit as function
    assert!(
        output.contains("function ConfigurableService"),
        "Expected ConfigurableService to emit as function: {}",
        output
    );

    // Static optional parameter metadata
    assert!(
        output.contains("ConfigurableService.__paramtypes__"),
        "Expected static __paramtypes__ property: {}",
        output
    );
    assert!(
        output.contains("ConfigurableService.__optional__"),
        "Expected static __optional__ property: {}",
        output
    );

    // Constructor should handle optional parameters with fallbacks
    assert!(
        output.contains("this.required = required"),
        "Expected required assignment: {}",
        output
    );
    assert!(
        output.contains("this.optional = optional || null") || output.contains("this.optional ="),
        "Expected optional assignment with fallback: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.hasOptional") || output.contains("prototype[\"hasOptional\"]"),
        "Expected hasOptional method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_constructor_param_attribute_decorator() {
    // Test class with constructor parameter attribute metadata
    // Similar to Angular's @Attribute decorator for host element attributes
    let source = r#"
class CustomElement {
    static __paramtypes__ = ["ElementRef", "string", "string"];
    static __attributes__ = { 1: "id", 2: "class" };

    private elementRef: any;
    private id: string;
    private className: string;

    constructor(elementRef: any, id: string, className: string) {
        this.elementRef = elementRef;
        this.id = id || "";
        this.className = className || "";
    }

    getId(): string {
        return this.id;
    }

    getClassName(): string {
        return this.className;
    }

    setClassName(name: string): void {
        this.className = name;
        this.elementRef.nativeElement.className = name;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // CustomElement should emit as function
    assert!(
        output.contains("function CustomElement"),
        "Expected CustomElement to emit as function: {}",
        output
    );

    // Static attribute metadata
    assert!(
        output.contains("CustomElement.__paramtypes__"),
        "Expected static __paramtypes__ property: {}",
        output
    );
    assert!(
        output.contains("CustomElement.__attributes__"),
        "Expected static __attributes__ property: {}",
        output
    );

    // Constructor should assign parameters
    assert!(
        output.contains("this.elementRef = elementRef"),
        "Expected elementRef assignment: {}",
        output
    );
    assert!(
        output.contains("this.id ="),
        "Expected id assignment: {}",
        output
    );
    assert!(
        output.contains("this.className ="),
        "Expected className assignment: {}",
        output
    );

    // Methods should be on prototype
    assert!(
        output.contains(".prototype.getId") || output.contains("prototype[\"getId\"]"),
        "Expected getId method on prototype: {}",
        output
    );
    assert!(
        output.contains(".prototype.getClassName")
            || output.contains("prototype[\"getClassName\"]"),
        "Expected getClassName method on prototype: {}",
        output
    );
    assert!(
        output.contains(".prototype.setClassName")
            || output.contains("prototype[\"setClassName\"]"),
        "Expected setClassName method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_instance_private_method() {
    // Test instance private method (#method syntax)
    let source = r#"
class Calculator {
    #validate(value: number): boolean {
        return value >= 0 && value <= 100;
    }

    calculate(a: number, b: number): number {
        if (this.#validate(a) && this.#validate(b)) {
            return a + b;
        }
        return 0;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Calculator"),
        "Expected Calculator class to emit as function: {}",
        output
    );

    // Should use WeakSet or __classPrivateFieldGet for private methods
    assert!(
        output.contains("WeakSet")
            || output.contains("__classPrivateFieldGet")
            || output.contains("_validate"),
        "Expected private method mechanism in output: {}",
        output
    );

    // Public method should be on prototype
    assert!(
        output.contains(".prototype.calculate") || output.contains("prototype[\"calculate\"]"),
        "Expected calculate method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_static_private_method_basic() {
    // Test static private method
    let source = r#"
class IdGenerator {
    static #counter: number = 0;

    static #increment(): number {
        return ++IdGenerator.#counter;
    }

    static generate(): string {
        return "id_" + IdGenerator.#increment();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function IdGenerator"),
        "Expected IdGenerator class to emit as function: {}",
        output
    );

    // Static public method should be on the class
    assert!(
        output.contains("IdGenerator.generate"),
        "Expected static generate method on class: {}",
        output
    );
}

#[test]
fn test_class_es5_private_method_calling_private_method() {
    // Test private method calling another private method
    let source = r#"
class DataProcessor {
    #normalize(value: string): string {
        return value.trim().toLowerCase();
    }

    #validate(value: string): boolean {
        const normalized = this.#normalize(value);
        return normalized.length > 0;
    }

    process(input: string): string | null {
        if (this.#validate(input)) {
            return this.#normalize(input);
        }
        return null;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function DataProcessor"),
        "Expected DataProcessor class to emit as function: {}",
        output
    );

    // Public method should be on prototype
    assert!(
        output.contains(".prototype.process") || output.contains("prototype[\"process\"]"),
        "Expected process method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_private_async_method() {
    // Test private async method
    let source = r#"
class ApiClient {
    async #fetchData(url: string): Promise<any> {
        const response = await fetch(url);
        return response.json();
    }

    async getData(endpoint: string): Promise<any> {
        return this.#fetchData("https://api.example.com" + endpoint);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function ApiClient"),
        "Expected ApiClient class to emit as function: {}",
        output
    );

    // Should use __awaiter for async method
    assert!(
        output.contains("__awaiter"),
        "Expected __awaiter for async methods: {}",
        output
    );

    // Public async method should be on prototype
    assert!(
        output.contains(".prototype.getData") || output.contains("prototype[\"getData\"]"),
        "Expected getData method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_private_generator_method() {
    // Test private generator method
    let source = r#"
class NumberSequence {
    *#generateRange(start: number, end: number): Generator<number> {
        for (let i = start; i <= end; i++) {
            yield i;
        }
    }

    getRange(start: number, end: number): number[] {
        return [...this.#generateRange(start, end)];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function NumberSequence"),
        "Expected NumberSequence class to emit as function: {}",
        output
    );

    // Public method should be on prototype
    assert!(
        output.contains(".prototype.getRange") || output.contains("prototype[\"getRange\"]"),
        "Expected getRange method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_private_method_with_private_field() {
    // Test private method accessing private fields
    let source = r#"
class BankAccount {
    #balance: number = 0;

    #updateBalance(amount: number): void {
        this.#balance += amount;
    }

    #getBalance(): number {
        return this.#balance;
    }

    deposit(amount: number): void {
        if (amount > 0) {
            this.#updateBalance(amount);
        }
    }

    getStatement(): string {
        return "Balance: $" + this.#getBalance();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function BankAccount"),
        "Expected BankAccount class to emit as function: {}",
        output
    );

    // Should have WeakMap for private fields
    assert!(
        output.contains("WeakMap")
            || output.contains("__classPrivateFieldGet")
            || output.contains("__classPrivateFieldSet"),
        "Expected private field mechanism: {}",
        output
    );

    // Public methods should be on prototype
    assert!(
        output.contains(".prototype.deposit") || output.contains("prototype[\"deposit\"]"),
        "Expected deposit method on prototype: {}",
        output
    );
    assert!(
        output.contains(".prototype.getStatement")
            || output.contains("prototype[\"getStatement\"]"),
        "Expected getStatement method on prototype: {}",
        output
    );
}

#[test]
fn test_class_es5_super_with_conditional_field_init() {
    // Test super() call with conditional field initializers
    // Field initializers that depend on constructor parameters
    let source = r#"
class Base {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
}

class Derived extends Base {
    isAdmin: boolean;
    permissions: string[] = [];

    constructor(name: string, isAdmin: boolean) {
        super(name);
        this.isAdmin = isAdmin;
        if (isAdmin) {
            this.permissions = ["read", "write", "delete"];
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    // Get the Derived class (second statement)
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected Derived class");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Derived should emit as function
    assert!(
        output.contains("function Derived"),
        "Expected Derived to emit as function: {}",
        output
    );

    // Should call parent constructor
    assert!(
        output.contains("_super.call(this") || output.contains("Base.call(this"),
        "Expected super() call: {}",
        output
    );

    // Field initializers should come after super()
    assert!(
        output.contains("this.permissions = []") || output.contains("this.permissions ="),
        "Expected permissions field initialization: {}",
        output
    );
}

#[test]
fn test_class_es5_super_with_arrow_field_init() {
    // Test super() with arrow function field initializers that capture 'this'
    let source = r#"
class EventEmitter {
    handlers: any[] = [];
    emit(event: string): void {}
}

class Button extends EventEmitter {
    label: string;
    onClick: () => void = () => {
        this.emit("click");
    };

    constructor(label: string) {
        super();
        this.label = label;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    // Get the Button class (second statement)
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected Button class");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Button should emit as function
    assert!(
        output.contains("function Button"),
        "Expected Button to emit as function: {}",
        output
    );

    // Should have super call
    assert!(
        output.contains("_super.call(this") || output.contains("EventEmitter.call(this"),
        "Expected super() call: {}",
        output
    );

    // Arrow function should be assigned to onClick
    assert!(
        output.contains("this.onClick"),
        "Expected onClick field: {}",
        output
    );

    // Arrow function may need _this capture for proper 'this' binding
    assert!(
        output.contains("_this") || output.contains("this.emit") || output.contains("function"),
        "Expected arrow function handling: {}",
        output
    );
}

#[test]
fn test_class_es5_super_with_computed_field_init() {
    // Test super() with computed/dynamic field initializers
    let source = r#"
class Config {
    settings: Record<string, any> = {};
}

class AppConfig extends Config {
    environment: string;
    apiUrl: string = "https://api.example.com";
    timeout: number = 5000;
    retries: number = 3;

    constructor(environment: string) {
        super();
        this.environment = environment;
        if (environment === "production") {
            this.timeout = 10000;
            this.retries = 5;
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    // Get the AppConfig class (second statement)
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected AppConfig class");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // AppConfig should emit as function
    assert!(
        output.contains("function AppConfig"),
        "Expected AppConfig to emit as function: {}",
        output
    );

    // Should call parent constructor
    assert!(
        output.contains("_super.call(this") || output.contains("Config.call(this"),
        "Expected super() call: {}",
        output
    );

    // Field initializers should be present
    assert!(
        output.contains("this.apiUrl ="),
        "Expected apiUrl field initialization: {}",
        output
    );
    assert!(
        output.contains("this.timeout = 5000") || output.contains("this.timeout ="),
        "Expected timeout field initialization: {}",
        output
    );
    assert!(
        output.contains("this.retries = 3") || output.contains("this.retries ="),
        "Expected retries field initialization: {}",
        output
    );
}

#[test]
fn test_class_es5_super_with_method_call_in_field_init() {
    // Test super() with field initializers that call methods
    let source = r#"
class Logger {
    log(msg: string): void {}
}

class Service extends Logger {
    id: string = this.generateId();
    createdAt: Date = new Date();
    status: string = "initialized";

    constructor() {
        super();
        this.log("Service created with id: " + this.id);
    }

    private generateId(): string {
        return "svc_" + Math.random().toString(36).substr(2, 9);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    // Get the Service class (second statement)
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected Service class");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Service should emit as function
    assert!(
        output.contains("function Service"),
        "Expected Service to emit as function: {}",
        output
    );

    // Should call parent constructor
    assert!(
        output.contains("_super.call(this") || output.contains("Logger.call(this"),
        "Expected super() call: {}",
        output
    );

    // Field with method call should be handled
    assert!(
        output.contains("this.id =") || output.contains("generateId"),
        "Expected id field with method call: {}",
        output
    );

    // Other field initializers
    assert!(
        output.contains("this.createdAt =") || output.contains("new Date"),
        "Expected createdAt field initialization: {}",
        output
    );
    assert!(
        output.contains("this.status ="),
        "Expected status field initialization: {}",
        output
    );

    // Private method should be on prototype
    assert!(
        output.contains("generateId"),
        "Expected generateId method: {}",
        output
    );
}

#[test]
fn test_class_es5_super_with_nested_inheritance_field_init() {
    // Test super() with deep inheritance chain and field initializers at each level
    let source = r#"
class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
}

class Mammal extends Animal {
    warmBlooded: boolean = true;
    legs: number = 4;

    constructor(name: string) {
        super(name);
    }
}

class Dog extends Mammal {
    breed: string;
    canBark: boolean = true;
    tricks: string[] = [];

    constructor(name: string, breed: string) {
        super(name);
        this.breed = breed;
    }

    bark(): void {
        console.log(this.name + " says woof!");
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    // Get the Dog class (third statement)
    let class_idx = source_file
        .statements
        .nodes
        .get(2)
        .expect("expected Dog class");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Dog should emit as function
    assert!(
        output.contains("function Dog"),
        "Expected Dog to emit as function: {}",
        output
    );

    // Should call parent constructor
    assert!(
        output.contains("_super.call(this") || output.contains("Mammal.call(this"),
        "Expected super() call: {}",
        output
    );

    // Dog's field initializers
    assert!(
        output.contains("this.canBark = true") || output.contains("this.canBark ="),
        "Expected canBark field initialization: {}",
        output
    );
    assert!(
        output.contains("this.tricks = []") || output.contains("this.tricks ="),
        "Expected tricks field initialization: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains(".prototype.bark") || output.contains("prototype[\"bark\"]"),
        "Expected bark method on prototype: {}",
        output
    );
}

// ============================================================================
// Class Expression Tests (using full ES5 emit pipeline)
// ============================================================================

#[test]
fn test_class_es5_class_expression_anonymous() {
    // Test anonymous class expression assigned to variable
    let source = r#"
const MyClass = class {
    value: number = 42;

    getValue(): number {
        return this.value;
    }
};
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should have var declaration
    assert!(
        output.contains("var MyClass"),
        "Expected var MyClass declaration: {}",
        output
    );

    // Class expression should emit as IIFE returning function
    assert!(
        output.contains("function") && output.contains("return"),
        "Expected class expression to emit as IIFE pattern: {}",
        output
    );

    // Field should be initialized
    assert!(
        output.contains("this.value = 42") || output.contains("this.value ="),
        "Expected value field initialization: {}",
        output
    );
}

#[test]
fn test_class_es5_class_expression_named() {
    // Test named class expression (const Foo = class Bar { ... })
    let source = r#"
const Factory = class ServiceFactory {
    static instance: any = null;

    name: string = "factory";

    create(): any {
        return {};
    }

    static getInstance(): any {
        if (!ServiceFactory.instance) {
            ServiceFactory.instance = new ServiceFactory();
        }
        return ServiceFactory.instance;
    }
};
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should have var declaration for Factory
    assert!(
        output.contains("var Factory"),
        "Expected var Factory declaration: {}",
        output
    );

    // Named class expression should use its internal name (ServiceFactory)
    assert!(
        output.contains("ServiceFactory") || output.contains("function"),
        "Expected ServiceFactory class name in output: {}",
        output
    );
}

#[test]
fn test_class_es5_class_expression_in_return() {
    // Test class expression returned from function
    let source = r#"
function createClass() {
    return class {
        value: number = 0;

        increment(): void {
            this.value++;
        }
    };
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should have createClass function
    assert!(
        output.contains("function createClass"),
        "Expected createClass function: {}",
        output
    );

    // Should return something (class expression transformed)
    assert!(
        output.contains("return"),
        "Expected return statement: {}",
        output
    );

    // Class should be transformed with prototype methods
    assert!(
        output.contains("prototype") || output.contains("function"),
        "Expected class expression transformation: {}",
        output
    );
}

#[test]
fn test_class_es5_class_expression_extends() {
    // Test class expression that extends another class
    let source = r#"
class Base {
    baseValue: number = 1;
}

const Derived = class extends Base {
    derivedValue: number = 2;

    getBoth(): number {
        return this.baseValue + this.derivedValue;
    }
};
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Base class should be transformed
    assert!(
        output.contains("function Base") || output.contains("var Base"),
        "Expected Base class transformation: {}",
        output
    );

    // Derived should extend Base
    assert!(
        output.contains("var Derived"),
        "Expected var Derived declaration: {}",
        output
    );

    // Should have __extends helper or inheritance pattern
    assert!(
        output.contains("__extends") || output.contains("prototype") || output.contains("Base"),
        "Expected inheritance pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_class_expression_with_static() {
    // Test class expression with static members
    let source = r#"
const Counter = class {
    static count: number = 0;
    static instances: any[] = [];

    id: number;

    constructor() {
        Counter.count++;
        this.id = Counter.count;
        Counter.instances.push(this);
    }

    static getCount(): number {
        return Counter.count;
    }

    static reset(): void {
        Counter.count = 0;
        Counter.instances = [];
    }
};
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should have Counter declaration
    assert!(
        output.contains("var Counter") || output.contains("Counter"),
        "Expected Counter declaration: {}",
        output
    );

    // Static properties should be on the constructor function
    assert!(
        output.contains(".count") || output.contains("count"),
        "Expected count static property: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("getCount") || output.contains("reset"),
        "Expected static methods: {}",
        output
    );
}

#[test]
fn test_class_es5_accessor_basic() {
    // Test basic accessor keyword (ES2022)
    let source = r#"
class Person {
    accessor name: string = "default";
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class to function
    assert!(
        output.contains("function Person") || output.contains("var Person"),
        "Expected Person class transformation: {}",
        output
    );

    // Accessor should generate getter/setter pattern
    // Either via Object.defineProperty or direct get/set
    assert!(
        output.contains("defineProperty") || output.contains("get") || output.contains("name"),
        "Expected accessor transformation: {}",
        output
    );
}

#[test]
fn test_class_es5_accessor_with_initializer() {
    // Test accessor with non-trivial initializer
    let source = r#"
class Counter {
    accessor count: number = 0;
    accessor label: string = "Counter: ";

    increment(): void {
        this.count++;
    }

    display(): string {
        return this.label + this.count;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function Counter") || output.contains("var Counter"),
        "Expected Counter class transformation: {}",
        output
    );

    // Methods should be on prototype
    assert!(
        output.contains("increment") && output.contains("display"),
        "Expected methods: {}",
        output
    );

    // Accessors should be handled
    assert!(
        output.contains("count") && output.contains("label"),
        "Expected accessor properties: {}",
        output
    );
}

#[test]
fn test_class_es5_accessor_static() {
    // Test static accessor keyword
    let source = r#"
class Config {
    static accessor debug: boolean = false;
    static accessor version: string = "1.0.0";

    static enableDebug(): void {
        Config.debug = true;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function Config") || output.contains("var Config"),
        "Expected Config class transformation: {}",
        output
    );

    // Static accessors should reference the constructor
    assert!(
        output.contains("Config") && output.contains("debug"),
        "Expected static accessor reference: {}",
        output
    );

    // Static method should be present
    assert!(
        output.contains("enableDebug"),
        "Expected enableDebug method: {}",
        output
    );
}

#[test]
fn test_class_es5_accessor_inheritance() {
    // Test accessor with inheritance
    let source = r#"
class Animal {
    accessor name: string = "unnamed";

    speak(): string {
        return this.name + " makes a sound";
    }
}

class Dog extends Animal {
    accessor breed: string = "unknown";

    speak(): string {
        return this.name + " barks";
    }

    describe(): string {
        return this.name + " is a " + this.breed;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be transformed
    assert!(
        output.contains("Animal") && output.contains("Dog"),
        "Expected both class transformations: {}",
        output
    );

    // Inheritance pattern should be present
    assert!(
        output.contains("__extends") || output.contains("prototype"),
        "Expected inheritance pattern: {}",
        output
    );

    // Accessors from both classes
    assert!(
        output.contains("name") && output.contains("breed"),
        "Expected accessor properties: {}",
        output
    );
}

#[test]
fn test_class_es5_accessor_private_backing() {
    // Test that accessor generates private backing field pattern
    let source = r#"
class SecureValue {
    accessor value: number = 0;

    increment(): void {
        this.value = this.value + 1;
    }

    getValue(): number {
        return this.value;
    }

    setValue(v: number): void {
        this.value = v;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function SecureValue") || output.contains("var SecureValue"),
        "Expected SecureValue class transformation: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("increment") && output.contains("getValue") && output.contains("setValue"),
        "Expected methods: {}",
        output
    );

    // Value accessor should be present
    assert!(
        output.contains("value"),
        "Expected value accessor: {}",
        output
    );
}

#[test]
fn test_class_es5_method_overloads_basic() {
    // Test basic method overloads with different parameter types
    let source = r#"
class Calculator {
    add(a: number, b: number): number;
    add(a: string, b: string): string;
    add(a: any, b: any): any {
        return a + b;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class to function
    assert!(
        output.contains("function Calculator") || output.contains("var Calculator"),
        "Expected Calculator class transformation: {}",
        output
    );

    // Only implementation should be emitted, not overload signatures
    assert!(output.contains("add"), "Expected add method: {}", output);

    // Method should be on prototype
    assert!(
        output.contains("prototype") || output.contains("Calculator"),
        "Expected prototype assignment: {}",
        output
    );
}

#[test]
fn test_class_es5_method_overloads_optional_params() {
    // Test method overloads with optional parameters
    let source = r#"
class Formatter {
    format(value: number): string;
    format(value: number, decimals: number): string;
    format(value: number, decimals: number, prefix: string): string;
    format(value: number, decimals?: number, prefix?: string): string {
        let result = value.toFixed(decimals || 0);
        return prefix ? prefix + result : result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function Formatter") || output.contains("var Formatter"),
        "Expected Formatter class transformation: {}",
        output
    );

    // Format method should be present
    assert!(
        output.contains("format"),
        "Expected format method: {}",
        output
    );

    // Implementation should have the method body
    assert!(
        output.contains("toFixed") || output.contains("result"),
        "Expected method implementation: {}",
        output
    );
}

#[test]
fn test_class_es5_method_overloads_generic() {
    // Test method overloads with generic types
    let source = r#"
class Container<T> {
    getValue(): T;
    getValue(defaultValue: T): T;
    getValue(defaultValue?: T): T {
        return this.value !== undefined ? this.value : defaultValue!;
    }

    private value: T | undefined;

    setValue(value: T): void {
        this.value = value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function Container") || output.contains("var Container"),
        "Expected Container class transformation: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("getValue") && output.contains("setValue"),
        "Expected getValue and setValue methods: {}",
        output
    );
}

#[test]
fn test_class_es5_method_overloads_static() {
    // Test static method overloads
    let source = r#"
class Factory {
    static create(): Factory;
    static create(config: object): Factory;
    static create(config?: object): Factory {
        const instance = new Factory();
        if (config) {
            instance.configure(config);
        }
        return instance;
    }

    private config: object = {};

    configure(config: object): void {
        this.config = config;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function Factory") || output.contains("var Factory"),
        "Expected Factory class transformation: {}",
        output
    );

    // Static method should be on constructor
    assert!(
        output.contains("create"),
        "Expected static create method: {}",
        output
    );

    // Instance method should be present
    assert!(
        output.contains("configure"),
        "Expected configure method: {}",
        output
    );
}

#[test]
fn test_class_es5_method_overloads_inheritance() {
    // Test method overloads with inheritance
    let source = r#"
class BaseService {
    fetch(url: string): Promise<any>;
    fetch(url: string, options: object): Promise<any>;
    fetch(url: string, options?: object): Promise<any> {
        return Promise.resolve({ url, options });
    }
}

class ExtendedService extends BaseService {
    fetch(url: string): Promise<any>;
    fetch(url: string, options: object): Promise<any>;
    fetch(url: string, options: object, timeout: number): Promise<any>;
    fetch(url: string, options?: object, timeout?: number): Promise<any> {
        return super.fetch(url, options || {});
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be transformed
    assert!(
        output.contains("BaseService") && output.contains("ExtendedService"),
        "Expected both class transformations: {}",
        output
    );

    // Inheritance pattern should be present
    assert!(
        output.contains("__extends") || output.contains("prototype"),
        "Expected inheritance pattern: {}",
        output
    );

    // Fetch method should be present
    assert!(
        output.contains("fetch"),
        "Expected fetch method: {}",
        output
    );
}

#[test]
fn test_class_es5_constructor_overloads_basic() {
    // Test basic constructor overloads
    let source = r#"
class Point {
    x: number;
    y: number;

    constructor();
    constructor(x: number);
    constructor(x: number, y: number);
    constructor(x?: number, y?: number) {
        this.x = x || 0;
        this.y = y || 0;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class to function
    assert!(
        output.contains("function Point") || output.contains("var Point"),
        "Expected Point class transformation: {}",
        output
    );

    // Constructor implementation should be present
    assert!(
        output.contains("this.x") && output.contains("this.y"),
        "Expected property assignments: {}",
        output
    );
}

#[test]
fn test_class_es5_constructor_overloads_with_types() {
    // Test constructor overloads with different parameter types
    let source = r#"
class Data {
    value: any;

    constructor(value: string);
    constructor(value: number);
    constructor(value: object);
    constructor(value: any) {
        this.value = value;
    }

    getValue(): any {
        return this.value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function Data") || output.contains("var Data"),
        "Expected Data class transformation: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("getValue"),
        "Expected getValue method: {}",
        output
    );

    // Constructor body should be present
    assert!(
        output.contains("this.value"),
        "Expected value assignment: {}",
        output
    );
}

#[test]
fn test_class_es5_constructor_overloads_inheritance() {
    // Test constructor overloads with inheritance
    let source = r#"
class Animal {
    name: string;

    constructor();
    constructor(name: string);
    constructor(name?: string) {
        this.name = name || "unknown";
    }
}

class Dog extends Animal {
    breed: string;

    constructor();
    constructor(name: string);
    constructor(name: string, breed: string);
    constructor(name?: string, breed?: string) {
        super(name);
        this.breed = breed || "mixed";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be transformed
    assert!(
        output.contains("Animal") && output.contains("Dog"),
        "Expected both class transformations: {}",
        output
    );

    // Inheritance should be present
    assert!(
        output.contains("__extends") || output.contains("prototype"),
        "Expected inheritance pattern: {}",
        output
    );

    // Properties should be assigned
    assert!(
        output.contains("name") && output.contains("breed"),
        "Expected property assignments: {}",
        output
    );
}

#[test]
fn test_class_es5_constructor_overloads_with_defaults() {
    // Test constructor overloads with default values
    let source = r#"
class Config {
    host: string;
    port: number;
    secure: boolean;

    constructor();
    constructor(host: string);
    constructor(host: string, port: number);
    constructor(host: string, port: number, secure: boolean);
    constructor(host: string = "localhost", port: number = 8080, secure: boolean = false) {
        this.host = host;
        this.port = port;
        this.secure = secure;
    }

    getUrl(): string {
        const protocol = this.secure ? "https" : "http";
        return protocol + "://" + this.host + ":" + this.port;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function Config") || output.contains("var Config"),
        "Expected Config class transformation: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("getUrl"),
        "Expected getUrl method: {}",
        output
    );

    // All properties should be assigned
    assert!(
        output.contains("host") && output.contains("port") && output.contains("secure"),
        "Expected property assignments: {}",
        output
    );
}

#[test]
fn test_class_es5_constructor_overloads_generic() {
    // Test constructor overloads with generic types
    let source = r#"
class Container<T> {
    items: T[];

    constructor();
    constructor(items: T[]);
    constructor(items?: T[]) {
        this.items = items || [];
    }

    add(item: T): void {
        this.items.push(item);
    }

    get(index: number): T {
        return this.items[index];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function Container") || output.contains("var Container"),
        "Expected Container class transformation: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("add") && output.contains("get"),
        "Expected add and get methods: {}",
        output
    );

    // Items property should be present
    assert!(
        output.contains("items"),
        "Expected items property: {}",
        output
    );
}

#[test]
fn test_class_es5_parameter_property_public() {
    // Test public parameter property
    let source = r#"
class Person {
    constructor(public name: string, public age: number) {}

    greet(): string {
        return "Hello, " + this.name;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class to function
    assert!(
        output.contains("function Person") || output.contains("var Person"),
        "Expected Person class transformation: {}",
        output
    );

    // Parameter properties should be assigned to this
    assert!(
        output.contains("this.name") && output.contains("this.age"),
        "Expected parameter property assignments: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("greet"),
        "Expected greet method: {}",
        output
    );
}

#[test]
fn test_class_es5_parameter_property_private() {
    // Test private parameter property
    let source = r#"
class BankAccount {
    constructor(private balance: number, private accountId: string) {}

    getBalance(): number {
        return this.balance;
    }

    deposit(amount: number): void {
        this.balance += amount;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function BankAccount") || output.contains("var BankAccount"),
        "Expected BankAccount class transformation: {}",
        output
    );

    // Private parameter properties should still be assigned
    assert!(
        output.contains("this.balance") || output.contains("balance"),
        "Expected balance property: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("getBalance") && output.contains("deposit"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_parameter_property_protected() {
    // Test protected parameter property with inheritance
    let source = r#"
class Vehicle {
    constructor(protected speed: number, protected fuel: number) {}

    accelerate(): void {
        this.speed += 10;
    }
}

class Car extends Vehicle {
    constructor(speed: number, fuel: number, private brand: string) {
        super(speed, fuel);
    }

    getInfo(): string {
        return this.brand + " at " + this.speed + " mph";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be transformed
    assert!(
        output.contains("Vehicle") && output.contains("Car"),
        "Expected both class transformations: {}",
        output
    );

    // Inheritance should be present
    assert!(
        output.contains("__extends") || output.contains("prototype"),
        "Expected inheritance pattern: {}",
        output
    );

    // Protected properties should be assigned
    assert!(
        output.contains("speed") && output.contains("fuel"),
        "Expected protected properties: {}",
        output
    );
}

#[test]
fn test_class_es5_parameter_property_readonly() {
    // Test readonly parameter property
    let source = r#"
class Config {
    constructor(
        readonly host: string,
        readonly port: number,
        readonly secure: boolean = false
    ) {}

    getUrl(): string {
        const protocol = this.secure ? "https" : "http";
        return protocol + "://" + this.host + ":" + this.port;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function Config") || output.contains("var Config"),
        "Expected Config class transformation: {}",
        output
    );

    // Readonly properties should be assigned
    assert!(
        output.contains("this.host") || output.contains("host"),
        "Expected host property: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("getUrl"),
        "Expected getUrl method: {}",
        output
    );
}

#[test]
fn test_class_es5_parameter_property_mixed() {
    // Test mixed parameter properties and regular parameters
    let source = r#"
class User {
    email: string;

    constructor(
        public id: number,
        private password: string,
        readonly createdAt: Date,
        name: string
    ) {
        this.email = name + "@example.com";
    }

    validatePassword(input: string): boolean {
        return this.password === input;
    }

    getId(): number {
        return this.id;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Should transform class
    assert!(
        output.contains("function User") || output.contains("var User"),
        "Expected User class transformation: {}",
        output
    );

    // Parameter properties should be assigned
    assert!(
        output.contains("id") && output.contains("password"),
        "Expected parameter properties: {}",
        output
    );

    // Regular property from constructor body should be present
    assert!(
        output.contains("email"),
        "Expected email property: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("validatePassword") && output.contains("getId"),
        "Expected methods: {}",
        output
    );
}

// =============================================================================
// Readonly Property Tests
// =============================================================================

#[test]
fn test_class_es5_readonly_property_basic() {
    // Test class with readonly property
    let source = r#"
class Config {
    readonly version: string = "1.0.0";
    readonly name: string;

    constructor(name: string) {
        this.name = name;
    }

    getVersion(): string {
        return this.version;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Config"),
        "Expected Config to emit as function: {}",
        output
    );

    // Properties should be assigned (readonly is erased)
    assert!(
        output.contains("this.version") || output.contains("version"),
        "Expected version property: {}",
        output
    );
    assert!(
        output.contains("this.name") || output.contains("name"),
        "Expected name property: {}",
        output
    );

    // readonly keyword should NOT appear in output
    assert!(
        !output.contains("readonly"),
        "readonly should be erased: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("getVersion"),
        "Expected getVersion method: {}",
        output
    );
}

#[test]
fn test_class_es5_readonly_parameter_property() {
    // Test readonly parameter property in constructor
    let source = r#"
class Entity {
    constructor(
        readonly id: string,
        readonly createdAt: Date = new Date()
    ) {}

    getId(): string {
        return this.id;
    }

    getCreatedAt(): Date {
        return this.createdAt;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Entity"),
        "Expected Entity to emit as function: {}",
        output
    );

    // Parameter properties should be assigned
    assert!(
        output.contains("this.id") || output.contains("id"),
        "Expected id property: {}",
        output
    );
    assert!(
        output.contains("this.createdAt") || output.contains("createdAt"),
        "Expected createdAt property: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("getId"),
        "Expected getId method: {}",
        output
    );
    assert!(
        output.contains("getCreatedAt"),
        "Expected getCreatedAt method: {}",
        output
    );
}

#[test]
fn test_class_es5_readonly_static_property() {
    // Test readonly static property
    let source = r#"
class Constants {
    static readonly PI: number = 3.14159;
    static readonly E: number = 2.71828;
    static readonly GOLDEN_RATIO: number = 1.61803;

    static getPI(): number {
        return Constants.PI;
    }

    static getE(): number {
        return Constants.E;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Constants"),
        "Expected Constants to emit as function: {}",
        output
    );

    // Static properties should be on constructor
    assert!(
        output.contains("Constants.PI") || output.contains("PI"),
        "Expected PI static property: {}",
        output
    );
    assert!(
        output.contains("Constants.E") || output.contains("E"),
        "Expected E static property: {}",
        output
    );
    assert!(
        output.contains("GOLDEN_RATIO"),
        "Expected GOLDEN_RATIO static property: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("getPI"),
        "Expected getPI static method: {}",
        output
    );
    assert!(
        output.contains("getE"),
        "Expected getE static method: {}",
        output
    );
}

#[test]
fn test_class_es5_readonly_with_inheritance() {
    // Test readonly properties in inheritance
    let source = r#"
class Base {
    readonly type: string = "base";
}

class Derived extends Base {
    readonly subtype: string;

    constructor(subtype: string) {
        super();
        this.subtype = subtype;
    }

    getFullType(): string {
        return this.type + ":" + this.subtype;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    // Get Derived class (second statement)
    let class_idx = *source_file
        .statements
        .nodes
        .get(1)
        .expect("expected Derived class");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Derived"),
        "Expected Derived to emit as function: {}",
        output
    );

    // Should have inheritance setup
    assert!(
        output.contains("_super") || output.contains("Base") || output.contains("__extends"),
        "Expected inheritance handling: {}",
        output
    );

    // subtype property should be assigned
    assert!(
        output.contains("this.subtype") || output.contains("subtype"),
        "Expected subtype property: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("getFullType"),
        "Expected getFullType method: {}",
        output
    );
}

#[test]
fn test_class_es5_readonly_array_property() {
    // Test readonly array property
    let source = r#"
class ImmutableList {
    readonly items: readonly string[];
    readonly length: number;

    constructor(items: string[]) {
        this.items = items;
        this.length = items.length;
    }

    get(index: number): string | undefined {
        return this.items[index];
    }

    contains(item: string): boolean {
        return this.items.includes(item);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function ImmutableList"),
        "Expected ImmutableList to emit as function: {}",
        output
    );

    // Properties should be assigned
    assert!(
        output.contains("this.items") || output.contains("items"),
        "Expected items property: {}",
        output
    );
    assert!(
        output.contains("this.length") || output.contains("length"),
        "Expected length property: {}",
        output
    );

    // Methods should be present
    assert!(output.contains("get"), "Expected get method: {}", output);
    assert!(
        output.contains("contains"),
        "Expected contains method: {}",
        output
    );
}

#[test]
fn test_class_es5_readonly_mixed_properties() {
    // Test class with mix of readonly and mutable properties
    let source = r#"
class User {
    readonly id: string;
    readonly createdAt: Date;
    name: string;
    email: string;
    lastLogin: Date | null = null;

    constructor(id: string, name: string, email: string) {
        this.id = id;
        this.createdAt = new Date();
        this.name = name;
        this.email = email;
    }

    updateName(name: string): void {
        this.name = name;
    }

    updateEmail(email: string): void {
        this.email = email;
    }

    recordLogin(): void {
        this.lastLogin = new Date();
    }

    getId(): string {
        return this.id;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit as function
    assert!(
        output.contains("function User"),
        "Expected User to emit as function: {}",
        output
    );

    // All properties should be assigned
    assert!(
        output.contains("this.id") || output.contains("id"),
        "Expected id property: {}",
        output
    );
    assert!(
        output.contains("this.name") || output.contains("name"),
        "Expected name property: {}",
        output
    );
    assert!(
        output.contains("this.email") || output.contains("email"),
        "Expected email property: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("updateName"),
        "Expected updateName method: {}",
        output
    );
    assert!(
        output.contains("updateEmail"),
        "Expected updateEmail method: {}",
        output
    );
    assert!(
        output.contains("recordLogin"),
        "Expected recordLogin method: {}",
        output
    );
    assert!(
        output.contains("getId"),
        "Expected getId method: {}",
        output
    );
}

// =============================================================================
// Ambient/Declare Class Tests
// =============================================================================

#[test]
fn test_class_es5_declare_class_basic() {
    // declare class should emit nothing - it's a type declaration only
    let source = r#"
declare class ExternalAPI {
    version: string;
    init(): void;
    shutdown(): void;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Declare class should produce no output or empty output
    let trimmed = output.trim();
    assert!(
        trimmed.is_empty() || !trimmed.contains("function ExternalAPI"),
        "declare class should not emit a function constructor: {}",
        output
    );
}

#[test]
fn test_class_es5_declare_class_with_methods() {
    // declare class with method signatures should emit nothing
    let source = r#"
declare class Database {
    connect(url: string): Promise<void>;
    query<T>(sql: string, params?: any[]): Promise<T[]>;
    disconnect(): Promise<void>;
    readonly isConnected: boolean;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Declare class with methods should produce no output
    let trimmed = output.trim();
    assert!(
        trimmed.is_empty() || !trimmed.contains("function Database"),
        "declare class should not emit a function constructor: {}",
        output
    );
    assert!(
        !trimmed.contains("prototype"),
        "declare class should not emit prototype assignments: {}",
        output
    );
}

#[test]
fn test_class_es5_declare_class_with_static() {
    // declare class with static members should emit nothing
    let source = r#"
declare class MathUtils {
    static PI: number;
    static E: number;
    static sin(x: number): number;
    static cos(x: number): number;
    static random(): number;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Declare class with static members should produce no output
    let trimmed = output.trim();
    assert!(
        trimmed.is_empty() || !trimmed.contains("function MathUtils"),
        "declare class should not emit a function constructor: {}",
        output
    );
    assert!(
        !trimmed.contains("MathUtils.PI"),
        "declare class should not emit static property assignments: {}",
        output
    );
}

#[test]
fn test_class_es5_declare_class_with_extends() {
    // declare class with extends should emit nothing
    let source = r#"
declare class BaseEvent {
    type: string;
    timestamp: number;
}

declare class MouseEvent extends BaseEvent {
    clientX: number;
    clientY: number;
    button: number;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Check second class (MouseEvent extends BaseEvent)
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected second class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Declare class with extends should produce no output
    let trimmed = output.trim();
    assert!(
        trimmed.is_empty() || !trimmed.contains("function MouseEvent"),
        "declare class should not emit a function constructor: {}",
        output
    );
    assert!(
        !trimmed.contains("__extends"),
        "declare class should not emit __extends helper: {}",
        output
    );
}

#[test]
fn test_class_es5_declare_class_with_implements() {
    // declare class with implements should emit nothing
    let source = r#"
interface Serializable {
    serialize(): string;
    deserialize(data: string): void;
}

declare class DataModel implements Serializable {
    id: string;
    serialize(): string;
    deserialize(data: string): void;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the declare class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Declare class with implements should produce no output
    let trimmed = output.trim();
    assert!(
        trimmed.is_empty() || !trimmed.contains("function DataModel"),
        "declare class should not emit a function constructor: {}",
        output
    );
}

#[test]
fn test_class_es5_declare_class_with_constructor() {
    // declare class with constructor signature should emit nothing
    let source = r#"
declare class Config {
    readonly host: string;
    readonly port: number;
    readonly secure: boolean;

    constructor(host: string, port: number, secure?: boolean);

    getUrl(): string;
    clone(): Config;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Declare class with constructor should produce no output
    let trimmed = output.trim();
    assert!(
        trimmed.is_empty() || !trimmed.contains("function Config"),
        "declare class should not emit a function constructor: {}",
        output
    );
    assert!(
        !trimmed.contains("this.host"),
        "declare class should not emit property assignments: {}",
        output
    );
}

// =============================================================================
// Class Field Decorator Tests
// =============================================================================

#[test]
fn test_class_es5_field_decorator_basic() {
    // Basic field decorator
    let source = r#"
function observable(target: any, key: string) {}

class Model {
    @observable
    name: string = "";
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit as function
    assert!(
        output.contains("function Model"),
        "Expected Model class: {}",
        output
    );

    // Field should be initialized in constructor
    assert!(
        output.contains("this.name") || output.contains("name"),
        "Expected name field initialization: {}",
        output
    );
}

#[test]
fn test_class_es5_field_decorator_with_initializer() {
    // Field decorator with initializer
    let source = r#"
function defaultValue(value: any) {
    return function(target: any, key: string) {};
}

class Config {
    @defaultValue(42)
    count: number = 0;

    @defaultValue("default")
    label: string = "initial";
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function Config") || output.contains("Config"),
        "Expected Config class: {}",
        output
    );

    // Field initializers should be present
    assert!(
        output.contains("count") && output.contains("label"),
        "Expected field names: {}",
        output
    );
}

#[test]
fn test_class_es5_field_decorator_static() {
    // Static field decorator
    let source = r#"
function logged(target: any, key: string) {}

class Service {
    @logged
    static instance: Service | null = null;

    @logged
    static version: string = "1.0.0";
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function Service") || output.contains("Service"),
        "Expected Service class: {}",
        output
    );

    // Static fields should be assigned on constructor
    assert!(
        output.contains("Service.instance") || output.contains("instance"),
        "Expected static instance field: {}",
        output
    );
    assert!(
        output.contains("Service.version") || output.contains("version"),
        "Expected static version field: {}",
        output
    );
}

#[test]
fn test_class_es5_field_decorator_multiple() {
    // Multiple decorators on a single field
    let source = r#"
function required(target: any, key: string) {}
function validate(target: any, key: string) {}
function format(target: any, key: string) {}

class Form {
    @required
    @validate
    @format
    email: string = "";
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Fourth statement is the class (after 3 function declarations)
    let class_idx = source_file
        .statements
        .nodes
        .get(3)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function Form") || output.contains("Form"),
        "Expected Form class: {}",
        output
    );

    // Email field should be present
    assert!(output.contains("email"), "Expected email field: {}", output);
}

#[test]
fn test_class_es5_field_decorator_in_derived_class() {
    // Field decorator in derived class
    let source = r#"
function tracked(target: any, key: string) {}

class BaseEntity {
    id: number = 0;
}

class User extends BaseEntity {
    @tracked
    name: string = "";

    @tracked
    lastLogin: Date | null = null;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Third statement is the User class
    let class_idx = source_file
        .statements
        .nodes
        .get(2)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit with extends
    assert!(
        output.contains("function User") || output.contains("User"),
        "Expected User class: {}",
        output
    );

    // Should have inheritance pattern
    assert!(
        output.contains("__extends") || output.contains("_super"),
        "Expected inheritance pattern: {}",
        output
    );

    // Decorated fields should be present
    assert!(
        output.contains("name") && output.contains("lastLogin"),
        "Expected decorated fields: {}",
        output
    );
}

#[test]
fn test_class_es5_field_decorator_with_accessor() {
    // Field decorator combined with accessor decorator
    let source = r#"
function observable(target: any, key: string) {}
function computed(target: any, key: string, descriptor: PropertyDescriptor) {}

class ViewModel {
    @observable
    firstName: string = "";

    @observable
    lastName: string = "";

    @computed
    get fullName(): string {
        return this.firstName + " " + this.lastName;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Third statement is the class
    let class_idx = source_file
        .statements
        .nodes
        .get(2)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function ViewModel") || output.contains("ViewModel"),
        "Expected ViewModel class: {}",
        output
    );

    // Fields should be present
    assert!(
        output.contains("firstName") && output.contains("lastName"),
        "Expected name fields: {}",
        output
    );

    // Getter should be present
    assert!(
        output.contains("fullName"),
        "Expected fullName getter: {}",
        output
    );
}

// =============================================================================
// Override Keyword Tests
// =============================================================================

#[test]
fn test_class_es5_override_method_basic() {
    // Basic override method - override keyword should be erased
    let source = r#"
class Animal {
    speak(): string {
        return "...";
    }
}

class Dog extends Animal {
    override speak(): string {
        return "Woof!";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the Dog class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit with extends
    assert!(
        output.contains("function Dog"),
        "Expected Dog class: {}",
        output
    );

    // Override keyword should be erased
    assert!(
        !output.contains("override"),
        "override keyword should be erased: {}",
        output
    );

    // Method should be on prototype
    assert!(
        output.contains("speak"),
        "Expected speak method: {}",
        output
    );

    // Should have inheritance pattern
    assert!(
        output.contains("__extends") || output.contains("_super"),
        "Expected inheritance pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_override_accessor() {
    // Override getter/setter - override keyword should be erased
    let source = r#"
class Base {
    protected _value: number = 0;

    get value(): number {
        return this._value;
    }

    set value(v: number) {
        this._value = v;
    }
}

class Derived extends Base {
    override get value(): number {
        return this._value * 2;
    }

    override set value(v: number) {
        this._value = v / 2;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the Derived class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function Derived"),
        "Expected Derived class: {}",
        output
    );

    // Override keyword should be erased
    assert!(
        !output.contains("override"),
        "override keyword should be erased: {}",
        output
    );

    // Accessor should use Object.defineProperty
    assert!(
        output.contains("value") || output.contains("defineProperty"),
        "Expected value accessor: {}",
        output
    );
}

#[test]
fn test_class_es5_override_multiple_methods() {
    // Multiple override methods
    let source = r#"
class Shape {
    getArea(): number { return 0; }
    getPerimeter(): number { return 0; }
    describe(): string { return "Shape"; }
}

class Rectangle extends Shape {
    width: number;
    height: number;

    constructor(w: number, h: number) {
        super();
        this.width = w;
        this.height = h;
    }

    override getArea(): number {
        return this.width * this.height;
    }

    override getPerimeter(): number {
        return 2 * (this.width + this.height);
    }

    override describe(): string {
        return "Rectangle";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the Rectangle class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function Rectangle"),
        "Expected Rectangle class: {}",
        output
    );

    // Override keyword should be erased
    assert!(
        !output.contains("override"),
        "override keyword should be erased: {}",
        output
    );

    // All methods should be present
    assert!(
        output.contains("getArea")
            && output.contains("getPerimeter")
            && output.contains("describe"),
        "Expected all override methods: {}",
        output
    );
}

#[test]
fn test_class_es5_override_multilevel_inheritance() {
    // Override in multi-level inheritance chain
    let source = r#"
class A {
    foo(): string { return "A"; }
}

class B extends A {
    override foo(): string { return "B"; }
}

class C extends B {
    override foo(): string { return "C"; }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Third statement is class C
    let class_idx = source_file
        .statements
        .nodes
        .get(2)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function C"),
        "Expected C class: {}",
        output
    );

    // Override keyword should be erased
    assert!(
        !output.contains("override"),
        "override keyword should be erased: {}",
        output
    );

    // Method should be present
    assert!(output.contains("foo"), "Expected foo method: {}", output);

    // Should have inheritance
    assert!(
        output.contains("__extends") || output.contains("_super"),
        "Expected inheritance pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_override_with_super_call() {
    // Override method that calls super
    let source = r#"
class Logger {
    log(message: string): void {
        console.log(message);
    }
}

class TimestampLogger extends Logger {
    override log(message: string): void {
        const timestamp = new Date().toISOString();
        super.log("[" + timestamp + "] " + message);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the TimestampLogger class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function TimestampLogger"),
        "Expected TimestampLogger class: {}",
        output
    );

    // Override keyword should be erased
    assert!(
        !output.contains("override"),
        "override keyword should be erased: {}",
        output
    );

    // Method should be present
    assert!(output.contains("log"), "Expected log method: {}", output);

    // Super call should be transformed
    assert!(
        output.contains("_super") || output.contains("prototype"),
        "Expected super call pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_override_abstract_method() {
    // Override abstract method
    let source = r#"
abstract class Component {
    abstract render(): string;
    abstract update(): void;
}

class Button extends Component {
    override render(): string {
        return "<button>Click me</button>";
    }

    override update(): void {
        console.log("Button updated");
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the Button class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function Button"),
        "Expected Button class: {}",
        output
    );

    // Override keyword should be erased
    assert!(
        !output.contains("override"),
        "override keyword should be erased: {}",
        output
    );

    // Abstract keyword should be erased
    assert!(
        !output.contains("abstract"),
        "abstract keyword should be erased: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("render") && output.contains("update"),
        "Expected render and update methods: {}",
        output
    );
}

// =============================================================================
// Satisfies Expression Tests
// =============================================================================

#[test]
fn test_class_es5_satisfies_field_initializer() {
    // satisfies in field initializer - should be erased
    let source = r#"
type Config = { host: string; port: number };

class Server {
    config = { host: "localhost", port: 8080 } satisfies Config;

    getHost(): string {
        return this.config.host;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function Server"),
        "Expected Server class: {}",
        output
    );

    // satisfies keyword should be erased
    assert!(
        !output.contains("satisfies"),
        "satisfies keyword should be erased: {}",
        output
    );

    // Field should be initialized (value may or may not be present depending on satisfies handling)
    assert!(
        output.contains("config"),
        "Expected config field: {}",
        output
    );
}

#[test]
fn test_class_es5_satisfies_in_method() {
    // satisfies in method return - should be erased
    let source = r#"
interface Point { x: number; y: number }

class Geometry {
    createPoint(x: number, y: number): Point {
        return { x, y } satisfies Point;
    }

    createOrigin(): Point {
        return { x: 0, y: 0 } satisfies Point;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function Geometry"),
        "Expected Geometry class: {}",
        output
    );

    // satisfies keyword should be erased
    assert!(
        !output.contains("satisfies"),
        "satisfies keyword should be erased: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("createPoint") && output.contains("createOrigin"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_satisfies_static_field() {
    // satisfies in static field - should be erased
    let source = r##"
type ColorMap = Record<string, string>;

class Theme {
    static colors = {
        primary: "#007bff",
        secondary: "#6c757d",
        success: "#28a745"
    } satisfies ColorMap;

    static getColor(name: string): string {
        return Theme.colors[name] || "#000000";
    }
}
"##;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function Theme") || output.contains("Theme"),
        "Expected Theme class: {}",
        output
    );

    // satisfies keyword should be erased
    assert!(
        !output.contains("satisfies"),
        "satisfies keyword should be erased: {}",
        output
    );

    // Static field should be present (value may or may not be present depending on satisfies handling)
    assert!(
        output.contains("colors"),
        "Expected colors field: {}",
        output
    );
}

#[test]
fn test_class_es5_satisfies_in_constructor() {
    // satisfies in constructor - should be erased
    let source = r#"
interface Options {
    timeout: number;
    retries: number;
}

class Client {
    options: Options;

    constructor() {
        this.options = { timeout: 5000, retries: 3 } satisfies Options;
    }

    getTimeout(): number {
        return this.options.timeout;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function Client"),
        "Expected Client class: {}",
        output
    );

    // satisfies keyword should be erased
    assert!(
        !output.contains("satisfies"),
        "satisfies keyword should be erased: {}",
        output
    );

    // Field should be present (value may or may not be present depending on satisfies handling)
    assert!(
        output.contains("options"),
        "Expected options field: {}",
        output
    );
}

#[test]
fn test_class_es5_satisfies_array_literal() {
    // satisfies with array literal - should be erased
    let source = r#"
type Route = { path: string; handler: string };

class Router {
    routes = [
        { path: "/", handler: "home" },
        { path: "/about", handler: "about" }
    ] satisfies Route[];

    getRoutes(): Route[] {
        return this.routes;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function Router"),
        "Expected Router class: {}",
        output
    );

    // satisfies keyword should be erased
    assert!(
        !output.contains("satisfies"),
        "satisfies keyword should be erased: {}",
        output
    );

    // Field should be present (value may or may not be present depending on satisfies handling)
    assert!(
        output.contains("routes"),
        "Expected routes field: {}",
        output
    );
}

#[test]
fn test_class_es5_satisfies_in_derived_class() {
    // satisfies in derived class - should be erased
    let source = r#"
interface Metadata { version: string; author: string }

class BasePlugin {
    name: string = "base";
}

class CustomPlugin extends BasePlugin {
    metadata = { version: "1.0.0", author: "dev" } satisfies Metadata;

    getVersion(): string {
        return this.metadata.version;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Third statement is the CustomPlugin class
    let class_idx = source_file
        .statements
        .nodes
        .get(2)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function CustomPlugin"),
        "Expected CustomPlugin class: {}",
        output
    );

    // satisfies keyword should be erased
    assert!(
        !output.contains("satisfies"),
        "satisfies keyword should be erased: {}",
        output
    );

    // Should have inheritance
    assert!(
        output.contains("__extends") || output.contains("_super"),
        "Expected inheritance pattern: {}",
        output
    );

    // Field should be present (value may or may not be present depending on satisfies handling)
    assert!(
        output.contains("metadata"),
        "Expected metadata field: {}",
        output
    );
}

// =============================================================================
// Namespace Merging Tests
// =============================================================================

#[test]
fn test_class_es5_namespace_merging_basic() {
    // Class merged with namespace - adds static members
    let source = r#"
class Validator {
    validate(input: string): boolean {
        return input.length > 0;
    }
}

namespace Validator {
    export const minLength = 1;
    export const maxLength = 100;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be present
    assert!(
        output.contains("Validator"),
        "Expected Validator class: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("validate"),
        "Expected validate method: {}",
        output
    );

    // Namespace exports should be present
    assert!(
        output.contains("minLength") && output.contains("maxLength"),
        "Expected namespace exports: {}",
        output
    );
}

#[test]
fn test_class_es5_namespace_merging_with_functions() {
    // Class merged with namespace containing functions
    let source = r#"
class StringUtils {
    value: string;

    constructor(value: string) {
        this.value = value;
    }

    toUpper(): string {
        return this.value.toUpperCase();
    }
}

namespace StringUtils {
    export function isEmpty(s: string): boolean {
        return s.length === 0;
    }

    export function trim(s: string): string {
        return s.trim();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be present
    assert!(
        output.contains("StringUtils"),
        "Expected StringUtils class: {}",
        output
    );

    // Instance method should be present
    assert!(
        output.contains("toUpper"),
        "Expected toUpper method: {}",
        output
    );

    // Namespace functions should be present
    assert!(
        output.contains("isEmpty") && output.contains("trim"),
        "Expected namespace functions: {}",
        output
    );
}

#[test]
fn test_class_es5_namespace_merging_with_interface() {
    // Class merged with namespace containing interface
    let source = r#"
class Point {
    x: number;
    y: number;

    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }

    distanceTo(other: Point): number {
        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));
    }
}

namespace Point {
    export interface Options {
        x: number;
        y: number;
    }

    export function origin(): Point {
        return new Point(0, 0);
    }

    export const ZERO = new Point(0, 0);
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be present
    assert!(output.contains("Point"), "Expected Point class: {}", output);

    // Instance method should be present
    assert!(
        output.contains("distanceTo"),
        "Expected distanceTo method: {}",
        output
    );

    // Interface should be erased (not in output)
    assert!(
        !output.contains("interface"),
        "Interface should be erased: {}",
        output
    );

    // Namespace function and const should be present
    assert!(
        output.contains("origin") && output.contains("ZERO"),
        "Expected namespace members: {}",
        output
    );
}

#[test]
fn test_class_es5_namespace_merging_with_nested() {
    // Class merged with namespace containing nested namespace
    let source = r#"
class Logger {
    log(message: string): void {
        console.log(message);
    }
}

namespace Logger {
    export const level = "info";

    export namespace Formatters {
        export function json(obj: any): string {
            return JSON.stringify(obj);
        }

        export function text(obj: any): string {
            return String(obj);
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be present
    assert!(
        output.contains("Logger"),
        "Expected Logger class: {}",
        output
    );

    // Instance method should be present
    assert!(output.contains("log"), "Expected log method: {}", output);

    // Nested namespace should be present
    assert!(
        output.contains("Formatters"),
        "Expected Formatters namespace: {}",
        output
    );

    // Nested functions should be present
    assert!(
        output.contains("json") && output.contains("text"),
        "Expected formatter functions: {}",
        output
    );
}

#[test]
fn test_class_es5_namespace_merging_with_inheritance() {
    // Derived class merged with namespace
    let source = r#"
class BaseService {
    name: string = "base";
}

class ApiService extends BaseService {
    endpoint: string;

    constructor(endpoint: string) {
        super();
        this.endpoint = endpoint;
    }

    fetch(): Promise<any> {
        return Promise.resolve({});
    }
}

namespace ApiService {
    export const defaultTimeout = 5000;
    export const defaultHeaders = { "Content-Type": "application/json" };

    export function create(endpoint: string): ApiService {
        return new ApiService(endpoint);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be present
    assert!(
        output.contains("BaseService") && output.contains("ApiService"),
        "Expected BaseService and ApiService classes: {}",
        output
    );

    // Inheritance should be present
    assert!(
        output.contains("__extends") || output.contains("prototype"),
        "Expected inheritance pattern: {}",
        output
    );

    // Instance method should be present
    assert!(
        output.contains("fetch"),
        "Expected fetch method: {}",
        output
    );

    // Namespace exports should be present
    assert!(
        output.contains("defaultTimeout") && output.contains("defaultHeaders"),
        "Expected namespace constants: {}",
        output
    );

    // Factory function should be present
    assert!(
        output.contains("create"),
        "Expected create factory function: {}",
        output
    );
}

// =============================================================================
// Class Expression with Generics Tests
// =============================================================================

#[test]
fn test_class_es5_class_expression_generic_basic() {
    // Basic class expression with generic type parameter
    let source = r#"
const Container = class<T> {
    private value: T;

    constructor(value: T) {
        this.value = value;
    }

    getValue(): T {
        return this.value;
    }
};
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Variable should be present
    assert!(
        output.contains("Container"),
        "Expected Container variable: {}",
        output
    );

    // Generic type parameter should be erased
    assert!(
        !output.contains("<T>"),
        "Generic type parameter should be erased: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("getValue"),
        "Expected getValue method: {}",
        output
    );
}

#[test]
fn test_class_es5_class_expression_generic_multiple_params() {
    // Class expression with multiple generic type parameters
    let source = r#"
const Pair = class<K, V> {
    constructor(public key: K, public value: V) {}

    getKey(): K {
        return this.key;
    }

    getValue(): V {
        return this.value;
    }

    swap(): Pair<V, K> {
        return new Pair(this.value, this.key);
    }
};
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Variable should be present
    assert!(
        output.contains("Pair"),
        "Expected Pair variable: {}",
        output
    );

    // Generic type parameters should be erased
    assert!(
        !output.contains("<K, V>") && !output.contains("<V, K>"),
        "Generic type parameters should be erased: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("getKey") && output.contains("getValue") && output.contains("swap"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_class_expression_generic_constraint() {
    // Class expression with generic constraint
    let source = r#"
interface HasLength {
    length: number;
}

const Measurable = class<T extends HasLength> {
    constructor(private item: T) {}

    getLength(): number {
        return this.item.length;
    }

    getItem(): T {
        return this.item;
    }
};
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Variable should be present
    assert!(
        output.contains("Measurable"),
        "Expected Measurable variable: {}",
        output
    );

    // Generic constraint should be erased
    assert!(
        !output.contains("extends HasLength"),
        "Generic constraint should be erased: {}",
        output
    );

    // Interface should be erased
    assert!(
        !output.contains("interface"),
        "Interface should be erased: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("getLength") && output.contains("getItem"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_class_expression_generic_extends() {
    // Generic class expression extending another class
    let source = r#"
class BaseCollection<T> {
    protected items: T[] = [];

    add(item: T): void {
        this.items.push(item);
    }
}

const SortedCollection = class<T> extends BaseCollection<T> {
    sort(compareFn: (a: T, b: T) => number): T[] {
        return this.items.sort(compareFn);
    }

    first(): T | undefined {
        return this.items[0];
    }
};
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be present
    assert!(
        output.contains("BaseCollection") && output.contains("SortedCollection"),
        "Expected BaseCollection and SortedCollection: {}",
        output
    );

    // Generic type parameters should be erased
    assert!(
        !output.contains("<T>"),
        "Generic type parameters should be erased: {}",
        output
    );

    // Inheritance should be present
    assert!(
        output.contains("__extends") || output.contains("prototype"),
        "Expected inheritance pattern: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("sort") && output.contains("first"),
        "Expected sort and first methods: {}",
        output
    );
}

#[test]
fn test_class_es5_class_expression_generic_factory() {
    // Generic class expression used in factory pattern
    let source = r#"
function createRepository<T>() {
    return class Repository {
        private data: T[] = [];

        save(item: T): void {
            this.data.push(item);
        }

        findAll(): T[] {
            return this.data;
        }

        count(): number {
            return this.data.length;
        }
    };
}

const UserRepo = createRepository<{ id: number; name: string }>();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Factory function should be present
    assert!(
        output.contains("createRepository"),
        "Expected createRepository function: {}",
        output
    );

    // Class name should be present
    assert!(
        output.contains("Repository"),
        "Expected Repository class: {}",
        output
    );

    // Generic type parameter should be erased
    assert!(
        !output.contains("<T>"),
        "Generic type parameter should be erased: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("save") && output.contains("findAll") && output.contains("count"),
        "Expected save, findAll, and count methods: {}",
        output
    );

    // Variable assignment should be present
    assert!(
        output.contains("UserRepo"),
        "Expected UserRepo variable: {}",
        output
    );
}

// =============================================================================
// Symbol.species Tests
// =============================================================================

#[test]
fn test_class_es5_symbol_species_basic() {
    // Basic Symbol.species static getter
    let source = r#"
class MyArray<T> {
    items: T[] = [];

    static get [Symbol.species](): typeof MyArray {
        return MyArray;
    }

    push(item: T): void {
        this.items.push(item);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit
    assert!(
        output.contains("function MyArray"),
        "Expected MyArray class: {}",
        output
    );

    // Method should be present
    assert!(output.contains("push"), "Expected push method: {}", output);

    // Symbol.species should be handled (either as computed property or defineProperty)
    assert!(
        output.contains("Symbol.species")
            || output.contains("species")
            || output.contains("defineProperty"),
        "Expected Symbol.species handling: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_species_derived() {
    // Symbol.species in derived class returning different constructor
    let source = r#"
class BaseCollection<T> {
    items: T[] = [];

    static get [Symbol.species](): typeof BaseCollection {
        return BaseCollection;
    }
}

class SpecialCollection<T> extends BaseCollection<T> {
    static get [Symbol.species](): typeof SpecialCollection {
        return SpecialCollection;
    }

    addSpecial(item: T): void {
        this.items.push(item);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the SpecialCollection class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function SpecialCollection"),
        "Expected SpecialCollection class: {}",
        output
    );

    // Should have inheritance
    assert!(
        output.contains("__extends") || output.contains("_super"),
        "Expected inheritance pattern: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("addSpecial"),
        "Expected addSpecial method: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_species_with_methods() {
    // Symbol.species with map-like method that uses it
    let source = r#"
class CustomList<T> {
    private data: T[] = [];

    static get [Symbol.species](): typeof CustomList {
        return CustomList;
    }

    add(item: T): this {
        this.data.push(item);
        return this;
    }

    map<U>(fn: (item: T) => U): CustomList<U> {
        const ctor = (this.constructor as any)[Symbol.species] || CustomList;
        const result = new ctor();
        for (const item of this.data) {
            result.add(fn(item));
        }
        return result;
    }

    get length(): number {
        return this.data.length;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit
    assert!(
        output.contains("function CustomList"),
        "Expected CustomList class: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("add") && output.contains("map"),
        "Expected add and map methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_species_returning_base() {
    // Symbol.species in subclass returning base class
    let source = r#"
class Observable<T> {
    value: T;

    constructor(value: T) {
        this.value = value;
    }

    static get [Symbol.species](): typeof Observable {
        return Observable;
    }
}

class BehaviorSubject<T> extends Observable<T> {
    // Returns base class instead of derived
    static get [Symbol.species](): typeof Observable {
        return Observable;
    }

    next(value: T): void {
        this.value = value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");

    // Second statement is the BehaviorSubject class
    let class_idx = source_file
        .statements
        .nodes
        .get(1)
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(*class_idx);

    // Class should emit
    assert!(
        output.contains("function BehaviorSubject"),
        "Expected BehaviorSubject class: {}",
        output
    );

    // Should have inheritance
    assert!(
        output.contains("__extends") || output.contains("_super"),
        "Expected inheritance pattern: {}",
        output
    );

    // Method should be present
    assert!(output.contains("next"), "Expected next method: {}", output);
}

#[test]
fn test_class_es5_symbol_species_with_static_members() {
    // Symbol.species alongside other static members
    let source = r#"
class Factory<T> {
    static defaultName: string = "Factory";
    static count: number = 0;

    static get [Symbol.species](): typeof Factory {
        return Factory;
    }

    static create<U>(value: U): Factory<U> {
        Factory.count++;
        return new Factory<U>();
    }

    produce(): T | null {
        return null;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit
    assert!(
        output.contains("function Factory") || output.contains("Factory"),
        "Expected Factory class: {}",
        output
    );

    // Static members should be present
    assert!(
        output.contains("defaultName") || output.contains("count") || output.contains("create"),
        "Expected static members: {}",
        output
    );

    // Instance method should be present
    assert!(
        output.contains("produce"),
        "Expected produce method: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_species_null() {
    // Symbol.species returning null to prevent subclass creation
    let source = r#"
class ImmutableList<T> {
    private readonly items: readonly T[];

    constructor(items: T[]) {
        this.items = Object.freeze([...items]);
    }

    // Returning null prevents derived instances
    static get [Symbol.species](): null {
        return null;
    }

    get(index: number): T | undefined {
        return this.items[index];
    }

    get length(): number {
        return this.items.length;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let root_node = parser.arena.get(root).expect("expected source file node");
    let source_file = parser
        .arena
        .get_source_file(root_node)
        .expect("expected source file data");
    let class_idx = *source_file
        .statements
        .nodes
        .first()
        .expect("expected class declaration");

    let mut emitter = ClassES5Emitter::new(&parser.arena);
    let output = emitter.emit_class(class_idx);

    // Class should emit
    assert!(
        output.contains("function ImmutableList"),
        "Expected ImmutableList class: {}",
        output
    );

    // Methods should be present
    assert!(output.contains("get"), "Expected get method: {}", output);

    // Constructor should handle items
    assert!(
        output.contains("items"),
        "Expected items handling: {}",
        output
    );
}

// =============================================================================
// WeakMap/WeakSet Private Field Polyfill Tests
// =============================================================================

#[test]
fn test_class_es5_weakmap_private_field_basic() {
    // Private fields polyfilled with WeakMap pattern
    let source = r#"
class SecureData {
    #secret: string;
    #value: number;

    constructor(secret: string, value: number) {
        this.#secret = secret;
        this.#value = value;
    }

    getSecret(): string {
        return this.#secret;
    }

    getValue(): number {
        return this.#value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be present
    assert!(
        output.contains("SecureData"),
        "Expected SecureData class: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("getSecret") && output.contains("getValue"),
        "Expected getSecret and getValue methods: {}",
        output
    );

    // Private field access should be transformed
    assert!(
        output.contains("secret") && output.contains("value"),
        "Expected private field references: {}",
        output
    );
}

#[test]
fn test_class_es5_weakmap_private_field_methods() {
    // Private methods polyfilled with WeakSet pattern
    let source = r#"
class Processor {
    #data: any[] = [];

    #validate(item: any): boolean {
        return item !== null && item !== undefined;
    }

    #transform(item: any): any {
        return { processed: true, data: item };
    }

    add(item: any): void {
        if (this.#validate(item)) {
            this.#data.push(this.#transform(item));
        }
    }

    getAll(): any[] {
        return this.#data;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be present
    assert!(
        output.contains("Processor"),
        "Expected Processor class: {}",
        output
    );

    // Public methods should be present
    assert!(
        output.contains("add") && output.contains("getAll"),
        "Expected add and getAll methods: {}",
        output
    );

    // Private method names should be present
    assert!(
        output.contains("validate") && output.contains("transform"),
        "Expected private method names: {}",
        output
    );
}

#[test]
fn test_class_es5_weakmap_private_field_inheritance() {
    // Private fields in inheritance - each class has its own WeakMap
    let source = r#"
class Parent {
    #parentSecret: string = "parent";

    getParentSecret(): string {
        return this.#parentSecret;
    }
}

class Child extends Parent {
    #childSecret: string = "child";

    getChildSecret(): string {
        return this.#childSecret;
    }

    getBoth(): string {
        return this.getParentSecret() + " " + this.#childSecret;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be present
    assert!(
        output.contains("Parent") && output.contains("Child"),
        "Expected Parent and Child classes: {}",
        output
    );

    // Inheritance should be present
    assert!(
        output.contains("__extends") || output.contains("prototype"),
        "Expected inheritance pattern: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("getParentSecret")
            && output.contains("getChildSecret")
            && output.contains("getBoth"),
        "Expected getter methods: {}",
        output
    );
}

#[test]
fn test_class_es5_weakmap_private_field_static() {
    // Static private fields with WeakMap-like pattern
    let source = r#"
class Registry {
    static #instances: Map<string, Registry> = new Map();
    static #counter: number = 0;

    #id: number;

    constructor() {
        this.#id = Registry.#counter++;
    }

    static register(name: string, instance: Registry): void {
        this.#instances.set(name, instance);
    }

    static get(name: string): Registry | undefined {
        return this.#instances.get(name);
    }

    getId(): number {
        return this.#id;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be present
    assert!(
        output.contains("Registry"),
        "Expected Registry class: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("register") && output.contains("get"),
        "Expected register and get methods: {}",
        output
    );

    // Instance method should be present
    assert!(
        output.contains("getId"),
        "Expected getId method: {}",
        output
    );

    // Private field references should be present
    assert!(
        output.contains("instances") || output.contains("counter") || output.contains("id"),
        "Expected private field references: {}",
        output
    );
}

#[test]
fn test_class_es5_weakmap_private_field_accessors() {
    // Private field with getter/setter accessors
    let source = r#"
class BoundedValue {
    #value: number = 0;
    #min: number;
    #max: number;

    constructor(min: number, max: number) {
        this.#min = min;
        this.#max = max;
    }

    get value(): number {
        return this.#value;
    }

    set value(v: number) {
        if (v < this.#min) {
            this.#value = this.#min;
        } else if (v > this.#max) {
            this.#value = this.#max;
        } else {
            this.#value = v;
        }
    }

    reset(): void {
        this.#value = this.#min;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be present
    assert!(
        output.contains("BoundedValue"),
        "Expected BoundedValue class: {}",
        output
    );

    // Accessor property should be defined
    assert!(
        output.contains("value"),
        "Expected value accessor: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("reset"),
        "Expected reset method: {}",
        output
    );

    // Private field references should be transformed
    assert!(
        output.contains("min") && output.contains("max"),
        "Expected min and max field references: {}",
        output
    );
}

// ============================================================================
// new.target Tests
// ============================================================================

#[test]
fn test_class_es5_new_target_basic() {
    // Basic new.target usage in constructor
    let source = r#"
class Example {
    name: string;

    constructor() {
        this.name = new.target.name;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("Example"),
        "Expected Example class: {}",
        output
    );

    // new.target should be transformed for ES5
    assert!(
        output.contains("name"),
        "Expected name property: {}",
        output
    );
}

#[test]
fn test_class_es5_new_target_derived() {
    // new.target in derived class constructor
    let source = r#"
class Base {
    constructor() {
        console.log(new.target.name);
    }
}

class Derived extends Base {
    constructor() {
        super();
        console.log(new.target.name);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be present
    assert!(output.contains("Base"), "Expected Base class: {}", output);
    assert!(
        output.contains("Derived"),
        "Expected Derived class: {}",
        output
    );

    // Inheritance should be set up
    assert!(
        output.contains("__extends") || output.contains("extends"),
        "Expected inheritance pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_new_target_abstract_pattern() {
    // new.target check to prevent direct instantiation (abstract class pattern)
    let source = r#"
class AbstractBase {
    constructor() {
        if (new.target === AbstractBase) {
            throw new Error("Cannot instantiate abstract class");
        }
    }

    abstract doWork(): void;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("AbstractBase"),
        "Expected AbstractBase class: {}",
        output
    );

    // Error throw should be present
    assert!(
        output.contains("Error") || output.contains("throw"),
        "Expected error handling: {}",
        output
    );
}

#[test]
fn test_class_es5_new_target_with_static() {
    // new.target with static factory method
    let source = r#"
class Factory {
    private data: string;

    constructor(data: string) {
        if (!new.target) {
            throw new Error("Must use new");
        }
        this.data = data;
    }

    static create(data: string): Factory {
        return new Factory(data);
    }

    getData(): string {
        return this.data;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("Factory"),
        "Expected Factory class: {}",
        output
    );

    // Static method should be present
    assert!(
        output.contains("create"),
        "Expected create static method: {}",
        output
    );

    // Instance method should be present
    assert!(
        output.contains("getData"),
        "Expected getData method: {}",
        output
    );
}

#[test]
fn test_class_es5_new_target_inheritance_chain() {
    // new.target through inheritance chain
    let source = r#"
class Animal {
    type: string;

    constructor() {
        this.type = new.target.name;
    }
}

class Mammal extends Animal {
    warm: boolean = true;
}

class Dog extends Mammal {
    breed: string;

    constructor(breed: string) {
        super();
        this.breed = breed;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // All classes should be present
    assert!(
        output.contains("Animal"),
        "Expected Animal class: {}",
        output
    );
    assert!(
        output.contains("Mammal"),
        "Expected Mammal class: {}",
        output
    );
    assert!(output.contains("Dog"), "Expected Dog class: {}", output);

    // Inheritance should be set up
    assert!(
        output.contains("__extends") || output.contains("_super"),
        "Expected inheritance pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_new_target_undefined_check() {
    // new.target undefined check for callable class pattern
    let source = r#"
class Callable {
    value: number;

    constructor(value: number) {
        if (new.target === undefined) {
            return new Callable(value);
        }
        this.value = value;
    }

    getValue(): number {
        return this.value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("Callable"),
        "Expected Callable class: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("getValue"),
        "Expected getValue method: {}",
        output
    );

    // undefined check pattern should be in output
    assert!(
        output.contains("undefined") || output.contains("value"),
        "Expected undefined check or value property: {}",
        output
    );
}

// ============================================================================
// Proxy Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_proxy_basic() {
    // Basic Proxy usage in class method
    let source = r#"
class ProxyWrapper<T extends object> {
    private target: T;
    private proxy: T;

    constructor(target: T) {
        this.target = target;
        this.proxy = new Proxy(target, {});
    }

    getProxy(): T {
        return this.proxy;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ProxyWrapper"),
        "Expected ProxyWrapper class: {}",
        output
    );

    // Proxy usage should be present
    assert!(output.contains("Proxy"), "Expected Proxy usage: {}", output);

    // Method should be present
    assert!(
        output.contains("getProxy"),
        "Expected getProxy method: {}",
        output
    );
}

#[test]
fn test_class_es5_proxy_handler_traps() {
    // Proxy with get/set handler traps
    let source = r#"
class ObservableObject {
    private data: Record<string, any> = {};
    private listeners: Array<(key: string, value: any) => void> = [];

    createProxy(): Record<string, any> {
        const self = this;
        return new Proxy(this.data, {
            get(target, prop: string) {
                return target[prop];
            },
            set(target, prop: string, value) {
                target[prop] = value;
                self.notify(prop, value);
                return true;
            }
        });
    }

    notify(key: string, value: any): void {
        this.listeners.forEach(fn => fn(key, value));
    }

    subscribe(fn: (key: string, value: any) => void): void {
        this.listeners.push(fn);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ObservableObject"),
        "Expected ObservableObject class: {}",
        output
    );

    // Proxy should be present
    assert!(output.contains("Proxy"), "Expected Proxy: {}", output);

    // Methods should be present
    assert!(
        output.contains("createProxy") && output.contains("notify") && output.contains("subscribe"),
        "Expected createProxy, notify, subscribe methods: {}",
        output
    );
}

#[test]
fn test_class_es5_proxy_apply_trap() {
    // Proxy with apply trap for function wrapping
    let source = r#"
class FunctionWrapper {
    wrap<T extends (...args: any[]) => any>(fn: T): T {
        return new Proxy(fn, {
            apply(target, thisArg, args) {
                console.log("Calling function with args:", args);
                const result = Reflect.apply(target, thisArg, args);
                console.log("Result:", result);
                return result;
            }
        }) as T;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("FunctionWrapper"),
        "Expected FunctionWrapper class: {}",
        output
    );

    // wrap method should be present
    assert!(output.contains("wrap"), "Expected wrap method: {}", output);
}

#[test]
fn test_class_es5_proxy_factory() {
    // Static factory method returning proxied instance
    let source = r#"
class ValidatedModel {
    name: string = "";
    age: number = 0;

    static create(): ValidatedModel {
        const instance = new ValidatedModel();
        return new Proxy(instance, {
            set(target, prop: keyof ValidatedModel, value) {
                if (prop === "age" && typeof value === "number" && value < 0) {
                    throw new Error("Age cannot be negative");
                }
                (target as any)[prop] = value;
                return true;
            }
        });
    }

    toJSON(): object {
        return { name: this.name, age: this.age };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ValidatedModel"),
        "Expected ValidatedModel class: {}",
        output
    );

    // Static method create should be present
    assert!(
        output.contains("create"),
        "Expected create static method: {}",
        output
    );

    // Proxy should be present
    assert!(output.contains("Proxy"), "Expected Proxy: {}", output);

    // Instance method should be present
    assert!(
        output.contains("toJSON"),
        "Expected toJSON method: {}",
        output
    );
}

#[test]
fn test_class_es5_proxy_with_reflect() {
    // Proxy using Reflect API for default behavior
    let source = r#"
class LoggingProxy<T extends object> {
    private logs: string[] = [];

    createLoggingProxy(target: T): T {
        const logs = this.logs;
        return new Proxy(target, {
            get(target, prop, receiver) {
                logs.push("get " + String(prop));
                return Reflect.get(target, prop, receiver);
            },
            set(target, prop, value, receiver) {
                logs.push("set " + String(prop));
                return Reflect.set(target, prop, value, receiver);
            },
            deleteProperty(target, prop) {
                logs.push("delete " + String(prop));
                return Reflect.deleteProperty(target, prop);
            }
        });
    }

    getLogs(): string[] {
        return this.logs;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("LoggingProxy"),
        "Expected LoggingProxy class: {}",
        output
    );

    // Proxy should be present
    assert!(output.contains("Proxy"), "Expected Proxy: {}", output);

    // Methods should be present
    assert!(
        output.contains("createLoggingProxy") && output.contains("getLogs"),
        "Expected createLoggingProxy and getLogs methods: {}",
        output
    );
}

#[test]
fn test_class_es5_proxy_revocable() {
    // Revocable proxy pattern
    let source = r#"
class RevocableAccess<T extends object> {
    private revoke: (() => void) | null = null;

    createRevocable(target: T): T {
        const { proxy, revoke } = Proxy.revocable(target, {
            get(target, prop, receiver) {
                return Reflect.get(target, prop, receiver);
            }
        });
        this.revoke = revoke;
        return proxy;
    }

    revokeAccess(): void {
        if (this.revoke) {
            this.revoke();
            this.revoke = null;
        }
    }

    isRevoked(): boolean {
        return this.revoke === null;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("RevocableAccess"),
        "Expected RevocableAccess class: {}",
        output
    );

    // Proxy.revocable should be present
    assert!(output.contains("Proxy"), "Expected Proxy: {}", output);

    // Methods should be present
    assert!(
        output.contains("createRevocable")
            && output.contains("revokeAccess")
            && output.contains("isRevoked"),
        "Expected createRevocable, revokeAccess, isRevoked methods: {}",
        output
    );
}

// ============================================================================
// WeakRef and FinalizationRegistry Tests
// ============================================================================

#[test]
fn test_class_es5_weakref_basic() {
    // Basic WeakRef usage in class
    let source = r#"
class WeakReference<T extends object> {
    private ref: WeakRef<T>;

    constructor(target: T) {
        this.ref = new WeakRef(target);
    }

    get(): T | undefined {
        return this.ref.deref();
    }

    isAlive(): boolean {
        return this.ref.deref() !== undefined;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("WeakReference"),
        "Expected WeakReference class: {}",
        output
    );

    // WeakRef should be present
    assert!(output.contains("WeakRef"), "Expected WeakRef: {}", output);

    // Methods should be present
    assert!(
        output.contains("get") && output.contains("isAlive"),
        "Expected get and isAlive methods: {}",
        output
    );
}

#[test]
fn test_class_es5_weakref_with_deref() {
    // WeakRef with conditional deref usage
    let source = r#"
class ObjectTracker<T extends object> {
    private weakRefs: WeakRef<T>[] = [];

    track(obj: T): void {
        this.weakRefs.push(new WeakRef(obj));
    }

    getAlive(): T[] {
        const alive: T[] = [];
        for (const ref of this.weakRefs) {
            const obj = ref.deref();
            if (obj !== undefined) {
                alive.push(obj);
            }
        }
        return alive;
    }

    cleanup(): void {
        this.weakRefs = this.weakRefs.filter(ref => ref.deref() !== undefined);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ObjectTracker"),
        "Expected ObjectTracker class: {}",
        output
    );

    // WeakRef should be present
    assert!(output.contains("WeakRef"), "Expected WeakRef: {}", output);

    // Methods should be present
    assert!(
        output.contains("track") && output.contains("getAlive") && output.contains("cleanup"),
        "Expected track, getAlive, cleanup methods: {}",
        output
    );
}

#[test]
fn test_class_es5_finalization_registry_basic() {
    // Basic FinalizationRegistry usage
    let source = r#"
class ResourceManager {
    private registry: FinalizationRegistry<string>;
    private resources: Map<string, object> = new Map();

    constructor() {
        this.registry = new FinalizationRegistry((id: string) => {
            console.log("Resource cleaned up:", id);
            this.resources.delete(id);
        });
    }

    register(id: string, resource: object): void {
        this.resources.set(id, resource);
        this.registry.register(resource, id);
    }

    getCount(): number {
        return this.resources.size;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ResourceManager"),
        "Expected ResourceManager class: {}",
        output
    );

    // FinalizationRegistry should be present
    assert!(
        output.contains("FinalizationRegistry"),
        "Expected FinalizationRegistry: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("register") && output.contains("getCount"),
        "Expected register and getCount methods: {}",
        output
    );
}

#[test]
fn test_class_es5_finalization_registry_with_unregister() {
    // FinalizationRegistry with unregister token
    let source = r#"
class ManagedResource {
    private registry: FinalizationRegistry<string>;
    private tokens: Map<string, object> = new Map();

    constructor() {
        this.registry = new FinalizationRegistry((heldValue: string) => {
            console.log("Releasing:", heldValue);
        });
    }

    acquire(id: string, resource: object): object {
        const token = { id };
        this.tokens.set(id, token);
        this.registry.register(resource, id, token);
        return resource;
    }

    release(id: string): boolean {
        const token = this.tokens.get(id);
        if (token) {
            this.registry.unregister(token);
            this.tokens.delete(id);
            return true;
        }
        return false;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ManagedResource"),
        "Expected ManagedResource class: {}",
        output
    );

    // FinalizationRegistry should be present
    assert!(
        output.contains("FinalizationRegistry"),
        "Expected FinalizationRegistry: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("acquire") && output.contains("release"),
        "Expected acquire and release methods: {}",
        output
    );
}

#[test]
fn test_class_es5_weakref_cache_pattern() {
    // WeakRef-based cache pattern
    let source = r#"
class WeakCache<K extends object, V> {
    private cache: Map<K, WeakRef<V & object>> = new Map();

    set(key: K, value: V & object): void {
        this.cache.set(key, new WeakRef(value));
    }

    get(key: K): V | undefined {
        const ref = this.cache.get(key);
        if (ref) {
            const value = ref.deref();
            if (value === undefined) {
                this.cache.delete(key);
            }
            return value;
        }
        return undefined;
    }

    has(key: K): boolean {
        const ref = this.cache.get(key);
        if (ref && ref.deref() !== undefined) {
            return true;
        }
        this.cache.delete(key);
        return false;
    }

    clear(): void {
        this.cache.clear();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("WeakCache"),
        "Expected WeakCache class: {}",
        output
    );

    // WeakRef should be present
    assert!(output.contains("WeakRef"), "Expected WeakRef: {}", output);

    // Methods should be present
    assert!(
        output.contains("set") && output.contains("has") && output.contains("clear"),
        "Expected set, has, clear methods: {}",
        output
    );
}

#[test]
fn test_class_es5_weakref_finalization_combined() {
    // Combined WeakRef and FinalizationRegistry pattern
    let source = r#"
class SubscriptionManager<T extends object> {
    private subscriptions: Map<string, WeakRef<T>> = new Map();
    private registry: FinalizationRegistry<string>;

    constructor() {
        this.registry = new FinalizationRegistry((id: string) => {
            this.subscriptions.delete(id);
            console.log("Subscription auto-removed:", id);
        });
    }

    subscribe(id: string, subscriber: T): void {
        this.subscriptions.set(id, new WeakRef(subscriber));
        this.registry.register(subscriber, id);
    }

    notify(message: string): void {
        for (const [id, ref] of this.subscriptions) {
            const subscriber = ref.deref();
            if (subscriber) {
                console.log("Notifying", id, ":", message);
            }
        }
    }

    unsubscribe(id: string): boolean {
        return this.subscriptions.delete(id);
    }

    getActiveCount(): number {
        let count = 0;
        for (const ref of this.subscriptions.values()) {
            if (ref.deref() !== undefined) {
                count++;
            }
        }
        return count;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("SubscriptionManager"),
        "Expected SubscriptionManager class: {}",
        output
    );

    // Both WeakRef and FinalizationRegistry should be present
    assert!(
        output.contains("WeakRef") && output.contains("FinalizationRegistry"),
        "Expected WeakRef and FinalizationRegistry: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("subscribe") && output.contains("notify") && output.contains("unsubscribe"),
        "Expected subscribe, notify, unsubscribe methods: {}",
        output
    );
}

// ============================================================================
// Reflect API Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_reflect_get_set() {
    // Reflect.get and Reflect.set usage
    let source = r#"
class PropertyAccessor {
    private data: Record<string, any> = {};

    getValue(key: string): any {
        return Reflect.get(this.data, key);
    }

    setValue(key: string, value: any): boolean {
        return Reflect.set(this.data, key, value);
    }

    getWithReceiver(target: object, key: string): any {
        return Reflect.get(target, key, this);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("PropertyAccessor"),
        "Expected PropertyAccessor class: {}",
        output
    );

    // Reflect should be present
    assert!(output.contains("Reflect"), "Expected Reflect: {}", output);

    // Methods should be present
    assert!(
        output.contains("getValue") && output.contains("setValue"),
        "Expected getValue and setValue methods: {}",
        output
    );
}

#[test]
fn test_class_es5_reflect_has_delete() {
    // Reflect.has and Reflect.deleteProperty
    let source = r#"
class ObjectManager {
    private store: Record<string, any> = {};

    hasProperty(key: string): boolean {
        return Reflect.has(this.store, key);
    }

    deleteProperty(key: string): boolean {
        return Reflect.deleteProperty(this.store, key);
    }

    checkAndDelete(key: string): boolean {
        if (Reflect.has(this.store, key)) {
            return Reflect.deleteProperty(this.store, key);
        }
        return false;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ObjectManager"),
        "Expected ObjectManager class: {}",
        output
    );

    // Reflect should be present
    assert!(output.contains("Reflect"), "Expected Reflect: {}", output);

    // Methods should be present
    assert!(
        output.contains("hasProperty")
            && output.contains("deleteProperty")
            && output.contains("checkAndDelete"),
        "Expected hasProperty, deleteProperty, checkAndDelete methods: {}",
        output
    );
}

#[test]
fn test_class_es5_reflect_construct() {
    // Reflect.construct usage
    let source = r#"
class Factory<T> {
    create(ctor: new (...args: any[]) => T, args: any[]): T {
        return Reflect.construct(ctor, args);
    }

    createWithNewTarget(ctor: new (...args: any[]) => T, args: any[], newTarget: Function): T {
        return Reflect.construct(ctor, args, newTarget);
    }

    createInstance<U>(ctor: new () => U): U {
        return Reflect.construct(ctor, []);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("Factory"),
        "Expected Factory class: {}",
        output
    );

    // Reflect.construct should be present
    assert!(output.contains("Reflect"), "Expected Reflect: {}", output);

    // Methods should be present
    assert!(
        output.contains("create") && output.contains("createInstance"),
        "Expected create and createInstance methods: {}",
        output
    );
}

#[test]
fn test_class_es5_reflect_apply() {
    // Reflect.apply usage
    let source = r#"
class FunctionInvoker {
    invoke<T>(fn: (...args: any[]) => T, thisArg: any, args: any[]): T {
        return Reflect.apply(fn, thisArg, args);
    }

    invokeMethod<T>(obj: any, methodName: string, args: any[]): T {
        const method = obj[methodName];
        return Reflect.apply(method, obj, args);
    }

    bindAndCall<T>(fn: (...args: any[]) => T, context: any): (...args: any[]) => T {
        return (...args: any[]) => Reflect.apply(fn, context, args);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("FunctionInvoker"),
        "Expected FunctionInvoker class: {}",
        output
    );

    // Reflect.apply should be present
    assert!(output.contains("Reflect"), "Expected Reflect: {}", output);

    // Methods should be present
    assert!(
        output.contains("invoke")
            && output.contains("invokeMethod")
            && output.contains("bindAndCall"),
        "Expected invoke, invokeMethod, bindAndCall methods: {}",
        output
    );
}

#[test]
fn test_class_es5_reflect_ownkeys() {
    // Reflect.ownKeys and Reflect.getOwnPropertyDescriptor
    let source = r#"
class ObjectInspector {
    getKeys(obj: object): (string | symbol)[] {
        return Reflect.ownKeys(obj);
    }

    getDescriptor(obj: object, key: PropertyKey): PropertyDescriptor | undefined {
        return Reflect.getOwnPropertyDescriptor(obj, key);
    }

    getEnumerableKeys(obj: object): string[] {
        return Reflect.ownKeys(obj).filter(key => {
            const desc = Reflect.getOwnPropertyDescriptor(obj, key);
            return desc && desc.enumerable;
        }) as string[];
    }

    isWritable(obj: object, key: PropertyKey): boolean {
        const desc = Reflect.getOwnPropertyDescriptor(obj, key);
        return desc ? !!desc.writable : false;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ObjectInspector"),
        "Expected ObjectInspector class: {}",
        output
    );

    // Reflect should be present
    assert!(output.contains("Reflect"), "Expected Reflect: {}", output);

    // Methods should be present
    assert!(
        output.contains("getKeys")
            && output.contains("getDescriptor")
            && output.contains("isWritable"),
        "Expected getKeys, getDescriptor, isWritable methods: {}",
        output
    );
}

#[test]
fn test_class_es5_reflect_define_property() {
    // Reflect.defineProperty and Reflect.getPrototypeOf
    let source = r#"
class PropertyDefiner {
    defineReadonly(obj: object, key: PropertyKey, value: any): boolean {
        return Reflect.defineProperty(obj, key, {
            value,
            writable: false,
            enumerable: true,
            configurable: false
        });
    }

    defineGetter(obj: object, key: PropertyKey, getter: () => any): boolean {
        return Reflect.defineProperty(obj, key, {
            get: getter,
            enumerable: true,
            configurable: true
        });
    }

    getPrototype(obj: object): object | null {
        return Reflect.getPrototypeOf(obj);
    }

    setPrototype(obj: object, proto: object | null): boolean {
        return Reflect.setPrototypeOf(obj, proto);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("PropertyDefiner"),
        "Expected PropertyDefiner class: {}",
        output
    );

    // Reflect should be present
    assert!(output.contains("Reflect"), "Expected Reflect: {}", output);

    // Methods should be present
    assert!(
        output.contains("defineReadonly")
            && output.contains("defineGetter")
            && output.contains("getPrototype"),
        "Expected defineReadonly, defineGetter, getPrototype methods: {}",
        output
    );
}

// ============================================================================
// Object.assign Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_object_assign_basic() {
    // Basic Object.assign usage
    let source = r#"
class ObjectMerger {
    merge<T extends object, U extends object>(target: T, source: U): T & U {
        return Object.assign(target, source);
    }

    extend<T extends object>(target: T, ...sources: object[]): T {
        return Object.assign(target, ...sources);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ObjectMerger"),
        "Expected ObjectMerger class: {}",
        output
    );

    // Object.assign should be present
    assert!(
        output.contains("Object.assign"),
        "Expected Object.assign: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("merge") && output.contains("extend"),
        "Expected merge and extend methods: {}",
        output
    );
}

#[test]
fn test_class_es5_object_assign_defaults() {
    // Object.assign for default values
    let source = r#"
interface Config {
    host: string;
    port: number;
    timeout: number;
}

class ConfigManager {
    private defaults: Config = {
        host: "localhost",
        port: 8080,
        timeout: 5000
    };

    getConfig(overrides: Partial<Config>): Config {
        return Object.assign({}, this.defaults, overrides);
    }

    updateDefaults(updates: Partial<Config>): void {
        Object.assign(this.defaults, updates);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ConfigManager"),
        "Expected ConfigManager class: {}",
        output
    );

    // Object.assign should be present
    assert!(
        output.contains("Object.assign"),
        "Expected Object.assign: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("getConfig") && output.contains("updateDefaults"),
        "Expected getConfig and updateDefaults methods: {}",
        output
    );
}

#[test]
fn test_class_es5_object_assign_clone() {
    // Object.assign for shallow cloning
    let source = r#"
class Cloner<T extends object> {
    shallowClone(obj: T): T {
        return Object.assign({}, obj) as T;
    }

    cloneWithChanges<U extends Partial<T>>(obj: T, changes: U): T {
        return Object.assign({}, obj, changes);
    }

    cloneArray(arr: T[]): T[] {
        return arr.map(item => Object.assign({}, item) as T);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("Cloner"),
        "Expected Cloner class: {}",
        output
    );

    // Object.assign should be present
    assert!(
        output.contains("Object.assign"),
        "Expected Object.assign: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("shallowClone")
            && output.contains("cloneWithChanges")
            && output.contains("cloneArray"),
        "Expected shallowClone, cloneWithChanges, cloneArray methods: {}",
        output
    );
}

#[test]
fn test_class_es5_object_assign_mixin() {
    // Object.assign for mixin pattern
    let source = r#"
interface Disposable {
    dispose(): void;
}

interface Activatable {
    activate(): void;
    deactivate(): void;
}

class MixinBuilder {
    applyMixins<T extends object>(target: T, ...mixins: object[]): T & Disposable & Activatable {
        return Object.assign(target, ...mixins) as T & Disposable & Activatable;
    }

    createWithMixins<T extends object>(base: T): T & Disposable {
        const disposable: Disposable = {
            dispose() { console.log("disposed"); }
        };
        return Object.assign({}, base, disposable);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("MixinBuilder"),
        "Expected MixinBuilder class: {}",
        output
    );

    // Object.assign should be present
    assert!(
        output.contains("Object.assign"),
        "Expected Object.assign: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("applyMixins") && output.contains("createWithMixins"),
        "Expected applyMixins and createWithMixins methods: {}",
        output
    );
}

#[test]
fn test_class_es5_object_assign_constructor() {
    // Object.assign in constructor
    let source = r#"
interface Options {
    name: string;
    value: number;
    enabled: boolean;
}

class Component {
    name: string;
    value: number;
    enabled: boolean;

    constructor(options: Partial<Options>) {
        const defaults: Options = {
            name: "default",
            value: 0,
            enabled: true
        };
        Object.assign(this, defaults, options);
        this.name = this.name;
        this.value = this.value;
        this.enabled = this.enabled;
    }

    getState(): Options {
        return Object.assign({}, { name: this.name, value: this.value, enabled: this.enabled });
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("Component"),
        "Expected Component class: {}",
        output
    );

    // Object.assign should be present
    assert!(
        output.contains("Object.assign"),
        "Expected Object.assign: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("getState"),
        "Expected getState method: {}",
        output
    );
}

#[test]
fn test_class_es5_object_assign_immutable() {
    // Object.assign for immutable update pattern
    let source = r#"
interface State {
    count: number;
    items: string[];
    metadata: Record<string, any>;
}

class StateManager {
    private state: State;

    constructor(initial: State) {
        this.state = Object.assign({}, initial);
    }

    updateCount(count: number): State {
        this.state = Object.assign({}, this.state, { count });
        return this.state;
    }

    addItem(item: string): State {
        const items = [...this.state.items, item];
        this.state = Object.assign({}, this.state, { items });
        return this.state;
    }

    setMetadata(key: string, value: any): State {
        const metadata = Object.assign({}, this.state.metadata, { [key]: value });
        this.state = Object.assign({}, this.state, { metadata });
        return this.state;
    }

    getState(): State {
        return Object.assign({}, this.state);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("StateManager"),
        "Expected StateManager class: {}",
        output
    );

    // Object.assign should be present
    assert!(
        output.contains("Object.assign"),
        "Expected Object.assign: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("updateCount")
            && output.contains("addItem")
            && output.contains("setMetadata"),
        "Expected updateCount, addItem, setMetadata methods: {}",
        output
    );
}

// ============================================================================
// Promise Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_promise_resolve_reject() {
    // Promise.resolve and Promise.reject usage
    let source = r#"
class PromiseFactory<T> {
    resolve(value: T): Promise<T> {
        return Promise.resolve(value);
    }

    reject(reason: any): Promise<never> {
        return Promise.reject(reason);
    }

    wrap(value: T | Promise<T>): Promise<T> {
        return Promise.resolve(value);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("PromiseFactory"),
        "Expected PromiseFactory class: {}",
        output
    );

    // Promise should be present
    assert!(output.contains("Promise"), "Expected Promise: {}", output);

    // Methods should be present
    assert!(
        output.contains("resolve") && output.contains("reject") && output.contains("wrap"),
        "Expected resolve, reject, wrap methods: {}",
        output
    );
}

#[test]
fn test_class_es5_promise_all() {
    // Promise.all usage
    let source = r#"
class BatchProcessor<T> {
    processAll(items: T[], processor: (item: T) => Promise<T>): Promise<T[]> {
        const promises = items.map(item => processor(item));
        return Promise.all(promises);
    }

    fetchAll(urls: string[]): Promise<Response[]> {
        return Promise.all(urls.map(url => fetch(url)));
    }

    parallel<R>(...promises: Promise<R>[]): Promise<R[]> {
        return Promise.all(promises);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("BatchProcessor"),
        "Expected BatchProcessor class: {}",
        output
    );

    // Promise.all should be present
    assert!(output.contains("Promise"), "Expected Promise: {}", output);

    // Methods should be present
    assert!(
        output.contains("processAll") && output.contains("fetchAll") && output.contains("parallel"),
        "Expected processAll, fetchAll, parallel methods: {}",
        output
    );
}

#[test]
fn test_class_es5_promise_race() {
    // Promise.race usage
    let source = r#"
class RaceRunner<T> {
    race(promises: Promise<T>[]): Promise<T> {
        return Promise.race(promises);
    }

    timeout<R>(promise: Promise<R>, ms: number): Promise<R> {
        const timeoutPromise = new Promise<never>((_, reject) => {
            setTimeout(() => reject(new Error("Timeout")), ms);
        });
        return Promise.race([promise, timeoutPromise]);
    }

    first<R>(...promises: Promise<R>[]): Promise<R> {
        return Promise.race(promises);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("RaceRunner"),
        "Expected RaceRunner class: {}",
        output
    );

    // Promise.race should be present
    assert!(output.contains("Promise"), "Expected Promise: {}", output);

    // Methods should be present
    assert!(
        output.contains("race") && output.contains("timeout") && output.contains("first"),
        "Expected race, timeout, first methods: {}",
        output
    );
}

#[test]
fn test_class_es5_promise_chaining() {
    // Promise chaining with then/catch/finally
    let source = r#"
class DataFetcher {
    private baseUrl: string;

    constructor(baseUrl: string) {
        this.baseUrl = baseUrl;
    }

    fetch<T>(path: string): Promise<T> {
        return fetch(this.baseUrl + path)
            .then(response => response.json())
            .then(data => data as T)
            .catch(error => {
                console.error("Fetch error:", error);
                throw error;
            });
    }

    fetchWithRetry<T>(path: string, retries: number): Promise<T> {
        return this.fetch<T>(path).catch(error => {
            if (retries > 0) {
                return this.fetchWithRetry<T>(path, retries - 1);
            }
            throw error;
        });
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("DataFetcher"),
        "Expected DataFetcher class: {}",
        output
    );

    // Promise methods should be present
    assert!(
        output.contains("then") || output.contains("catch"),
        "Expected then or catch: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("fetch") && output.contains("fetchWithRetry"),
        "Expected fetch and fetchWithRetry methods: {}",
        output
    );
}

#[test]
fn test_class_es5_promise_allsettled() {
    // Promise.allSettled usage
    let source = r#"
interface SettledResult<T> {
    status: "fulfilled" | "rejected";
    value?: T;
    reason?: any;
}

class SettledProcessor<T> {
    processAllSettled(promises: Promise<T>[]): Promise<SettledResult<T>[]> {
        return Promise.allSettled(promises);
    }

    getSuccessful(promises: Promise<T>[]): Promise<T[]> {
        return Promise.allSettled(promises).then(results =>
            results
                .filter(r => r.status === "fulfilled")
                .map(r => (r as PromiseFulfilledResult<T>).value)
        );
    }

    getFailed(promises: Promise<T>[]): Promise<any[]> {
        return Promise.allSettled(promises).then(results =>
            results
                .filter(r => r.status === "rejected")
                .map(r => (r as PromiseRejectedResult).reason)
        );
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("SettledProcessor"),
        "Expected SettledProcessor class: {}",
        output
    );

    // Promise should be present
    assert!(output.contains("Promise"), "Expected Promise: {}", output);

    // Methods should be present
    assert!(
        output.contains("processAllSettled")
            && output.contains("getSuccessful")
            && output.contains("getFailed"),
        "Expected processAllSettled, getSuccessful, getFailed methods: {}",
        output
    );
}

#[test]
fn test_class_es5_promise_wrapper() {
    // Custom Promise wrapper class
    let source = r#"
class Deferred<T> {
    promise: Promise<T>;
    private resolveFunc!: (value: T) => void;
    private rejectFunc!: (reason: any) => void;

    constructor() {
        this.promise = new Promise<T>((resolve, reject) => {
            this.resolveFunc = resolve;
            this.rejectFunc = reject;
        });
    }

    resolve(value: T): void {
        this.resolveFunc(value);
    }

    reject(reason: any): void {
        this.rejectFunc(reason);
    }

    then<R>(onFulfilled: (value: T) => R): Promise<R> {
        return this.promise.then(onFulfilled);
    }

    catch(onRejected: (reason: any) => any): Promise<T> {
        return this.promise.catch(onRejected);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("Deferred"),
        "Expected Deferred class: {}",
        output
    );

    // Promise constructor should be present
    assert!(output.contains("Promise"), "Expected Promise: {}", output);

    // Methods should be present
    assert!(
        output.contains("resolve") && output.contains("reject") && output.contains("then"),
        "Expected resolve, reject, then methods: {}",
        output
    );
}

// ============================================================================
// Array.from Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_array_from_basic() {
    // Basic Array.from with iterable
    let source = r#"
class ArrayConverter<T> {
    fromIterable(iterable: Iterable<T>): T[] {
        return Array.from(iterable);
    }

    fromString(str: string): string[] {
        return Array.from(str);
    }

    fromSet(set: Set<T>): T[] {
        return Array.from(set);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ArrayConverter"),
        "Expected ArrayConverter class: {}",
        output
    );

    // Array.from should be present
    assert!(
        output.contains("Array.from"),
        "Expected Array.from: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("fromIterable")
            && output.contains("fromString")
            && output.contains("fromSet"),
        "Expected fromIterable, fromString, fromSet methods: {}",
        output
    );
}

#[test]
fn test_class_es5_array_from_map_function() {
    // Array.from with map function
    let source = r#"
class ArrayMapper<T, U> {
    mapFrom(iterable: Iterable<T>, mapFn: (item: T, index: number) => U): U[] {
        return Array.from(iterable, mapFn);
    }

    doubleNumbers(numbers: Iterable<number>): number[] {
        return Array.from(numbers, x => x * 2);
    }

    indexedMap<R>(items: Iterable<T>, transform: (item: T, idx: number) => R): R[] {
        return Array.from(items, (item, idx) => transform(item, idx));
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ArrayMapper"),
        "Expected ArrayMapper class: {}",
        output
    );

    // Array.from should be present
    assert!(
        output.contains("Array.from"),
        "Expected Array.from: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("mapFrom")
            && output.contains("doubleNumbers")
            && output.contains("indexedMap"),
        "Expected mapFrom, doubleNumbers, indexedMap methods: {}",
        output
    );
}

#[test]
fn test_class_es5_array_from_array_like() {
    // Array.from with array-like objects
    let source = r#"
interface ArrayLike<T> {
    length: number;
    [index: number]: T;
}

class ArrayLikeConverter {
    fromArrayLike<T>(arrayLike: ArrayLike<T>): T[] {
        return Array.from(arrayLike);
    }

    fromArguments(args: IArguments): any[] {
        return Array.from(args);
    }

    fromNodeList(nodeList: { length: number; item(index: number): any }): any[] {
        return Array.from({ length: nodeList.length }, (_, i) => nodeList.item(i));
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ArrayLikeConverter"),
        "Expected ArrayLikeConverter class: {}",
        output
    );

    // Array.from should be present
    assert!(
        output.contains("Array.from"),
        "Expected Array.from: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("fromArrayLike")
            && output.contains("fromArguments")
            && output.contains("fromNodeList"),
        "Expected fromArrayLike, fromArguments, fromNodeList methods: {}",
        output
    );
}

#[test]
fn test_class_es5_array_from_collections() {
    // Array.from with Set and Map
    let source = r#"
class CollectionConverter<K, V> {
    setToArray(set: Set<V>): V[] {
        return Array.from(set);
    }

    mapKeysToArray(map: Map<K, V>): K[] {
        return Array.from(map.keys());
    }

    mapValuesToArray(map: Map<K, V>): V[] {
        return Array.from(map.values());
    }

    mapEntriesToArray(map: Map<K, V>): [K, V][] {
        return Array.from(map.entries());
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("CollectionConverter"),
        "Expected CollectionConverter class: {}",
        output
    );

    // Array.from should be present
    assert!(
        output.contains("Array.from"),
        "Expected Array.from: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("setToArray")
            && output.contains("mapKeysToArray")
            && output.contains("mapValuesToArray"),
        "Expected setToArray, mapKeysToArray, mapValuesToArray methods: {}",
        output
    );
}

#[test]
fn test_class_es5_array_from_generator() {
    // Array.from with generator
    let source = r#"
class GeneratorConverter {
    *range(start: number, end: number): Generator<number> {
        for (let i = start; i < end; i++) {
            yield i;
        }
    }

    rangeToArray(start: number, end: number): number[] {
        return Array.from(this.range(start, end));
    }

    generatorToArray<T>(gen: Generator<T>): T[] {
        return Array.from(gen);
    }

    iteratorToArray<T>(iterator: Iterator<T>): T[] {
        const result: T[] = [];
        let next = iterator.next();
        while (!next.done) {
            result.push(next.value);
            next = iterator.next();
        }
        return result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("GeneratorConverter"),
        "Expected GeneratorConverter class: {}",
        output
    );

    // Array.from should be present
    assert!(
        output.contains("Array.from"),
        "Expected Array.from: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("range")
            && output.contains("rangeToArray")
            && output.contains("generatorToArray"),
        "Expected range, rangeToArray, generatorToArray methods: {}",
        output
    );
}

#[test]
fn test_class_es5_array_from_length() {
    // Array.from with length property for creating arrays
    let source = r#"
class ArrayFactory {
    createWithLength(length: number): undefined[] {
        return Array.from({ length });
    }

    createSequence(length: number): number[] {
        return Array.from({ length }, (_, i) => i);
    }

    createFilled<T>(length: number, value: T): T[] {
        return Array.from({ length }, () => value);
    }

    createMatrix(rows: number, cols: number): number[][] {
        return Array.from({ length: rows }, () =>
            Array.from({ length: cols }, () => 0)
        );
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ArrayFactory"),
        "Expected ArrayFactory class: {}",
        output
    );

    // Array.from should be present
    assert!(
        output.contains("Array.from"),
        "Expected Array.from: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("createWithLength")
            && output.contains("createSequence")
            && output.contains("createFilled"),
        "Expected createWithLength, createSequence, createFilled methods: {}",
        output
    );
}

// ============================================================================
// Map/Set Collection Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_map_basic() {
    // Basic Map operations
    let source = r#"
class MapWrapper<K, V> {
    private map: Map<K, V> = new Map();

    set(key: K, value: V): this {
        this.map.set(key, value);
        return this;
    }

    get(key: K): V | undefined {
        return this.map.get(key);
    }

    has(key: K): boolean {
        return this.map.has(key);
    }

    delete(key: K): boolean {
        return this.map.delete(key);
    }

    clear(): void {
        this.map.clear();
    }

    get size(): number {
        return this.map.size;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("MapWrapper"),
        "Expected MapWrapper class: {}",
        output
    );

    // Map should be present
    assert!(output.contains("Map"), "Expected Map: {}", output);

    // Methods should be present
    assert!(
        output.contains("set") && output.contains("get") && output.contains("has"),
        "Expected set, get, has methods: {}",
        output
    );
}

#[test]
fn test_class_es5_map_iteration() {
    // Map iteration patterns
    let source = r#"
class MapIterator<K, V> {
    private data: Map<K, V> = new Map();

    keys(): K[] {
        return Array.from(this.data.keys());
    }

    values(): V[] {
        return Array.from(this.data.values());
    }

    entries(): [K, V][] {
        return Array.from(this.data.entries());
    }

    forEach(callback: (value: V, key: K) => void): void {
        this.data.forEach((v, k) => callback(v, k));
    }

    map<R>(transform: (value: V, key: K) => R): R[] {
        const result: R[] = [];
        this.data.forEach((v, k) => result.push(transform(v, k)));
        return result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("MapIterator"),
        "Expected MapIterator class: {}",
        output
    );

    // Map should be present
    assert!(output.contains("Map"), "Expected Map: {}", output);

    // Methods should be present
    assert!(
        output.contains("keys") && output.contains("values") && output.contains("entries"),
        "Expected keys, values, entries methods: {}",
        output
    );
}

#[test]
fn test_class_es5_set_basic() {
    // Basic Set operations
    let source = r#"
class SetWrapper<T> {
    private set: Set<T> = new Set();

    add(value: T): this {
        this.set.add(value);
        return this;
    }

    has(value: T): boolean {
        return this.set.has(value);
    }

    delete(value: T): boolean {
        return this.set.delete(value);
    }

    clear(): void {
        this.set.clear();
    }

    toArray(): T[] {
        return Array.from(this.set);
    }

    get size(): number {
        return this.set.size;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("SetWrapper"),
        "Expected SetWrapper class: {}",
        output
    );

    // Set should be present
    assert!(output.contains("Set"), "Expected Set: {}", output);

    // Methods should be present
    assert!(
        output.contains("add") && output.contains("has") && output.contains("toArray"),
        "Expected add, has, toArray methods: {}",
        output
    );
}

#[test]
fn test_class_es5_weakmap_usage() {
    // WeakMap for private data pattern
    let source = r#"
const privateData = new WeakMap<object, Record<string, any>>();

class PrivateStore {
    constructor() {
        privateData.set(this, {});
    }

    setPrivate(key: string, value: any): void {
        const data = privateData.get(this);
        if (data) {
            data[key] = value;
        }
    }

    getPrivate(key: string): any {
        const data = privateData.get(this);
        return data ? data[key] : undefined;
    }

    hasPrivate(key: string): boolean {
        const data = privateData.get(this);
        return data ? key in data : false;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("PrivateStore"),
        "Expected PrivateStore class: {}",
        output
    );

    // WeakMap should be present
    assert!(output.contains("WeakMap"), "Expected WeakMap: {}", output);

    // Methods should be present
    assert!(
        output.contains("setPrivate")
            && output.contains("getPrivate")
            && output.contains("hasPrivate"),
        "Expected setPrivate, getPrivate, hasPrivate methods: {}",
        output
    );
}

#[test]
fn test_class_es5_weakset_usage() {
    // WeakSet for tracking objects
    let source = r#"
class ObjectTracker {
    private tracked: WeakSet<object> = new WeakSet();

    track(obj: object): void {
        this.tracked.add(obj);
    }

    isTracked(obj: object): boolean {
        return this.tracked.has(obj);
    }

    untrack(obj: object): boolean {
        return this.tracked.delete(obj);
    }

    trackMultiple(...objects: object[]): void {
        for (const obj of objects) {
            this.tracked.add(obj);
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(
        output.contains("ObjectTracker"),
        "Expected ObjectTracker class: {}",
        output
    );

    // WeakSet should be present
    assert!(output.contains("WeakSet"), "Expected WeakSet: {}", output);

    // Methods should be present
    assert!(
        output.contains("track") && output.contains("isTracked") && output.contains("untrack"),
        "Expected track, isTracked, untrack methods: {}",
        output
    );
}

#[test]
fn test_class_es5_map_set_combined() {
    // Combined Map and Set patterns
    let source = r#"
class Graph<T> {
    private nodes: Set<T> = new Set();
    private edges: Map<T, Set<T>> = new Map();

    addNode(node: T): void {
        this.nodes.add(node);
        if (!this.edges.has(node)) {
            this.edges.set(node, new Set());
        }
    }

    addEdge(from: T, to: T): void {
        this.addNode(from);
        this.addNode(to);
        this.edges.get(from)!.add(to);
    }

    getNeighbors(node: T): T[] {
        const neighbors = this.edges.get(node);
        return neighbors ? Array.from(neighbors) : [];
    }

    hasNode(node: T): boolean {
        return this.nodes.has(node);
    }

    hasEdge(from: T, to: T): boolean {
        const neighbors = this.edges.get(from);
        return neighbors ? neighbors.has(to) : false;
    }

    getNodeCount(): number {
        return this.nodes.size;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be emitted
    assert!(output.contains("Graph"), "Expected Graph class: {}", output);

    // Map and Set should be present
    assert!(
        output.contains("Map") && output.contains("Set"),
        "Expected Map and Set: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("addNode") && output.contains("addEdge") && output.contains("getNeighbors"),
        "Expected addNode, addEdge, getNeighbors methods: {}",
        output
    );
}

// ============================================================================
// Symbol.asyncIterator Tests
// ============================================================================

#[test]
fn test_class_es5_symbol_async_iterator_basic() {
    // Basic async iterator implementation
    let source = r#"
class AsyncRange {
    private start: number;
    private end: number;

    constructor(start: number, end: number) {
        this.start = start;
        this.end = end;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<number> {
        for (let i = this.start; i <= this.end; i++) {
            yield i;
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function AsyncRange"),
        "Expected function declaration: {}",
        output
    );

    // asyncIterator symbol should be referenced
    assert!(
        output.contains("asyncIterator") || output.contains("Symbol"),
        "Expected asyncIterator reference: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_async_iterator_with_delay() {
    // Async iterator with actual async behavior
    let source = r#"
class DelayedSequence<T> {
    private items: T[];
    private delayMs: number;

    constructor(items: T[], delayMs: number) {
        this.items = items;
        this.delayMs = delayMs;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<T> {
        for (const item of this.items) {
            await this.delay(this.delayMs);
            yield item;
        }
    }

    private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function DelayedSequence"),
        "Expected function declaration: {}",
        output
    );

    // delay method should be present
    assert!(
        output.contains("delay"),
        "Expected delay method: {}",
        output
    );

    // Promise should be referenced
    assert!(
        output.contains("Promise"),
        "Expected Promise reference: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_async_iterator_paginated() {
    // Async iterator for paginated data fetching
    let source = r#"
class PaginatedFetcher<T> {
    private baseUrl: string;
    private pageSize: number;

    constructor(baseUrl: string, pageSize: number) {
        this.baseUrl = baseUrl;
        this.pageSize = pageSize;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<T[]> {
        let page = 0;
        let hasMore = true;

        while (hasMore) {
            const data = await this.fetchPage(page);
            if (data.length < this.pageSize) {
                hasMore = false;
            }
            if (data.length > 0) {
                yield data;
            }
            page++;
        }
    }

    private async fetchPage(page: number): Promise<T[]> {
        const response = await fetch(this.baseUrl + "?page=" + page);
        return response.json();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function PaginatedFetcher"),
        "Expected function declaration: {}",
        output
    );

    // fetchPage method should be present
    assert!(
        output.contains("fetchPage"),
        "Expected fetchPage method: {}",
        output
    );

    // fetch should be referenced
    assert!(
        output.contains("fetch"),
        "Expected fetch reference: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_async_iterator_with_inheritance() {
    // Async iterator with class inheritance
    let source = r#"
abstract class BaseAsyncCollection<T> {
    protected items: T[] = [];

    abstract [Symbol.asyncIterator](): AsyncGenerator<T>;

    add(item: T): void {
        this.items.push(item);
    }
}

class AsyncQueue<T> extends BaseAsyncCollection<T> {
    async *[Symbol.asyncIterator](): AsyncGenerator<T> {
        while (this.items.length > 0) {
            const item = this.items.shift();
            if (item !== undefined) {
                yield item;
            }
        }
    }

    enqueue(item: T): void {
        this.add(item);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be present
    assert!(
        output.contains("BaseAsyncCollection") && output.contains("AsyncQueue"),
        "Expected both classes: {}",
        output
    );

    // Inheritance pattern should be present
    assert!(
        output.contains("__extends") || output.contains("prototype"),
        "Expected inheritance pattern: {}",
        output
    );

    // enqueue method should be present
    assert!(
        output.contains("enqueue"),
        "Expected enqueue method: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_async_iterator_stream_like() {
    // Stream-like async iterator with both sync and async iteration
    let source = r#"
class DataStream<T> {
    private buffer: T[] = [];
    private closed: boolean = false;

    *[Symbol.iterator](): Generator<T> {
        yield* this.buffer;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<T> {
        for (const item of this.buffer) {
            yield item;
        }
    }

    push(item: T): void {
        if (!this.closed) {
            this.buffer.push(item);
        }
    }

    close(): void {
        this.closed = true;
    }

    get length(): number {
        return this.buffer.length;
    }

    get isClosed(): boolean {
        return this.closed;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function DataStream"),
        "Expected function declaration: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("push") && output.contains("close"),
        "Expected methods: {}",
        output
    );

    // Properties should be present
    assert!(
        output.contains("length") && output.contains("isClosed"),
        "Expected properties: {}",
        output
    );
}

// ============================================================================
// Symbol.match Tests
// ============================================================================

#[test]
fn test_class_es5_symbol_match_basic() {
    // Basic Symbol.match implementation for custom matcher
    let source = r#"
class WordMatcher {
    private pattern: string;

    constructor(pattern: string) {
        this.pattern = pattern;
    }

    [Symbol.match](str: string): RegExpMatchArray | null {
        const idx = str.indexOf(this.pattern);
        if (idx === -1) return null;
        const result: RegExpMatchArray = [this.pattern] as RegExpMatchArray;
        result.index = idx;
        result.input = str;
        return result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function WordMatcher"),
        "Expected function declaration: {}",
        output
    );

    // Symbol.match should be referenced
    assert!(
        output.contains("match") || output.contains("Symbol"),
        "Expected Symbol.match reference: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_match_with_flags() {
    // Symbol.match with flags property like RegExp
    let source = r#"
class CaseInsensitiveMatcher {
    private term: string;
    readonly flags: string = "i";

    constructor(term: string) {
        this.term = term.toLowerCase();
    }

    [Symbol.match](str: string): RegExpMatchArray | null {
        const lowerStr = str.toLowerCase();
        const idx = lowerStr.indexOf(this.term);
        if (idx === -1) return null;
        const matched = str.substring(idx, idx + this.term.length);
        const result: RegExpMatchArray = [matched] as RegExpMatchArray;
        result.index = idx;
        result.input = str;
        return result;
    }

    get source(): string {
        return this.term;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function CaseInsensitiveMatcher"),
        "Expected function declaration: {}",
        output
    );

    // Flags property should be present
    assert!(
        output.contains("flags"),
        "Expected flags property: {}",
        output
    );

    // Source getter should be present
    assert!(
        output.contains("source") || output.contains("defineProperty"),
        "Expected source getter: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_match_global() {
    // Symbol.match returning all matches (global flag behavior)
    let source = r#"
class GlobalMatcher {
    private pattern: string;
    readonly global: boolean = true;

    constructor(pattern: string) {
        this.pattern = pattern;
    }

    [Symbol.match](str: string): string[] | null {
        const matches: string[] = [];
        let idx = 0;
        while ((idx = str.indexOf(this.pattern, idx)) !== -1) {
            matches.push(this.pattern);
            idx += this.pattern.length;
        }
        return matches.length > 0 ? matches : null;
    }

    get lastIndex(): number {
        return 0;
    }

    set lastIndex(value: number) {
        // no-op for this implementation
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function GlobalMatcher"),
        "Expected function declaration: {}",
        output
    );

    // Global property should be present
    assert!(
        output.contains("global"),
        "Expected global property: {}",
        output
    );

    // lastIndex getter/setter should be present
    assert!(
        output.contains("lastIndex"),
        "Expected lastIndex accessor: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_match_with_inheritance() {
    // Symbol.match with class inheritance
    let source = r#"
abstract class BaseMatcher {
    abstract readonly pattern: string;

    abstract [Symbol.match](str: string): RegExpMatchArray | null;

    test(str: string): boolean {
        return this[Symbol.match](str) !== null;
    }
}

class PrefixMatcher extends BaseMatcher {
    readonly pattern: string;

    constructor(prefix: string) {
        super();
        this.pattern = prefix;
    }

    [Symbol.match](str: string): RegExpMatchArray | null {
        if (str.startsWith(this.pattern)) {
            const result: RegExpMatchArray = [this.pattern] as RegExpMatchArray;
            result.index = 0;
            result.input = str;
            return result;
        }
        return null;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be converted
    assert!(
        output.contains("function BaseMatcher"),
        "Expected BaseMatcher function: {}",
        output
    );
    assert!(
        output.contains("function PrefixMatcher"),
        "Expected PrefixMatcher function: {}",
        output
    );

    // Inheritance should be set up
    assert!(
        output.contains("__extends") || output.contains("extends"),
        "Expected inheritance: {}",
        output
    );

    // Test method should be present
    assert!(output.contains("test"), "Expected test method: {}", output);
}

#[test]
fn test_class_es5_symbol_match_combined_protocols() {
    // Class implementing multiple string protocol symbols
    let source = r#"
class CustomPattern {
    private pattern: string;

    constructor(pattern: string) {
        this.pattern = pattern;
    }

    [Symbol.match](str: string): RegExpMatchArray | null {
        const idx = str.indexOf(this.pattern);
        if (idx === -1) return null;
        const result: RegExpMatchArray = [this.pattern] as RegExpMatchArray;
        result.index = idx;
        result.input = str;
        return result;
    }

    [Symbol.replace](str: string, replacement: string): string {
        return str.split(this.pattern).join(replacement);
    }

    [Symbol.search](str: string): number {
        return str.indexOf(this.pattern);
    }

    [Symbol.split](str: string, limit?: number): string[] {
        return str.split(this.pattern, limit);
    }

    toString(): string {
        return this.pattern;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function CustomPattern"),
        "Expected function declaration: {}",
        output
    );

    // toString method should be present
    assert!(
        output.contains("toString"),
        "Expected toString method: {}",
        output
    );

    // Multiple Symbol methods should be handled
    assert!(
        output.contains("Symbol") || output.contains("prototype"),
        "Expected Symbol methods on prototype: {}",
        output
    );
}

// ============================================================================
// Symbol.replace Tests
// ============================================================================

#[test]
fn test_class_es5_symbol_replace_basic() {
    // Basic Symbol.replace implementation for custom replacer
    let source = r#"
class SimpleReplacer {
    private searchValue: string;
    private replaceValue: string;

    constructor(search: string, replace: string) {
        this.searchValue = search;
        this.replaceValue = replace;
    }

    [Symbol.replace](str: string): string {
        return str.split(this.searchValue).join(this.replaceValue);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function SimpleReplacer"),
        "Expected function declaration: {}",
        output
    );

    // Symbol.replace should be referenced
    assert!(
        output.contains("replace") || output.contains("Symbol"),
        "Expected Symbol.replace reference: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_replace_with_function() {
    // Symbol.replace with replacer function parameter
    let source = r#"
class FunctionReplacer {
    private pattern: string;

    constructor(pattern: string) {
        this.pattern = pattern;
    }

    [Symbol.replace](str: string, replacer: (match: string, offset: number, original: string) => string): string {
        let result = str;
        let idx = 0;
        while ((idx = result.indexOf(this.pattern, idx)) !== -1) {
            const replacement = replacer(this.pattern, idx, str);
            result = result.substring(0, idx) + replacement + result.substring(idx + this.pattern.length);
            idx += replacement.length;
        }
        return result;
    }

    get source(): string {
        return this.pattern;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function FunctionReplacer"),
        "Expected function declaration: {}",
        output
    );

    // Source getter should be present
    assert!(
        output.contains("source") || output.contains("defineProperty"),
        "Expected source getter: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_replace_global() {
    // Symbol.replace with global flag behavior
    let source = r#"
class GlobalReplacer {
    private pattern: string;
    readonly global: boolean = true;
    readonly flags: string = "g";

    constructor(pattern: string) {
        this.pattern = pattern;
    }

    [Symbol.replace](str: string, replacement: string): string {
        return str.split(this.pattern).join(replacement);
    }

    get lastIndex(): number {
        return 0;
    }

    set lastIndex(value: number) {
        // Reset behavior
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function GlobalReplacer"),
        "Expected function declaration: {}",
        output
    );

    // Global and flags properties should be present
    assert!(
        output.contains("global") && output.contains("flags"),
        "Expected global and flags properties: {}",
        output
    );

    // lastIndex accessor should be present
    assert!(
        output.contains("lastIndex"),
        "Expected lastIndex accessor: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_replace_with_inheritance() {
    // Symbol.replace with class inheritance
    let source = r#"
abstract class BaseReplacer {
    abstract readonly pattern: string;

    abstract [Symbol.replace](str: string, replacement: string): string;

    replaceAll(str: string, replacement: string): string {
        let result = str;
        let prev = "";
        while (result !== prev) {
            prev = result;
            result = this[Symbol.replace](result, replacement);
        }
        return result;
    }
}

class CasePreservingReplacer extends BaseReplacer {
    readonly pattern: string;

    constructor(pattern: string) {
        super();
        this.pattern = pattern;
    }

    [Symbol.replace](str: string, replacement: string): string {
        const idx = str.toLowerCase().indexOf(this.pattern.toLowerCase());
        if (idx === -1) return str;
        const original = str.substring(idx, idx + this.pattern.length);
        const preserved = this.preserveCase(original, replacement);
        return str.substring(0, idx) + preserved + str.substring(idx + this.pattern.length);
    }

    private preserveCase(original: string, replacement: string): string {
        if (original === original.toUpperCase()) {
            return replacement.toUpperCase();
        }
        if (original[0] === original[0].toUpperCase()) {
            return replacement[0].toUpperCase() + replacement.slice(1);
        }
        return replacement;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be converted
    assert!(
        output.contains("function BaseReplacer"),
        "Expected BaseReplacer function: {}",
        output
    );
    assert!(
        output.contains("function CasePreservingReplacer"),
        "Expected CasePreservingReplacer function: {}",
        output
    );

    // Inheritance should be set up
    assert!(
        output.contains("__extends") || output.contains("extends"),
        "Expected inheritance: {}",
        output
    );

    // replaceAll method should be present
    assert!(
        output.contains("replaceAll"),
        "Expected replaceAll method: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_replace_template() {
    // Symbol.replace with template string support
    let source = r#"
class TemplateReplacer {
    private pattern: string;
    private captureGroups: Map<string, string> = new Map();

    constructor(pattern: string) {
        this.pattern = pattern;
    }

    [Symbol.replace](str: string, template: string): string {
        const idx = str.indexOf(this.pattern);
        if (idx === -1) return str;

        let result = template;
        result = result.replace("$&", this.pattern);
        result = result.replace("$\`", str.substring(0, idx));
        result = result.replace("$'", str.substring(idx + this.pattern.length));

        return str.substring(0, idx) + result + str.substring(idx + this.pattern.length);
    }

    addCapture(name: string, value: string): void {
        this.captureGroups.set(name, value);
    }

    getCapture(name: string): string | undefined {
        return this.captureGroups.get(name);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function TemplateReplacer"),
        "Expected function declaration: {}",
        output
    );

    // Helper methods should be present
    assert!(
        output.contains("addCapture") && output.contains("getCapture"),
        "Expected capture methods: {}",
        output
    );

    // Map usage should be preserved
    assert!(output.contains("Map"), "Expected Map usage: {}", output);
}

// ============================================================================
// Symbol.search Tests
// ============================================================================

#[test]
fn test_class_es5_symbol_search_basic() {
    // Basic Symbol.search implementation for custom searcher
    let source = r#"
class SubstringSearcher {
    private needle: string;

    constructor(needle: string) {
        this.needle = needle;
    }

    [Symbol.search](str: string): number {
        return str.indexOf(this.needle);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function SubstringSearcher"),
        "Expected function declaration: {}",
        output
    );

    // Symbol.search should be referenced
    assert!(
        output.contains("search") || output.contains("Symbol"),
        "Expected Symbol.search reference: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_search_case_insensitive() {
    // Symbol.search with case-insensitive matching
    let source = r#"
class CaseInsensitiveSearcher {
    private pattern: string;
    readonly flags: string = "i";

    constructor(pattern: string) {
        this.pattern = pattern.toLowerCase();
    }

    [Symbol.search](str: string): number {
        return str.toLowerCase().indexOf(this.pattern);
    }

    get source(): string {
        return this.pattern;
    }

    get ignoreCase(): boolean {
        return true;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function CaseInsensitiveSearcher"),
        "Expected function declaration: {}",
        output
    );

    // Flags property should be present
    assert!(
        output.contains("flags"),
        "Expected flags property: {}",
        output
    );

    // Getters should be present
    assert!(
        output.contains("source") && output.contains("ignoreCase"),
        "Expected source and ignoreCase getters: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_search_last_index() {
    // Symbol.search returning last occurrence
    let source = r#"
class LastIndexSearcher {
    private pattern: string;

    constructor(pattern: string) {
        this.pattern = pattern;
    }

    [Symbol.search](str: string): number {
        return str.lastIndexOf(this.pattern);
    }

    searchFirst(str: string): number {
        return str.indexOf(this.pattern);
    }

    searchAll(str: string): number[] {
        const indices: number[] = [];
        let idx = 0;
        while ((idx = str.indexOf(this.pattern, idx)) !== -1) {
            indices.push(idx);
            idx += 1;
        }
        return indices;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function LastIndexSearcher"),
        "Expected function declaration: {}",
        output
    );

    // Helper methods should be present
    assert!(
        output.contains("searchFirst") && output.contains("searchAll"),
        "Expected helper methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_search_with_inheritance() {
    // Symbol.search with class inheritance
    let source = r#"
abstract class BaseSearcher {
    abstract readonly pattern: string;

    abstract [Symbol.search](str: string): number;

    contains(str: string): boolean {
        return this[Symbol.search](str) !== -1;
    }

    startsWith(str: string): boolean {
        return this[Symbol.search](str) === 0;
    }
}

class WordBoundarySearcher extends BaseSearcher {
    readonly pattern: string;

    constructor(word: string) {
        super();
        this.pattern = word;
    }

    [Symbol.search](str: string): number {
        const words = str.split(/\s+/);
        let position = 0;
        for (const word of words) {
            if (word === this.pattern) {
                return position;
            }
            position += word.length + 1;
        }
        return -1;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be converted
    assert!(
        output.contains("function BaseSearcher"),
        "Expected BaseSearcher function: {}",
        output
    );
    assert!(
        output.contains("function WordBoundarySearcher"),
        "Expected WordBoundarySearcher function: {}",
        output
    );

    // Inheritance should be set up
    assert!(
        output.contains("__extends") || output.contains("extends"),
        "Expected inheritance: {}",
        output
    );

    // Helper methods should be present
    assert!(
        output.contains("contains") && output.contains("startsWith"),
        "Expected helper methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_search_multiple_patterns() {
    // Symbol.search with multiple pattern support
    let source = r#"
class MultiPatternSearcher {
    private patterns: string[];

    constructor(...patterns: string[]) {
        this.patterns = patterns;
    }

    [Symbol.search](str: string): number {
        let earliest = -1;
        for (const pattern of this.patterns) {
            const idx = str.indexOf(pattern);
            if (idx !== -1 && (earliest === -1 || idx < earliest)) {
                earliest = idx;
            }
        }
        return earliest;
    }

    addPattern(pattern: string): void {
        this.patterns.push(pattern);
    }

    removePattern(pattern: string): boolean {
        const idx = this.patterns.indexOf(pattern);
        if (idx !== -1) {
            this.patterns.splice(idx, 1);
            return true;
        }
        return false;
    }

    get patternCount(): number {
        return this.patterns.length;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function MultiPatternSearcher"),
        "Expected function declaration: {}",
        output
    );

    // Helper methods should be present
    assert!(
        output.contains("addPattern") && output.contains("removePattern"),
        "Expected pattern management methods: {}",
        output
    );

    // patternCount getter should be present
    assert!(
        output.contains("patternCount"),
        "Expected patternCount getter: {}",
        output
    );
}

// ============================================================================
// Symbol.split Tests
// ============================================================================

#[test]
fn test_class_es5_symbol_split_basic() {
    // Basic Symbol.split implementation for custom splitter
    let source = r#"
class SimpleSplitter {
    private delimiter: string;

    constructor(delimiter: string) {
        this.delimiter = delimiter;
    }

    [Symbol.split](str: string, limit?: number): string[] {
        return str.split(this.delimiter, limit);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function SimpleSplitter"),
        "Expected function declaration: {}",
        output
    );

    // Symbol.split should be referenced
    assert!(
        output.contains("split") || output.contains("Symbol"),
        "Expected Symbol.split reference: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_split_with_limit() {
    // Symbol.split respecting limit parameter
    let source = r#"
class LimitedSplitter {
    private separator: string;
    readonly flags: string = "";

    constructor(separator: string) {
        this.separator = separator;
    }

    [Symbol.split](str: string, limit?: number): string[] {
        const parts = str.split(this.separator);
        if (limit !== undefined && limit >= 0) {
            return parts.slice(0, limit);
        }
        return parts;
    }

    get source(): string {
        return this.separator;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function LimitedSplitter"),
        "Expected function declaration: {}",
        output
    );

    // Flags and source should be present
    assert!(
        output.contains("flags") && output.contains("source"),
        "Expected flags and source properties: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_split_preserve_separators() {
    // Symbol.split that preserves separators in output
    let source = r#"
class PreservingSplitter {
    private separator: string;

    constructor(separator: string) {
        this.separator = separator;
    }

    [Symbol.split](str: string, limit?: number): string[] {
        const result: string[] = [];
        let lastIndex = 0;
        let idx = 0;

        while ((idx = str.indexOf(this.separator, lastIndex)) !== -1) {
            result.push(str.substring(lastIndex, idx));
            result.push(this.separator);
            lastIndex = idx + this.separator.length;

            if (limit !== undefined && result.length >= limit) {
                return result.slice(0, limit);
            }
        }

        result.push(str.substring(lastIndex));
        return limit !== undefined ? result.slice(0, limit) : result;
    }

    getSeparator(): string {
        return this.separator;
    }

    setSeparator(sep: string): void {
        this.separator = sep;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function PreservingSplitter"),
        "Expected function declaration: {}",
        output
    );

    // Helper methods should be present
    assert!(
        output.contains("getSeparator") && output.contains("setSeparator"),
        "Expected getter and setter methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_split_with_inheritance() {
    // Symbol.split with class inheritance
    let source = r#"
abstract class BaseSplitter {
    abstract readonly separator: string;

    abstract [Symbol.split](str: string, limit?: number): string[];

    splitAndTrim(str: string): string[] {
        return this[Symbol.split](str).map(s => s.trim());
    }

    splitAndFilter(str: string): string[] {
        return this[Symbol.split](str).filter(s => s.length > 0);
    }
}

class WhitespaceSplitter extends BaseSplitter {
    readonly separator: string = " ";

    [Symbol.split](str: string, limit?: number): string[] {
        const parts = str.split(/\s+/);
        return limit !== undefined ? parts.slice(0, limit) : parts;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be converted
    assert!(
        output.contains("function BaseSplitter"),
        "Expected BaseSplitter function: {}",
        output
    );
    assert!(
        output.contains("function WhitespaceSplitter"),
        "Expected WhitespaceSplitter function: {}",
        output
    );

    // Inheritance should be set up
    assert!(
        output.contains("__extends") || output.contains("extends"),
        "Expected inheritance: {}",
        output
    );

    // Helper methods should be present
    assert!(
        output.contains("splitAndTrim") && output.contains("splitAndFilter"),
        "Expected helper methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_split_csv_parser() {
    // Symbol.split for CSV-like parsing
    let source = r#"
class CSVSplitter {
    private delimiter: string;
    private quote: string;

    constructor(delimiter: string = ",", quote: string = "\"") {
        this.delimiter = delimiter;
        this.quote = quote;
    }

    [Symbol.split](str: string, limit?: number): string[] {
        const result: string[] = [];
        let current = "";
        let inQuotes = false;

        for (let i = 0; i < str.length; i++) {
            const char = str[i];

            if (char === this.quote) {
                inQuotes = !inQuotes;
            } else if (char === this.delimiter && !inQuotes) {
                result.push(current);
                current = "";
                if (limit !== undefined && result.length >= limit) {
                    return result;
                }
            } else {
                current += char;
            }
        }

        result.push(current);
        return limit !== undefined ? result.slice(0, limit) : result;
    }

    get delimiterChar(): string {
        return this.delimiter;
    }

    get quoteChar(): string {
        return this.quote;
    }

    parseRow(row: string): string[] {
        return this[Symbol.split](row);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function CSVSplitter"),
        "Expected function declaration: {}",
        output
    );

    // Getters should be present
    assert!(
        output.contains("delimiterChar") && output.contains("quoteChar"),
        "Expected delimiter and quote getters: {}",
        output
    );

    // parseRow method should be present
    assert!(
        output.contains("parseRow"),
        "Expected parseRow method: {}",
        output
    );
}

// ============================================================================
// Symbol.unscopables Tests
// ============================================================================

#[test]
fn test_class_es5_symbol_unscopables_basic() {
    // Basic Symbol.unscopables static getter
    let source = r#"
class CustomArray<T> {
    private items: T[] = [];

    static get [Symbol.unscopables](): Record<string, boolean> {
        return {
            copyWithin: true,
            entries: true,
            fill: true,
            find: true,
            findIndex: true,
            keys: true,
            values: true
        };
    }

    push(item: T): number {
        return this.items.push(item);
    }

    pop(): T | undefined {
        return this.items.pop();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function CustomArray"),
        "Expected function declaration: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("push") && output.contains("pop"),
        "Expected push and pop methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_unscopables_with_methods() {
    // Symbol.unscopables excluding specific methods from with scope
    let source = r#"
class Collection<T> {
    private data: T[] = [];

    static get [Symbol.unscopables](): { [key: string]: boolean } {
        return {
            at: true,
            findLast: true,
            findLastIndex: true,
            toReversed: true,
            toSorted: true,
            toSpliced: true
        };
    }

    at(index: number): T | undefined {
        return this.data[index >= 0 ? index : this.data.length + index];
    }

    findLast(predicate: (item: T) => boolean): T | undefined {
        for (let i = this.data.length - 1; i >= 0; i--) {
            if (predicate(this.data[i])) {
                return this.data[i];
            }
        }
        return undefined;
    }

    get length(): number {
        return this.data.length;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Collection"),
        "Expected function declaration: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("at") && output.contains("findLast"),
        "Expected at and findLast methods: {}",
        output
    );

    // Length getter should be present
    assert!(
        output.contains("length"),
        "Expected length getter: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_unscopables_computed() {
    // Symbol.unscopables with computed property values
    let source = r#"
class DynamicUnscopables {
    private excluded: string[];

    constructor(excluded: string[]) {
        this.excluded = excluded;
    }

    static get [Symbol.unscopables](): Record<string, boolean> {
        const result: Record<string, boolean> = {};
        const defaultExcluded = ["values", "keys", "entries"];
        for (const key of defaultExcluded) {
            result[key] = true;
        }
        return result;
    }

    values(): string[] {
        return [...this.excluded];
    }

    keys(): number[] {
        return this.excluded.map((_, i) => i);
    }

    entries(): [number, string][] {
        return this.excluded.map((v, i) => [i, v]);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function DynamicUnscopables"),
        "Expected function declaration: {}",
        output
    );

    // Iterator-like methods should be present
    assert!(
        output.contains("values") && output.contains("keys") && output.contains("entries"),
        "Expected values, keys, entries methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_unscopables_with_inheritance() {
    // Symbol.unscopables with class inheritance
    let source = r#"
class BaseContainer<T> {
    protected items: T[] = [];

    static get [Symbol.unscopables](): Record<string, boolean> {
        return {
            flat: true,
            flatMap: true,
            includes: true
        };
    }

    includes(item: T): boolean {
        return this.items.indexOf(item) !== -1;
    }
}

class ExtendedContainer<T> extends BaseContainer<T> {
    static get [Symbol.unscopables](): Record<string, boolean> {
        return {
            ...BaseContainer[Symbol.unscopables],
            at: true,
            with: true
        };
    }

    at(index: number): T | undefined {
        return this.items[index];
    }

    add(item: T): void {
        this.items.push(item);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be converted
    assert!(
        output.contains("function BaseContainer"),
        "Expected BaseContainer function: {}",
        output
    );
    assert!(
        output.contains("function ExtendedContainer"),
        "Expected ExtendedContainer function: {}",
        output
    );

    // Inheritance should be set up
    assert!(
        output.contains("__extends") || output.contains("extends"),
        "Expected inheritance: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("includes") && output.contains("at") && output.contains("add"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_unscopables_frozen() {
    // Symbol.unscopables returning frozen object
    let source = r#"
class ImmutableConfig {
    private config: Map<string, unknown> = new Map();

    static get [Symbol.unscopables](): Readonly<Record<string, boolean>> {
        return Object.freeze({
            get: true,
            set: true,
            has: true,
            delete: true,
            clear: true
        });
    }

    get(key: string): unknown {
        return this.config.get(key);
    }

    set(key: string, value: unknown): void {
        this.config.set(key, value);
    }

    has(key: string): boolean {
        return this.config.has(key);
    }

    delete(key: string): boolean {
        return this.config.delete(key);
    }

    clear(): void {
        this.config.clear();
    }

    get size(): number {
        return this.config.size;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function ImmutableConfig"),
        "Expected function declaration: {}",
        output
    );

    // Map-like methods should be present
    assert!(
        output.contains("get") && output.contains("set") && output.contains("has"),
        "Expected get, set, has methods: {}",
        output
    );

    // Object.freeze should be preserved
    assert!(
        output.contains("Object.freeze"),
        "Expected Object.freeze call: {}",
        output
    );

    // size getter should be present
    assert!(output.contains("size"), "Expected size getter: {}", output);
}

// ============================================================================
// Symbol.for / Symbol.keyFor Tests
// ============================================================================

#[test]
fn test_class_es5_symbol_for_basic() {
    // Basic Symbol.for usage for global symbol registry
    let source = r#"
class SymbolRegistry {
    private static readonly TYPE_KEY = Symbol.for("type");
    private static readonly ID_KEY = Symbol.for("id");

    private data: Map<symbol, unknown> = new Map();

    setType(value: string): void {
        this.data.set(SymbolRegistry.TYPE_KEY, value);
    }

    getType(): string | undefined {
        return this.data.get(SymbolRegistry.TYPE_KEY) as string | undefined;
    }

    setId(value: number): void {
        this.data.set(SymbolRegistry.ID_KEY, value);
    }

    getId(): number | undefined {
        return this.data.get(SymbolRegistry.ID_KEY) as number | undefined;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function SymbolRegistry"),
        "Expected function declaration: {}",
        output
    );

    // Symbol.for should be present
    assert!(
        output.contains("Symbol.for"),
        "Expected Symbol.for call: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("setType") && output.contains("getType"),
        "Expected type methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_keyfor_basic() {
    // Symbol.keyFor to retrieve key from global registry
    let source = r#"
class SymbolInspector {
    private symbols: symbol[] = [];

    register(key: string): symbol {
        const sym = Symbol.for(key);
        this.symbols.push(sym);
        return sym;
    }

    getKey(sym: symbol): string | undefined {
        return Symbol.keyFor(sym);
    }

    getAllKeys(): (string | undefined)[] {
        return this.symbols.map(sym => Symbol.keyFor(sym));
    }

    isGlobal(sym: symbol): boolean {
        return Symbol.keyFor(sym) !== undefined;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function SymbolInspector"),
        "Expected function declaration: {}",
        output
    );

    // Symbol.for and Symbol.keyFor should be present
    assert!(
        output.contains("Symbol.for") && output.contains("Symbol.keyFor"),
        "Expected Symbol.for and Symbol.keyFor calls: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("register") && output.contains("getKey") && output.contains("isGlobal"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_for_computed_property() {
    // Using Symbol.for for computed property keys
    let source = r#"
const METADATA_KEY = Symbol.for("metadata");
const VERSION_KEY = Symbol.for("version");

class Annotated {
    [METADATA_KEY]: Record<string, unknown> = {};
    [VERSION_KEY]: string = "1.0.0";

    setMeta(key: string, value: unknown): void {
        this[METADATA_KEY][key] = value;
    }

    getMeta(key: string): unknown {
        return this[METADATA_KEY][key];
    }

    getVersion(): string {
        return this[VERSION_KEY];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Annotated"),
        "Expected function declaration: {}",
        output
    );

    // Symbol.for should be present for constants
    assert!(
        output.contains("Symbol.for"),
        "Expected Symbol.for call: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("setMeta") && output.contains("getMeta") && output.contains("getVersion"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_for_with_inheritance() {
    // Symbol.for with class inheritance
    let source = r#"
class BaseEntity {
    protected static readonly ID_SYMBOL = Symbol.for("entity.id");
    protected static readonly TYPE_SYMBOL = Symbol.for("entity.type");

    protected [BaseEntity.ID_SYMBOL]: string;

    constructor(id: string) {
        this[BaseEntity.ID_SYMBOL] = id;
    }

    getId(): string {
        return this[BaseEntity.ID_SYMBOL];
    }

    static getIdKey(): string | undefined {
        return Symbol.keyFor(BaseEntity.ID_SYMBOL);
    }
}

class User extends BaseEntity {
    private name: string;

    constructor(id: string, name: string) {
        super(id);
        this.name = name;
    }

    getName(): string {
        return this.name;
    }

    toJSON(): object {
        return {
            id: this.getId(),
            name: this.name
        };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be converted
    assert!(
        output.contains("function BaseEntity"),
        "Expected BaseEntity function: {}",
        output
    );
    assert!(
        output.contains("function User"),
        "Expected User function: {}",
        output
    );

    // Inheritance should be set up
    assert!(
        output.contains("__extends") || output.contains("extends"),
        "Expected inheritance: {}",
        output
    );

    // Symbol.for should be present
    assert!(
        output.contains("Symbol.for"),
        "Expected Symbol.for call: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_for_registry_pattern() {
    // Complete registry pattern using Symbol.for/keyFor
    let source = r#"
class PluginRegistry {
    private static plugins: Map<symbol, unknown> = new Map();

    static register<T>(name: string, plugin: T): symbol {
        const key = Symbol.for("plugin." + name);
        this.plugins.set(key, plugin);
        return key;
    }

    static get<T>(key: symbol): T | undefined {
        return this.plugins.get(key) as T | undefined;
    }

    static getByName<T>(name: string): T | undefined {
        const key = Symbol.for("plugin." + name);
        return this.plugins.get(key) as T | undefined;
    }

    static has(key: symbol): boolean {
        return this.plugins.has(key);
    }

    static getName(key: symbol): string | undefined {
        const fullKey = Symbol.keyFor(key);
        if (fullKey && fullKey.startsWith("plugin.")) {
            return fullKey.substring(7);
        }
        return undefined;
    }

    static list(): string[] {
        const names: string[] = [];
        for (const key of this.plugins.keys()) {
            const name = this.getName(key);
            if (name) {
                names.push(name);
            }
        }
        return names;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function PluginRegistry"),
        "Expected function declaration: {}",
        output
    );

    // Symbol.for and Symbol.keyFor should be present
    assert!(
        output.contains("Symbol.for") && output.contains("Symbol.keyFor"),
        "Expected Symbol.for and Symbol.keyFor calls: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("register") && output.contains("getByName") && output.contains("getName"),
        "Expected static methods: {}",
        output
    );

    // list method should be present
    assert!(output.contains("list"), "Expected list method: {}", output);
}

// ============================================================================
// Symbol.iterator Pattern Tests (Full Pipeline)
// ============================================================================

#[test]
fn test_class_es5_symbol_iterator_range() {
    // Custom range iterator implementation
    let source = r#"
class Range {
    private start: number;
    private end: number;
    private step: number;

    constructor(start: number, end: number, step: number = 1) {
        this.start = start;
        this.end = end;
        this.step = step;
    }

    *[Symbol.iterator](): Generator<number> {
        for (let i = this.start; i <= this.end; i += this.step) {
            yield i;
        }
    }

    toArray(): number[] {
        return [...this];
    }

    get length(): number {
        return Math.ceil((this.end - this.start + 1) / this.step);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Range"),
        "Expected function declaration: {}",
        output
    );

    // Symbol.iterator should be present
    assert!(
        output.contains("Symbol.iterator") || output.contains("iterator"),
        "Expected Symbol.iterator reference: {}",
        output
    );

    // Helper methods should be present
    assert!(
        output.contains("toArray"),
        "Expected toArray method: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_iterator_linked_list() {
    // Linked list with iterator implementation
    let source = r#"
class LinkedListNode<T> {
    value: T;
    next: LinkedListNode<T> | null = null;

    constructor(value: T) {
        this.value = value;
    }
}

class LinkedList<T> {
    private head: LinkedListNode<T> | null = null;
    private tail: LinkedListNode<T> | null = null;
    private size: number = 0;

    append(value: T): void {
        const node = new LinkedListNode(value);
        if (!this.tail) {
            this.head = this.tail = node;
        } else {
            this.tail.next = node;
            this.tail = node;
        }
        this.size++;
    }

    *[Symbol.iterator](): Generator<T> {
        let current = this.head;
        while (current) {
            yield current.value;
            current = current.next;
        }
    }

    get length(): number {
        return this.size;
    }

    isEmpty(): boolean {
        return this.size === 0;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Both classes should be converted
    assert!(
        output.contains("function LinkedListNode"),
        "Expected LinkedListNode function: {}",
        output
    );
    assert!(
        output.contains("function LinkedList"),
        "Expected LinkedList function: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("append") && output.contains("isEmpty"),
        "Expected append and isEmpty methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_iterator_with_return_value() {
    // Iterator with return value and done state
    let source = r#"
class CountdownIterator {
    private count: number;

    constructor(start: number) {
        this.count = start;
    }

    [Symbol.iterator](): Iterator<number, string> {
        let current = this.count;
        return {
            next(): IteratorResult<number, string> {
                if (current > 0) {
                    return { value: current--, done: false };
                }
                return { value: "Liftoff!", done: true };
            }
        };
    }

    reset(value: number): void {
        this.count = value;
    }

    get remaining(): number {
        return this.count;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function CountdownIterator"),
        "Expected function declaration: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("reset"),
        "Expected reset method: {}",
        output
    );

    // remaining getter should be present
    assert!(
        output.contains("remaining"),
        "Expected remaining getter: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_iterator_with_inheritance() {
    // Iterator with class inheritance
    let source = r#"
abstract class IterableCollection<T> {
    protected items: T[] = [];

    abstract [Symbol.iterator](): Iterator<T>;

    add(item: T): void {
        this.items.push(item);
    }

    get size(): number {
        return this.items.length;
    }
}

class ForwardIterable<T> extends IterableCollection<T> {
    *[Symbol.iterator](): Generator<T> {
        for (const item of this.items) {
            yield item;
        }
    }
}

class ReverseIterable<T> extends IterableCollection<T> {
    *[Symbol.iterator](): Generator<T> {
        for (let i = this.items.length - 1; i >= 0; i--) {
            yield this.items[i];
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // All three classes should be converted
    assert!(
        output.contains("function IterableCollection"),
        "Expected IterableCollection function: {}",
        output
    );
    assert!(
        output.contains("function ForwardIterable"),
        "Expected ForwardIterable function: {}",
        output
    );
    assert!(
        output.contains("function ReverseIterable"),
        "Expected ReverseIterable function: {}",
        output
    );

    // Inheritance should be set up
    assert!(
        output.contains("__extends") || output.contains("extends"),
        "Expected inheritance: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_iterator_map_entries() {
    // Custom map with iterator returning entries
    let source = r#"
class SimpleMap<K, V> {
    private keys: K[] = [];
    private values: V[] = [];

    set(key: K, value: V): void {
        const idx = this.keys.indexOf(key);
        if (idx === -1) {
            this.keys.push(key);
            this.values.push(value);
        } else {
            this.values[idx] = value;
        }
    }

    get(key: K): V | undefined {
        const idx = this.keys.indexOf(key);
        return idx !== -1 ? this.values[idx] : undefined;
    }

    *[Symbol.iterator](): Generator<[K, V]> {
        for (let i = 0; i < this.keys.length; i++) {
            yield [this.keys[i], this.values[i]];
        }
    }

    *entries(): Generator<[K, V]> {
        yield* this;
    }

    *keysIter(): Generator<K> {
        for (const key of this.keys) {
            yield key;
        }
    }

    *valuesIter(): Generator<V> {
        for (const value of this.values) {
            yield value;
        }
    }

    get size(): number {
        return this.keys.length;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function SimpleMap"),
        "Expected function declaration: {}",
        output
    );

    // Map methods should be present
    assert!(
        output.contains("set") && output.contains("get"),
        "Expected set and get methods: {}",
        output
    );

    // Iterator methods should be present
    assert!(
        output.contains("entries") && output.contains("keysIter") && output.contains("valuesIter"),
        "Expected iterator methods: {}",
        output
    );

    // size getter should be present
    assert!(output.contains("size"), "Expected size getter: {}", output);
}

// ============================================================================
// Symbol.toStringTag Tests
// ============================================================================

#[test]
fn test_class_es5_symbol_to_string_tag_basic() {
    // Basic Symbol.toStringTag getter for custom class name
    let source = r#"
class CustomCollection {
    private items: unknown[] = [];

    get [Symbol.toStringTag](): string {
        return "CustomCollection";
    }

    add(item: unknown): void {
        this.items.push(item);
    }

    get length(): number {
        return this.items.length;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function CustomCollection"),
        "Expected function declaration: {}",
        output
    );

    // Symbol.toStringTag or defineProperty should be present
    assert!(
        output.contains("toStringTag")
            || output.contains("defineProperty")
            || output.contains("Symbol"),
        "Expected Symbol.toStringTag handling: {}",
        output
    );

    // Methods should be present
    assert!(output.contains("add"), "Expected add method: {}", output);
}

#[test]
fn test_class_es5_symbol_to_string_tag_dynamic() {
    // Symbol.toStringTag with dynamic value based on state
    let source = r#"
class StatefulObject {
    private state: "idle" | "running" | "stopped" = "idle";

    get [Symbol.toStringTag](): string {
        return "StatefulObject<" + this.state + ">";
    }

    start(): void {
        this.state = "running";
    }

    stop(): void {
        this.state = "stopped";
    }

    reset(): void {
        this.state = "idle";
    }

    get currentState(): string {
        return this.state;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function StatefulObject"),
        "Expected function declaration: {}",
        output
    );

    // State methods should be present
    assert!(
        output.contains("start") && output.contains("stop") && output.contains("reset"),
        "Expected state methods: {}",
        output
    );

    // currentState getter should be present
    assert!(
        output.contains("currentState"),
        "Expected currentState getter: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_to_string_tag_with_inheritance() {
    // Symbol.toStringTag with class inheritance
    let source = r#"
class BaseType {
    get [Symbol.toStringTag](): string {
        return "BaseType";
    }

    getTypeName(): string {
        return Object.prototype.toString.call(this);
    }
}

class DerivedType extends BaseType {
    get [Symbol.toStringTag](): string {
        return "DerivedType";
    }

    getParentTypeName(): string {
        return "BaseType";
    }
}

class AnotherDerived extends BaseType {
    private customName: string;

    constructor(name: string) {
        super();
        this.customName = name;
    }

    get [Symbol.toStringTag](): string {
        return this.customName;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // All classes should be converted
    assert!(
        output.contains("function BaseType"),
        "Expected BaseType function: {}",
        output
    );
    assert!(
        output.contains("function DerivedType"),
        "Expected DerivedType function: {}",
        output
    );
    assert!(
        output.contains("function AnotherDerived"),
        "Expected AnotherDerived function: {}",
        output
    );

    // Inheritance should be set up
    assert!(
        output.contains("__extends") || output.contains("extends"),
        "Expected inheritance: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_to_string_tag_static() {
    // Static Symbol.toStringTag (less common but valid)
    let source = r#"
class TypeRegistry {
    private static types: Map<string, unknown> = new Map();

    static get [Symbol.toStringTag](): string {
        return "TypeRegistry";
    }

    static register(name: string, type: unknown): void {
        this.types.set(name, type);
    }

    static get(name: string): unknown {
        return this.types.get(name);
    }

    static has(name: string): boolean {
        return this.types.has(name);
    }

    static get count(): number {
        return this.types.size;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function TypeRegistry"),
        "Expected function declaration: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("register") && output.contains("has"),
        "Expected static methods: {}",
        output
    );
}

#[test]
fn test_class_es5_symbol_to_string_tag_with_iterator() {
    // Symbol.toStringTag combined with Symbol.iterator
    let source = r#"
class AdvancedCollection<T> {
    private items: T[] = [];

    get [Symbol.toStringTag](): string {
        return "AdvancedCollection";
    }

    *[Symbol.iterator](): Generator<T> {
        for (const item of this.items) {
            yield item;
        }
    }

    add(item: T): void {
        this.items.push(item);
    }

    remove(item: T): boolean {
        const idx = this.items.indexOf(item);
        if (idx !== -1) {
            this.items.splice(idx, 1);
            return true;
        }
        return false;
    }

    get length(): number {
        return this.items.length;
    }

    toString(): string {
        return "[object " + this[Symbol.toStringTag] + "]";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function AdvancedCollection"),
        "Expected function declaration: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("add") && output.contains("remove") && output.contains("toString"),
        "Expected methods: {}",
        output
    );

    // length getter should be present
    assert!(
        output.contains("length"),
        "Expected length getter: {}",
        output
    );
}

#[test]
fn test_class_es5_reflect_construct_basic() {
    // Basic Reflect.construct usage for constructor invocation
    let source = r#"
class ConstructorInvoker {
    static create<T>(ctor: new (...args: any[]) => T, args: any[]): T {
        return Reflect.construct(ctor, args);
    }

    static createWithProto<T>(ctor: new (...args: any[]) => T, args: any[], proto: object): T {
        return Reflect.construct(ctor, args, proto.constructor as any);
    }

    static instantiate<T extends object>(
        target: new (...args: any[]) => T,
        argArray: any[]
    ): T {
        return Reflect.construct(target, argArray);
    }

    createInstance<T>(ctor: new (...args: any[]) => T, ...args: any[]): T {
        return Reflect.construct(ctor, args);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("ConstructorInvoker"),
        "Expected ConstructorInvoker class: {}",
        output
    );
    assert!(
        output.contains("Reflect.construct"),
        "Expected Reflect.construct: {}",
        output
    );
    assert!(
        output.contains("create") && output.contains("createInstance"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_reflect_apply_basic() {
    // Basic Reflect.apply usage for function application
    let source = r#"
class FunctionApplier {
    static apply<T, R>(fn: (...args: any[]) => R, thisArg: T, args: any[]): R {
        return Reflect.apply(fn, thisArg, args);
    }

    static call<T, R>(fn: (this: T, ...args: any[]) => R, context: T, ...args: any[]): R {
        return Reflect.apply(fn, context, args);
    }

    static bind<T, R>(fn: (this: T, ...args: any[]) => R, context: T): (...args: any[]) => R {
        return (...args: any[]) => Reflect.apply(fn, context, args);
    }

    invokeMethod<T, K extends keyof T>(obj: T, method: K, args: any[]): any {
        const fn = obj[method];
        if (typeof fn === 'function') {
            return Reflect.apply(fn as Function, obj, args);
        }
        throw new Error('Not a function');
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("FunctionApplier"),
        "Expected FunctionApplier class: {}",
        output
    );
    assert!(
        output.contains("Reflect.apply"),
        "Expected Reflect.apply: {}",
        output
    );
    assert!(
        output.contains("apply") && output.contains("call") && output.contains("bind"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_reflect_construct_newtarget() {
    // Reflect.construct with newTarget parameter
    let source = r#"
class NewTargetHandler {
    static constructAs<T, U>(
        target: new (...args: any[]) => T,
        args: any[],
        newTarget: new (...args: any[]) => U
    ): T {
        return Reflect.construct(target, args, newTarget);
    }

    static createSubclass<T>(
        baseClass: new (...args: any[]) => T,
        subClass: new (...args: any[]) => any,
        args: any[]
    ): T {
        return Reflect.construct(baseClass, args, subClass);
    }

    static extendBuiltin<T extends object>(
        builtin: new (...args: any[]) => T,
        args: any[],
        customClass: Function
    ): T {
        return Reflect.construct(builtin, args, customClass);
    }

    createWithNewTarget<T>(
        ctor: new (...args: any[]) => T,
        args: any[],
        newTarget?: Function
    ): T {
        if (newTarget) {
            return Reflect.construct(ctor, args, newTarget);
        }
        return Reflect.construct(ctor, args);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("NewTargetHandler"),
        "Expected NewTargetHandler class: {}",
        output
    );
    assert!(
        output.contains("Reflect.construct"),
        "Expected Reflect.construct: {}",
        output
    );
    assert!(
        output.contains("constructAs") && output.contains("createSubclass"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_reflect_apply_context() {
    // Reflect.apply with different this context
    let source = r#"
class ContextBinder {
    static withContext<T, R>(fn: Function, context: T, args: any[]): R {
        return Reflect.apply(fn, context, args) as R;
    }

    static borrowMethod<T, U>(
        source: T,
        methodName: keyof T,
        target: U,
        args: any[]
    ): any {
        const method = source[methodName];
        if (typeof method === 'function') {
            return Reflect.apply(method as Function, target, args);
        }
        return undefined;
    }

    static chainCalls<T>(
        context: T,
        calls: Array<{ fn: Function; args: any[] }>
    ): any[] {
        return calls.map(({ fn, args }) => Reflect.apply(fn, context, args));
    }

    applyWithFallback<T, R>(
        fn: Function,
        context: T,
        args: any[],
        fallback: R
    ): R {
        try {
            return Reflect.apply(fn, context, args) as R;
        } catch {
            return fallback;
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("ContextBinder"),
        "Expected ContextBinder class: {}",
        output
    );
    assert!(
        output.contains("Reflect.apply"),
        "Expected Reflect.apply: {}",
        output
    );
    assert!(
        output.contains("withContext") && output.contains("borrowMethod"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_reflect_in_constructor() {
    // Reflect.construct/apply in constructor
    let source = r#"
class ReflectiveClass {
    private instance: object;
    private boundMethods: Map<string, Function>;

    constructor(
        baseClass: new (...args: any[]) => object,
        args: any[],
        methodsToBind: string[]
    ) {
        this.instance = Reflect.construct(baseClass, args);
        this.boundMethods = new Map();

        methodsToBind.forEach(methodName => {
            const method = (this.instance as any)[methodName];
            if (typeof method === 'function') {
                this.boundMethods.set(methodName, (...callArgs: any[]) => {
                    return Reflect.apply(method, this.instance, callArgs);
                });
            }
        });
    }

    callMethod(name: string, ...args: any[]): any {
        const method = this.boundMethods.get(name);
        if (method) {
            return Reflect.apply(method, null, args);
        }
        throw new Error('Method not found');
    }

    getInstance(): object {
        return this.instance;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("ReflectiveClass"),
        "Expected ReflectiveClass class: {}",
        output
    );
    assert!(
        output.contains("Reflect.construct") && output.contains("Reflect.apply"),
        "Expected Reflect methods: {}",
        output
    );
    assert!(
        output.contains("callMethod") && output.contains("getInstance"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_reflect_combined() {
    // Combined Reflect.construct and Reflect.apply patterns
    let source = r#"
class ReflectUtilities {
    static factory<T>(
        ctor: new (...args: any[]) => T,
        initializer?: (instance: T) => void
    ): (...args: any[]) => T {
        return (...args: any[]) => {
            const instance = Reflect.construct(ctor, args);
            if (initializer) {
                Reflect.apply(initializer, null, [instance]);
            }
            return instance;
        };
    }

    static memoizedConstruct<T>(
        ctor: new (...args: any[]) => T,
        keyFn: (...args: any[]) => string
    ): (...args: any[]) => T {
        const cache = new Map<string, T>();
        return (...args: any[]) => {
            const key = Reflect.apply(keyFn, null, args);
            if (cache.has(key)) {
                return cache.get(key)!;
            }
            const instance = Reflect.construct(ctor, args);
            cache.set(key, instance);
            return instance;
        };
    }

    invokeAll<T>(
        methods: Array<{ target: object; fn: Function; args: any[] }>
    ): any[] {
        return methods.map(({ target, fn, args }) => Reflect.apply(fn, target, args));
    }

    constructAll<T>(
        ctors: Array<{ ctor: new (...args: any[]) => T; args: any[] }>
    ): T[] {
        return ctors.map(({ ctor, args }) => Reflect.construct(ctor, args));
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("ReflectUtilities"),
        "Expected ReflectUtilities class: {}",
        output
    );
    assert!(
        output.contains("Reflect.construct") && output.contains("Reflect.apply"),
        "Expected Reflect methods: {}",
        output
    );
    assert!(
        output.contains("factory") && output.contains("memoizedConstruct"),
        "Expected factory methods: {}",
        output
    );
    assert!(
        output.contains("invokeAll") && output.contains("constructAll"),
        "Expected batch methods: {}",
        output
    );
}

// ============================================================================
// Async/Await in Derived Constructor Tests
// ============================================================================

#[test]
fn test_class_es5_async_derived_constructor_basic() {
    // Basic derived class with async method pattern
    let source = r#"
class BaseService {
    protected name: string;

    constructor(name: string) {
        this.name = name;
    }
}

class AsyncService extends BaseService {
    private data: any = null;

    constructor(name: string) {
        super(name);
    }

    async initialize(): Promise<void> {
        this.data = await this.fetchData();
    }

    private async fetchData(): Promise<any> {
        return await Promise.resolve({ initialized: true });
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted to functions
    assert!(
        output.contains("function BaseService"),
        "Expected BaseService function: {}",
        output
    );
    assert!(
        output.contains("function AsyncService"),
        "Expected AsyncService function: {}",
        output
    );

    // Async methods should use generator pattern
    assert!(
        output.contains("__awaiter") || output.contains("__generator") || output.contains("return"),
        "Expected async transform: {}",
        output
    );

    // super() call should be present (using _super.call pattern)
    assert!(
        output.contains("_super.call")
            || output.contains("BaseService.call")
            || output.contains(".call(this"),
        "Expected super call: {}",
        output
    );
}

#[test]
fn test_class_es5_async_derived_constructor_factory() {
    // Derived class with async static factory method
    let source = r#"
class Entity {
    id: string;

    constructor(id: string) {
        this.id = id;
    }
}

class AsyncEntity extends Entity {
    private loaded: boolean = false;
    private metadata: any;

    constructor(id: string) {
        super(id);
    }

    static async create(id: string): Promise<AsyncEntity> {
        const entity = new AsyncEntity(id);
        await entity.load();
        return entity;
    }

    private async load(): Promise<void> {
        this.metadata = await this.fetchMetadata();
        this.loaded = true;
    }

    private async fetchMetadata(): Promise<any> {
        return await Promise.resolve({ type: "entity", version: 1 });
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("function Entity") && output.contains("function AsyncEntity"),
        "Expected class functions: {}",
        output
    );

    // Static method should be present
    assert!(
        output.contains("create") || output.contains("AsyncEntity.create"),
        "Expected static create method: {}",
        output
    );

    // Async patterns should be present
    assert!(
        output.contains("load") && output.contains("fetchMetadata"),
        "Expected async methods: {}",
        output
    );
}

#[test]
fn test_class_es5_async_derived_constructor_chain() {
    // Multi-level inheritance with async patterns
    let source = r#"
class BaseComponent {
    protected element: any;

    constructor(tag: string) {
        this.element = { tag };
    }
}

class InteractiveComponent extends BaseComponent {
    protected handlers: Map<string, Function> = new Map();

    constructor(tag: string) {
        super(tag);
    }

    async bindEvents(): Promise<void> {
        const config = await this.loadEventConfig();
        for (const [event, handler] of Object.entries(config)) {
            this.handlers.set(event, handler as Function);
        }
    }

    private async loadEventConfig(): Promise<Record<string, Function>> {
        return await Promise.resolve({});
    }
}

class AsyncWidget extends InteractiveComponent {
    private state: any = {};

    constructor(tag: string) {
        super(tag);
    }

    async initialize(): Promise<void> {
        await super.bindEvents();
        this.state = await this.loadInitialState();
    }

    private async loadInitialState(): Promise<any> {
        return await Promise.resolve({ ready: true });
    }

    async updateState(newState: any): Promise<void> {
        const validated = await this.validateState(newState);
        this.state = { ...this.state, ...validated };
    }

    private async validateState(state: any): Promise<any> {
        return await Promise.resolve(state);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // All classes should be converted
    assert!(
        output.contains("function BaseComponent"),
        "Expected BaseComponent function: {}",
        output
    );
    assert!(
        output.contains("function InteractiveComponent"),
        "Expected InteractiveComponent function: {}",
        output
    );
    assert!(
        output.contains("function AsyncWidget"),
        "Expected AsyncWidget function: {}",
        output
    );

    // Inheritance chain should be established (using _super.call pattern)
    assert!(
        output.contains("_super.call")
            || output.contains("BaseComponent.call")
            || output.contains("InteractiveComponent.call"),
        "Expected super calls in chain: {}",
        output
    );
}

#[test]
fn test_class_es5_async_derived_constructor_with_field_init() {
    // Derived class with async field initializers pattern
    let source = r#"
class DataStore {
    protected cache: Map<string, any> = new Map();

    constructor(name: string) {}
}

class AsyncDataStore extends DataStore {
    private pending: Promise<void>[] = [];
    private syncInterval: number = 1000;

    constructor(name: string) {
        super(name);
    }

    async set(key: string, value: any): Promise<void> {
        const operation = this.performSet(key, value);
        this.pending.push(operation);
        await operation;
    }

    private async performSet(key: string, value: any): Promise<void> {
        await this.validate(key, value);
        this.cache.set(key, value);
    }

    private async validate(key: string, value: any): Promise<void> {
        if (!key) {
            throw new Error("Invalid key");
        }
        await Promise.resolve();
    }

    async flush(): Promise<void> {
        await Promise.all(this.pending);
        this.pending = [];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("function DataStore") && output.contains("function AsyncDataStore"),
        "Expected class functions: {}",
        output
    );

    // Field initializers should be present
    assert!(
        output.contains("pending") && output.contains("syncInterval"),
        "Expected field initializers: {}",
        output
    );

    // Async methods
    assert!(
        output.contains("set") && output.contains("flush"),
        "Expected async methods: {}",
        output
    );
}

#[test]
fn test_class_es5_async_derived_constructor_protected() {
    // Derived class with protected async methods
    let source = r#"
abstract class AbstractRepository<T> {
    protected items: T[] = [];

    constructor() {}

    protected abstract fetchAll(): Promise<T[]>;
}

class UserRepository extends AbstractRepository<{ id: string; name: string }> {
    constructor() {
        super();
    }

    protected async fetchAll(): Promise<{ id: string; name: string }[]> {
        const response = await this.makeRequest("/users");
        return response.data;
    }

    private async makeRequest(url: string): Promise<{ data: any[] }> {
        return await Promise.resolve({ data: [] });
    }

    async getById(id: string): Promise<{ id: string; name: string } | undefined> {
        const all = await this.fetchAll();
        return all.find(item => item.id === id);
    }

    async save(user: { id: string; name: string }): Promise<void> {
        await this.makeRequest("/users/" + user.id);
        this.items.push(user);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("AbstractRepository") || output.contains("function UserRepository"),
        "Expected class functions: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("fetchAll") && output.contains("getById"),
        "Expected repository methods: {}",
        output
    );
}

// ============================================================================
// Private Static Field Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_private_static_field_basic() {
    // Basic private static field usage
    let source = r#"
class Counter {
    static #count: number = 0;

    constructor() {
        Counter.#count++;
    }

    static getCount(): number {
        return Counter.#count;
    }

    static reset(): void {
        Counter.#count = 0;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Counter"),
        "Expected Counter function: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("getCount") && output.contains("reset"),
        "Expected static methods: {}",
        output
    );

    // Private field should use WeakMap or similar pattern
    assert!(
        output.contains("count") || output.contains("_count") || output.contains("WeakMap"),
        "Expected private field handling: {}",
        output
    );
}

#[test]
fn test_class_es5_private_static_field_singleton() {
    // Private static field for singleton pattern
    let source = r#"
class Singleton {
    static #instance: Singleton | null = null;
    private value: string;

    private constructor(value: string) {
        this.value = value;
    }

    static getInstance(): Singleton {
        if (Singleton.#instance === null) {
            Singleton.#instance = new Singleton("default");
        }
        return Singleton.#instance;
    }

    static hasInstance(): boolean {
        return Singleton.#instance !== null;
    }

    getValue(): string {
        return this.value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Singleton"),
        "Expected Singleton function: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("getInstance") && output.contains("hasInstance"),
        "Expected static methods: {}",
        output
    );

    // Instance method should be present
    assert!(
        output.contains("getValue"),
        "Expected getValue method: {}",
        output
    );
}

#[test]
fn test_class_es5_private_static_field_cache() {
    // Private static field for caching pattern
    let source = r#"
class ResourceLoader {
    static #cache: Map<string, any> = new Map();
    static #loading: Set<string> = new Set();

    static async load(url: string): Promise<any> {
        if (ResourceLoader.#cache.has(url)) {
            return ResourceLoader.#cache.get(url);
        }

        if (ResourceLoader.#loading.has(url)) {
            // Wait for existing load
            return new Promise(resolve => {
                setTimeout(() => resolve(ResourceLoader.load(url)), 100);
            });
        }

        ResourceLoader.#loading.add(url);
        const data = await fetch(url).then(r => r.json());
        ResourceLoader.#cache.set(url, data);
        ResourceLoader.#loading.delete(url);
        return data;
    }

    static clearCache(): void {
        ResourceLoader.#cache.clear();
    }

    static getCacheSize(): number {
        return ResourceLoader.#cache.size;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function ResourceLoader"),
        "Expected ResourceLoader function: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("load") && output.contains("clearCache"),
        "Expected static methods: {}",
        output
    );

    // Cache handling
    assert!(
        output.contains("getCacheSize"),
        "Expected getCacheSize method: {}",
        output
    );
}

#[test]
fn test_class_es5_private_static_field_registry() {
    // Private static field for registry pattern
    let source = r#"
class ComponentRegistry {
    static #components: Map<string, new () => object> = new Map();
    static #instances: WeakMap<object, string> = new WeakMap();

    static register(name: string, component: new () => object): void {
        ComponentRegistry.#components.set(name, component);
    }

    static create(name: string): object | null {
        const Component = ComponentRegistry.#components.get(name);
        if (!Component) return null;

        const instance = new Component();
        ComponentRegistry.#instances.set(instance, name);
        return instance;
    }

    static getComponentName(instance: object): string | undefined {
        return ComponentRegistry.#instances.get(instance);
    }

    static getRegisteredNames(): string[] {
        return Array.from(ComponentRegistry.#components.keys());
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function ComponentRegistry"),
        "Expected ComponentRegistry function: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("register") && output.contains("create"),
        "Expected register and create methods: {}",
        output
    );

    assert!(
        output.contains("getComponentName") && output.contains("getRegisteredNames"),
        "Expected getter methods: {}",
        output
    );
}

#[test]
fn test_class_es5_private_static_field_config() {
    // Private static field for configuration pattern
    let source = r#"
class AppConfig {
    static #config: Record<string, any> = {};
    static #frozen: boolean = false;
    static #validators: Map<string, (value: any) => boolean> = new Map();

    static set(key: string, value: any): void {
        if (AppConfig.#frozen) {
            throw new Error("Config is frozen");
        }

        const validator = AppConfig.#validators.get(key);
        if (validator && !validator(value)) {
            throw new Error(`Invalid value for ${key}`);
        }

        AppConfig.#config[key] = value;
    }

    static get(key: string): any {
        return AppConfig.#config[key];
    }

    static addValidator(key: string, validator: (value: any) => boolean): void {
        if (AppConfig.#frozen) {
            throw new Error("Config is frozen");
        }
        AppConfig.#validators.set(key, validator);
    }

    static freeze(): void {
        AppConfig.#frozen = true;
    }

    static isFrozen(): boolean {
        return AppConfig.#frozen;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function AppConfig"),
        "Expected AppConfig function: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("set") && output.contains("get"),
        "Expected set and get methods: {}",
        output
    );

    assert!(
        output.contains("freeze") && output.contains("isFrozen"),
        "Expected freeze methods: {}",
        output
    );

    assert!(
        output.contains("addValidator"),
        "Expected addValidator method: {}",
        output
    );
}

// ============================================================================
// Accessor Keyword (Auto-Accessors) Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_accessor_keyword_basic() {
    // Basic accessor keyword usage
    let source = r#"
class Person {
    accessor name: string = "";
    accessor age: number = 0;

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }

    greet(): string {
        return `Hello, I'm ${this.name} and I'm ${this.age} years old`;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Person"),
        "Expected Person function: {}",
        output
    );

    // Accessor should be transformed (defineProperty or getter/setter)
    assert!(
        output.contains("name") && output.contains("age"),
        "Expected accessor fields: {}",
        output
    );

    // Method should be present
    assert!(
        output.contains("greet"),
        "Expected greet method: {}",
        output
    );
}

#[test]
fn test_class_es5_accessor_keyword_with_inheritance() {
    // Accessor keyword with class inheritance
    let source = r#"
class BaseEntity {
    accessor id: string = "";
    accessor createdAt: Date = new Date();

    constructor(id: string) {
        this.id = id;
    }
}

class User extends BaseEntity {
    accessor email: string = "";
    accessor isActive: boolean = true;

    constructor(id: string, email: string) {
        super(id);
        this.email = email;
    }

    deactivate(): void {
        this.isActive = false;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("function BaseEntity") && output.contains("function User"),
        "Expected class functions: {}",
        output
    );

    // Inheritance should work
    assert!(
        output.contains("_super.call") || output.contains("BaseEntity.call"),
        "Expected super call: {}",
        output
    );

    // Accessors should be present
    assert!(
        output.contains("id") && output.contains("email"),
        "Expected accessor fields: {}",
        output
    );
}

#[test]
fn test_class_es5_accessor_keyword_private() {
    // Private accessor keyword
    let source = r#"
class SecureStorage {
    accessor #data: Map<string, any> = new Map();
    accessor #encryptionKey: string = "";

    constructor(key: string) {
        this.#encryptionKey = key;
    }

    set(key: string, value: any): void {
        this.#data.set(key, this.encrypt(value));
    }

    get(key: string): any {
        const encrypted = this.#data.get(key);
        return encrypted ? this.decrypt(encrypted) : undefined;
    }

    private encrypt(value: any): string {
        return JSON.stringify(value) + this.#encryptionKey;
    }

    private decrypt(encrypted: string): any {
        const data = encrypted.slice(0, -this.#encryptionKey.length);
        return JSON.parse(data);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function SecureStorage"),
        "Expected SecureStorage function: {}",
        output
    );

    // Public methods should be present
    assert!(
        output.contains("set") && output.contains("get"),
        "Expected set/get methods: {}",
        output
    );

    // Private methods should be present
    assert!(
        output.contains("encrypt") && output.contains("decrypt"),
        "Expected encrypt/decrypt methods: {}",
        output
    );
}

#[test]
fn test_class_es5_accessor_keyword_static() {
    // Static accessor keyword
    let source = r#"
class Configuration {
    static accessor debug: boolean = false;
    static accessor logLevel: string = "info";
    static accessor maxRetries: number = 3;

    static enableDebug(): void {
        Configuration.debug = true;
        Configuration.logLevel = "debug";
    }

    static disableDebug(): void {
        Configuration.debug = false;
        Configuration.logLevel = "info";
    }

    static isDebugEnabled(): boolean {
        return Configuration.debug;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Configuration"),
        "Expected Configuration function: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("enableDebug") && output.contains("disableDebug"),
        "Expected static methods: {}",
        output
    );

    assert!(
        output.contains("isDebugEnabled"),
        "Expected isDebugEnabled method: {}",
        output
    );
}

#[test]
fn test_class_es5_accessor_keyword_reactive() {
    // Accessor keyword for reactive pattern
    let source = r#"
class ReactiveValue<T> {
    accessor value: T;
    private listeners: Array<(value: T) => void> = [];

    constructor(initialValue: T) {
        this.value = initialValue;
    }

    subscribe(listener: (value: T) => void): () => void {
        this.listeners.push(listener);
        return () => {
            const index = this.listeners.indexOf(listener);
            if (index > -1) {
                this.listeners.splice(index, 1);
            }
        };
    }

    update(newValue: T): void {
        this.value = newValue;
        this.notifyListeners();
    }

    private notifyListeners(): void {
        for (const listener of this.listeners) {
            listener(this.value);
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function ReactiveValue"),
        "Expected ReactiveValue function: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("subscribe") && output.contains("update"),
        "Expected subscribe/update methods: {}",
        output
    );

    assert!(
        output.contains("notifyListeners"),
        "Expected notifyListeners method: {}",
        output
    );
}

// ============================================================================
// Using Declarations (Resource Management) Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_using_declaration_basic() {
    // Basic using declaration with Symbol.dispose
    let source = r#"
class FileHandle {
    private path: string;
    private isOpen: boolean = true;

    constructor(path: string) {
        this.path = path;
    }

    read(): string {
        if (!this.isOpen) throw new Error("File is closed");
        return "file contents";
    }

    [Symbol.dispose](): void {
        this.isOpen = false;
        console.log(`Closing file: ${this.path}`);
    }
}

function processFile(path: string): string {
    using file = new FileHandle(path);
    return file.read();
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function FileHandle"),
        "Expected FileHandle function: {}",
        output
    );

    // Symbol.dispose should be present
    assert!(
        output.contains("Symbol.dispose") || output.contains("dispose"),
        "Expected dispose method: {}",
        output
    );

    // Methods should be present
    assert!(output.contains("read"), "Expected read method: {}", output);
}

#[test]
fn test_class_es5_using_declaration_async() {
    // Async using declaration with Symbol.asyncDispose
    let source = r#"
class AsyncConnection {
    private url: string;
    private connected: boolean = false;

    constructor(url: string) {
        this.url = url;
    }

    async connect(): Promise<void> {
        this.connected = true;
        console.log(`Connected to ${this.url}`);
    }

    async query(sql: string): Promise<any[]> {
        if (!this.connected) throw new Error("Not connected");
        return [];
    }

    async [Symbol.asyncDispose](): Promise<void> {
        if (this.connected) {
            this.connected = false;
            console.log(`Disconnected from ${this.url}`);
        }
    }
}

async function runQuery(url: string, sql: string): Promise<any[]> {
    await using conn = new AsyncConnection(url);
    await conn.connect();
    return await conn.query(sql);
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function AsyncConnection"),
        "Expected AsyncConnection function: {}",
        output
    );

    // Async methods should be transformed
    assert!(
        output.contains("connect") && output.contains("query"),
        "Expected async methods: {}",
        output
    );
}

#[test]
fn test_class_es5_using_declaration_in_class_method() {
    // Using declaration inside class methods
    let source = r#"
class Lock {
    private locked: boolean = false;

    acquire(): void {
        this.locked = true;
    }

    [Symbol.dispose](): void {
        this.locked = false;
    }
}

class CriticalSection {
    private lock: Lock = new Lock();

    executeWithLock(callback: () => void): void {
        using acquired = this.lock;
        acquired.acquire();
        callback();
    }

    async executeWithLockAsync(callback: () => Promise<void>): Promise<void> {
        using acquired = this.lock;
        acquired.acquire();
        await callback();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("function Lock") && output.contains("function CriticalSection"),
        "Expected class functions: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("executeWithLock") && output.contains("acquire"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_using_declaration_multiple() {
    // Multiple using declarations
    let source = r#"
class Resource {
    private name: string;
    private disposed: boolean = false;

    constructor(name: string) {
        this.name = name;
        console.log(`Acquired: ${name}`);
    }

    use(): void {
        if (this.disposed) throw new Error(`${this.name} is disposed`);
        console.log(`Using: ${this.name}`);
    }

    [Symbol.dispose](): void {
        this.disposed = true;
        console.log(`Disposed: ${this.name}`);
    }
}

function useMultipleResources(): void {
    using r1 = new Resource("first");
    using r2 = new Resource("second");
    using r3 = new Resource("third");

    r1.use();
    r2.use();
    r3.use();
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Resource"),
        "Expected Resource function: {}",
        output
    );

    // Methods should be present
    assert!(output.contains("use"), "Expected use method: {}", output);

    // Function should be present
    assert!(
        output.contains("useMultipleResources"),
        "Expected useMultipleResources function: {}",
        output
    );
}

#[test]
fn test_class_es5_using_declaration_disposable_pattern() {
    // Disposable pattern with inheritance
    let source = r#"
interface Disposable {
    [Symbol.dispose](): void;
}

class BaseResource implements Disposable {
    protected disposed: boolean = false;

    [Symbol.dispose](): void {
        this.disposed = true;
    }

    protected checkDisposed(): void {
        if (this.disposed) {
            throw new Error("Resource already disposed");
        }
    }
}

class DatabaseConnection extends BaseResource {
    private connectionString: string;

    constructor(connectionString: string) {
        super();
        this.connectionString = connectionString;
    }

    execute(query: string): any[] {
        this.checkDisposed();
        return [];
    }

    [Symbol.dispose](): void {
        console.log("Closing database connection");
        super[Symbol.dispose]();
    }
}

class TransactionScope extends BaseResource {
    private connection: DatabaseConnection;
    private committed: boolean = false;

    constructor(connection: DatabaseConnection) {
        super();
        this.connection = connection;
    }

    commit(): void {
        this.checkDisposed();
        this.committed = true;
    }

    rollback(): void {
        this.checkDisposed();
        this.committed = false;
    }

    [Symbol.dispose](): void {
        if (!this.committed) {
            console.log("Rolling back transaction");
        }
        super[Symbol.dispose]();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("function BaseResource"),
        "Expected BaseResource function: {}",
        output
    );
    assert!(
        output.contains("function DatabaseConnection"),
        "Expected DatabaseConnection function: {}",
        output
    );
    assert!(
        output.contains("function TransactionScope"),
        "Expected TransactionScope function: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("execute") && output.contains("commit"),
        "Expected methods: {}",
        output
    );
}

// ============================================================================
// Class Static Initialization Block Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_static_block_basic() {
    // Basic static initialization block
    let source = r#"
class Config {
    static readonly ENV: string;
    static readonly DEBUG: boolean;
    static readonly VERSION: string;

    static {
        Config.ENV = process.env.NODE_ENV || "development";
        Config.DEBUG = Config.ENV === "development";
        Config.VERSION = "1.0.0";
    }

    static getConfig(): { env: string; debug: boolean; version: string } {
        return {
            env: Config.ENV,
            debug: Config.DEBUG,
            version: Config.VERSION
        };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Config") || output.contains("Config"),
        "Expected Config class: {}",
        output
    );

    // Static properties should be initialized
    assert!(
        output.contains("ENV") && output.contains("DEBUG") && output.contains("VERSION"),
        "Expected static properties: {}",
        output
    );

    // Static method should be present
    assert!(
        output.contains("getConfig"),
        "Expected getConfig method: {}",
        output
    );
}

#[test]
fn test_class_es5_static_block_multiple() {
    // Multiple static initialization blocks
    let source = r#"
class Registry {
    static handlers: Map<string, Function> = new Map();
    static validators: Map<string, Function> = new Map();
    static initialized: boolean = false;

    static {
        // Register default handlers
        Registry.handlers.set("log", console.log);
        Registry.handlers.set("error", console.error);
    }

    static {
        // Register default validators
        Registry.validators.set("string", (v: any) => typeof v === "string");
        Registry.validators.set("number", (v: any) => typeof v === "number");
    }

    static {
        // Mark as initialized
        Registry.initialized = true;
        console.log("Registry initialized");
    }

    static addHandler(name: string, handler: Function): void {
        Registry.handlers.set(name, handler);
    }

    static addValidator(name: string, validator: Function): void {
        Registry.validators.set(name, validator);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Registry") || output.contains("Registry"),
        "Expected Registry class: {}",
        output
    );

    // Static properties should be present
    assert!(
        output.contains("handlers") && output.contains("validators"),
        "Expected static properties: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("addHandler") && output.contains("addValidator"),
        "Expected static methods: {}",
        output
    );
}

#[test]
fn test_class_es5_static_block_private_fields() {
    // Static block with private static fields
    let source = r#"
class SecureService {
    static #secret: string;
    static #apiKey: string;
    static #initialized: boolean = false;

    static {
        SecureService.#secret = crypto.randomUUID();
        SecureService.#apiKey = `key_${SecureService.#secret.slice(0, 8)}`;
        SecureService.#initialized = true;
    }

    static isInitialized(): boolean {
        return SecureService.#initialized;
    }

    static getApiKey(): string {
        if (!SecureService.#initialized) {
            throw new Error("Service not initialized");
        }
        return SecureService.#apiKey;
    }

    static validateSecret(secret: string): boolean {
        return secret === SecureService.#secret;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function SecureService") || output.contains("SecureService"),
        "Expected SecureService class: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("isInitialized") && output.contains("getApiKey"),
        "Expected static methods: {}",
        output
    );

    assert!(
        output.contains("validateSecret"),
        "Expected validateSecret method: {}",
        output
    );
}

#[test]
fn test_class_es5_static_block_inheritance() {
    // Static block with inheritance
    let source = r#"
class BaseLogger {
    static logLevel: string = "info";
    static prefix: string = "";

    static {
        BaseLogger.prefix = "[BaseLogger]";
    }

    static log(message: string): void {
        console.log(`${BaseLogger.prefix} ${message}`);
    }
}

class AppLogger extends BaseLogger {
    static appName: string;

    static {
        AppLogger.appName = "MyApp";
        AppLogger.prefix = `[${AppLogger.appName}]`;
        AppLogger.logLevel = "debug";
    }

    static debug(message: string): void {
        if (AppLogger.logLevel === "debug") {
            console.log(`${AppLogger.prefix} DEBUG: ${message}`);
        }
    }

    static info(message: string): void {
        console.log(`${AppLogger.prefix} INFO: ${message}`);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("function BaseLogger") || output.contains("BaseLogger"),
        "Expected BaseLogger class: {}",
        output
    );
    assert!(
        output.contains("function AppLogger") || output.contains("AppLogger"),
        "Expected AppLogger class: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("log") && output.contains("debug") && output.contains("info"),
        "Expected logging methods: {}",
        output
    );
}

#[test]
fn test_class_es5_static_block_complex_init() {
    // Static block with complex initialization logic
    let source = r#"
class DataProcessor {
    static processors: Map<string, (data: any) => any> = new Map();
    static defaultProcessor: (data: any) => any;
    static stats: { processed: number; errors: number };

    static {
        // Initialize stats
        DataProcessor.stats = { processed: 0, errors: 0 };

        // Set up default processor
        DataProcessor.defaultProcessor = (data: any) => {
            DataProcessor.stats.processed++;
            return data;
        };

        // Register built-in processors
        DataProcessor.processors.set("uppercase", (data: string) => {
            DataProcessor.stats.processed++;
            return data.toUpperCase();
        });

        DataProcessor.processors.set("lowercase", (data: string) => {
            DataProcessor.stats.processed++;
            return data.toLowerCase();
        });

        DataProcessor.processors.set("trim", (data: string) => {
            DataProcessor.stats.processed++;
            return data.trim();
        });
    }

    static process(type: string, data: any): any {
        const processor = DataProcessor.processors.get(type) || DataProcessor.defaultProcessor;
        try {
            return processor(data);
        } catch (e) {
            DataProcessor.stats.errors++;
            throw e;
        }
    }

    static getStats(): { processed: number; errors: number } {
        return { ...DataProcessor.stats };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function DataProcessor") || output.contains("DataProcessor"),
        "Expected DataProcessor class: {}",
        output
    );

    // Static properties should be present
    assert!(
        output.contains("processors") && output.contains("stats"),
        "Expected static properties: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("process") && output.contains("getStats"),
        "Expected static methods: {}",
        output
    );
}

// ============================================================================
// Class Field Decorators Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_field_decorator_observable_pattern() {
    // Observable field decorator pattern
    let source = r#"
function observable(target: any, propertyKey: string) {
    let value: any;
    Object.defineProperty(target, propertyKey, {
        get() { return value; },
        set(newValue) {
            console.log(`Setting ${propertyKey} to ${newValue}`);
            value = newValue;
        },
        enumerable: true,
        configurable: true
    });
}

class User {
    @observable
    name: string = "";

    @observable
    email: string = "";

    constructor(name: string, email: string) {
        this.name = name;
        this.email = email;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function User") || output.contains("User"),
        "Expected User class: {}",
        output
    );

    // Decorator function should be present
    assert!(
        output.contains("observable"),
        "Expected observable decorator: {}",
        output
    );

    // Fields should be present
    assert!(
        output.contains("name") && output.contains("email"),
        "Expected field names: {}",
        output
    );
}

#[test]
fn test_class_es5_field_decorator_stacked_pattern() {
    // Stacked decorators on fields pattern
    let source = r#"
function validate(target: any, propertyKey: string) {
    console.log(`Validating ${propertyKey}`);
}

function log(target: any, propertyKey: string) {
    console.log(`Logging ${propertyKey}`);
}

function required(target: any, propertyKey: string) {
    console.log(`Required ${propertyKey}`);
}

class FormData {
    @validate
    @log
    @required
    username: string = "";

    @validate
    @required
    password: string = "";

    @log
    rememberMe: boolean = false;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function FormData") || output.contains("FormData"),
        "Expected FormData class: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("validate") && output.contains("log") && output.contains("required"),
        "Expected decorator functions: {}",
        output
    );

    // Fields should be present
    assert!(
        output.contains("username") && output.contains("password"),
        "Expected field names: {}",
        output
    );
}

#[test]
fn test_class_es5_field_decorator_factory_pattern() {
    // Field decorator with arguments (decorator factory)
    let source = r#"
function minLength(min: number) {
    return function(target: any, propertyKey: string) {
        let value: string = "";
        Object.defineProperty(target, propertyKey, {
            get() { return value; },
            set(newValue: string) {
                if (newValue.length < min) {
                    throw new Error(`${propertyKey} must be at least ${min} characters`);
                }
                value = newValue;
            }
        });
    };
}

function maxLength(max: number) {
    return function(target: any, propertyKey: string) {
        let value: string = "";
        Object.defineProperty(target, propertyKey, {
            get() { return value; },
            set(newValue: string) {
                if (newValue.length > max) {
                    throw new Error(`${propertyKey} must be at most ${max} characters`);
                }
                value = newValue;
            }
        });
    };
}

function range(min: number, max: number) {
    return function(target: any, propertyKey: string) {
        let value: number = min;
        Object.defineProperty(target, propertyKey, {
            get() { return value; },
            set(newValue: number) {
                if (newValue < min || newValue > max) {
                    throw new Error(`${propertyKey} must be between ${min} and ${max}`);
                }
                value = newValue;
            }
        });
    };
}

class Product {
    @minLength(3)
    @maxLength(100)
    name: string = "";

    @minLength(10)
    description: string = "";

    @range(0, 10000)
    price: number = 0;

    @range(0, 1000)
    quantity: number = 0;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Product") || output.contains("Product"),
        "Expected Product class: {}",
        output
    );

    // Decorator factory functions should be present
    assert!(
        output.contains("minLength") && output.contains("maxLength"),
        "Expected decorator factories: {}",
        output
    );

    // Fields should be present
    assert!(
        output.contains("name") && output.contains("price"),
        "Expected field names: {}",
        output
    );
}

#[test]
fn test_class_es5_field_decorator_deep_inheritance() {
    // Field decorators with deep inheritance chain
    let source = r#"
function tracked(target: any, propertyKey: string) {
    console.log(`Tracking ${propertyKey}`);
}

function serializable(target: any, propertyKey: string) {
    console.log(`Serializable ${propertyKey}`);
}

class BaseEntity {
    @tracked
    id: string = "";

    @tracked
    createdAt: Date = new Date();

    @tracked
    updatedAt: Date = new Date();
}

class Document extends BaseEntity {
    @tracked
    @serializable
    title: string = "";

    @tracked
    @serializable
    content: string = "";

    @tracked
    author: string = "";
}

class Article extends Document {
    @tracked
    @serializable
    category: string = "";

    @tracked
    tags: string[] = [];

    @serializable
    publishedAt: Date | null = null;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("BaseEntity") || output.contains("function BaseEntity"),
        "Expected BaseEntity class: {}",
        output
    );
    assert!(
        output.contains("Document") || output.contains("function Document"),
        "Expected Document class: {}",
        output
    );
    assert!(
        output.contains("Article") || output.contains("function Article"),
        "Expected Article class: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("tracked") && output.contains("serializable"),
        "Expected decorator functions: {}",
        output
    );
}

#[test]
fn test_class_es5_field_decorator_metadata() {
    // Field decorators with metadata pattern
    let source = r#"
const METADATA_KEY = Symbol("metadata");

function type(typeName: string) {
    return function(target: any, propertyKey: string) {
        const metadata = target[METADATA_KEY] || {};
        metadata[propertyKey] = { ...metadata[propertyKey], type: typeName };
        target[METADATA_KEY] = metadata;
    };
}

function defaultValue(value: any) {
    return function(target: any, propertyKey: string) {
        const metadata = target[METADATA_KEY] || {};
        metadata[propertyKey] = { ...metadata[propertyKey], default: value };
        target[METADATA_KEY] = metadata;
    };
}

function nullable(target: any, propertyKey: string) {
    const metadata = target[METADATA_KEY] || {};
    metadata[propertyKey] = { ...metadata[propertyKey], nullable: true };
    target[METADATA_KEY] = metadata;
}

class Schema {
    @type("string")
    @defaultValue("")
    name: string = "";

    @type("number")
    @defaultValue(0)
    age: number = 0;

    @type("string")
    @nullable
    @defaultValue(null)
    nickname: string | null = null;

    @type("boolean")
    @defaultValue(true)
    active: boolean = true;

    static getMetadata(): Record<string, any> {
        return (Schema.prototype as any)[METADATA_KEY] || {};
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Schema") || output.contains("Schema"),
        "Expected Schema class: {}",
        output
    );

    // Decorator factory functions should be present
    assert!(
        output.contains("type") && output.contains("defaultValue"),
        "Expected decorator factories: {}",
        output
    );

    // Static method should be present
    assert!(
        output.contains("getMetadata"),
        "Expected getMetadata method: {}",
        output
    );

    // Symbol should be present
    assert!(
        output.contains("METADATA_KEY") || output.contains("Symbol"),
        "Expected metadata symbol: {}",
        output
    );
}

// ============================================================================
// Class Method Decorator Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_method_decorator_factory_pattern() {
    // Method decorator factory with configurable options
    let source = r#"
function timeout(ms: number) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = async function(...args: any[]) {
            return Promise.race([
                originalMethod.apply(this, args),
                new Promise((_, reject) =>
                    setTimeout(() => reject(new Error(`${propertyKey} timed out`)), ms)
                )
            ]);
        };
        return descriptor;
    };
}

function retry(attempts: number, delay: number = 1000) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = async function(...args: any[]) {
            for (let i = 0; i < attempts; i++) {
                try {
                    return await originalMethod.apply(this, args);
                } catch (e) {
                    if (i === attempts - 1) throw e;
                    await new Promise(r => setTimeout(r, delay));
                }
            }
        };
        return descriptor;
    };
}

class ApiClient {
    @timeout(5000)
    async fetchData(url: string): Promise<any> {
        const response = await fetch(url);
        return response.json();
    }

    @retry(3, 500)
    async postData(url: string, data: any): Promise<any> {
        const response = await fetch(url, {
            method: 'POST',
            body: JSON.stringify(data)
        });
        return response.json();
    }

    @timeout(10000)
    @retry(2)
    async uploadFile(url: string, file: File): Promise<any> {
        const formData = new FormData();
        formData.append('file', file);
        const response = await fetch(url, { method: 'POST', body: formData });
        return response.json();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function ApiClient") || output.contains("ApiClient"),
        "Expected ApiClient class: {}",
        output
    );

    // Decorator factories should be present
    assert!(
        output.contains("timeout") && output.contains("retry"),
        "Expected decorator factories: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("fetchData")
            && output.contains("postData")
            && output.contains("uploadFile"),
        "Expected API methods: {}",
        output
    );
}

#[test]
fn test_class_es5_method_decorator_stacked() {
    // Stacked method decorators executed in order
    let source = r#"
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        console.log(`Calling ${propertyKey} with`, args);
        const result = original.apply(this, args);
        console.log(`${propertyKey} returned`, result);
        return result;
    };
    return descriptor;
}

function validate(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        if (args.some(arg => arg === undefined || arg === null)) {
            throw new Error(`${propertyKey}: Invalid arguments`);
        }
        return original.apply(this, args);
    };
    return descriptor;
}

function memoize(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const cache = new Map<string, any>();
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        const key = JSON.stringify(args);
        if (cache.has(key)) return cache.get(key);
        const result = original.apply(this, args);
        cache.set(key, result);
        return result;
    };
    return descriptor;
}

function benchmark(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        const start = performance.now();
        const result = original.apply(this, args);
        console.log(`${propertyKey} took ${performance.now() - start}ms`);
        return result;
    };
    return descriptor;
}

class Calculator {
    @log
    @validate
    @memoize
    @benchmark
    compute(a: number, b: number, operation: string): number {
        switch (operation) {
            case 'add': return a + b;
            case 'subtract': return a - b;
            case 'multiply': return a * b;
            case 'divide': return a / b;
            default: throw new Error('Unknown operation');
        }
    }

    @log
    @validate
    factorial(n: number): number {
        if (n <= 1) return 1;
        return n * this.factorial(n - 1);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function Calculator") || output.contains("Calculator"),
        "Expected Calculator class: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("log") && output.contains("validate") && output.contains("memoize"),
        "Expected decorator functions: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("compute") && output.contains("factorial"),
        "Expected methods: {}",
        output
    );
}

#[test]
fn test_class_es5_method_decorator_async() {
    // Async method decorators
    let source = r#"
function asyncLog(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = async function(...args: any[]) {
        console.log(`[${new Date().toISOString()}] Starting ${propertyKey}`);
        try {
            const result = await original.apply(this, args);
            console.log(`[${new Date().toISOString()}] Completed ${propertyKey}`);
            return result;
        } catch (error) {
            console.error(`[${new Date().toISOString()}] Failed ${propertyKey}:`, error);
            throw error;
        }
    };
    return descriptor;
}

function measure(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = async function(...args: any[]) {
        const start = Date.now();
        const result = await original.apply(this, args);
        console.log(`${propertyKey} execution time: ${Date.now() - start}ms`);
        return result;
    };
    return descriptor;
}

function cache(ttlMs: number) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const cacheMap = new Map<string, { value: any; expires: number }>();
        const original = descriptor.value;
        descriptor.value = async function(...args: any[]) {
            const key = JSON.stringify(args);
            const cached = cacheMap.get(key);
            if (cached && cached.expires > Date.now()) {
                return cached.value;
            }
            const result = await original.apply(this, args);
            cacheMap.set(key, { value: result, expires: Date.now() + ttlMs });
            return result;
        };
        return descriptor;
    };
}

class DataService {
    @asyncLog
    @measure
    async fetchUsers(): Promise<any[]> {
        const response = await fetch('/api/users');
        return response.json();
    }

    @cache(60000)
    @asyncLog
    async getUser(id: string): Promise<any> {
        const response = await fetch(`/api/users/${id}`);
        return response.json();
    }

    @asyncLog
    @measure
    async saveUser(user: any): Promise<void> {
        await fetch('/api/users', {
            method: 'POST',
            body: JSON.stringify(user)
        });
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function DataService") || output.contains("DataService"),
        "Expected DataService class: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("asyncLog") && output.contains("measure"),
        "Expected async decorator functions: {}",
        output
    );

    // Async methods should be present
    assert!(
        output.contains("fetchUsers") && output.contains("getUser") && output.contains("saveUser"),
        "Expected async methods: {}",
        output
    );
}

#[test]
fn test_class_es5_method_decorator_static() {
    // Static method decorators
    let source = r#"
function singleton(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    let instance: any = null;
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        if (instance === null) {
            instance = original.apply(this, args);
        }
        return instance;
    };
    return descriptor;
}

function deprecated(message: string) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            console.warn(`DEPRECATED: ${propertyKey} - ${message}`);
            return original.apply(this, args);
        };
        return descriptor;
    };
}

function authorize(roles: string[]) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            const currentUser = (this as any).getCurrentUser?.() || {};
            if (!roles.some(role => currentUser.roles?.includes(role))) {
                throw new Error('Unauthorized');
            }
            return original.apply(this, args);
        };
        return descriptor;
    };
}

class ServiceFactory {
    private static instances = new Map<string, any>();

    @singleton
    static createDatabase(): any {
        console.log('Creating database connection');
        return { type: 'database', connected: true };
    }

    @singleton
    static createCache(): any {
        console.log('Creating cache instance');
        return { type: 'cache', entries: new Map() };
    }

    @deprecated('Use createDatabase instead')
    static getDbConnection(): any {
        return ServiceFactory.createDatabase();
    }

    @authorize(['admin'])
    static resetAll(): void {
        ServiceFactory.instances.clear();
        console.log('All instances reset');
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function ServiceFactory") || output.contains("ServiceFactory"),
        "Expected ServiceFactory class: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("singleton") && output.contains("deprecated"),
        "Expected static decorator functions: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("createDatabase") && output.contains("createCache"),
        "Expected static factory methods: {}",
        output
    );
}

#[test]
fn test_class_es5_method_decorator_combined() {
    // Combined method and accessor decorators
    let source = r#"
function readonly(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.writable = false;
    return descriptor;
}

function enumerable(value: boolean) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
        return descriptor;
    };
}

function bound(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    return {
        configurable: true,
        get() {
            const boundFn = original.bind(this);
            Object.defineProperty(this, propertyKey, {
                value: boundFn,
                configurable: true,
                writable: true
            });
            return boundFn;
        }
    };
}

function throttle(ms: number) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        let lastCall = 0;
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            const now = Date.now();
            if (now - lastCall >= ms) {
                lastCall = now;
                return original.apply(this, args);
            }
        };
        return descriptor;
    };
}

class EventHandler {
    private events: string[] = [];

    @bound
    @throttle(100)
    handleClick(event: any): void {
        this.events.push('click');
        console.log('Click handled');
    }

    @bound
    @throttle(50)
    handleScroll(event: any): void {
        this.events.push('scroll');
        console.log('Scroll handled');
    }

    @readonly
    @enumerable(false)
    getEventCount(): number {
        return this.events.length;
    }

    @enumerable(true)
    getEvents(): string[] {
        return [...this.events];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function EventHandler") || output.contains("EventHandler"),
        "Expected EventHandler class: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("bound") && output.contains("throttle"),
        "Expected combined decorator functions: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("handleClick") && output.contains("handleScroll"),
        "Expected event handler methods: {}",
        output
    );
}

// ============================================================================
// Parameter Decorator Pattern Tests
// ============================================================================

#[test]
fn test_class_es5_param_decorator_constructor() {
    // Constructor parameter decorators
    let source = r#"
const INJECT_METADATA = Symbol("inject");

function inject(token: string) {
    return function(target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const existingParams = Reflect.getMetadata(INJECT_METADATA, target) || [];
        existingParams[parameterIndex] = token;
        Reflect.defineMetadata(INJECT_METADATA, existingParams, target);
    };
}

function optional(target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {
    const existingOptional = Reflect.getMetadata("optional", target) || [];
    existingOptional[parameterIndex] = true;
    Reflect.defineMetadata("optional", existingOptional, target);
}

class DatabaseService {
    query(sql: string): any[] { return []; }
}

class LoggerService {
    log(message: string): void { console.log(message); }
}

class CacheService {
    get(key: string): any { return null; }
    set(key: string, value: any): void {}
}

class UserRepository {
    constructor(
        @inject("DatabaseService") private db: DatabaseService,
        @inject("LoggerService") private logger: LoggerService,
        @inject("CacheService") @optional private cache?: CacheService
    ) {}

    findAll(): any[] {
        this.logger.log("Finding all users");
        return this.db.query("SELECT * FROM users");
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("function UserRepository") || output.contains("UserRepository"),
        "Expected UserRepository class: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("inject") && output.contains("optional"),
        "Expected parameter decorators: {}",
        output
    );

    // Service classes should be present
    assert!(
        output.contains("DatabaseService") && output.contains("LoggerService"),
        "Expected service classes: {}",
        output
    );
}

#[test]
fn test_class_es5_param_decorator_method() {
    // Method parameter decorators
    let source = r#"
function validate(target: any, propertyKey: string, parameterIndex: number) {
    const existingValidators = Reflect.getMetadata("validators", target, propertyKey) || [];
    existingValidators.push(parameterIndex);
    Reflect.defineMetadata("validators", existingValidators, target, propertyKey);
}

function required(target: any, propertyKey: string, parameterIndex: number) {
    const existingRequired = Reflect.getMetadata("required", target, propertyKey) || [];
    existingRequired.push(parameterIndex);
    Reflect.defineMetadata("required", existingRequired, target, propertyKey);
}

function maxLength(length: number) {
    return function(target: any, propertyKey: string, parameterIndex: number) {
        const existingMaxLength = Reflect.getMetadata("maxLength", target, propertyKey) || {};
        existingMaxLength[parameterIndex] = length;
        Reflect.defineMetadata("maxLength", existingMaxLength, target, propertyKey);
    };
}

function minValue(value: number) {
    return function(target: any, propertyKey: string, parameterIndex: number) {
        const existingMinValue = Reflect.getMetadata("minValue", target, propertyKey) || {};
        existingMinValue[parameterIndex] = value;
        Reflect.defineMetadata("minValue", existingMinValue, target, propertyKey);
    };
}

class ProductService {
    createProduct(
        @validate @required @maxLength(100) name: string,
        @validate @required description: string,
        @validate @minValue(0) price: number,
        @validate @minValue(0) quantity: number
    ): any {
        return { name, description, price, quantity };
    }

    updateProduct(
        @required id: string,
        @maxLength(100) name?: string,
        description?: string,
        @minValue(0) price?: number
    ): any {
        return { id, name, description, price };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function ProductService") || output.contains("ProductService"),
        "Expected ProductService class: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("validate") && output.contains("required"),
        "Expected parameter decorators: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_param_decorator_factory() {
    // Decorator factories with params
    let source = r#"
function paramType(typeName: string) {
    return function(target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const types = Reflect.getMetadata("paramTypes", target, propertyKey as string) || {};
        types[parameterIndex] = typeName;
        Reflect.defineMetadata("paramTypes", types, target, propertyKey as string);
    };
}

function range(min: number, max: number) {
    return function(target: any, propertyKey: string, parameterIndex: number) {
        const ranges = Reflect.getMetadata("ranges", target, propertyKey) || {};
        ranges[parameterIndex] = { min, max };
        Reflect.defineMetadata("ranges", ranges, target, propertyKey);
    };
}

function pattern(regex: RegExp) {
    return function(target: any, propertyKey: string, parameterIndex: number) {
        const patterns = Reflect.getMetadata("patterns", target, propertyKey) || {};
        patterns[parameterIndex] = regex;
        Reflect.defineMetadata("patterns", patterns, target, propertyKey);
    };
}

function transform(fn: (value: any) => any) {
    return function(target: any, propertyKey: string, parameterIndex: number) {
        const transforms = Reflect.getMetadata("transforms", target, propertyKey) || {};
        transforms[parameterIndex] = fn;
        Reflect.defineMetadata("transforms", transforms, target, propertyKey);
    };
}

class ValidationService {
    validateUser(
        @paramType("string") @pattern(/^[a-zA-Z0-9]+$/) username: string,
        @paramType("string") @pattern(/^[\w.-]+@[\w.-]+\.\w+$/) email: string,
        @paramType("number") @range(18, 120) age: number
    ): boolean {
        return true;
    }

    processInput(
        @transform((v: string) => v.trim().toLowerCase()) input: string,
        @transform((v: number) => Math.abs(v)) value: number
    ): { input: string; value: number } {
        return { input, value };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function ValidationService") || output.contains("ValidationService"),
        "Expected ValidationService class: {}",
        output
    );

    // Decorator factories should be present
    assert!(
        output.contains("paramType") && output.contains("range"),
        "Expected decorator factories: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_param_decorator_combined() {
    // Combined parameter and method decorators
    let source = r#"
function logMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        console.log(`Calling ${propertyKey}`);
        return original.apply(this, args);
    };
    return descriptor;
}

function validateParams(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        const required = Reflect.getMetadata("required", target, propertyKey) || [];
        for (const index of required) {
            if (args[index] === undefined || args[index] === null) {
                throw new Error(`Parameter ${index} is required`);
            }
        }
        return original.apply(this, args);
    };
    return descriptor;
}

function required(target: any, propertyKey: string, parameterIndex: number) {
    const existingRequired = Reflect.getMetadata("required", target, propertyKey) || [];
    existingRequired.push(parameterIndex);
    Reflect.defineMetadata("required", existingRequired, target, propertyKey);
}

function body(target: any, propertyKey: string, parameterIndex: number) {
    Reflect.defineMetadata("body", parameterIndex, target, propertyKey);
}

function query(name: string) {
    return function(target: any, propertyKey: string, parameterIndex: number) {
        const queries = Reflect.getMetadata("queries", target, propertyKey) || {};
        queries[parameterIndex] = name;
        Reflect.defineMetadata("queries", queries, target, propertyKey);
    };
}

class ApiController {
    @logMethod
    @validateParams
    createItem(
        @required @body data: any,
        @query("userId") userId: string
    ): any {
        return { ...data, userId };
    }

    @logMethod
    @validateParams
    getItems(
        @required @query("page") page: number,
        @query("limit") limit: number = 10,
        @query("sort") sort?: string
    ): any[] {
        return [];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("function ApiController") || output.contains("ApiController"),
        "Expected ApiController class: {}",
        output
    );

    // Decorators should be present
    assert!(
        output.contains("logMethod") && output.contains("validateParams"),
        "Expected method decorators: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_param_decorator_di_pattern() {
    // Dependency injection pattern with parameter decorators
    let source = r#"
const INJECTABLE_METADATA = Symbol("injectable");
const INJECT_METADATA = Symbol("inject");

function injectable() {
    return function(target: any) {
        Reflect.defineMetadata(INJECTABLE_METADATA, true, target);
    };
}

function inject(token: string | symbol) {
    return function(target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const injections = Reflect.getMetadata(INJECT_METADATA, target) || [];
        injections[parameterIndex] = token;
        Reflect.defineMetadata(INJECT_METADATA, injections, target);
    };
}

function lazy(target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {
    const lazyParams = Reflect.getMetadata("lazy", target) || [];
    lazyParams[parameterIndex] = true;
    Reflect.defineMetadata("lazy", lazyParams, target);
}

function scope(scopeName: string) {
    return function(target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const scopes = Reflect.getMetadata("scopes", target) || {};
        scopes[parameterIndex] = scopeName;
        Reflect.defineMetadata("scopes", scopes, target);
    };
}

@injectable()
class ConfigService {
    get(key: string): string { return ""; }
}

@injectable()
class HttpClient {
    get(url: string): Promise<any> { return Promise.resolve({}); }
}

@injectable()
class AuthService {
    constructor(
        @inject("ConfigService") private config: ConfigService,
        @inject("HttpClient") @lazy private http: HttpClient
    ) {}

    async login(username: string, password: string): Promise<boolean> {
        const authUrl = this.config.get("authUrl");
        const result = await this.http.get(authUrl);
        return result.success;
    }
}

@injectable()
class ApplicationService {
    constructor(
        @inject("AuthService") @scope("request") private auth: AuthService,
        @inject("ConfigService") @scope("singleton") private config: ConfigService,
        @inject("HttpClient") private http: HttpClient
    ) {}

    async initialize(): Promise<void> {
        console.log("Application initialized");
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ConfigService") && output.contains("AuthService"),
        "Expected service classes: {}",
        output
    );

    // DI decorators should be present
    assert!(
        output.contains("injectable") && output.contains("inject"),
        "Expected DI decorators: {}",
        output
    );

    // ApplicationService should be present
    assert!(
        output.contains("ApplicationService"),
        "Expected ApplicationService class: {}",
        output
    );
}

#[test]
fn test_class_es5_property_decorator_initialization() {
    // Property initialization decorator pattern
    let source = r#"
function defaultValue(value: any) {
    return function(target: any, propertyKey: string) {
        let val = value;
        Object.defineProperty(target, propertyKey, {
            get() { return val; },
            set(newVal) { val = newVal; },
            enumerable: true,
            configurable: true
        });
    };
}

function readonly(target: any, propertyKey: string) {
    Object.defineProperty(target, propertyKey, {
        writable: false,
        configurable: false
    });
}

function enumerable(isEnumerable: boolean) {
    return function(target: any, propertyKey: string, descriptor?: PropertyDescriptor) {
        if (descriptor) {
            descriptor.enumerable = isEnumerable;
        }
    };
}

class Configuration {
    @defaultValue("localhost")
    host: string;

    @defaultValue(3000)
    port: number;

    @readonly
    version: string = "1.0.0";

    @enumerable(false)
    secret: string = "hidden";
}

class UserSettings {
    @defaultValue([])
    preferences: string[];

    @defaultValue({})
    metadata: Record<string, any>;

    @readonly
    @defaultValue("user")
    role: string;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Configuration") && output.contains("UserSettings"),
        "Expected Configuration and UserSettings classes: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("defaultValue") && output.contains("readonly"),
        "Expected property decorators: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_property_decorator_lazy_init() {
    // Lazy initialization decorator pattern
    let source = r#"
function lazy<T>(initializer: () => T) {
    return function(target: any, propertyKey: string) {
        let value: T | undefined;
        let initialized = false;

        Object.defineProperty(target, propertyKey, {
            get() {
                if (!initialized) {
                    value = initializer();
                    initialized = true;
                }
                return value;
            },
            enumerable: true,
            configurable: true
        });
    };
}

function cached(target: any, propertyKey: string) {
    const cacheKey = Symbol(`__cache_${propertyKey}`);
    const originalDescriptor = Object.getOwnPropertyDescriptor(target, propertyKey);

    if (originalDescriptor && originalDescriptor.get) {
        Object.defineProperty(target, propertyKey, {
            get() {
                if (!(cacheKey in this)) {
                    (this as any)[cacheKey] = originalDescriptor.get!.call(this);
                }
                return (this as any)[cacheKey];
            },
            enumerable: true,
            configurable: true
        });
    }
}

function memoize(target: any, propertyKey: string) {
    const memoKey = `__memo_${propertyKey}`;
    return {
        get() {
            if (!this[memoKey]) {
                this[memoKey] = this[`compute${propertyKey}`]();
            }
            return this[memoKey];
        }
    };
}

class ExpensiveComputation {
    @lazy(() => {
        console.log("Computing heavy data...");
        return Array.from({ length: 10000 }, (_, i) => i * 2);
    })
    heavyData: number[];

    @lazy(() => new Map<string, any>())
    cache: Map<string, any>;

    @cached
    get computedValue(): number {
        return Math.random() * 1000;
    }
}

class DatabaseConnection {
    @lazy(() => {
        console.log("Establishing connection...");
        return { connected: true, pool: [] };
    })
    connection: { connected: boolean; pool: any[] };

    @lazy(() => new WeakMap())
    queryCache: WeakMap<object, any>;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ExpensiveComputation") && output.contains("DatabaseConnection"),
        "Expected ExpensiveComputation and DatabaseConnection classes: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("lazy") && output.contains("cached"),
        "Expected lazy decorators: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_property_decorator_validation() {
    // Validation decorator pattern for properties
    let source = r#"
function minLength(min: number) {
    return function(target: any, propertyKey: string) {
        let value: string;
        Object.defineProperty(target, propertyKey, {
            get() { return value; },
            set(newVal: string) {
                if (newVal.length < min) {
                    throw new Error(`${propertyKey} must be at least ${min} characters`);
                }
                value = newVal;
            },
            enumerable: true,
            configurable: true
        });
    };
}

function maxLength(max: number) {
    return function(target: any, propertyKey: string) {
        let value: string;
        Object.defineProperty(target, propertyKey, {
            get() { return value; },
            set(newVal: string) {
                if (newVal.length > max) {
                    throw new Error(`${propertyKey} must be at most ${max} characters`);
                }
                value = newVal;
            },
            enumerable: true,
            configurable: true
        });
    };
}

function pattern(regex: RegExp) {
    return function(target: any, propertyKey: string) {
        let value: string;
        Object.defineProperty(target, propertyKey, {
            get() { return value; },
            set(newVal: string) {
                if (!regex.test(newVal)) {
                    throw new Error(`${propertyKey} does not match pattern`);
                }
                value = newVal;
            },
            enumerable: true,
            configurable: true
        });
    };
}

function range(min: number, max: number) {
    return function(target: any, propertyKey: string) {
        let value: number;
        Object.defineProperty(target, propertyKey, {
            get() { return value; },
            set(newVal: number) {
                if (newVal < min || newVal > max) {
                    throw new Error(`${propertyKey} must be between ${min} and ${max}`);
                }
                value = newVal;
            },
            enumerable: true,
            configurable: true
        });
    };
}

class UserForm {
    @minLength(3)
    @maxLength(50)
    username: string;

    @pattern(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/)
    email: string;

    @minLength(8)
    password: string;

    @range(18, 120)
    age: number;
}

class ProductForm {
    @minLength(1)
    @maxLength(100)
    name: string;

    @maxLength(500)
    description: string;

    @range(0.01, 999999.99)
    price: number;

    @range(0, 10000)
    quantity: number;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("UserForm") && output.contains("ProductForm"),
        "Expected UserForm and ProductForm classes: {}",
        output
    );

    // Validation decorators should be present
    assert!(
        output.contains("minLength") && output.contains("maxLength") && output.contains("range"),
        "Expected validation decorators: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_property_decorator_observable() {
    // Observable pattern decorator
    let source = r#"
type Subscriber<T> = (value: T) => void;

function observable(target: any, propertyKey: string) {
    const subscribersKey = Symbol(`${propertyKey}_subscribers`);
    let value: any;

    Object.defineProperty(target, propertyKey, {
        get() { return value; },
        set(newVal) {
            const oldVal = value;
            value = newVal;
            const subscribers = (this as any)[subscribersKey] || [];
            subscribers.forEach((sub: Subscriber<any>) => sub(newVal));
        },
        enumerable: true,
        configurable: true
    });
}

function computed(dependencies: string[]) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalGet = descriptor.get;
        let cachedValue: any;
        let isDirty = true;

        dependencies.forEach(dep => {
            const originalSet = Object.getOwnPropertyDescriptor(target, dep)?.set;
            if (originalSet) {
                Object.defineProperty(target, dep, {
                    set(val) {
                        originalSet.call(this, val);
                        isDirty = true;
                    }
                });
            }
        });

        descriptor.get = function() {
            if (isDirty) {
                cachedValue = originalGet?.call(this);
                isDirty = false;
            }
            return cachedValue;
        };
    };
}

function watch(callback: string) {
    return function(target: any, propertyKey: string) {
        let value: any;
        Object.defineProperty(target, propertyKey, {
            get() { return value; },
            set(newVal) {
                const oldVal = value;
                value = newVal;
                if (typeof this[callback] === 'function') {
                    this[callback](newVal, oldVal, propertyKey);
                }
            },
            enumerable: true,
            configurable: true
        });
    };
}

class ReactiveState {
    @observable
    count: number = 0;

    @observable
    name: string = "";

    @observable
    items: string[] = [];

    @computed(["count", "name"])
    get summary(): string {
        return `${this.name}: ${this.count}`;
    }
}

class FormModel {
    @watch("onFieldChange")
    firstName: string;

    @watch("onFieldChange")
    lastName: string;

    @watch("onFieldChange")
    email: string;

    onFieldChange(newVal: any, oldVal: any, field: string) {
        console.log(`${field} changed from ${oldVal} to ${newVal}`);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ReactiveState") && output.contains("FormModel"),
        "Expected ReactiveState and FormModel classes: {}",
        output
    );

    // Observable decorators should be present
    assert!(
        output.contains("observable") && output.contains("watch"),
        "Expected observable decorators: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_property_decorator_combined() {
    // Combined property decorator patterns
    let source = r#"
function logged(target: any, propertyKey: string) {
    let value: any;
    Object.defineProperty(target, propertyKey, {
        get() {
            console.log(`Getting ${propertyKey}`);
            return value;
        },
        set(newVal) {
            console.log(`Setting ${propertyKey} to ${newVal}`);
            value = newVal;
        },
        enumerable: true,
        configurable: true
    });
}

function serializable(target: any, propertyKey: string) {
    const metadata = Reflect.getMetadata("serializable", target) || [];
    metadata.push(propertyKey);
    Reflect.defineMetadata("serializable", metadata, target);
}

function jsonProperty(name?: string) {
    return function(target: any, propertyKey: string) {
        const props = Reflect.getMetadata("jsonProperties", target) || {};
        props[propertyKey] = name || propertyKey;
        Reflect.defineMetadata("jsonProperties", props, target);
    };
}

function transient(target: any, propertyKey: string) {
    const transients = Reflect.getMetadata("transient", target) || [];
    transients.push(propertyKey);
    Reflect.defineMetadata("transient", transients, target);
}

function deprecated(message?: string) {
    return function(target: any, propertyKey: string) {
        let value: any;
        Object.defineProperty(target, propertyKey, {
            get() {
                console.warn(`${propertyKey} is deprecated. ${message || ''}`);
                return value;
            },
            set(newVal) {
                value = newVal;
            },
            enumerable: true,
            configurable: true
        });
    };
}

class Entity {
    @serializable
    @jsonProperty("id")
    @logged
    entityId: string;

    @serializable
    @jsonProperty()
    name: string;

    @transient
    @logged
    temporaryState: any;

    @deprecated("Use newField instead")
    @serializable
    oldField: string;

    @serializable
    newField: string;
}

class ApiResponse<T> {
    @serializable
    @jsonProperty("status_code")
    statusCode: number;

    @serializable
    @jsonProperty()
    data: T;

    @transient
    rawResponse: any;

    @serializable
    @jsonProperty("error_message")
    errorMessage?: string;

    @logged
    @serializable
    timestamp: Date;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Entity") && output.contains("ApiResponse"),
        "Expected Entity and ApiResponse classes: {}",
        output
    );

    // Various property decorators should be present
    assert!(
        output.contains("serializable") && output.contains("jsonProperty"),
        "Expected serialization decorators: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

// ============================================================================
// super() call pattern tests
// ============================================================================

#[test]
fn test_class_es5_super_with_conditional() {
    // super() with conditional expressions
    let source = r#"
class BaseConfig {
    protected value: string;

    constructor(value: string) {
        this.value = value;
    }

    getValue(): string {
        return this.value;
    }
}

class ConditionalConfig extends BaseConfig {
    constructor(value: string | null, defaultValue: string = "default") {
        super(value ?? defaultValue);
    }
}

class TernaryConfig extends BaseConfig {
    constructor(useDefault: boolean, customValue: string) {
        super(useDefault ? "default" : customValue);
    }
}

class LogicalAndConfig extends BaseConfig {
    constructor(value: string | undefined) {
        super(value && value.length > 0 ? value : "fallback");
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function BaseConfig"),
        "Expected BaseConfig function: {}",
        output
    );
    assert!(
        output.contains("ConditionalConfig") && output.contains("TernaryConfig"),
        "Expected derived classes: {}",
        output
    );
}

#[test]
fn test_class_es5_super_in_try_catch() {
    // super() in try/catch block
    let source = r#"
class BaseValidator {
    protected data: any;

    constructor(data: any) {
        if (data === null || data === undefined) {
            throw new Error("Data cannot be null");
        }
        this.data = data;
    }
}

class SafeValidator extends BaseValidator {
    private error: Error | null = null;

    constructor(data: any) {
        try {
            super(data);
        } catch (e) {
            super({});
            this.error = e as Error;
        }
    }

    hasError(): boolean {
        return this.error !== null;
    }

    getError(): Error | null {
        return this.error;
    }
}

class RetryValidator extends BaseValidator {
    private attempts: number = 0;

    constructor(dataProvider: () => any, maxAttempts: number = 3) {
        let data: any;
        let lastError: Error | undefined;

        for (let i = 0; i < maxAttempts; i++) {
            try {
                data = dataProvider();
                break;
            } catch (e) {
                lastError = e as Error;
            }
        }

        super(data ?? {});
        this.attempts = maxAttempts;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function BaseValidator"),
        "Expected BaseValidator function: {}",
        output
    );
    assert!(
        output.contains("SafeValidator") && output.contains("RetryValidator"),
        "Expected derived classes: {}",
        output
    );
}

#[test]
fn test_class_es5_super_with_promise_resolve() {
    // super() with Promise.resolve patterns
    let source = r#"
class BaseAsync {
    protected id: string;
    protected ready: Promise<void>;

    constructor(id: string) {
        this.id = id;
        this.ready = Promise.resolve();
    }

    async getId(): Promise<string> {
        await this.ready;
        return this.id;
    }
}

class DelayedInit extends BaseAsync {
    private initPromise: Promise<void>;

    constructor(id: string, delay: number) {
        super(id);
        this.initPromise = new Promise(resolve => {
            setTimeout(resolve, delay);
        });
    }

    async waitForInit(): Promise<void> {
        await this.initPromise;
    }
}

class ChainedAsync extends BaseAsync {
    private data: any;

    constructor(id: string, dataLoader: () => Promise<any>) {
        super(id);
        this.ready = Promise.resolve().then(async () => {
            this.data = await dataLoader();
        });
    }

    async getData(): Promise<any> {
        await this.ready;
        return this.data;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function BaseAsync"),
        "Expected BaseAsync function: {}",
        output
    );
    assert!(
        output.contains("Promise.resolve"),
        "Expected Promise.resolve: {}",
        output
    );
}

#[test]
fn test_class_es5_super_with_async_await() {
    // super() in async/await context (async factory pattern)
    let source = r#"
class BaseEntity {
    protected id: number;
    protected name: string;

    constructor(id: number, name: string) {
        this.id = id;
        this.name = name;
    }

    getId(): number {
        return this.id;
    }
}

class AsyncEntity extends BaseEntity {
    private metadata: any;

    private constructor(id: number, name: string, metadata: any) {
        super(id, name);
        this.metadata = metadata;
    }

    static async create(id: number): Promise<AsyncEntity> {
        const data = await fetch(`/api/entity/${id}`);
        const json = await data.json();
        return new AsyncEntity(id, json.name, json.metadata);
    }

    getMetadata(): any {
        return this.metadata;
    }
}

class CachedEntity extends BaseEntity {
    private static cache = new Map<number, CachedEntity>();

    private constructor(id: number, name: string) {
        super(id, name);
    }

    static async getOrCreate(id: number): Promise<CachedEntity> {
        if (this.cache.has(id)) {
            return this.cache.get(id)!;
        }
        const data = await fetch(`/api/entity/${id}`);
        const json = await data.json();
        const entity = new CachedEntity(id, json.name);
        this.cache.set(id, entity);
        return entity;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function BaseEntity"),
        "Expected BaseEntity function: {}",
        output
    );
    assert!(
        output.contains("AsyncEntity") && output.contains("CachedEntity"),
        "Expected derived classes: {}",
        output
    );
    assert!(
        output.contains("create") && output.contains("getOrCreate"),
        "Expected static async methods: {}",
        output
    );
}

#[test]
fn test_class_es5_super_with_spread() {
    // super() with spread in derived constructor
    let source = r#"
class BaseCollection {
    protected items: any[];

    constructor(...items: any[]) {
        this.items = items;
    }

    getItems(): any[] {
        return this.items;
    }
}

class ExtendedCollection extends BaseCollection {
    private metadata: string;

    constructor(metadata: string, ...items: any[]) {
        super(...items);
        this.metadata = metadata;
    }

    getMetadata(): string {
        return this.metadata;
    }
}

class MergedCollection extends BaseCollection {
    constructor(first: any[], second: any[], ...rest: any[]) {
        super(...first, ...second, ...rest);
    }
}

class FilteredCollection extends BaseCollection {
    constructor(items: any[], filter: (item: any) => boolean) {
        super(...items.filter(filter));
    }
}

class TransformedCollection extends BaseCollection {
    constructor(items: any[], transform: (item: any) => any) {
        super(...items.map(transform));
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function BaseCollection"),
        "Expected BaseCollection function: {}",
        output
    );
    assert!(
        output.contains("ExtendedCollection") && output.contains("MergedCollection"),
        "Expected spread-using derived classes: {}",
        output
    );
    assert!(
        output.contains("FilteredCollection") && output.contains("TransformedCollection"),
        "Expected transform-spread derived classes: {}",
        output
    );
}

#[test]
fn test_class_es5_super_with_complex_args() {
    // super() with complex argument expressions
    let source = r#"
class BaseProcessor {
    protected config: { name: string; options: any };

    constructor(name: string, options: any) {
        this.config = { name, options };
    }

    getConfig(): { name: string; options: any } {
        return this.config;
    }
}

class ComputedArgsProcessor extends BaseProcessor {
    constructor(parts: string[], optionsList: any[]) {
        super(
            parts.join("-").toLowerCase(),
            optionsList.reduce((acc, opt) => ({ ...acc, ...opt }), {})
        );
    }
}

class FunctionCallProcessor extends BaseProcessor {
    constructor(nameProvider: () => string, optionsProvider: () => any) {
        super(nameProvider(), optionsProvider());
    }
}

class TemplateProcessor extends BaseProcessor {
    constructor(prefix: string, suffix: string, id: number) {
        super(
            `${prefix}_${id}_${suffix}`,
            { generated: true, timestamp: Date.now() }
        );
    }
}

class DestructuredProcessor extends BaseProcessor {
    constructor({ name, version }: { name: string; version: string }, extra: any) {
        super(
            `${name}@${version}`,
            { ...extra, name, version }
        );
    }
}

class ChainedCallProcessor extends BaseProcessor {
    constructor(data: string) {
        super(
            data.trim().toLowerCase().replace(/\s+/g, "-"),
            JSON.parse(data.includes("{") ? data : "{}")
        );
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function BaseProcessor"),
        "Expected BaseProcessor function: {}",
        output
    );
    assert!(
        output.contains("ComputedArgsProcessor") && output.contains("FunctionCallProcessor"),
        "Expected complex args derived classes: {}",
        output
    );
    assert!(
        output.contains("TemplateProcessor") && output.contains("DestructuredProcessor"),
        "Expected more derived classes: {}",
        output
    );
    assert!(
        output.contains("ChainedCallProcessor"),
        "Expected ChainedCallProcessor: {}",
        output
    );
}

// ============================================================================
// abstract class pattern tests
// ============================================================================

#[test]
fn test_class_es5_abstract_method_inheritance() {
    // Test abstract class with abstract methods implemented by derived class
    let source = r#"
abstract class Shape {
    abstract getArea(): number;
    abstract getPerimeter(): number;

    describe(): string {
        return `Area: ${this.getArea()}, Perimeter: ${this.getPerimeter()}`;
    }
}

class Rectangle extends Shape {
    constructor(private width: number, private height: number) {
        super();
    }

    getArea(): number {
        return this.width * this.height;
    }

    getPerimeter(): number {
        return 2 * (this.width + this.height);
    }
}

class Circle extends Shape {
    constructor(private radius: number) {
        super();
    }

    getArea(): number {
        return Math.PI * this.radius * this.radius;
    }

    getPerimeter(): number {
        return 2 * Math.PI * this.radius;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Shape"),
        "Expected Shape function: {}",
        output
    );
    assert!(
        output.contains("Shape.prototype.describe"),
        "Expected describe method on prototype: {}",
        output
    );
    assert!(
        output.contains("function Rectangle") && output.contains("__extends(Rectangle, _super)"),
        "Expected Rectangle extending Shape: {}",
        output
    );
    assert!(
        output.contains("Rectangle.prototype.getArea")
            && output.contains("Rectangle.prototype.getPerimeter"),
        "Expected Rectangle implementing abstract methods: {}",
        output
    );
    assert!(
        output.contains("function Circle") && output.contains("__extends(Circle, _super)"),
        "Expected Circle extending Shape: {}",
        output
    );
}

#[test]
fn test_class_es5_abstract_with_decorators() {
    // Test abstract class with decorators on class and methods
    let source = r#"
function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}

function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(...args: any[]) {
        console.log(`Calling ${propertyKey}`);
        return original.apply(this, args);
    };
}

@sealed
abstract class BaseService {
    abstract process(data: string): void;

    @log
    validate(data: string): boolean {
        return data.length > 0;
    }
}

class UserService extends BaseService {
    @log
    process(data: string): void {
        console.log(`Processing: ${data}`);
    }
}

@sealed
abstract class DecoratedAbstract {
    abstract getName(): string;

    @log
    greet(): string {
        return `Hello, ${this.getName()}`;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function sealed") && output.contains("Object.seal"),
        "Expected sealed decorator function: {}",
        output
    );
    assert!(
        output.contains("function BaseService"),
        "Expected BaseService function: {}",
        output
    );
    assert!(
        output.contains("function UserService")
            && output.contains("__extends(UserService, _super)"),
        "Expected UserService extending BaseService: {}",
        output
    );
    assert!(
        output.contains("__decorate") || output.contains("sealed") || output.contains("log"),
        "Expected decorator application: {}",
        output
    );
    assert!(
        output.contains("DecoratedAbstract"),
        "Expected DecoratedAbstract: {}",
        output
    );
}

#[test]
fn test_class_es5_abstract_static_methods() {
    // Test abstract class with static methods and properties
    let source = r#"
abstract class Registry {
    private static instances: Map<string, Registry> = new Map();

    static register(name: string, instance: Registry): void {
        Registry.instances.set(name, instance);
    }

    static get(name: string): Registry | undefined {
        return Registry.instances.get(name);
    }

    abstract getName(): string;
    abstract initialize(): void;
}

class PluginRegistry extends Registry {
    private plugins: string[] = [];

    getName(): string {
        return "PluginRegistry";
    }

    initialize(): void {
        this.plugins = [];
    }

    static createDefault(): PluginRegistry {
        const registry = new PluginRegistry();
        Registry.register("plugins", registry);
        return registry;
    }
}

abstract class Singleton {
    private static _instance: Singleton | null = null;

    static getInstance<T extends Singleton>(this: new () => T): T {
        if (!Singleton._instance) {
            Singleton._instance = new this();
        }
        return Singleton._instance as T;
    }

    abstract doWork(): void;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Registry"),
        "Expected Registry function: {}",
        output
    );
    assert!(
        output.contains("Registry.register") || output.contains("Registry.instances"),
        "Expected static method or property on Registry: {}",
        output
    );
    assert!(
        output.contains("function PluginRegistry")
            && output.contains("__extends(PluginRegistry, _super)"),
        "Expected PluginRegistry extending Registry: {}",
        output
    );
    assert!(
        output.contains("PluginRegistry.createDefault")
            || output.contains("PluginRegistry.prototype.getName"),
        "Expected PluginRegistry static or instance methods: {}",
        output
    );
    assert!(
        output.contains("function Singleton"),
        "Expected Singleton function: {}",
        output
    );
}

#[test]
fn test_class_es5_abstract_getters_setters() {
    // Test abstract class with abstract getters and setters
    let source = r#"
abstract class DataSource {
    abstract get data(): string;
    abstract set data(value: string);

    abstract get isReady(): boolean;

    load(): void {
        if (this.isReady) {
            console.log(this.data);
        }
    }
}

class FileDataSource extends DataSource {
    private _data: string = "";
    private _ready: boolean = false;

    get data(): string {
        return this._data;
    }

    set data(value: string) {
        this._data = value;
        this._ready = true;
    }

    get isReady(): boolean {
        return this._ready;
    }
}

abstract class Observable<T> {
    protected _value: T;

    constructor(initial: T) {
        this._value = initial;
    }

    abstract get value(): T;
    abstract set value(v: T);

    abstract subscribe(callback: (value: T) => void): void;
}

class BehaviorSubject<T> extends Observable<T> {
    private subscribers: ((value: T) => void)[] = [];

    get value(): T {
        return this._value;
    }

    set value(v: T) {
        this._value = v;
        this.subscribers.forEach(cb => cb(v));
    }

    subscribe(callback: (value: T) => void): void {
        this.subscribers.push(callback);
        callback(this._value);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function DataSource"),
        "Expected DataSource function: {}",
        output
    );
    assert!(
        output.contains("DataSource.prototype.load"),
        "Expected load method on prototype: {}",
        output
    );
    assert!(
        output.contains("function FileDataSource")
            && output.contains("__extends(FileDataSource, _super)"),
        "Expected FileDataSource extending DataSource: {}",
        output
    );
    assert!(
        output.contains("Object.defineProperty") && output.contains("FileDataSource.prototype"),
        "Expected getter/setter via Object.defineProperty: {}",
        output
    );
    assert!(
        output.contains("function Observable") && output.contains("function BehaviorSubject"),
        "Expected Observable and BehaviorSubject: {}",
        output
    );
}

#[test]
fn test_class_es5_abstract_multi_level_inheritance() {
    // Test abstract class with multiple levels of inheritance
    let source = r#"
abstract class Entity {
    abstract get id(): string;

    equals(other: Entity): boolean {
        return this.id === other.id;
    }
}

abstract class TimestampedEntity extends Entity {
    abstract get createdAt(): Date;
    abstract get updatedAt(): Date;

    isNewer(other: TimestampedEntity): boolean {
        return this.updatedAt > other.updatedAt;
    }
}

abstract class AuditableEntity extends TimestampedEntity {
    abstract get createdBy(): string;
    abstract get modifiedBy(): string;

    getAuditLog(): string {
        return `Created by ${this.createdBy} at ${this.createdAt}`;
    }
}

class User extends AuditableEntity {
    private _id: string;
    private _createdAt: Date;
    private _updatedAt: Date;
    private _createdBy: string;
    private _modifiedBy: string;

    constructor(id: string, creator: string) {
        super();
        this._id = id;
        this._createdAt = new Date();
        this._updatedAt = new Date();
        this._createdBy = creator;
        this._modifiedBy = creator;
    }

    get id(): string { return this._id; }
    get createdAt(): Date { return this._createdAt; }
    get updatedAt(): Date { return this._updatedAt; }
    get createdBy(): string { return this._createdBy; }
    get modifiedBy(): string { return this._modifiedBy; }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Entity"),
        "Expected Entity function: {}",
        output
    );
    assert!(
        output.contains("function TimestampedEntity")
            && output.contains("__extends(TimestampedEntity, _super)"),
        "Expected TimestampedEntity extending Entity: {}",
        output
    );
    assert!(
        output.contains("function AuditableEntity")
            && output.contains("__extends(AuditableEntity, _super)"),
        "Expected AuditableEntity extending TimestampedEntity: {}",
        output
    );
    assert!(
        output.contains("function User") && output.contains("__extends(User, _super)"),
        "Expected User extending AuditableEntity: {}",
        output
    );
    assert!(
        output.contains("Entity.prototype.equals")
            && output.contains("TimestampedEntity.prototype.isNewer"),
        "Expected inherited methods on prototypes: {}",
        output
    );
}

#[test]
fn test_class_es5_abstract_combined_patterns() {
    // Test abstract class combining all patterns
    let source = r#"
abstract class Component<T> {
    private static componentCount: number = 0;
    protected props: T;

    constructor(props: T) {
        this.props = props;
        Component.componentCount++;
    }

    static getCount(): number {
        return Component.componentCount;
    }

    abstract render(): string;
    abstract get displayName(): string;
    abstract set state(value: any);
}

abstract class PureComponent<T> extends Component<T> {
    private _state: any = null;

    abstract shouldUpdate(nextProps: T): boolean;

    get state(): any {
        return this._state;
    }

    set state(value: any) {
        this._state = value;
    }
}

class Button extends PureComponent<{ label: string }> {
    private _displayName = "Button";

    get displayName(): string {
        return this._displayName;
    }

    shouldUpdate(nextProps: { label: string }): boolean {
        return nextProps.label !== this.props.label;
    }

    render(): string {
        return `<button>${this.props.label}</button>`;
    }
}

abstract class AbstractFactory<T> {
    protected instances: T[] = [];

    abstract create(): T;

    createMany(count: number): T[] {
        return Array.from({ length: count }, () => {
            const instance = this.create();
            this.instances.push(instance);
            return instance;
        });
    }

    abstract get factoryName(): string;
}

class WidgetFactory extends AbstractFactory<{ id: number }> {
    private counter = 0;

    get factoryName(): string {
        return "WidgetFactory";
    }

    create(): { id: number } {
        return { id: ++this.counter };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Component"),
        "Expected Component function: {}",
        output
    );
    assert!(
        output.contains("Component.getCount") || output.contains("Component.componentCount"),
        "Expected static members on Component: {}",
        output
    );
    assert!(
        output.contains("function PureComponent")
            && output.contains("__extends(PureComponent, _super)"),
        "Expected PureComponent extending Component: {}",
        output
    );
    assert!(
        output.contains("function Button") && output.contains("__extends(Button, _super)"),
        "Expected Button extending PureComponent: {}",
        output
    );
    assert!(
        output.contains("Button.prototype.render")
            && output.contains("Button.prototype.shouldUpdate"),
        "Expected Button implementing abstract methods: {}",
        output
    );
    assert!(
        output.contains("function AbstractFactory") && output.contains("function WidgetFactory"),
        "Expected AbstractFactory and WidgetFactory: {}",
        output
    );
}

// ============================================================================
// namespace merging pattern tests
// ============================================================================

#[test]
fn test_class_es5_namespace_class_augmentation() {
    // Test class with namespace augmentation (declaration merging)
    let source = r#"
class Calculator {
    add(a: number, b: number): number {
        return a + b;
    }

    subtract(a: number, b: number): number {
        return a - b;
    }
}

namespace Calculator {
    export const VERSION = "1.0.0";
    export const MAX_VALUE = 1000000;

    export function isValidInput(n: number): boolean {
        return !isNaN(n) && isFinite(n) && n <= MAX_VALUE;
    }

    export function createDefault(): Calculator {
        return new Calculator();
    }
}

class Logger {
    log(message: string): void {
        console.log(message);
    }
}

namespace Logger {
    export enum Level {
        DEBUG,
        INFO,
        WARN,
        ERROR
    }

    export interface Options {
        level: Level;
        prefix?: string;
    }

    export function create(options: Options): Logger {
        return new Logger();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Calculator"),
        "Expected Calculator function: {}",
        output
    );
    assert!(
        output.contains("Calculator.prototype.add")
            && output.contains("Calculator.prototype.subtract"),
        "Expected Calculator methods on prototype: {}",
        output
    );
    assert!(
        output.contains("Calculator.VERSION")
            || output.contains("Calculator.MAX_VALUE")
            || output.contains("Calculator.isValidInput"),
        "Expected namespace members on Calculator: {}",
        output
    );
    assert!(
        output.contains("function Logger"),
        "Expected Logger function: {}",
        output
    );
}

#[test]
fn test_class_es5_namespace_with_interface() {
    // Test namespace containing interface declarations
    let source = r#"
namespace Validation {
    export interface StringValidator {
        isValid(s: string): boolean;
    }

    export interface NumberValidator {
        isValid(n: number): boolean;
    }

    export class RegexValidator implements StringValidator {
        constructor(private pattern: RegExp) {}

        isValid(s: string): boolean {
            return this.pattern.test(s);
        }
    }

    export class RangeValidator implements NumberValidator {
        constructor(private min: number, private max: number) {}

        isValid(n: number): boolean {
            return n >= this.min && n <= this.max;
        }
    }
}

namespace Forms {
    export interface FormField {
        name: string;
        value: any;
        validator?: Validation.StringValidator;
    }

    export interface FormConfig {
        fields: FormField[];
        onSubmit: (data: Record<string, any>) => void;
    }

    export class Form {
        private fields: FormField[] = [];

        constructor(config: FormConfig) {
            this.fields = config.fields;
        }

        validate(): boolean {
            return this.fields.every(field =>
                !field.validator || field.validator.isValid(String(field.value))
            );
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("Validation") || output.contains("var Validation"),
        "Expected Validation namespace: {}",
        output
    );
    assert!(
        output.contains("RegexValidator") && output.contains("RangeValidator"),
        "Expected validator classes: {}",
        output
    );
    assert!(
        output.contains("Forms") || output.contains("var Forms"),
        "Expected Forms namespace: {}",
        output
    );
    assert!(
        output.contains("Form") && output.contains("validate"),
        "Expected Form class with validate method: {}",
        output
    );
}

#[test]
fn test_class_es5_namespace_with_enum() {
    // Test namespace containing enum declarations
    let source = r#"
namespace HttpClient {
    export enum Method {
        GET = "GET",
        POST = "POST",
        PUT = "PUT",
        DELETE = "DELETE",
        PATCH = "PATCH"
    }

    export enum StatusCode {
        OK = 200,
        CREATED = 201,
        BAD_REQUEST = 400,
        UNAUTHORIZED = 401,
        NOT_FOUND = 404,
        INTERNAL_ERROR = 500
    }

    export class Request {
        constructor(
            public url: string,
            public method: Method = Method.GET,
            public body?: any
        ) {}

        send(): Promise<Response> {
            return fetch(this.url, {
                method: this.method,
                body: this.body ? JSON.stringify(this.body) : undefined
            });
        }
    }

    export class Response {
        constructor(
            public status: StatusCode,
            public data: any
        ) {}

        isSuccess(): boolean {
            return this.status >= 200 && this.status < 300;
        }
    }
}

namespace Database {
    export const enum QueryType {
        SELECT,
        INSERT,
        UPDATE,
        DELETE
    }

    export class Query {
        constructor(private type: QueryType, private table: string) {}

        getType(): QueryType {
            return this.type;
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("HttpClient") || output.contains("var HttpClient"),
        "Expected HttpClient namespace: {}",
        output
    );
    assert!(
        output.contains("Method") || output.contains("\"GET\"") || output.contains("\"POST\""),
        "Expected Method enum values: {}",
        output
    );
    assert!(
        output.contains("StatusCode") || output.contains("200") || output.contains("404"),
        "Expected StatusCode enum values: {}",
        output
    );
    assert!(
        output.contains("Request") && output.contains("Response"),
        "Expected Request and Response classes: {}",
        output
    );
    assert!(
        output.contains("Database") || output.contains("Query"),
        "Expected Database namespace with Query: {}",
        output
    );
}

#[test]
fn test_class_es5_namespace_with_function() {
    // Test function with namespace augmentation
    let source = r#"
function greet(name: string): string {
    return `Hello, ${name}!`;
}

namespace greet {
    export const defaultName = "World";
    export const separator = ", ";

    export function formal(name: string): string {
        return `Good day, ${name}.`;
    }

    export function casual(name: string): string {
        return `Hey ${name}!`;
    }

    export function multiple(...names: string[]): string {
        return names.map(n => greet(n)).join(separator);
    }
}

function createFactory<T>(name: string): T {
    return {} as T;
}

namespace createFactory {
    export interface FactoryOptions {
        singleton?: boolean;
        lazy?: boolean;
    }

    export function withOptions<T>(name: string, options: FactoryOptions): T {
        return createFactory<T>(name);
    }

    export class Registry {
        private factories: Map<string, any> = new Map();

        register<T>(name: string, factory: () => T): void {
            this.factories.set(name, factory);
        }

        get<T>(name: string): T | undefined {
            const factory = this.factories.get(name);
            return factory ? factory() : undefined;
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function greet"),
        "Expected greet function: {}",
        output
    );
    assert!(
        output.contains("greet.defaultName")
            || output.contains("greet.formal")
            || output.contains("greet.casual"),
        "Expected namespace members on greet: {}",
        output
    );
    assert!(
        output.contains("function createFactory"),
        "Expected createFactory function: {}",
        output
    );
    assert!(
        output.contains("createFactory.withOptions")
            || output.contains("createFactory.Registry")
            || output.contains("Registry"),
        "Expected namespace members on createFactory: {}",
        output
    );
}

#[test]
fn test_class_es5_nested_namespaces() {
    // Test nested namespace declarations
    let source = r#"
namespace App {
    export namespace Models {
        export class User {
            constructor(public id: string, public name: string) {}

            toJSON(): object {
                return { id: this.id, name: this.name };
            }
        }

        export class Product {
            constructor(public sku: string, public price: number) {}

            getFormattedPrice(): string {
                return `$${this.price.toFixed(2)}`;
            }
        }
    }

    export namespace Services {
        export class UserService {
            private users: Models.User[] = [];

            add(user: Models.User): void {
                this.users.push(user);
            }

            findById(id: string): Models.User | undefined {
                return this.users.find(u => u.id === id);
            }
        }

        export class ProductService {
            private products: Models.Product[] = [];

            add(product: Models.Product): void {
                this.products.push(product);
            }

            findBySku(sku: string): Models.Product | undefined {
                return this.products.find(p => p.sku === sku);
            }
        }
    }

    export namespace Utils {
        export namespace Formatters {
            export function currency(amount: number): string {
                return `$${amount.toFixed(2)}`;
            }

            export function date(d: Date): string {
                return d.toISOString();
            }
        }

        export namespace Validators {
            export function isEmail(s: string): boolean {
                return s.includes("@");
            }

            export function isPositive(n: number): boolean {
                return n > 0;
            }
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("App") || output.contains("var App"),
        "Expected App namespace: {}",
        output
    );
    assert!(
        output.contains("Models") || output.contains("App.Models"),
        "Expected Models namespace: {}",
        output
    );
    assert!(
        output.contains("User") && output.contains("Product"),
        "Expected User and Product classes: {}",
        output
    );
    assert!(
        output.contains("Services")
            || output.contains("UserService")
            || output.contains("ProductService"),
        "Expected Services namespace with classes: {}",
        output
    );
    assert!(
        output.contains("Utils") || output.contains("Formatters") || output.contains("Validators"),
        "Expected Utils with nested namespaces: {}",
        output
    );
}

#[test]
fn test_class_es5_namespace_exports() {
    // Test namespace with various export patterns
    let source = r#"
namespace Exports {
    // Private (not exported)
    class InternalHelper {
        static process(data: string): string {
            return data.trim();
        }
    }

    const internalConfig = { debug: false };

    // Exported class
    export class PublicApi {
        private helper = InternalHelper;

        process(data: string): string {
            return this.helper.process(data);
        }
    }

    // Exported constant
    export const VERSION = "2.0.0";

    // Exported function using internal
    export function initialize(): PublicApi {
        if (internalConfig.debug) {
            console.log("Initializing...");
        }
        return new PublicApi();
    }

    // Re-export pattern
    export { InternalHelper as Helper };
}

namespace Library {
    export abstract class BaseComponent {
        abstract render(): string;
    }

    export class Button extends BaseComponent {
        constructor(private label: string) {
            super();
        }

        render(): string {
            return `<button>${this.label}</button>`;
        }
    }

    export class Input extends BaseComponent {
        constructor(private placeholder: string) {
            super();
        }

        render(): string {
            return `<input placeholder="${this.placeholder}" />`;
        }
    }

    // Export type alias (erased at runtime)
    export type ComponentType = typeof BaseComponent;

    // Export namespace member
    export const components = {
        Button,
        Input
    };
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("Exports") || output.contains("var Exports"),
        "Expected Exports namespace: {}",
        output
    );
    assert!(
        output.contains("PublicApi") && output.contains("VERSION"),
        "Expected exported PublicApi and VERSION: {}",
        output
    );
    assert!(
        output.contains("initialize"),
        "Expected initialize function: {}",
        output
    );
    assert!(
        output.contains("Library") || output.contains("var Library"),
        "Expected Library namespace: {}",
        output
    );
    assert!(
        output.contains("BaseComponent") && output.contains("Button") && output.contains("Input"),
        "Expected Library components: {}",
        output
    );
    assert!(
        output.contains("components"),
        "Expected components export: {}",
        output
    );
}

#[test]
fn test_class_es5_mixed_decorator_combined() {
    // Combined class/method/property decorators pattern
    let source = r#"
function component(name: string) {
    return function(target: Function) {
        Reflect.defineMetadata("component:name", name, target);
    };
}

function injectable(target: Function) {
    Reflect.defineMetadata("di:injectable", true, target);
}

function property(options?: { required?: boolean }) {
    return function(target: any, propertyKey: string) {
        const props = Reflect.getMetadata("properties", target) || [];
        props.push({ key: propertyKey, ...options });
        Reflect.defineMetadata("properties", props, target);
    };
}

function method(options?: { async?: boolean }) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const methods = Reflect.getMetadata("methods", target) || [];
        methods.push({ key: propertyKey, ...options });
        Reflect.defineMetadata("methods", methods, target);
        return descriptor;
    };
}

function param(name: string) {
    return function(target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const params = Reflect.getMetadata("params", target, propertyKey as string) || [];
        params[parameterIndex] = name;
        Reflect.defineMetadata("params", params, target, propertyKey as string);
    };
}

@component("UserCard")
@injectable
class UserCardComponent {
    @property({ required: true })
    userId: string;

    @property()
    displayName: string;

    @property({ required: false })
    avatar?: string;

    @method({ async: true })
    async loadUser(@param("id") id: string): Promise<void> {
        console.log(`Loading user ${id}`);
    }

    @method()
    render(): string {
        return `<div>${this.displayName}</div>`;
    }
}

@component("DataGrid")
class DataGridComponent {
    @property({ required: true })
    data: any[];

    @property()
    columns: string[];

    @method()
    sort(@param("column") column: string, @param("direction") direction: string): void {
        console.log(`Sorting by ${column} ${direction}`);
    }

    @method({ async: true })
    async refresh(): Promise<void> {
        console.log("Refreshing data");
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("UserCardComponent") && output.contains("DataGridComponent"),
        "Expected combined decorated classes: {}",
        output
    );

    // Various decorator types should be present
    assert!(
        output.contains("component") && output.contains("property") && output.contains("method"),
        "Expected mixed decorators: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_mixed_decorator_order() {
    // Decorator order of execution pattern
    let source = r#"
const executionOrder: string[] = [];

function first(target: Function) {
    executionOrder.push("first-class");
}

function second(target: Function) {
    executionOrder.push("second-class");
}

function third(target: Function) {
    executionOrder.push("third-class");
}

function methodFirst(target: any, key: string, descriptor: PropertyDescriptor) {
    executionOrder.push("first-method");
    return descriptor;
}

function methodSecond(target: any, key: string, descriptor: PropertyDescriptor) {
    executionOrder.push("second-method");
    return descriptor;
}

function propFirst(target: any, key: string) {
    executionOrder.push("first-prop");
}

function propSecond(target: any, key: string) {
    executionOrder.push("second-prop");
}

function paramFirst(target: any, key: string | symbol | undefined, index: number) {
    executionOrder.push("first-param");
}

function paramSecond(target: any, key: string | symbol | undefined, index: number) {
    executionOrder.push("second-param");
}

@first
@second
@third
class OrderedClass {
    @propFirst
    @propSecond
    value: string;

    @methodFirst
    @methodSecond
    process(
        @paramFirst @paramSecond input: string
    ): void {
        console.log(input);
    }
}

@third
@second
@first
class ReverseOrderedClass {
    @propSecond
    @propFirst
    data: number;

    @methodSecond
    @methodFirst
    execute(): void {
        console.log("executing");
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("OrderedClass") && output.contains("ReverseOrderedClass"),
        "Expected ordered decorator classes: {}",
        output
    );

    // Order-related decorators should be present
    assert!(
        output.contains("first") && output.contains("second") && output.contains("third"),
        "Expected order decorators: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_mixed_decorator_inheritance() {
    // Decorator with inheritance pattern
    let source = r#"
function baseClass(target: Function) {
    Reflect.defineMetadata("isBase", true, target);
}

function derivedClass(target: Function) {
    Reflect.defineMetadata("isDerived", true, target);
}

function inherited(target: any, propertyKey: string, descriptor?: PropertyDescriptor) {
    Reflect.defineMetadata("inherited", true, target, propertyKey);
    return descriptor;
}

function overridden(target: any, propertyKey: string, descriptor?: PropertyDescriptor) {
    Reflect.defineMetadata("overridden", true, target, propertyKey);
    return descriptor;
}

function baseProperty(target: any, propertyKey: string) {
    Reflect.defineMetadata("baseProperty", true, target, propertyKey);
}

function derivedProperty(target: any, propertyKey: string) {
    Reflect.defineMetadata("derivedProperty", true, target, propertyKey);
}

@baseClass
class BaseService {
    @baseProperty
    serviceName: string = "base";

    @inherited
    initialize(): void {
        console.log("Base initialize");
    }

    @inherited
    process(data: any): any {
        return data;
    }
}

@derivedClass
class ExtendedService extends BaseService {
    @derivedProperty
    extendedName: string = "extended";

    @overridden
    initialize(): void {
        super.initialize();
        console.log("Extended initialize");
    }

    @overridden
    process(data: any): any {
        const result = super.process(data);
        return { ...result, extended: true };
    }

    @inherited
    newMethod(): void {
        console.log("New method");
    }
}

@derivedClass
class FinalService extends ExtendedService {
    @derivedProperty
    finalName: string = "final";

    @overridden
    initialize(): void {
        super.initialize();
        console.log("Final initialize");
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("BaseService")
            && output.contains("ExtendedService")
            && output.contains("FinalService"),
        "Expected inheritance decorated classes: {}",
        output
    );

    // Inheritance decorators should be present
    assert!(
        output.contains("baseClass") && output.contains("derivedClass"),
        "Expected inheritance decorators: {}",
        output
    );

    // ES5 extends helper should be present
    assert!(
        output.contains("__extends") || output.contains("_super"),
        "Expected ES5 extends pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_mixed_decorator_metadata() {
    // Decorator metadata reflection pattern
    let source = r#"
const TYPE_METADATA = Symbol("design:type");
const PARAM_TYPES = Symbol("design:paramtypes");
const RETURN_TYPE = Symbol("design:returntype");

function reflectType(target: any, propertyKey: string) {
    const type = Reflect.getMetadata("design:type", target, propertyKey);
    Reflect.defineMetadata(TYPE_METADATA, type, target, propertyKey);
}

function reflectParams(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const paramTypes = Reflect.getMetadata("design:paramtypes", target, propertyKey);
    Reflect.defineMetadata(PARAM_TYPES, paramTypes, target, propertyKey);
    return descriptor;
}

function reflectReturn(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const returnType = Reflect.getMetadata("design:returntype", target, propertyKey);
    Reflect.defineMetadata(RETURN_TYPE, returnType, target, propertyKey);
    return descriptor;
}

function entity(tableName: string) {
    return function(target: Function) {
        Reflect.defineMetadata("entity:table", tableName, target);
        Reflect.defineMetadata("entity:columns", [], target);
    };
}

function column(options: { type: string; nullable?: boolean }) {
    return function(target: any, propertyKey: string) {
        const columns = Reflect.getMetadata("entity:columns", target.constructor) || [];
        columns.push({ name: propertyKey, ...options });
        Reflect.defineMetadata("entity:columns", columns, target.constructor);
    };
}

function relation(type: string, target: () => Function) {
    return function(classTarget: any, propertyKey: string) {
        const relations = Reflect.getMetadata("entity:relations", classTarget.constructor) || [];
        relations.push({ name: propertyKey, type, target });
        Reflect.defineMetadata("entity:relations", relations, classTarget.constructor);
    };
}

@entity("users")
class UserEntity {
    @column({ type: "int" })
    @reflectType
    id: number;

    @column({ type: "varchar", nullable: false })
    @reflectType
    name: string;

    @column({ type: "varchar", nullable: true })
    @reflectType
    email?: string;

    @relation("one-to-many", () => PostEntity)
    posts: any[];

    @reflectParams
    @reflectReturn
    findById(id: number): UserEntity | null {
        return null;
    }
}

@entity("posts")
class PostEntity {
    @column({ type: "int" })
    id: number;

    @column({ type: "text" })
    content: string;

    @relation("many-to-one", () => UserEntity)
    author: any;
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("UserEntity") && output.contains("PostEntity"),
        "Expected metadata decorated classes: {}",
        output
    );

    // Metadata decorators should be present
    assert!(
        output.contains("entity") && output.contains("column") && output.contains("relation"),
        "Expected metadata decorators: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

#[test]
fn test_class_es5_mixed_decorator_private_members() {
    // Decorator with private members pattern
    let source = r#"
function logAccess(target: any, propertyKey: string, descriptor?: PropertyDescriptor) {
    if (descriptor) {
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            console.log(`Accessing ${propertyKey}`);
            return original.apply(this, args);
        };
        return descriptor;
    }
}

function validatePrivate(target: any, propertyKey: string) {
    console.log(`Validating private property ${propertyKey}`);
}

function boundMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    return {
        configurable: true,
        get() {
            const bound = original.bind(this);
            Object.defineProperty(this, propertyKey, {
                value: bound,
                configurable: true,
                writable: true
            });
            return bound;
        }
    };
}

function memoized(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    const cacheKey = Symbol(`__cache_${propertyKey}`);

    descriptor.value = function(...args: any[]) {
        if (!(this as any)[cacheKey]) {
            (this as any)[cacheKey] = new Map();
        }
        const cache = (this as any)[cacheKey];
        const key = JSON.stringify(args);
        if (!cache.has(key)) {
            cache.set(key, original.apply(this, args));
        }
        return cache.get(key);
    };
    return descriptor;
}

class SecureService {
    @validatePrivate
    private _secretKey: string = "secret123";

    @validatePrivate
    private _apiToken: string = "";

    private _cache: Map<string, any> = new Map();

    @logAccess
    private validateToken(token: string): boolean {
        return token === this._secretKey;
    }

    @boundMethod
    public authenticate(token: string): boolean {
        return this.validateToken(token);
    }

    @memoized
    public computeHash(data: string): string {
        return btoa(data + this._secretKey);
    }
}

class DataProcessor {
    @validatePrivate
    private _buffer: any[] = [];

    @validatePrivate
    private _maxSize: number = 1000;

    @logAccess
    private processItem(item: any): any {
        return { ...item, processed: true };
    }

    @boundMethod
    public addItem(item: any): void {
        if (this._buffer.length < this._maxSize) {
            this._buffer.push(this.processItem(item));
        }
    }

    @memoized
    public getStats(): object {
        return {
            size: this._buffer.length,
            maxSize: this._maxSize
        };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("SecureService") && output.contains("DataProcessor"),
        "Expected private member decorated classes: {}",
        output
    );

    // Private member decorators should be present
    assert!(
        output.contains("logAccess") && output.contains("validatePrivate"),
        "Expected private member decorators: {}",
        output
    );

    // Class IIFE pattern should be present
    assert!(
        output.contains("(function ()") || output.contains("(function()"),
        "Expected class IIFE pattern: {}",
        output
    );
}

// ============================================================================
// module pattern variation tests
// ============================================================================

#[test]
fn test_class_es5_commonjs_class_exports() {
    // Test CommonJS module pattern with class exports
    let source = r#"
class DatabaseConnection {
    private host: string;
    private port: number;

    constructor(host: string, port: number = 5432) {
        this.host = host;
        this.port = port;
    }

    connect(): Promise<void> {
        return Promise.resolve();
    }

    disconnect(): void {
        console.log("Disconnected");
    }
}

class QueryBuilder {
    private query: string = "";

    select(...columns: string[]): this {
        this.query = `SELECT ${columns.join(", ")}`;
        return this;
    }

    from(table: string): this {
        this.query += ` FROM ${table}`;
        return this;
    }

    build(): string {
        return this.query;
    }
}

// CommonJS exports
module.exports = { DatabaseConnection, QueryBuilder };
module.exports.DatabaseConnection = DatabaseConnection;
module.exports.QueryBuilder = QueryBuilder;
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function DatabaseConnection"),
        "Expected DatabaseConnection function: {}",
        output
    );
    assert!(
        output.contains("DatabaseConnection.prototype.connect")
            && output.contains("DatabaseConnection.prototype.disconnect"),
        "Expected DatabaseConnection methods on prototype: {}",
        output
    );
    assert!(
        output.contains("function QueryBuilder"),
        "Expected QueryBuilder function: {}",
        output
    );
    assert!(
        output.contains("QueryBuilder.prototype.select")
            && output.contains("QueryBuilder.prototype.from"),
        "Expected QueryBuilder methods on prototype: {}",
        output
    );
    assert!(
        output.contains("module.exports"),
        "Expected module.exports: {}",
        output
    );
}

// Debug test: minimal version of the commonjs test to bisect the issue
#[test]
fn test_class_es5_commonjs_debug_querybuilder() {
    // Minimal test case - module.exports without object literal
    let source = r#"
var A = 1;
module.exports = A;
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("var A") && output.contains("= 1"),
        "Expected var A assignment: {}",
        output
    );
    assert!(
        output.contains("module.exports") && output.contains("= A"),
        "Expected module.exports assignment: {}",
        output
    );
}

#[test]
fn test_class_es5_esm_default_class() {
    // Test ESM default export with class
    let source = r#"
export default class Application {
    private name: string;
    private version: string;

    constructor(name: string, version: string = "1.0.0") {
        this.name = name;
        this.version = version;
    }

    getName(): string {
        return this.name;
    }

    getVersion(): string {
        return this.version;
    }

    static create(name: string): Application {
        return new Application(name);
    }
}

export class Plugin {
    constructor(public id: string, public enabled: boolean = true) {}

    enable(): void {
        this.enabled = true;
    }

    disable(): void {
        this.enabled = false;
    }
}

export class Config {
    private settings: Map<string, any> = new Map();

    set(key: string, value: any): void {
        this.settings.set(key, value);
    }

    get(key: string): any {
        return this.settings.get(key);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Application"),
        "Expected Application function: {}",
        output
    );
    assert!(
        output.contains("Application.prototype.getName")
            && output.contains("Application.prototype.getVersion"),
        "Expected Application methods on prototype: {}",
        output
    );
    assert!(
        output.contains("Application.create"),
        "Expected Application static method: {}",
        output
    );
    assert!(
        output.contains("function Plugin") && output.contains("function Config"),
        "Expected Plugin and Config functions: {}",
        output
    );
    assert!(
        output.contains("export") || output.contains("exports"),
        "Expected export statements: {}",
        output
    );
}

#[test]
fn test_class_es5_esm_named_exports() {
    // Test ESM named exports with classes
    let source = r#"
export class Logger {
    private prefix: string;

    constructor(prefix: string = "") {
        this.prefix = prefix;
    }

    log(message: string): void {
        console.log(`${this.prefix}${message}`);
    }

    error(message: string): void {
        console.error(`${this.prefix}ERROR: ${message}`);
    }

    warn(message: string): void {
        console.warn(`${this.prefix}WARN: ${message}`);
    }
}

export class Formatter {
    static formatDate(date: Date): string {
        return date.toISOString();
    }

    static formatCurrency(amount: number, currency: string = "USD"): string {
        return `${currency} ${amount.toFixed(2)}`;
    }

    static formatPercentage(value: number): string {
        return `${(value * 100).toFixed(1)}%`;
    }
}

export class Validator {
    static isEmail(value: string): boolean {
        return value.includes("@") && value.includes(".");
    }

    static isUrl(value: string): boolean {
        return value.startsWith("http://") || value.startsWith("https://");
    }

    static isPhone(value: string): boolean {
        return /^\d{10,}$/.test(value.replace(/\D/g, ""));
    }
}

export { Logger as DefaultLogger };
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Logger"),
        "Expected Logger function: {}",
        output
    );
    assert!(
        output.contains("Logger.prototype.log") && output.contains("Logger.prototype.error"),
        "Expected Logger methods on prototype: {}",
        output
    );
    assert!(
        output.contains("function Formatter") || output.contains("Formatter.formatDate"),
        "Expected Formatter with static methods: {}",
        output
    );
    assert!(
        output.contains("function Validator") || output.contains("Validator.isEmail"),
        "Expected Validator with static methods: {}",
        output
    );
}

#[test]
fn test_class_es5_re_export_patterns() {
    // Test re-export patterns with classes
    let source = r#"
// Original classes
class BaseEntity {
    constructor(public id: string) {}

    getId(): string {
        return this.id;
    }
}

class User extends BaseEntity {
    constructor(id: string, public name: string, public email: string) {
        super(id);
    }

    getDisplayName(): string {
        return this.name;
    }
}

class Product extends BaseEntity {
    constructor(id: string, public sku: string, public price: number) {
        super(id);
    }

    getFormattedPrice(): string {
        return `$${this.price.toFixed(2)}`;
    }
}

class Order extends BaseEntity {
    private items: Product[] = [];

    constructor(id: string, public userId: string) {
        super(id);
    }

    addItem(product: Product): void {
        this.items.push(product);
    }

    getTotal(): number {
        return this.items.reduce((sum, p) => sum + p.price, 0);
    }
}

// Re-export patterns
export { BaseEntity, User, Product, Order };
export { User as Customer };
export { Product as Item };
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function BaseEntity"),
        "Expected BaseEntity function: {}",
        output
    );
    assert!(
        output.contains("function User") && output.contains("__extends(User, _super)"),
        "Expected User extending BaseEntity: {}",
        output
    );
    assert!(
        output.contains("function Product") && output.contains("__extends(Product, _super)"),
        "Expected Product extending BaseEntity: {}",
        output
    );
    assert!(
        output.contains("function Order") && output.contains("__extends(Order, _super)"),
        "Expected Order extending BaseEntity: {}",
        output
    );
    assert!(
        output.contains("export") || output.contains("exports"),
        "Expected export statements: {}",
        output
    );
}

#[test]
fn test_class_es5_barrel_export_pattern() {
    // Test barrel export pattern (index file pattern)
    let source = r#"
// Service classes
class AuthService {
    private token: string | null = null;

    login(username: string, password: string): Promise<boolean> {
        return Promise.resolve(true);
    }

    logout(): void {
        this.token = null;
    }

    isAuthenticated(): boolean {
        return this.token !== null;
    }
}

class ApiService {
    private baseUrl: string;

    constructor(baseUrl: string) {
        this.baseUrl = baseUrl;
    }

    get<T>(endpoint: string): Promise<T> {
        return fetch(`${this.baseUrl}${endpoint}`).then(r => r.json());
    }

    post<T>(endpoint: string, data: any): Promise<T> {
        return fetch(`${this.baseUrl}${endpoint}`, {
            method: "POST",
            body: JSON.stringify(data)
        }).then(r => r.json());
    }
}

class StorageService {
    get(key: string): string | null {
        return localStorage.getItem(key);
    }

    set(key: string, value: string): void {
        localStorage.setItem(key, value);
    }

    remove(key: string): void {
        localStorage.removeItem(key);
    }
}

// Barrel exports
export { AuthService, ApiService, StorageService };
export type { AuthService as IAuthService };

// Default export
const services = {
    auth: new AuthService(),
    storage: new StorageService()
};

export default services;
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function AuthService"),
        "Expected AuthService function: {}",
        output
    );
    assert!(
        output.contains("AuthService.prototype.login")
            && output.contains("AuthService.prototype.logout"),
        "Expected AuthService methods: {}",
        output
    );
    assert!(
        output.contains("function ApiService"),
        "Expected ApiService function: {}",
        output
    );
    assert!(
        output.contains("function StorageService"),
        "Expected StorageService function: {}",
        output
    );
    assert!(
        output.contains("services") || output.contains("default"),
        "Expected services object or default export: {}",
        output
    );
}

#[test]
fn test_class_es5_mixed_module_patterns() {
    // Test mixed module patterns combining CommonJS and ESM
    let source = r#"
// Classes with various export patterns
export class EventEmitter {
    private listeners: Map<string, Function[]> = new Map();

    on(event: string, callback: Function): void {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event)!.push(callback);
    }

    emit(event: string, ...args: any[]): void {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            callbacks.forEach(cb => cb(...args));
        }
    }

    off(event: string, callback: Function): void {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }
}

class InternalProcessor {
    process(data: any): any {
        return data;
    }
}

export class DataPipeline extends EventEmitter {
    private processor = new InternalProcessor();
    private stages: Function[] = [];

    addStage(stage: Function): this {
        this.stages.push(stage);
        return this;
    }

    async run(input: any): Promise<any> {
        let result = input;
        for (const stage of this.stages) {
            result = await stage(result);
            this.emit("stage-complete", result);
        }
        return this.processor.process(result);
    }
}

// Mixed exports
export { EventEmitter as Emitter };
export default DataPipeline;

// Type-only export (should be erased)
export type PipelineStage = (input: any) => any | Promise<any>;
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function EventEmitter"),
        "Expected EventEmitter function: {}",
        output
    );
    assert!(
        output.contains("EventEmitter.prototype.on")
            && output.contains("EventEmitter.prototype.emit"),
        "Expected EventEmitter methods: {}",
        output
    );
    assert!(
        output.contains("function InternalProcessor"),
        "Expected InternalProcessor function: {}",
        output
    );
    assert!(
        output.contains("function DataPipeline")
            && output.contains("__extends(DataPipeline, _super)"),
        "Expected DataPipeline extending EventEmitter: {}",
        output
    );
    assert!(
        output.contains("DataPipeline.prototype.addStage")
            && output.contains("DataPipeline.prototype.run"),
        "Expected DataPipeline methods: {}",
        output
    );
}

// ============================================================================
// type guard pattern tests
// ============================================================================

#[test]
fn test_class_es5_user_defined_type_guards() {
    // Test user-defined type guard functions in classes
    let source = r#"
interface Cat {
    meow(): void;
    purr(): void;
}

interface Dog {
    bark(): void;
    fetch(): void;
}

type Animal = Cat | Dog;

class AnimalValidator {
    isCat(animal: Animal): animal is Cat {
        return "meow" in animal;
    }

    isDog(animal: Animal): animal is Dog {
        return "bark" in animal;
    }

    processAnimal(animal: Animal): string {
        if (this.isCat(animal)) {
            animal.meow();
            return "cat";
        } else if (this.isDog(animal)) {
            animal.bark();
            return "dog";
        }
        return "unknown";
    }
}

class TypeChecker<T> {
    private validators: Map<string, (value: unknown) => value is T> = new Map();

    register(name: string, validator: (value: unknown) => value is T): void {
        this.validators.set(name, validator);
    }

    check(name: string, value: unknown): value is T {
        const validator = this.validators.get(name);
        return validator ? validator(value) : false;
    }
}

function isString(value: unknown): value is string {
    return typeof value === "string";
}

function isNumber(value: unknown): value is number {
    return typeof value === "number";
}

class DataProcessor {
    processValue(value: unknown): string {
        if (isString(value)) {
            return value.toUpperCase();
        }
        if (isNumber(value)) {
            return value.toFixed(2);
        }
        return String(value);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function AnimalValidator"),
        "Expected AnimalValidator function: {}",
        output
    );
    assert!(
        output.contains("AnimalValidator.prototype.isCat")
            && output.contains("AnimalValidator.prototype.isDog"),
        "Expected type guard methods: {}",
        output
    );
    assert!(
        output.contains("AnimalValidator.prototype.processAnimal"),
        "Expected processAnimal method: {}",
        output
    );
    assert!(
        output.contains("function TypeChecker") && output.contains("function DataProcessor"),
        "Expected TypeChecker and DataProcessor: {}",
        output
    );
    assert!(
        output.contains("function isString") && output.contains("function isNumber"),
        "Expected standalone type guard functions: {}",
        output
    );
}

#[test]
fn test_class_es5_in_operator_guards() {
    // Test 'in' operator type guards
    let source = r#"
interface HttpResponse {
    status: number;
    data: any;
}

interface HttpError {
    status: number;
    error: string;
    message: string;
}

type HttpResult = HttpResponse | HttpError;

class HttpClient {
    private baseUrl: string;

    constructor(baseUrl: string) {
        this.baseUrl = baseUrl;
    }

    isError(result: HttpResult): result is HttpError {
        return "error" in result;
    }

    async handleResponse(result: HttpResult): Promise<any> {
        if ("error" in result) {
            throw new Error(result.message);
        }
        return result.data;
    }

    processResult(result: HttpResult): string {
        if ("message" in result && "error" in result) {
            return `Error: ${result.error} - ${result.message}`;
        }
        return `Success: ${JSON.stringify(result.data)}`;
    }
}

interface AdminUser {
    role: "admin";
    permissions: string[];
}

interface RegularUser {
    role: "user";
    email: string;
}

type User = AdminUser | RegularUser;

class UserService {
    isAdmin(user: User): user is AdminUser {
        return "permissions" in user && user.role === "admin";
    }

    getPermissions(user: User): string[] {
        if ("permissions" in user) {
            return user.permissions;
        }
        return [];
    }

    getUserInfo(user: User): string {
        if ("email" in user) {
            return `User: ${user.email}`;
        }
        return `Admin with ${user.permissions.length} permissions`;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function HttpClient"),
        "Expected HttpClient function: {}",
        output
    );
    assert!(
        output.contains("HttpClient.prototype.isError")
            && output.contains("HttpClient.prototype.handleResponse"),
        "Expected HttpClient methods: {}",
        output
    );
    assert!(
        output.contains("function UserService"),
        "Expected UserService function: {}",
        output
    );
    assert!(
        output.contains("UserService.prototype.isAdmin")
            && output.contains("UserService.prototype.getPermissions"),
        "Expected UserService type guard methods: {}",
        output
    );
}

#[test]
fn test_class_es5_typeof_guards() {
    // Test typeof type guards
    let source = r#"
type Primitive = string | number | boolean | null | undefined;

class PrimitiveHandler {
    handleValue(value: Primitive): string {
        if (typeof value === "string") {
            return `String: ${value.toUpperCase()}`;
        }
        if (typeof value === "number") {
            return `Number: ${value.toFixed(2)}`;
        }
        if (typeof value === "boolean") {
            return `Boolean: ${value ? "true" : "false"}`;
        }
        if (value === null) {
            return "Null value";
        }
        return "Undefined value";
    }

    isStringOrNumber(value: unknown): value is string | number {
        return typeof value === "string" || typeof value === "number";
    }

    processInput(input: unknown): string {
        if (typeof input === "function") {
            return `Function: ${input.name || "anonymous"}`;
        }
        if (typeof input === "object" && input !== null) {
            return `Object: ${Object.keys(input).length} keys`;
        }
        if (typeof input === "symbol") {
            return `Symbol: ${input.toString()}`;
        }
        return this.handleValue(input as Primitive);
    }
}

class ConfigParser {
    private config: Record<string, unknown> = {};

    set(key: string, value: unknown): void {
        this.config[key] = value;
    }

    getString(key: string): string | undefined {
        const value = this.config[key];
        if (typeof value === "string") {
            return value;
        }
        return undefined;
    }

    getNumber(key: string): number | undefined {
        const value = this.config[key];
        if (typeof value === "number") {
            return value;
        }
        return undefined;
    }

    getBoolean(key: string): boolean | undefined {
        const value = this.config[key];
        if (typeof value === "boolean") {
            return value;
        }
        return undefined;
    }

    getObject<T extends object>(key: string): T | undefined {
        const value = this.config[key];
        if (typeof value === "object" && value !== null) {
            return value as T;
        }
        return undefined;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function PrimitiveHandler"),
        "Expected PrimitiveHandler function: {}",
        output
    );
    assert!(
        output.contains("PrimitiveHandler.prototype.handleValue") && output.contains("typeof"),
        "Expected handleValue with typeof checks: {}",
        output
    );
    assert!(
        output.contains("function ConfigParser"),
        "Expected ConfigParser function: {}",
        output
    );
    assert!(
        output.contains("ConfigParser.prototype.getString")
            && output.contains("ConfigParser.prototype.getNumber"),
        "Expected ConfigParser getter methods: {}",
        output
    );
}

#[test]
fn test_class_es5_instanceof_guards() {
    // Test instanceof type guards
    let source = r#"
class BaseError extends Error {
    constructor(message: string) {
        super(message);
        this.name = "BaseError";
    }
}

class ValidationError extends BaseError {
    constructor(public field: string, message: string) {
        super(message);
        this.name = "ValidationError";
    }
}

class NetworkError extends BaseError {
    constructor(public statusCode: number, message: string) {
        super(message);
        this.name = "NetworkError";
    }
}

class ErrorHandler {
    handle(error: unknown): string {
        if (error instanceof ValidationError) {
            return `Validation failed for ${error.field}: ${error.message}`;
        }
        if (error instanceof NetworkError) {
            return `Network error ${error.statusCode}: ${error.message}`;
        }
        if (error instanceof BaseError) {
            return `Base error: ${error.message}`;
        }
        if (error instanceof Error) {
            return `Error: ${error.message}`;
        }
        return `Unknown error: ${String(error)}`;
    }

    isRecoverable(error: unknown): boolean {
        if (error instanceof NetworkError) {
            return error.statusCode >= 500;
        }
        return error instanceof ValidationError;
    }
}

class Shape {}

class Circle extends Shape {
    constructor(public radius: number) {
        super();
    }

    getArea(): number {
        return Math.PI * this.radius * this.radius;
    }
}

class Rectangle extends Shape {
    constructor(public width: number, public height: number) {
        super();
    }

    getArea(): number {
        return this.width * this.height;
    }
}

class ShapeCalculator {
    calculateArea(shape: Shape): number {
        if (shape instanceof Circle) {
            return shape.getArea();
        }
        if (shape instanceof Rectangle) {
            return shape.getArea();
        }
        return 0;
    }

    describe(shape: Shape): string {
        if (shape instanceof Circle) {
            return `Circle with radius ${shape.radius}`;
        }
        if (shape instanceof Rectangle) {
            return `Rectangle ${shape.width}x${shape.height}`;
        }
        return "Unknown shape";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function BaseError") && output.contains("__extends(BaseError, _super)"),
        "Expected BaseError extending Error: {}",
        output
    );
    assert!(
        output.contains("function ValidationError") && output.contains("function NetworkError"),
        "Expected error subclasses: {}",
        output
    );
    assert!(
        output.contains("function ErrorHandler") && output.contains("instanceof"),
        "Expected ErrorHandler with instanceof: {}",
        output
    );
    assert!(
        output.contains("function Circle") && output.contains("function Rectangle"),
        "Expected Shape subclasses: {}",
        output
    );
    assert!(
        output.contains("function ShapeCalculator"),
        "Expected ShapeCalculator: {}",
        output
    );
}

#[test]
fn test_class_es5_discriminated_unions() {
    // Test discriminated union type guards
    let source = r#"
interface LoadingState {
    kind: "loading";
}

interface SuccessState {
    kind: "success";
    data: any;
}

interface ErrorState {
    kind: "error";
    error: string;
}

type RequestState = LoadingState | SuccessState | ErrorState;

class StateManager {
    private state: RequestState = { kind: "loading" };

    isLoading(): boolean {
        return this.state.kind === "loading";
    }

    isSuccess(): boolean {
        return this.state.kind === "success";
    }

    isError(): boolean {
        return this.state.kind === "error";
    }

    getData(): any | undefined {
        if (this.state.kind === "success") {
            return this.state.data;
        }
        return undefined;
    }

    getError(): string | undefined {
        if (this.state.kind === "error") {
            return this.state.error;
        }
        return undefined;
    }

    render(): string {
        switch (this.state.kind) {
            case "loading":
                return "Loading...";
            case "success":
                return `Data: ${JSON.stringify(this.state.data)}`;
            case "error":
                return `Error: ${this.state.error}`;
        }
    }
}

type Action =
    | { type: "INCREMENT"; amount: number }
    | { type: "DECREMENT"; amount: number }
    | { type: "RESET" }
    | { type: "SET"; value: number };

class Counter {
    private value: number = 0;

    dispatch(action: Action): void {
        switch (action.type) {
            case "INCREMENT":
                this.value += action.amount;
                break;
            case "DECREMENT":
                this.value -= action.amount;
                break;
            case "RESET":
                this.value = 0;
                break;
            case "SET":
                this.value = action.value;
                break;
        }
    }

    getValue(): number {
        return this.value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function StateManager"),
        "Expected StateManager function: {}",
        output
    );
    assert!(
        output.contains("StateManager.prototype.isLoading")
            && output.contains("StateManager.prototype.isSuccess"),
        "Expected StateManager state check methods: {}",
        output
    );
    assert!(
        output.contains("StateManager.prototype.render")
            && (output.contains("switch") || output.contains("case")),
        "Expected render method with switch: {}",
        output
    );
    assert!(
        output.contains("function Counter"),
        "Expected Counter function: {}",
        output
    );
    assert!(
        output.contains("Counter.prototype.dispatch"),
        "Expected dispatch method: {}",
        output
    );
}

#[test]
fn test_class_es5_assertion_functions() {
    // Test assertion functions in classes
    let source = r#"
class Assertions {
    assertDefined<T>(value: T | undefined | null, message?: string): asserts value is T {
        if (value === undefined || value === null) {
            throw new Error(message ?? "Value is not defined");
        }
    }

    assertString(value: unknown, message?: string): asserts value is string {
        if (typeof value !== "string") {
            throw new Error(message ?? "Value is not a string");
        }
    }

    assertNumber(value: unknown, message?: string): asserts value is number {
        if (typeof value !== "number" || isNaN(value)) {
            throw new Error(message ?? "Value is not a valid number");
        }
    }

    assertArray<T>(value: unknown, message?: string): asserts value is T[] {
        if (!Array.isArray(value)) {
            throw new Error(message ?? "Value is not an array");
        }
    }
}

class SafeProcessor {
    private assertions = new Assertions();

    processString(input: unknown): string {
        this.assertions.assertString(input);
        return input.toUpperCase();
    }

    processNumber(input: unknown): number {
        this.assertions.assertNumber(input);
        return input * 2;
    }

    processArray<T>(input: unknown): T[] {
        this.assertions.assertArray<T>(input);
        return input.slice();
    }
}

function assertNonNull<T>(value: T | null | undefined): asserts value is T {
    if (value === null || value === undefined) {
        throw new Error("Value cannot be null or undefined");
    }
}

class DataValidator {
    private data: Record<string, unknown> = {};

    set(key: string, value: unknown): void {
        this.data[key] = value;
    }

    getRequired(key: string): unknown {
        const value = this.data[key];
        assertNonNull(value);
        return value;
    }

    assertHasKey(key: string): asserts this is { data: Record<string, unknown> & Record<typeof key, unknown> } {
        if (!(key in this.data)) {
            throw new Error(`Key "${key}" is required`);
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Assertions"),
        "Expected Assertions function: {}",
        output
    );
    assert!(
        output.contains("Assertions.prototype.assertDefined")
            && output.contains("Assertions.prototype.assertString"),
        "Expected assertion methods: {}",
        output
    );
    assert!(
        output.contains("function SafeProcessor"),
        "Expected SafeProcessor function: {}",
        output
    );
    assert!(
        output.contains("SafeProcessor.prototype.processString")
            && output.contains("SafeProcessor.prototype.processNumber"),
        "Expected SafeProcessor methods: {}",
        output
    );
    assert!(
        output.contains("function assertNonNull"),
        "Expected standalone assertion function: {}",
        output
    );
    assert!(
        output.contains("function DataValidator"),
        "Expected DataValidator function: {}",
        output
    );
}

// ============================================================================
// control flow analysis pattern tests
// ============================================================================

#[test]
fn test_class_es5_type_narrowing_basic() {
    // Test basic type narrowing in class methods
    let source = r#"
class TypeNarrower {
    processValue(value: string | number | null | undefined): string {
        if (value === null) {
            return "null";
        }
        if (value === undefined) {
            return "undefined";
        }
        // value is now string | number
        if (typeof value === "string") {
            return value.toUpperCase();
        }
        // value is now number
        return value.toFixed(2);
    }

    processArray(items: (string | number)[]): string[] {
        return items.map(item => {
            if (typeof item === "string") {
                return item.toLowerCase();
            }
            return String(item);
        });
    }

    narrowWithTruthy(value: string | null | undefined): string {
        if (value) {
            // value is string (truthy)
            return value.trim();
        }
        return "default";
    }
}

class ObjectNarrower {
    private data: { name?: string; age?: number } = {};

    getName(): string {
        if (this.data.name !== undefined) {
            return this.data.name;
        }
        return "Unknown";
    }

    getAge(): number {
        if (this.data.age != null) {
            return this.data.age;
        }
        return 0;
    }

    processOptional(obj: { value?: string }): string {
        if ("value" in obj && obj.value !== undefined) {
            return obj.value.toUpperCase();
        }
        return "no value";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function TypeNarrower"),
        "Expected TypeNarrower function: {}",
        output
    );
    assert!(
        output.contains("TypeNarrower.prototype.processValue") && output.contains("typeof"),
        "Expected processValue with typeof: {}",
        output
    );
    assert!(
        output.contains("TypeNarrower.prototype.narrowWithTruthy"),
        "Expected narrowWithTruthy method: {}",
        output
    );
    assert!(
        output.contains("function ObjectNarrower"),
        "Expected ObjectNarrower function: {}",
        output
    );
    assert!(
        output.contains("ObjectNarrower.prototype.getName")
            && output.contains("ObjectNarrower.prototype.getAge"),
        "Expected ObjectNarrower methods: {}",
        output
    );
}

#[test]
fn test_class_es5_exhaustiveness_checks() {
    // Test exhaustiveness checking with never type
    let source = r#"
type Shape =
    | { kind: "circle"; radius: number }
    | { kind: "rectangle"; width: number; height: number }
    | { kind: "triangle"; base: number; height: number };

class ShapeCalculator {
    calculateArea(shape: Shape): number {
        switch (shape.kind) {
            case "circle":
                return Math.PI * shape.radius * shape.radius;
            case "rectangle":
                return shape.width * shape.height;
            case "triangle":
                return (shape.base * shape.height) / 2;
            default:
                return this.assertNever(shape);
        }
    }

    private assertNever(value: never): never {
        throw new Error(`Unexpected value: ${JSON.stringify(value)}`);
    }

    describe(shape: Shape): string {
        switch (shape.kind) {
            case "circle":
                return `Circle with radius ${shape.radius}`;
            case "rectangle":
                return `Rectangle ${shape.width}x${shape.height}`;
            case "triangle":
                return `Triangle with base ${shape.base}`;
            default: {
                const _exhaustive: never = shape;
                throw new Error(`Unknown shape: ${_exhaustive}`);
            }
        }
    }
}

type Status = "pending" | "active" | "completed" | "cancelled";

class StatusHandler {
    getColor(status: Status): string {
        switch (status) {
            case "pending":
                return "gray";
            case "active":
                return "blue";
            case "completed":
                return "green";
            case "cancelled":
                return "red";
            default:
                const _check: never = status;
                return _check;
        }
    }

    getLabel(status: Status): string {
        switch (status) {
            case "pending":
                return "Pending";
            case "active":
                return "Active";
            case "completed":
                return "Completed";
            case "cancelled":
                return "Cancelled";
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ShapeCalculator"),
        "Expected ShapeCalculator function: {}",
        output
    );
    assert!(
        output.contains("ShapeCalculator.prototype.calculateArea") && output.contains("switch"),
        "Expected calculateArea with switch: {}",
        output
    );
    assert!(
        output.contains("ShapeCalculator.prototype.assertNever"),
        "Expected assertNever method: {}",
        output
    );
    assert!(
        output.contains("function StatusHandler"),
        "Expected StatusHandler function: {}",
        output
    );
    assert!(
        output.contains("StatusHandler.prototype.getColor")
            && output.contains("StatusHandler.prototype.getLabel"),
        "Expected StatusHandler methods: {}",
        output
    );
}

#[test]
fn test_class_es5_never_type_patterns() {
    // Test never type usage patterns
    let source = r#"
class ErrorThrower {
    fail(message: string): never {
        throw new Error(message);
    }

    assertCondition(condition: boolean, message: string): asserts condition {
        if (!condition) {
            this.fail(message);
        }
    }

    infiniteLoop(): never {
        while (true) {
            console.log("looping");
        }
    }
}

class ResultHandler<T, E> {
    private value: T | null = null;
    private error: E | null = null;

    static success<T, E>(value: T): ResultHandler<T, E> {
        const handler = new ResultHandler<T, E>();
        handler.value = value;
        return handler;
    }

    static failure<T, E>(error: E): ResultHandler<T, E> {
        const handler = new ResultHandler<T, E>();
        handler.error = error;
        return handler;
    }

    unwrap(): T {
        if (this.value !== null) {
            return this.value;
        }
        throw new Error("Cannot unwrap error result");
    }

    unwrapOr(defaultValue: T): T {
        if (this.value !== null) {
            return this.value;
        }
        return defaultValue;
    }

    match<R>(onSuccess: (value: T) => R, onError: (error: E) => R): R {
        if (this.value !== null) {
            return onSuccess(this.value);
        }
        if (this.error !== null) {
            return onError(this.error);
        }
        throw new Error("Invalid state");
    }
}

function exhaustiveCheck(value: never): never {
    throw new Error(`Unhandled value: ${value}`);
}

class EnumHandler {
    handle(value: "a" | "b" | "c"): string {
        if (value === "a") return "A";
        if (value === "b") return "B";
        if (value === "c") return "C";
        return exhaustiveCheck(value);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ErrorThrower"),
        "Expected ErrorThrower function: {}",
        output
    );
    assert!(
        output.contains("ErrorThrower.prototype.fail") && output.contains("throw"),
        "Expected fail method with throw: {}",
        output
    );
    assert!(
        output.contains("function ResultHandler"),
        "Expected ResultHandler function: {}",
        output
    );
    assert!(
        output.contains("ResultHandler.success") || output.contains("ResultHandler.failure"),
        "Expected ResultHandler static methods: {}",
        output
    );
    assert!(
        output.contains("function exhaustiveCheck"),
        "Expected exhaustiveCheck function: {}",
        output
    );
    assert!(
        output.contains("function EnumHandler"),
        "Expected EnumHandler function: {}",
        output
    );
}

#[test]
fn test_class_es5_conditional_narrowing() {
    // Test conditional type narrowing patterns
    let source = r#"
interface SuccessResponse<T> {
    success: true;
    data: T;
}

interface ErrorResponse {
    success: false;
    error: string;
}

type ApiResponse<T> = SuccessResponse<T> | ErrorResponse;

class ApiClient {
    async fetchData<T>(url: string): Promise<ApiResponse<T>> {
        try {
            const response = await fetch(url);
            const data = await response.json();
            return { success: true, data };
        } catch (error) {
            return { success: false, error: String(error) };
        }
    }

    processResponse<T>(response: ApiResponse<T>): T | null {
        if (response.success) {
            // response is SuccessResponse<T>
            return response.data;
        }
        // response is ErrorResponse
        console.error(response.error);
        return null;
    }

    handleResponse<T>(
        response: ApiResponse<T>,
        onSuccess: (data: T) => void,
        onError: (error: string) => void
    ): void {
        if (response.success === true) {
            onSuccess(response.data);
        } else {
            onError(response.error);
        }
    }
}

class OptionalChainHandler {
    private config: {
        settings?: {
            theme?: {
                primaryColor?: string;
                secondaryColor?: string;
            };
            features?: string[];
        };
    } = {};

    getPrimaryColor(): string {
        if (this.config.settings &&
            this.config.settings.theme &&
            this.config.settings.theme.primaryColor) {
            return this.config.settings.theme.primaryColor;
        }
        return "black";
    }

    hasFeature(feature: string): boolean {
        if (this.config.settings &&
            this.config.settings.features &&
            Array.isArray(this.config.settings.features)) {
            return this.config.settings.features.includes(feature);
        }
        return false;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ApiClient"),
        "Expected ApiClient function: {}",
        output
    );
    assert!(
        output.contains("ApiClient.prototype.fetchData")
            && output.contains("ApiClient.prototype.processResponse"),
        "Expected ApiClient methods: {}",
        output
    );
    assert!(
        output.contains("ApiClient.prototype.handleResponse"),
        "Expected handleResponse method: {}",
        output
    );
    assert!(
        output.contains("function OptionalChainHandler"),
        "Expected OptionalChainHandler function: {}",
        output
    );
    assert!(
        output.contains("OptionalChainHandler.prototype.getPrimaryColor")
            && output.contains("OptionalChainHandler.prototype.hasFeature"),
        "Expected OptionalChainHandler methods: {}",
        output
    );
}

#[test]
fn test_class_es5_array_narrowing() {
    // Test array type narrowing patterns
    let source = r#"
class ArrayProcessor {
    processItems(items: (string | number)[]): { strings: string[]; numbers: number[] } {
        const strings: string[] = [];
        const numbers: number[] = [];

        for (const item of items) {
            if (typeof item === "string") {
                strings.push(item);
            } else {
                numbers.push(item);
            }
        }

        return { strings, numbers };
    }

    findFirst<T>(items: T[], predicate: (item: T) => boolean): T | undefined {
        for (const item of items) {
            if (predicate(item)) {
                return item;
            }
        }
        return undefined;
    }

    filterNonNull<T>(items: (T | null | undefined)[]): T[] {
        const result: T[] = [];
        for (const item of items) {
            if (item !== null && item !== undefined) {
                result.push(item);
            }
        }
        return result;
    }

    isNonEmpty<T>(arr: T[]): arr is [T, ...T[]] {
        return arr.length > 0;
    }

    getFirst<T>(arr: T[]): T | undefined {
        if (this.isNonEmpty(arr)) {
            return arr[0];
        }
        return undefined;
    }
}

class TupleHandler {
    processPair(pair: [string, number]): string {
        const [name, value] = pair;
        return `${name}: ${value}`;
    }

    processOptionalPair(pair: [string, number?]): string {
        const [name, value] = pair;
        if (value !== undefined) {
            return `${name}: ${value}`;
        }
        return name;
    }

    isStringNumberPair(arr: unknown[]): arr is [string, number] {
        return arr.length === 2 &&
               typeof arr[0] === "string" &&
               typeof arr[1] === "number";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ArrayProcessor"),
        "Expected ArrayProcessor function: {}",
        output
    );
    assert!(
        output.contains("ArrayProcessor.prototype.processItems")
            && output.contains("ArrayProcessor.prototype.filterNonNull"),
        "Expected ArrayProcessor methods: {}",
        output
    );
    assert!(
        output.contains("ArrayProcessor.prototype.isNonEmpty"),
        "Expected isNonEmpty type guard: {}",
        output
    );
    assert!(
        output.contains("function TupleHandler"),
        "Expected TupleHandler function: {}",
        output
    );
    assert!(
        output.contains("TupleHandler.prototype.processPair")
            && output.contains("TupleHandler.prototype.isStringNumberPair"),
        "Expected TupleHandler methods: {}",
        output
    );
}

#[test]
fn test_class_es5_control_flow_combined() {
    // Test combined control flow analysis patterns
    let source = r#"
type JsonValue = string | number | boolean | null | JsonObject | JsonArray;
interface JsonObject { [key: string]: JsonValue }
interface JsonArray extends Array<JsonValue> {}

class JsonValidator {
    isString(value: JsonValue): value is string {
        return typeof value === "string";
    }

    isNumber(value: JsonValue): value is number {
        return typeof value === "number";
    }

    isBoolean(value: JsonValue): value is boolean {
        return typeof value === "boolean";
    }

    isNull(value: JsonValue): value is null {
        return value === null;
    }

    isObject(value: JsonValue): value is JsonObject {
        return typeof value === "object" && value !== null && !Array.isArray(value);
    }

    isArray(value: JsonValue): value is JsonArray {
        return Array.isArray(value);
    }

    stringify(value: JsonValue, indent: number = 0): string {
        const pad = " ".repeat(indent);

        if (this.isNull(value)) {
            return "null";
        }
        if (this.isString(value)) {
            return `"${value}"`;
        }
        if (this.isNumber(value) || this.isBoolean(value)) {
            return String(value);
        }
        if (this.isArray(value)) {
            const items = value.map(v => this.stringify(v, indent + 2));
            return `[\n${pad}  ${items.join(",\n" + pad + "  ")}\n${pad}]`;
        }
        if (this.isObject(value)) {
            const entries = Object.entries(value)
                .map(([k, v]) => `"${k}": ${this.stringify(v, indent + 2)}`);
            return `{\n${pad}  ${entries.join(",\n" + pad + "  ")}\n${pad}}`;
        }
        // This should be unreachable
        throw new Error("Unknown JSON value type");
    }
}

class StateMachine<S extends string, E extends string> {
    private state: S;
    private transitions: Map<S, Map<E, S>> = new Map();

    constructor(initialState: S) {
        this.state = initialState;
    }

    addTransition(from: S, event: E, to: S): void {
        if (!this.transitions.has(from)) {
            this.transitions.set(from, new Map());
        }
        this.transitions.get(from)!.set(event, to);
    }

    dispatch(event: E): boolean {
        const stateTransitions = this.transitions.get(this.state);
        if (!stateTransitions) {
            return false;
        }
        const nextState = stateTransitions.get(event);
        if (nextState === undefined) {
            return false;
        }
        this.state = nextState;
        return true;
    }

    getState(): S {
        return this.state;
    }

    canTransition(event: E): boolean {
        const stateTransitions = this.transitions.get(this.state);
        if (!stateTransitions) {
            return false;
        }
        return stateTransitions.has(event);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function JsonValidator"),
        "Expected JsonValidator function: {}",
        output
    );
    assert!(
        output.contains("JsonValidator.prototype.isString")
            && output.contains("JsonValidator.prototype.isObject"),
        "Expected JsonValidator type guard methods: {}",
        output
    );
    assert!(
        output.contains("JsonValidator.prototype.stringify"),
        "Expected stringify method: {}",
        output
    );
    assert!(
        output.contains("function StateMachine"),
        "Expected StateMachine function: {}",
        output
    );
    assert!(
        output.contains("StateMachine.prototype.addTransition")
            && output.contains("StateMachine.prototype.dispatch"),
        "Expected StateMachine methods: {}",
        output
    );
    assert!(
        output.contains("StateMachine.prototype.canTransition"),
        "Expected canTransition method: {}",
        output
    );
}

// ============================================================================
// mapped type class pattern tests
// ============================================================================

#[test]
fn test_class_es5_partial_class_fields() {
    // Test Partial<T> mapped type patterns in classes
    let source = r#"
interface UserConfig {
    name: string;
    email: string;
    age: number;
    theme: string;
}

class ConfigBuilder {
    private config: Partial<UserConfig> = {};

    setName(name: string): this {
        this.config.name = name;
        return this;
    }

    setEmail(email: string): this {
        this.config.email = email;
        return this;
    }

    setAge(age: number): this {
        this.config.age = age;
        return this;
    }

    setTheme(theme: string): this {
        this.config.theme = theme;
        return this;
    }

    build(): UserConfig {
        if (!this.config.name || !this.config.email ||
            this.config.age === undefined || !this.config.theme) {
            throw new Error("Missing required fields");
        }
        return this.config as UserConfig;
    }

    getPartial(): Partial<UserConfig> {
        return { ...this.config };
    }
}

class UpdateHandler<T> {
    update(original: T, changes: Partial<T>): T {
        return { ...original, ...changes };
    }

    merge(items: Partial<T>[]): Partial<T> {
        return items.reduce((acc, item) => ({ ...acc, ...item }), {});
    }

    hasChanges(original: T, changes: Partial<T>): boolean {
        for (const key in changes) {
            if (original[key] !== changes[key]) {
                return true;
            }
        }
        return false;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ConfigBuilder"),
        "Expected ConfigBuilder function: {}",
        output
    );
    assert!(
        output.contains("ConfigBuilder.prototype.setName")
            && output.contains("ConfigBuilder.prototype.setEmail"),
        "Expected ConfigBuilder setter methods: {}",
        output
    );
    assert!(
        output.contains("ConfigBuilder.prototype.build")
            && output.contains("ConfigBuilder.prototype.getPartial"),
        "Expected ConfigBuilder build methods: {}",
        output
    );
    assert!(
        output.contains("function UpdateHandler"),
        "Expected UpdateHandler function: {}",
        output
    );
    assert!(
        output.contains("UpdateHandler.prototype.update")
            && output.contains("UpdateHandler.prototype.merge"),
        "Expected UpdateHandler methods: {}",
        output
    );
}

#[test]
fn test_class_es5_required_class_fields() {
    // Test Required<T> mapped type patterns in classes
    let source = r#"
interface OptionalSettings {
    debug?: boolean;
    verbose?: boolean;
    timeout?: number;
    maxRetries?: number;
}

class SettingsValidator {
    validate(settings: OptionalSettings): Required<OptionalSettings> {
        return {
            debug: settings.debug ?? false,
            verbose: settings.verbose ?? false,
            timeout: settings.timeout ?? 5000,
            maxRetries: settings.maxRetries ?? 3
        };
    }

    isComplete(settings: OptionalSettings): settings is Required<OptionalSettings> {
        return settings.debug !== undefined &&
               settings.verbose !== undefined &&
               settings.timeout !== undefined &&
               settings.maxRetries !== undefined;
    }

    fillDefaults<T>(obj: Partial<T>, defaults: Required<T>): Required<T> {
        const result = { ...defaults };
        for (const key in obj) {
            if (obj[key] !== undefined) {
                (result as any)[key] = obj[key];
            }
        }
        return result;
    }
}

interface FormFields {
    username?: string;
    password?: string;
    email?: string;
}

class FormValidator {
    private requiredFields: (keyof FormFields)[] = ["username", "password"];

    validate(fields: FormFields): { valid: boolean; missing: string[] } {
        const missing: string[] = [];
        for (const field of this.requiredFields) {
            if (fields[field] === undefined || fields[field] === "") {
                missing.push(field);
            }
        }
        return { valid: missing.length === 0, missing };
    }

    toRequired(fields: FormFields): Required<FormFields> {
        return {
            username: fields.username ?? "",
            password: fields.password ?? "",
            email: fields.email ?? ""
        };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function SettingsValidator"),
        "Expected SettingsValidator function: {}",
        output
    );
    assert!(
        output.contains("SettingsValidator.prototype.validate")
            && output.contains("SettingsValidator.prototype.isComplete"),
        "Expected SettingsValidator methods: {}",
        output
    );
    assert!(
        output.contains("SettingsValidator.prototype.fillDefaults"),
        "Expected fillDefaults method: {}",
        output
    );
    assert!(
        output.contains("function FormValidator"),
        "Expected FormValidator function: {}",
        output
    );
    assert!(
        output.contains("FormValidator.prototype.validate")
            && output.contains("FormValidator.prototype.toRequired"),
        "Expected FormValidator methods: {}",
        output
    );
}

#[test]
#[ignore = "ES5 class downleveling with readonly members not fully implemented"]
fn test_class_es5_readonly_class_members() {
    // Test Readonly<T> mapped type patterns in classes
    let source = r#"
interface MutableState {
    count: number;
    items: string[];
    config: { enabled: boolean };
}

class StateManager {
    private state: MutableState = {
        count: 0,
        items: [],
        config: { enabled: true }
    };

    getState(): Readonly<MutableState> {
        return this.state;
    }

    getItems(): ReadonlyArray<string> {
        return this.state.items;
    }

    freeze<T extends object>(obj: T): Readonly<T> {
        return Object.freeze({ ...obj });
    }

    deepFreeze<T extends object>(obj: T): Readonly<T> {
        const result = { ...obj };
        for (const key in result) {
            const value = (result as any)[key];
            if (typeof value === "object" && value !== null) {
                (result as any)[key] = this.deepFreeze(value);
            }
        }
        return Object.freeze(result) as Readonly<T>;
    }
}

class ImmutableRecord<T extends object> {
    private data: Readonly<T>;

    constructor(initial: T) {
        this.data = Object.freeze({ ...initial });
    }

    get(): Readonly<T> {
        return this.data;
    }

    with(changes: Partial<T>): ImmutableRecord<T> {
        return new ImmutableRecord({ ...this.data, ...changes } as T);
    }

    getProperty<K extends keyof T>(key: K): T[K] {
        return this.data[key];
    }
}

class ReadonlyCollection<T> {
    private items: ReadonlyArray<T>;

    constructor(items: T[]) {
        this.items = Object.freeze([...items]);
    }

    get(index: number): T | undefined {
        return this.items[index];
    }

    map<U>(fn: (item: T) => U): ReadonlyCollection<U> {
        return new ReadonlyCollection(this.items.map(fn));
    }

    toArray(): ReadonlyArray<T> {
        return this.items;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function StateManager"),
        "Expected StateManager function: {}",
        output
    );
    assert!(
        output.contains("StateManager.prototype.getState")
            && output.contains("StateManager.prototype.freeze"),
        "Expected StateManager methods: {}",
        output
    );
    assert!(
        output.contains("function ImmutableRecord"),
        "Expected ImmutableRecord function: {}",
        output
    );
    assert!(
        output.contains("ImmutableRecord.prototype.get")
            && output.contains("ImmutableRecord.prototype.with"),
        "Expected ImmutableRecord methods: {}",
        output
    );
    assert!(
        output.contains("function ReadonlyCollection"),
        "Expected ReadonlyCollection function: {}",
        output
    );
}

#[test]
fn test_class_es5_pick_omit_patterns() {
    // Test Pick<T, K> and Omit<T, K> mapped type patterns
    let source = r#"
interface FullUser {
    id: string;
    username: string;
    email: string;
    password: string;
    createdAt: Date;
    updatedAt: Date;
    isAdmin: boolean;
}

type PublicUser = Pick<FullUser, "id" | "username" | "email">;
type UserCredentials = Pick<FullUser, "username" | "password">;
type UserWithoutDates = Omit<FullUser, "createdAt" | "updatedAt">;

class UserTransformer {
    toPublic(user: FullUser): PublicUser {
        return {
            id: user.id,
            username: user.username,
            email: user.email
        };
    }

    toCredentials(user: FullUser): UserCredentials {
        return {
            username: user.username,
            password: user.password
        };
    }

    omitDates(user: FullUser): UserWithoutDates {
        const { createdAt, updatedAt, ...rest } = user;
        return rest;
    }

    pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
        const result = {} as Pick<T, K>;
        for (const key of keys) {
            result[key] = obj[key];
        }
        return result;
    }

    omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {
        const result = { ...obj };
        for (const key of keys) {
            delete (result as any)[key];
        }
        return result as Omit<T, K>;
    }
}

class DataProjector<T> {
    private data: T;

    constructor(data: T) {
        this.data = data;
    }

    select<K extends keyof T>(...keys: K[]): Pick<T, K> {
        const result = {} as Pick<T, K>;
        for (const key of keys) {
            result[key] = this.data[key];
        }
        return result;
    }

    exclude<K extends keyof T>(...keys: K[]): Omit<T, K> {
        const result = { ...this.data };
        for (const key of keys) {
            delete (result as any)[key];
        }
        return result as Omit<T, K>;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function UserTransformer"),
        "Expected UserTransformer function: {}",
        output
    );
    assert!(
        output.contains("UserTransformer.prototype.toPublic")
            && output.contains("UserTransformer.prototype.toCredentials"),
        "Expected UserTransformer projection methods: {}",
        output
    );
    assert!(
        output.contains("UserTransformer.prototype.pick")
            && output.contains("UserTransformer.prototype.omit"),
        "Expected pick and omit utility methods: {}",
        output
    );
    assert!(
        output.contains("function DataProjector"),
        "Expected DataProjector function: {}",
        output
    );
    assert!(
        output.contains("DataProjector.prototype.select")
            && output.contains("DataProjector.prototype.exclude"),
        "Expected DataProjector methods: {}",
        output
    );
}

#[test]
fn test_class_es5_record_patterns() {
    // Test Record<K, V> mapped type patterns
    let source = r#"
type StatusCode = "ok" | "error" | "pending" | "cancelled";
type StatusInfo = { label: string; color: string };

class StatusRegistry {
    private statuses: Record<StatusCode, StatusInfo> = {
        ok: { label: "OK", color: "green" },
        error: { label: "Error", color: "red" },
        pending: { label: "Pending", color: "yellow" },
        cancelled: { label: "Cancelled", color: "gray" }
    };

    getStatus(code: StatusCode): StatusInfo {
        return this.statuses[code];
    }

    getAllStatuses(): Record<StatusCode, StatusInfo> {
        return { ...this.statuses };
    }

    updateStatus(code: StatusCode, info: Partial<StatusInfo>): void {
        this.statuses[code] = { ...this.statuses[code], ...info };
    }
}

class DictionaryBuilder<V> {
    private dict: Record<string, V> = {};

    set(key: string, value: V): this {
        this.dict[key] = value;
        return this;
    }

    get(key: string): V | undefined {
        return this.dict[key];
    }

    has(key: string): boolean {
        return key in this.dict;
    }

    keys(): string[] {
        return Object.keys(this.dict);
    }

    values(): V[] {
        return Object.values(this.dict);
    }

    entries(): [string, V][] {
        return Object.entries(this.dict);
    }

    toRecord(): Record<string, V> {
        return { ...this.dict };
    }
}

class IndexedStore<T> {
    private store: Record<number, T> = {};
    private nextId: number = 0;

    add(item: T): number {
        const id = this.nextId++;
        this.store[id] = item;
        return id;
    }

    get(id: number): T | undefined {
        return this.store[id];
    }

    remove(id: number): boolean {
        if (id in this.store) {
            delete this.store[id];
            return true;
        }
        return false;
    }

    getAll(): Record<number, T> {
        return { ...this.store };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function StatusRegistry"),
        "Expected StatusRegistry function: {}",
        output
    );
    assert!(
        output.contains("StatusRegistry.prototype.getStatus")
            && output.contains("StatusRegistry.prototype.getAllStatuses"),
        "Expected StatusRegistry methods: {}",
        output
    );
    assert!(
        output.contains("function DictionaryBuilder"),
        "Expected DictionaryBuilder function: {}",
        output
    );
    assert!(
        output.contains("DictionaryBuilder.prototype.set")
            && output.contains("DictionaryBuilder.prototype.get"),
        "Expected DictionaryBuilder methods: {}",
        output
    );
    assert!(
        output.contains("function IndexedStore"),
        "Expected IndexedStore function: {}",
        output
    );
    assert!(
        output.contains("IndexedStore.prototype.add")
            && output.contains("IndexedStore.prototype.remove"),
        "Expected IndexedStore methods: {}",
        output
    );
}

#[test]
fn test_class_es5_combined_mapped_types() {
    // Test combined mapped type patterns
    let source = r#"
interface Entity {
    id: string;
    name: string;
    description?: string;
    tags: string[];
    metadata: Record<string, unknown>;
}

type CreateEntity = Omit<Entity, "id">;
type UpdateEntity = Partial<Omit<Entity, "id">>;
type EntitySummary = Pick<Entity, "id" | "name">;
type ReadonlyEntity = Readonly<Entity>;

class EntityService {
    private entities: Map<string, Entity> = new Map();

    create(data: CreateEntity): Entity {
        const id = Math.random().toString(36).substr(2, 9);
        const entity: Entity = { id, ...data };
        this.entities.set(id, entity);
        return entity;
    }

    update(id: string, changes: UpdateEntity): Entity | undefined {
        const entity = this.entities.get(id);
        if (!entity) return undefined;
        const updated = { ...entity, ...changes };
        this.entities.set(id, updated);
        return updated;
    }

    getSummary(id: string): EntitySummary | undefined {
        const entity = this.entities.get(id);
        if (!entity) return undefined;
        return { id: entity.id, name: entity.name };
    }

    getReadonly(id: string): ReadonlyEntity | undefined {
        const entity = this.entities.get(id);
        if (!entity) return undefined;
        return Object.freeze({ ...entity });
    }

    list(): EntitySummary[] {
        return Array.from(this.entities.values()).map(e => ({
            id: e.id,
            name: e.name
        }));
    }
}

type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

class DeepTransformer<T extends object> {
    makeDeepPartial(obj: T): DeepPartial<T> {
        const result: any = {};
        for (const key in obj) {
            const value = obj[key];
            if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                result[key] = this.makeDeepPartial(value as any);
            } else {
                result[key] = value;
            }
        }
        return result;
    }

    makeDeepReadonly(obj: T): DeepReadonly<T> {
        const result: any = {};
        for (const key in obj) {
            const value = obj[key];
            if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                result[key] = this.makeDeepReadonly(value as any);
            } else {
                result[key] = value;
            }
        }
        return Object.freeze(result);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function EntityService"),
        "Expected EntityService function: {}",
        output
    );
    assert!(
        output.contains("EntityService.prototype.create")
            && output.contains("EntityService.prototype.update"),
        "Expected EntityService CRUD methods: {}",
        output
    );
    assert!(
        output.contains("EntityService.prototype.getSummary")
            && output.contains("EntityService.prototype.getReadonly"),
        "Expected EntityService projection methods: {}",
        output
    );
    assert!(
        output.contains("function DeepTransformer"),
        "Expected DeepTransformer function: {}",
        output
    );
    assert!(
        output.contains("DeepTransformer.prototype.makeDeepPartial")
            && output.contains("DeepTransformer.prototype.makeDeepReadonly"),
        "Expected DeepTransformer methods: {}",
        output
    );
}

// =============================================================================
// CONDITIONAL TYPE PATTERNS - ES5 TRANSFORMATION TESTS
// =============================================================================

/// Test: infer keyword in class context
/// Verifies that classes using infer keyword in conditional types transform correctly to ES5
#[test]
fn test_class_es5_infer_keyword_patterns() {
    let source = r#"
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;
type ParameterType<T> = T extends (arg: infer P) => any ? P : never;
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;

class TypeInferrer {
    inferReturnType<T extends (...args: any[]) => any>(fn: T): ReturnType<T> {
        return fn() as ReturnType<T>;
    }

    inferFirstParam<T extends (arg: any) => any>(fn: T): ParameterType<T> | undefined {
        return undefined;
    }

    async unwrapValue<T>(value: T): Promise<UnwrapPromise<T>> {
        if (value instanceof Promise) {
            return await value as UnwrapPromise<T>;
        }
        return value as UnwrapPromise<T>;
    }
}

class ArrayTypeExtractor {
    extractElementType<T>(arr: T): T extends (infer E)[] ? E : never {
        if (Array.isArray(arr) && arr.length > 0) {
            return arr[0];
        }
        throw new Error("Cannot extract from empty or non-array");
    }

    extractTupleFirst<T extends [any, ...any[]]>(tuple: T): T extends [infer F, ...any[]] ? F : never {
        return tuple[0] as any;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function TypeInferrer"),
        "Expected TypeInferrer function: {}",
        output
    );
    assert!(
        output.contains("TypeInferrer.prototype.inferReturnType"),
        "Expected inferReturnType method: {}",
        output
    );
    assert!(
        output.contains("TypeInferrer.prototype.inferFirstParam"),
        "Expected inferFirstParam method: {}",
        output
    );
    assert!(
        output.contains("TypeInferrer.prototype.unwrapValue"),
        "Expected unwrapValue async method: {}",
        output
    );
    assert!(
        output.contains("function ArrayTypeExtractor"),
        "Expected ArrayTypeExtractor function: {}",
        output
    );
    assert!(
        output.contains("ArrayTypeExtractor.prototype.extractElementType"),
        "Expected extractElementType method: {}",
        output
    );
}

/// Test: distributive conditional types
/// Verifies that classes using distributive conditionals transform correctly to ES5
#[test]
fn test_class_es5_distributive_conditionals() {
    let source = r#"
type ToArray<T> = T extends any ? T[] : never;
type NonNullableCustom<T> = T extends null | undefined ? never : T;
type Flatten<T> = T extends any[] ? T[number] : T;

class DistributiveProcessor<T> {
    private value: T;

    constructor(value: T) {
        this.value = value;
    }

    toArrayType(): ToArray<T> {
        return [this.value] as ToArray<T>;
    }

    ensureNonNull(): NonNullableCustom<T> {
        if (this.value === null || this.value === undefined) {
            throw new Error("Value is null or undefined");
        }
        return this.value as NonNullableCustom<T>;
    }

    flattenIfArray(): Flatten<T> {
        if (Array.isArray(this.value)) {
            return this.value[0] as Flatten<T>;
        }
        return this.value as Flatten<T>;
    }
}

class UnionDistributor {
    distributeOverUnion<T extends string | number>(value: T): T extends string ? string[] : number[] {
        if (typeof value === "string") {
            return value.split("") as any;
        }
        return [value] as any;
    }

    filterType<T, U>(value: T, guard: (v: T) => v is T & U): U | undefined {
        if (guard(value)) {
            return value;
        }
        return undefined;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function DistributiveProcessor"),
        "Expected DistributiveProcessor function: {}",
        output
    );
    assert!(
        output.contains("this.value = value"),
        "Expected constructor assignment: {}",
        output
    );
    assert!(
        output.contains("DistributiveProcessor.prototype.toArrayType"),
        "Expected toArrayType method: {}",
        output
    );
    assert!(
        output.contains("DistributiveProcessor.prototype.ensureNonNull"),
        "Expected ensureNonNull method: {}",
        output
    );
    assert!(
        output.contains("function UnionDistributor"),
        "Expected UnionDistributor function: {}",
        output
    );
    assert!(
        output.contains("UnionDistributor.prototype.distributeOverUnion"),
        "Expected distributeOverUnion method: {}",
        output
    );
}

/// Test: Extract utility type patterns
/// Verifies that classes using Extract<T, U> type transform correctly to ES5
#[test]
fn test_class_es5_extract_type_patterns() {
    let source = r#"
type EventType = "click" | "scroll" | "keydown" | "keyup" | "focus" | "blur";
type MouseEvent = Extract<EventType, "click" | "scroll">;
type KeyEvent = Extract<EventType, "keydown" | "keyup">;
type FocusEvent = Extract<EventType, "focus" | "blur">;

class EventRegistry {
    private mouseHandlers: Map<MouseEvent, Function[]> = new Map();
    private keyHandlers: Map<KeyEvent, Function[]> = new Map();

    registerMouseEvent(event: MouseEvent, handler: Function): void {
        const handlers = this.mouseHandlers.get(event) || [];
        handlers.push(handler);
        this.mouseHandlers.set(event, handlers);
    }

    registerKeyEvent(event: KeyEvent, handler: Function): void {
        const handlers = this.keyHandlers.get(event) || [];
        handlers.push(handler);
        this.keyHandlers.set(event, handlers);
    }

    triggerMouse(event: MouseEvent): void {
        const handlers = this.mouseHandlers.get(event) || [];
        handlers.forEach(h => h());
    }
}

type Shape = { kind: "circle"; radius: number } | { kind: "square"; size: number } | { kind: "triangle"; base: number; height: number };
type CircleShape = Extract<Shape, { kind: "circle" }>;
type PolygonShape = Extract<Shape, { kind: "square" } | { kind: "triangle" }>;

class ShapeProcessor {
    processCircle(shape: CircleShape): number {
        return Math.PI * shape.radius * shape.radius;
    }

    processPolygon(shape: PolygonShape): number {
        if (shape.kind === "square") {
            return shape.size * shape.size;
        }
        return 0.5 * shape.base * shape.height;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function EventRegistry"),
        "Expected EventRegistry function: {}",
        output
    );
    assert!(
        output.contains("EventRegistry.prototype.registerMouseEvent"),
        "Expected registerMouseEvent method: {}",
        output
    );
    assert!(
        output.contains("EventRegistry.prototype.registerKeyEvent"),
        "Expected registerKeyEvent method: {}",
        output
    );
    assert!(
        output.contains("EventRegistry.prototype.triggerMouse"),
        "Expected triggerMouse method: {}",
        output
    );
    assert!(
        output.contains("function ShapeProcessor"),
        "Expected ShapeProcessor function: {}",
        output
    );
    assert!(
        output.contains("ShapeProcessor.prototype.processCircle")
            && output.contains("ShapeProcessor.prototype.processPolygon"),
        "Expected ShapeProcessor methods: {}",
        output
    );
}

/// Test: Exclude utility type patterns
/// Verifies that classes using Exclude<T, U> type transform correctly to ES5
#[test]
fn test_class_es5_exclude_type_patterns() {
    let source = r#"
type AllPermissions = "read" | "write" | "delete" | "admin" | "superadmin";
type BasicPermissions = Exclude<AllPermissions, "admin" | "superadmin">;
type AdminPermissions = Exclude<AllPermissions, "superadmin">;

class PermissionManager {
    private userPermissions: Set<BasicPermissions> = new Set();
    private adminPermissions: Set<AdminPermissions> = new Set();

    grantBasic(permission: BasicPermissions): void {
        this.userPermissions.add(permission);
    }

    grantAdmin(permission: AdminPermissions): void {
        this.adminPermissions.add(permission);
    }

    hasBasicPermission(permission: BasicPermissions): boolean {
        return this.userPermissions.has(permission);
    }

    revokeBasic(permission: BasicPermissions): void {
        this.userPermissions.delete(permission);
    }
}

type PrimitiveType = string | number | boolean | null | undefined | symbol | bigint;
type ObjectType = Exclude<unknown, PrimitiveType>;

class TypeFilter {
    filterPrimitives<T>(values: T[]): Exclude<T, null | undefined>[] {
        return values.filter((v): v is Exclude<T, null | undefined> => v !== null && v !== undefined);
    }

    excludeFalsy<T>(value: T): Exclude<T, false | 0 | "" | null | undefined> | undefined {
        if (value) {
            return value as Exclude<T, false | 0 | "" | null | undefined>;
        }
        return undefined;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function PermissionManager"),
        "Expected PermissionManager function: {}",
        output
    );
    assert!(
        output.contains("PermissionManager.prototype.grantBasic"),
        "Expected grantBasic method: {}",
        output
    );
    assert!(
        output.contains("PermissionManager.prototype.grantAdmin"),
        "Expected grantAdmin method: {}",
        output
    );
    assert!(
        output.contains("PermissionManager.prototype.hasBasicPermission"),
        "Expected hasBasicPermission method: {}",
        output
    );
    assert!(
        output.contains("function TypeFilter"),
        "Expected TypeFilter function: {}",
        output
    );
    assert!(
        output.contains("TypeFilter.prototype.filterPrimitives")
            && output.contains("TypeFilter.prototype.excludeFalsy"),
        "Expected TypeFilter methods: {}",
        output
    );
}

/// Test: nested conditional types
/// Verifies that classes using nested conditional types transform correctly to ES5
#[test]
fn test_class_es5_nested_conditional_types() {
    let source = r#"
type DeepUnwrap<T> = T extends Promise<infer U>
    ? DeepUnwrap<U>
    : T extends Array<infer E>
        ? DeepUnwrap<E>[]
        : T;

type TypeName<T> = T extends string ? "string"
    : T extends number ? "number"
    : T extends boolean ? "boolean"
    : T extends undefined ? "undefined"
    : T extends Function ? "function"
    : "object";

class DeepUnwrapper {
    async unwrap<T>(value: T): Promise<DeepUnwrap<T>> {
        let result: any = value;
        while (result instanceof Promise) {
            result = await result;
        }
        return result;
    }

    unwrapArray<T extends any[]>(arr: T): DeepUnwrap<T> {
        return arr.map(item => {
            if (Array.isArray(item)) {
                return this.unwrapArray(item);
            }
            return item;
        }) as DeepUnwrap<T>;
    }
}

class TypeNameResolver {
    getTypeName<T>(value: T): TypeName<T> {
        const type = typeof value;
        if (type === "string") return "string" as TypeName<T>;
        if (type === "number") return "number" as TypeName<T>;
        if (type === "boolean") return "boolean" as TypeName<T>;
        if (type === "undefined") return "undefined" as TypeName<T>;
        if (type === "function") return "function" as TypeName<T>;
        return "object" as TypeName<T>;
    }

    isType<T, N extends TypeName<any>>(value: T, name: N): value is T & { __typeName: N } {
        return this.getTypeName(value) === name;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function DeepUnwrapper"),
        "Expected DeepUnwrapper function: {}",
        output
    );
    assert!(
        output.contains("DeepUnwrapper.prototype.unwrap"),
        "Expected unwrap async method: {}",
        output
    );
    assert!(
        output.contains("DeepUnwrapper.prototype.unwrapArray"),
        "Expected unwrapArray method: {}",
        output
    );
    assert!(
        output.contains("function TypeNameResolver"),
        "Expected TypeNameResolver function: {}",
        output
    );
    assert!(
        output.contains("TypeNameResolver.prototype.getTypeName"),
        "Expected getTypeName method: {}",
        output
    );
    assert!(
        output.contains("TypeNameResolver.prototype.isType"),
        "Expected isType method: {}",
        output
    );
}

/// Test: combined conditional type patterns
/// Verifies that classes using multiple conditional type patterns together transform correctly to ES5
#[test]
fn test_class_es5_combined_conditional_types() {
    let source = r#"
type UnwrapFunction<T> = T extends (...args: infer A) => infer R ? { args: A; return: R } : never;
type ExtractArrayItem<T> = T extends (infer U)[] ? U : T;
type ExcludeNullish<T> = Exclude<T, null | undefined>;
type ExtractAsync<T> = Extract<T, Promise<any>>;

class FunctionAnalyzer<T extends (...args: any[]) => any> {
    private fn: T;

    constructor(fn: T) {
        this.fn = fn;
    }

    getMetadata(): UnwrapFunction<T> {
        return {
            args: [] as any,
            return: undefined as any
        } as UnwrapFunction<T>;
    }

    invoke(...args: UnwrapFunction<T> extends { args: infer A } ? A extends any[] ? A : never : never): UnwrapFunction<T> extends { return: infer R } ? R : never {
        return this.fn(...args);
    }
}

class DataPipeline<T> {
    private data: T[];

    constructor(data: T[]) {
        this.data = data;
    }

    extractItems(): ExtractArrayItem<T>[] {
        return this.data.flatMap(item =>
            Array.isArray(item) ? item : [item]
        ) as ExtractArrayItem<T>[];
    }

    excludeNullish(): ExcludeNullish<T>[] {
        return this.data.filter((item): item is ExcludeNullish<T> =>
            item !== null && item !== undefined
        );
    }

    async resolveAsync(): Promise<Awaited<ExtractAsync<T>>[]> {
        const asyncItems = this.data.filter((item): item is ExtractAsync<T> =>
            item instanceof Promise
        );
        return Promise.all(asyncItems);
    }

    transform<U>(fn: (item: ExcludeNullish<T>) => U): DataPipeline<U> {
        const transformed = this.excludeNullish().map(fn);
        return new DataPipeline(transformed);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function FunctionAnalyzer"),
        "Expected FunctionAnalyzer function: {}",
        output
    );
    assert!(
        output.contains("this.fn = fn"),
        "Expected FunctionAnalyzer constructor assignment: {}",
        output
    );
    assert!(
        output.contains("FunctionAnalyzer.prototype.getMetadata")
            && output.contains("FunctionAnalyzer.prototype.invoke"),
        "Expected FunctionAnalyzer methods: {}",
        output
    );
    assert!(
        output.contains("function DataPipeline"),
        "Expected DataPipeline function: {}",
        output
    );
    assert!(
        output.contains("this.data = data"),
        "Expected DataPipeline constructor assignment: {}",
        output
    );
    assert!(
        output.contains("DataPipeline.prototype.extractItems")
            && output.contains("DataPipeline.prototype.excludeNullish"),
        "Expected DataPipeline extraction methods: {}",
        output
    );
    assert!(
        output.contains("DataPipeline.prototype.resolveAsync")
            && output.contains("DataPipeline.prototype.transform"),
        "Expected DataPipeline async and transform methods: {}",
        output
    );
}

// ============================================================================
// DECORATOR FACTORY PATTERN TESTS
// ============================================================================

/// Test ES5 class with decorator factory with parameters
#[test]
fn test_class_es5_decorator_factory_with_params() {
    let source = r#"
// Decorator factory with parameters
function Log(prefix: string) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            console.log(`${prefix}: ${propertyKey} called with`, args);
            const result = original.apply(this, args);
            console.log(`${prefix}: ${propertyKey} returned`, result);
            return result;
        };
        return descriptor;
    };
}

function Throttle(ms: number) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        let lastCall = 0;
        descriptor.value = function(...args: any[]) {
            const now = Date.now();
            if (now - lastCall >= ms) {
                lastCall = now;
                return original.apply(this, args);
            }
        };
        return descriptor;
    };
}

function Retry(attempts: number, delay: number) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = async function(...args: any[]) {
            for (let i = 0; i < attempts; i++) {
                try {
                    return await original.apply(this, args);
                } catch (e) {
                    if (i === attempts - 1) throw e;
                    await new Promise(r => setTimeout(r, delay));
                }
            }
        };
        return descriptor;
    };
}

class ApiService {
    @Log("API")
    fetchData(endpoint: string): Promise<any> {
        return fetch(endpoint).then(r => r.json());
    }

    @Throttle(1000)
    handleClick(): void {
        console.log("Click handled");
    }

    @Retry(3, 500)
    async submitForm(data: any): Promise<void> {
        const response = await fetch("/submit", {
            method: "POST",
            body: JSON.stringify(data)
        });
        if (!response.ok) throw new Error("Submit failed");
    }
}

class CacheService {
    @Log("Cache")
    @Throttle(100)
    get(key: string): any {
        return localStorage.getItem(key);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Decorator factory functions should be present
    assert!(
        output.contains("Log") && output.contains("Throttle") && output.contains("Retry"),
        "Expected decorator factory functions: {}",
        output
    );

    // Classes should be converted
    assert!(
        output.contains("ApiService") && output.contains("CacheService"),
        "Expected classes: {}",
        output
    );

    // Decorator invocations should be present (decorators are applied)
    assert!(
        output.contains("__decorate") || output.contains("Log(") || output.contains("Throttle("),
        "Expected decorator application pattern: {}",
        output
    );
}

/// Test ES5 class with composed decorators
#[test]
fn test_class_es5_decorator_composed() {
    let source = r#"
// Composed decorators pattern
function Enumerable(value: boolean) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
        return descriptor;
    };
}

function Configurable(value: boolean) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.configurable = value;
        return descriptor;
    };
}

function Writable(value: boolean) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.writable = value;
        return descriptor;
    };
}

// Composed decorator factory
function Sealed() {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.configurable = false;
        descriptor.writable = false;
        return descriptor;
    };
}

function Validate(validator: (value: any) => boolean) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const original = descriptor.set;
        if (original) {
            descriptor.set = function(value: any) {
                if (!validator(value)) {
                    throw new Error(`Invalid value for ${propertyKey}`);
                }
                original.call(this, value);
            };
        }
        return descriptor;
    };
}

function Memoize() {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const cache = new Map<string, any>();
        const original = descriptor.value;
        descriptor.value = function(...args: any[]) {
            const key = JSON.stringify(args);
            if (cache.has(key)) {
                return cache.get(key);
            }
            const result = original.apply(this, args);
            cache.set(key, result);
            return result;
        };
        return descriptor;
    };
}

class Configuration {
    @Enumerable(false)
    @Configurable(false)
    get secret(): string {
        return "hidden";
    }

    @Sealed()
    getApiKey(): string {
        return "api-key-123";
    }

    @Memoize()
    @Enumerable(true)
    computeExpensive(input: number): number {
        let result = 0;
        for (let i = 0; i < input * 1000000; i++) {
            result += i;
        }
        return result;
    }
}

class UserSettings {
    private _age: number = 0;

    @Validate((v: number) => v >= 0 && v <= 150)
    set age(value: number) {
        this._age = value;
    }

    get age(): number {
        return this._age;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Decorator factory functions should be present
    assert!(
        output.contains("Enumerable")
            && output.contains("Configurable")
            && output.contains("Sealed"),
        "Expected decorator factory functions: {}",
        output
    );

    // Additional decorators
    assert!(
        output.contains("Validate") && output.contains("Memoize"),
        "Expected additional decorator factories: {}",
        output
    );

    // Classes should be converted
    assert!(
        output.contains("Configuration") && output.contains("UserSettings"),
        "Expected classes: {}",
        output
    );
}

/// Test ES5 class with metadata decorators
#[test]
fn test_class_es5_decorator_metadata() {
    let source = r#"
// Metadata decorators pattern
const METADATA_KEY = Symbol("metadata");

interface FieldMetadata {
    type: string;
    required: boolean;
    validation?: RegExp;
}

function Field(metadata: FieldMetadata) {
    return function(target: any, propertyKey: string) {
        const existing = Reflect.getMetadata(METADATA_KEY, target) || {};
        existing[propertyKey] = metadata;
        Reflect.defineMetadata(METADATA_KEY, existing, target);
    };
}

function Required() {
    return Field({ type: "any", required: true });
}

function TypedField(type: string) {
    return Field({ type, required: false });
}

function Pattern(regex: RegExp) {
    return function(target: any, propertyKey: string) {
        const existing = Reflect.getMetadata(METADATA_KEY, target) || {};
        existing[propertyKey] = { ...existing[propertyKey], validation: regex };
        Reflect.defineMetadata(METADATA_KEY, existing, target);
    };
}

function Entity(tableName: string) {
    return function<T extends { new(...args: any[]): {} }>(constructor: T) {
        return class extends constructor {
            static tableName = tableName;
            static getMetadata() {
                return Reflect.getMetadata(METADATA_KEY, constructor.prototype);
            }
        };
    };
}

@Entity("users")
class User {
    @Required()
    @TypedField("string")
    id!: string;

    @Required()
    @Pattern(/^[a-zA-Z0-9_]+$/)
    username!: string;

    @TypedField("string")
    @Pattern(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)
    email!: string;

    @TypedField("number")
    age?: number;
}

@Entity("products")
class Product {
    @Required()
    @TypedField("string")
    sku!: string;

    @Required()
    @TypedField("string")
    name!: string;

    @TypedField("number")
    price!: number;

    @TypedField("number")
    quantity?: number;
}

class MetadataReader {
    static getFieldsFor<T>(EntityClass: new () => T): FieldMetadata[] {
        const metadata = Reflect.getMetadata(METADATA_KEY, EntityClass.prototype);
        return Object.values(metadata || {});
    }

    static validateEntity<T extends object>(entity: T): boolean {
        const metadata = Reflect.getMetadata(METADATA_KEY, Object.getPrototypeOf(entity));
        for (const [key, meta] of Object.entries(metadata || {})) {
            const fieldMeta = meta as FieldMetadata;
            const value = (entity as any)[key];
            if (fieldMeta.required && value === undefined) {
                return false;
            }
            if (fieldMeta.validation && value && !fieldMeta.validation.test(String(value))) {
                return false;
            }
        }
        return true;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Decorator factory functions should be present
    assert!(
        output.contains("Field") && output.contains("Required") && output.contains("Entity"),
        "Expected metadata decorator factories: {}",
        output
    );

    // Additional decorators
    assert!(
        output.contains("TypedField") && output.contains("Pattern"),
        "Expected additional metadata decorators: {}",
        output
    );

    // Classes should be converted
    assert!(
        output.contains("User") && output.contains("Product") && output.contains("MetadataReader"),
        "Expected classes: {}",
        output
    );

    // Interface should be stripped
    assert!(
        !output.contains("interface FieldMetadata"),
        "Expected interface to be stripped: {}",
        output
    );
}

// ============================================================================
// CLASS FIELD INITIALIZER PATTERN TESTS
// ============================================================================

/// Test ES5 class with complex field initializers
#[test]
fn test_class_es5_field_initializer_complex() {
    let source = r#"
// Complex field initializers
class ConfigService {
    private readonly defaultConfig = {
        host: "localhost",
        port: 8080,
        timeout: 30000,
        retries: 3,
        headers: {
            "Content-Type": "application/json",
            "Accept": "application/json"
        }
    };

    private connections: Map<string, { active: boolean; lastUsed: Date }> = new Map();

    private validators = [
        (x: number) => x > 0,
        (x: number) => x < 100,
        (x: number) => Number.isInteger(x)
    ];

    private readonly now = Date.now();

    private lazyValue = (() => {
        console.log("Initializing lazy value");
        return Math.random();
    })();
}

class DataProcessor {
    private buffer: ArrayBuffer = new ArrayBuffer(1024);
    private view = new DataView(this.buffer);
    private encoder = new TextEncoder();
    private decoder = new TextDecoder("utf-8");

    private readonly metadata = Object.freeze({
        version: "1.0.0",
        format: "binary",
        encoding: "utf-8"
    });

    private cache = new WeakMap<object, any>();
}

class StateManager {
    private state = {
        count: 0,
        items: [] as string[],
        nested: {
            level1: {
                level2: {
                    value: 42
                }
            }
        }
    };

    private reducers = new Map<string, (state: any, action: any) => any>([
        ["INCREMENT", (s, a) => ({ ...s, count: s.count + 1 })],
        ["DECREMENT", (s, a) => ({ ...s, count: s.count - 1 })],
        ["ADD_ITEM", (s, a) => ({ ...s, items: [...s.items, a.payload] })]
    ]);
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ConfigService")
            && output.contains("DataProcessor")
            && output.contains("StateManager"),
        "Expected complex initializer classes: {}",
        output
    );

    // Object literals and Map should be present
    assert!(
        output.contains("Map") && output.contains("localhost"),
        "Expected complex initializer values: {}",
        output
    );
}

/// Test ES5 class with computed field names
#[test]
fn test_class_es5_field_initializer_computed() {
    let source = r#"
// Computed field names
const FIELD_PREFIX = "data_";
const VERSION = "v1";

const fieldName = Symbol("fieldName");
const privateKey = Symbol.for("privateKey");

class DynamicFields {
    [FIELD_PREFIX + "name"] = "default";
    [FIELD_PREFIX + "value"] = 42;
    [`${VERSION}_config`] = { enabled: true };

    [fieldName] = "symbol field value";
    [privateKey] = "symbol private value";

    ["computed" + "Method"]() {
        return this[FIELD_PREFIX + "name"];
    }
}

class SymbolProperties {
    static [Symbol.toStringTag] = "SymbolProperties";
    [Symbol.iterator] = function* () {
        yield 1;
        yield 2;
        yield 3;
    };

    private [Symbol.for("hidden")] = "secret";
}

class DynamicAccessor {
    private _values: Record<string, any> = {};

    ["get" + "Value"](key: string): any {
        return this._values[key];
    }

    ["set" + "Value"](key: string, value: any): void {
        this._values[key] = value;
    }
}

const keys = ["a", "b", "c"] as const;

class MultipleComputed {
    [keys[0]] = 1;
    [keys[1]] = 2;
    [keys[2]] = 3;

    getAll() {
        return [this[keys[0]], this[keys[1]], this[keys[2]]];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("DynamicFields")
            && output.contains("SymbolProperties")
            && output.contains("DynamicAccessor"),
        "Expected computed field classes: {}",
        output
    );

    // Symbol usage should be present
    assert!(
        output.contains("Symbol") || output.contains("fieldName"),
        "Expected Symbol usage: {}",
        output
    );
}

/// Test ES5 class with arrow function field initializers
#[test]
fn test_class_es5_field_initializer_arrow() {
    let source = r#"
// Arrow function field initializers
class EventHandler {
    onClick = (event: MouseEvent) => {
        console.log("Clicked at", event.clientX, event.clientY);
        this.handleEvent(event);
    };

    onKeyDown = (event: KeyboardEvent) => {
        if (event.key === "Enter") {
            this.submit();
        }
    };

    onScroll = (event: Event) => {
        requestAnimationFrame(() => {
            this.updatePosition();
        });
    };

    private handleEvent(event: Event) {
        console.log("Event handled:", event.type);
    }

    private submit() {
        console.log("Submitting...");
    }

    private updatePosition() {
        console.log("Position updated");
    }
}

class ReactiveComponent {
    render = () => {
        return `<div>${this.state.value}</div>`;
    };

    setState = (newState: Partial<typeof this.state>) => {
        this.state = { ...this.state, ...newState };
        this.render();
    };

    private state = { value: 0 };

    componentDidMount = () => {
        this.initialize();
    };

    private initialize = () => {
        console.log("Component initialized");
    };
}

class AsyncHandler {
    fetchData = async (url: string) => {
        const response = await fetch(url);
        return response.json();
    };

    processData = async (data: any) => {
        return new Promise((resolve) => {
            setTimeout(() => resolve(data), 100);
        });
    };

    handleError = (error: Error) => {
        console.error("Error:", error.message);
        this.logError(error);
    };

    private logError = (error: Error) => {
        console.log("Logged:", error);
    };
}

class BoundMethods {
    private value = 0;

    increment = () => {
        this.value++;
        return this.value;
    };

    decrement = () => {
        this.value--;
        return this.value;
    };

    reset = () => {
        this.value = 0;
        return this.value;
    };

    getValue = () => this.value;

    setValue = (v: number) => {
        this.value = v;
    };
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("EventHandler")
            && output.contains("ReactiveComponent")
            && output.contains("AsyncHandler"),
        "Expected arrow initializer classes: {}",
        output
    );

    // BoundMethods class should be present
    assert!(
        output.contains("BoundMethods"),
        "Expected BoundMethods class: {}",
        output
    );

    // Arrow functions should be transformed (either kept as arrows or converted to functions with this capture)
    assert!(
        output.contains("onClick") && output.contains("increment"),
        "Expected arrow field names to be preserved: {}",
        output
    );
}

// =============================================================================
// VARIADIC TUPLE PATTERNS - ES5 TRANSFORMATION TESTS
// =============================================================================

/// Test: spread in tuple types
/// Verifies that classes using spread in tuple types transform correctly to ES5
#[test]
fn test_class_es5_spread_in_tuples() {
    let source = r#"
type Concat<T extends unknown[], U extends unknown[]> = [...T, ...U];
type Prepend<T, U extends unknown[]> = [T, ...U];
type Append<T extends unknown[], U> = [...T, U];

class TupleConcatenator {
    concat<T extends unknown[], U extends unknown[]>(first: T, second: U): Concat<T, U> {
        return [...first, ...second] as Concat<T, U>;
    }

    prepend<T, U extends unknown[]>(item: T, tuple: U): Prepend<T, U> {
        return [item, ...tuple] as Prepend<T, U>;
    }

    append<T extends unknown[], U>(tuple: T, item: U): Append<T, U> {
        return [...tuple, item] as Append<T, U>;
    }
}

class ArraySpreadHandler {
    private items: unknown[] = [];

    spreadAndCollect<T extends unknown[]>(...args: T): T {
        this.items.push(...args);
        return args;
    }

    mergeArrays<T extends unknown[], U extends unknown[]>(a: T, b: U): [...T, ...U] {
        return [...a, ...b] as [...T, ...U];
    }

    wrapInTuple<T extends unknown[]>(items: T): [string, ...T, string] {
        return ["start", ...items, "end"] as [string, ...T, string];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function TupleConcatenator"),
        "Expected TupleConcatenator function: {}",
        output
    );
    assert!(
        output.contains("TupleConcatenator.prototype.concat"),
        "Expected concat method: {}",
        output
    );
    assert!(
        output.contains("TupleConcatenator.prototype.prepend")
            && output.contains("TupleConcatenator.prototype.append"),
        "Expected prepend and append methods: {}",
        output
    );
    assert!(
        output.contains("function ArraySpreadHandler"),
        "Expected ArraySpreadHandler function: {}",
        output
    );
    assert!(
        output.contains("ArraySpreadHandler.prototype.spreadAndCollect"),
        "Expected spreadAndCollect method: {}",
        output
    );
    assert!(
        output.contains("ArraySpreadHandler.prototype.mergeArrays")
            && output.contains("ArraySpreadHandler.prototype.wrapInTuple"),
        "Expected mergeArrays and wrapInTuple methods: {}",
        output
    );
}

/// Test: labeled tuple elements
/// Verifies that classes using labeled tuple elements transform correctly to ES5
#[test]
fn test_class_es5_labeled_tuple_elements() {
    let source = r#"
type Point2D = [x: number, y: number];
type Point3D = [x: number, y: number, z: number];
type NamedRange = [start: number, end: number, label: string];

class PointFactory {
    create2D(x: number, y: number): Point2D {
        return [x, y];
    }

    create3D(x: number, y: number, z: number): Point3D {
        return [x, y, z];
    }

    distance2D(a: Point2D, b: Point2D): number {
        const [ax, ay] = a;
        const [bx, by] = b;
        return Math.sqrt((bx - ax) ** 2 + (by - ay) ** 2);
    }

    to3D(point: Point2D, z: number): Point3D {
        return [...point, z];
    }
}

type PersonTuple = [name: string, age: number, active: boolean];
type ExtendedPerson = [...PersonTuple, role: string];

class TupleTransformer {
    createPerson(name: string, age: number, active: boolean): PersonTuple {
        return [name, age, active];
    }

    extendPerson(person: PersonTuple, role: string): ExtendedPerson {
        return [...person, role];
    }

    extractName(person: PersonTuple): string {
        const [name] = person;
        return name;
    }

    createRange(start: number, end: number, label: string): NamedRange {
        return [start, end, label];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function PointFactory"),
        "Expected PointFactory function: {}",
        output
    );
    assert!(
        output.contains("PointFactory.prototype.create2D")
            && output.contains("PointFactory.prototype.create3D"),
        "Expected create2D and create3D methods: {}",
        output
    );
    assert!(
        output.contains("PointFactory.prototype.distance2D"),
        "Expected distance2D method: {}",
        output
    );
    assert!(
        output.contains("PointFactory.prototype.to3D"),
        "Expected to3D method: {}",
        output
    );
    assert!(
        output.contains("function TupleTransformer"),
        "Expected TupleTransformer function: {}",
        output
    );
    assert!(
        output.contains("TupleTransformer.prototype.createPerson")
            && output.contains("TupleTransformer.prototype.extendPerson"),
        "Expected TupleTransformer methods: {}",
        output
    );
}

/// Test: rest elements in tuple types
/// Verifies that classes using rest elements in tuples transform correctly to ES5
#[test]
fn test_class_es5_rest_elements_in_tuples() {
    let source = r#"
type HeadAndTail<T extends unknown[]> = T extends [infer H, ...infer R] ? [H, R] : never;
type FirstTwo<T extends unknown[]> = T extends [infer A, infer B, ...unknown[]] ? [A, B] : never;
type Last<T extends unknown[]> = T extends [...unknown[], infer L] ? L : never;

class TupleDestructor {
    getHead<T extends [unknown, ...unknown[]]>(tuple: T): T[0] {
        return tuple[0];
    }

    getTail<T extends [unknown, ...unknown[]]>(tuple: T): T extends [unknown, ...infer R] ? R : never {
        const [, ...rest] = tuple;
        return rest as any;
    }

    getFirstTwo<T extends [unknown, unknown, ...unknown[]]>(tuple: T): [T[0], T[1]] {
        return [tuple[0], tuple[1]];
    }

    getLast<T extends [...unknown[], unknown]>(tuple: T): T extends [...unknown[], infer L] ? L : never {
        return tuple[tuple.length - 1] as any;
    }
}

class RestParamHandler {
    collectRest<H, T extends unknown[]>(head: H, ...tail: T): [H, ...T] {
        return [head, ...tail];
    }

    processWithRest<A, B, R extends unknown[]>(a: A, b: B, ...rest: R): { first: A; second: B; rest: R } {
        return { first: a, second: b, rest };
    }

    spreadMiddle<H, M extends unknown[], T>(head: H, middle: M, tail: T): [H, ...M, T] {
        return [head, ...middle, tail];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function TupleDestructor"),
        "Expected TupleDestructor function: {}",
        output
    );
    assert!(
        output.contains("TupleDestructor.prototype.getHead")
            && output.contains("TupleDestructor.prototype.getTail"),
        "Expected getHead and getTail methods: {}",
        output
    );
    assert!(
        output.contains("TupleDestructor.prototype.getFirstTwo")
            && output.contains("TupleDestructor.prototype.getLast"),
        "Expected getFirstTwo and getLast methods: {}",
        output
    );
    assert!(
        output.contains("function RestParamHandler"),
        "Expected RestParamHandler function: {}",
        output
    );
    assert!(
        output.contains("RestParamHandler.prototype.collectRest")
            && output.contains("RestParamHandler.prototype.processWithRest"),
        "Expected RestParamHandler methods: {}",
        output
    );
}

/// Test: tuple manipulation utilities
/// Verifies that classes using tuple manipulation types transform correctly to ES5
#[test]
fn test_class_es5_tuple_manipulation() {
    let source = r#"
type Reverse<T extends unknown[]> = T extends [infer H, ...infer R] ? [...Reverse<R>, H] : [];
type Length<T extends unknown[]> = T["length"];
type Pop<T extends unknown[]> = T extends [...infer R, unknown] ? R : never;
type Shift<T extends unknown[]> = T extends [unknown, ...infer R] ? R : never;

class TupleManipulator {
    reverse<T extends unknown[]>(tuple: T): unknown[] {
        return [...tuple].reverse();
    }

    getLength<T extends unknown[]>(tuple: T): Length<T> {
        return tuple.length as Length<T>;
    }

    pop<T extends unknown[]>(tuple: T): Pop<T> {
        const result = [...tuple];
        result.pop();
        return result as Pop<T>;
    }

    shift<T extends unknown[]>(tuple: T): Shift<T> {
        const [, ...rest] = tuple;
        return rest as Shift<T>;
    }
}

type Take<T extends unknown[], N extends number, R extends unknown[] = []> =
    R["length"] extends N ? R : T extends [infer H, ...infer T2] ? Take<T2, N, [...R, H]> : R;

class TupleSlice {
    take<T extends unknown[]>(tuple: T, count: number): unknown[] {
        return tuple.slice(0, count);
    }

    skip<T extends unknown[]>(tuple: T, count: number): unknown[] {
        return tuple.slice(count);
    }

    slice<T extends unknown[]>(tuple: T, start: number, end: number): unknown[] {
        return tuple.slice(start, end);
    }

    splitAt<T extends unknown[]>(tuple: T, index: number): [unknown[], unknown[]] {
        return [tuple.slice(0, index), tuple.slice(index)];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function TupleManipulator"),
        "Expected TupleManipulator function: {}",
        output
    );
    assert!(
        output.contains("TupleManipulator.prototype.reverse")
            && output.contains("TupleManipulator.prototype.getLength"),
        "Expected reverse and getLength methods: {}",
        output
    );
    assert!(
        output.contains("TupleManipulator.prototype.pop")
            && output.contains("TupleManipulator.prototype.shift"),
        "Expected pop and shift methods: {}",
        output
    );
    assert!(
        output.contains("function TupleSlice"),
        "Expected TupleSlice function: {}",
        output
    );
    assert!(
        output.contains("TupleSlice.prototype.take")
            && output.contains("TupleSlice.prototype.skip"),
        "Expected take and skip methods: {}",
        output
    );
    assert!(
        output.contains("TupleSlice.prototype.splitAt"),
        "Expected splitAt method: {}",
        output
    );
}

/// Test: optional tuple elements
/// Verifies that classes using optional tuple elements transform correctly to ES5
#[test]
fn test_class_es5_optional_tuple_elements() {
    let source = r#"
type OptionalCoords = [x: number, y: number, z?: number];
type ConfigTuple = [name: string, value: unknown, description?: string, tags?: string[]];

class CoordinateHandler {
    create(x: number, y: number, z?: number): OptionalCoords {
        if (z !== undefined) {
            return [x, y, z];
        }
        return [x, y];
    }

    is3D(coords: OptionalCoords): boolean {
        return coords.length === 3;
    }

    normalize(coords: OptionalCoords): [number, number, number] {
        const [x, y, z = 0] = coords;
        return [x, y, z];
    }
}

class ConfigBuilder {
    private configs: ConfigTuple[] = [];

    add(name: string, value: unknown, description?: string, tags?: string[]): this {
        if (tags !== undefined) {
            this.configs.push([name, value, description, tags]);
        } else if (description !== undefined) {
            this.configs.push([name, value, description]);
        } else {
            this.configs.push([name, value]);
        }
        return this;
    }

    getByName(name: string): ConfigTuple | undefined {
        return this.configs.find(([n]) => n === name);
    }

    toObject(): Record<string, { value: unknown; description?: string; tags?: string[] }> {
        const result: Record<string, any> = {};
        for (const config of this.configs) {
            const [name, value, description, tags] = config;
            result[name] = { value, description, tags };
        }
        return result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function CoordinateHandler"),
        "Expected CoordinateHandler function: {}",
        output
    );
    assert!(
        output.contains("CoordinateHandler.prototype.create"),
        "Expected create method: {}",
        output
    );
    assert!(
        output.contains("CoordinateHandler.prototype.is3D")
            && output.contains("CoordinateHandler.prototype.normalize"),
        "Expected is3D and normalize methods: {}",
        output
    );
    assert!(
        output.contains("function ConfigBuilder"),
        "Expected ConfigBuilder function: {}",
        output
    );
    assert!(
        output.contains("ConfigBuilder.prototype.add")
            && output.contains("ConfigBuilder.prototype.getByName"),
        "Expected add and getByName methods: {}",
        output
    );
    assert!(
        output.contains("ConfigBuilder.prototype.toObject"),
        "Expected toObject method: {}",
        output
    );
}

/// Test: combined variadic tuple patterns
/// Verifies that classes using multiple variadic tuple patterns together transform correctly to ES5
#[test]
fn test_class_es5_combined_variadic_tuple_patterns() {
    let source = r#"
type EventArgs<T extends unknown[]> = [eventName: string, ...args: T];
type Middleware<In extends unknown[], Out extends unknown[]> = (...args: In) => Out;
type Pipeline<T extends unknown[]> = [...T, done: boolean];

class EventEmitter<Events extends Record<string, unknown[]>> {
    private listeners: Map<string, Function[]> = new Map();

    emit<K extends keyof Events>(event: K, ...args: Events[K]): void {
        const handlers = this.listeners.get(event as string) || [];
        handlers.forEach(h => h(...args));
    }

    on<K extends keyof Events>(event: K, handler: (...args: Events[K]) => void): void {
        const handlers = this.listeners.get(event as string) || [];
        handlers.push(handler);
        this.listeners.set(event as string, handlers);
    }

    createEventArgs<K extends keyof Events>(event: K, ...args: Events[K]): EventArgs<Events[K]> {
        return [event as string, ...args] as EventArgs<Events[K]>;
    }
}

class PipelineBuilder<T extends unknown[]> {
    private steps: Function[] = [];

    pipe<U extends unknown[]>(fn: Middleware<T, U>): PipelineBuilder<U> {
        this.steps.push(fn);
        return this as unknown as PipelineBuilder<U>;
    }

    execute(...input: T): Pipeline<T> {
        let result: unknown[] = input;
        for (const step of this.steps) {
            result = step(...result);
        }
        return [...result, true] as Pipeline<T>;
    }

    compose<A extends unknown[], B extends unknown[], C extends unknown[]>(
        f: Middleware<A, B>,
        g: Middleware<B, C>
    ): Middleware<A, C> {
        return (...args: A) => g(...f(...args));
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function EventEmitter"),
        "Expected EventEmitter function: {}",
        output
    );
    assert!(
        output.contains("EventEmitter.prototype.emit")
            && output.contains("EventEmitter.prototype.on"),
        "Expected emit and on methods: {}",
        output
    );
    assert!(
        output.contains("EventEmitter.prototype.createEventArgs"),
        "Expected createEventArgs method: {}",
        output
    );
    assert!(
        output.contains("function PipelineBuilder"),
        "Expected PipelineBuilder function: {}",
        output
    );
    assert!(
        output.contains("PipelineBuilder.prototype.pipe")
            && output.contains("PipelineBuilder.prototype.execute"),
        "Expected pipe and execute methods: {}",
        output
    );
    assert!(
        output.contains("PipelineBuilder.prototype.compose"),
        "Expected compose method: {}",
        output
    );
}

// =============================================================================
// RECURSIVE TYPE PATTERNS - ES5 TRANSFORMATION TESTS
// =============================================================================

/// Test: recursive type aliases
/// Verifies that classes using recursive type aliases transform correctly to ES5
#[test]
fn test_class_es5_recursive_type_aliases() {
    let source = r#"
type NestedArray<T> = T | NestedArray<T>[];
type DeepPartial<T> = T extends object ? { [P in keyof T]?: DeepPartial<T[P]> } : T;
type DeepReadonly<T> = T extends object ? { readonly [P in keyof T]: DeepReadonly<T[P]> } : T;

class NestedArrayHandler<T> {
    flatten(nested: NestedArray<T>): T[] {
        if (Array.isArray(nested)) {
            return nested.flatMap(item => this.flatten(item));
        }
        return [nested];
    }

    depth(nested: NestedArray<T>): number {
        if (Array.isArray(nested)) {
            if (nested.length === 0) return 1;
            return 1 + Math.max(...nested.map(item => this.depth(item)));
        }
        return 0;
    }

    wrap(value: T, levels: number): NestedArray<T> {
        let result: NestedArray<T> = value;
        for (let i = 0; i < levels; i++) {
            result = [result];
        }
        return result;
    }
}

class DeepTransformHandler {
    makeDeepPartial<T extends object>(obj: T): DeepPartial<T> {
        const result: any = {};
        for (const key of Object.keys(obj)) {
            const value = (obj as any)[key];
            if (value && typeof value === "object" && !Array.isArray(value)) {
                result[key] = this.makeDeepPartial(value);
            } else {
                result[key] = value;
            }
        }
        return result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function NestedArrayHandler"),
        "Expected NestedArrayHandler function: {}",
        output
    );
    assert!(
        output.contains("NestedArrayHandler.prototype.flatten"),
        "Expected flatten method: {}",
        output
    );
    assert!(
        output.contains("NestedArrayHandler.prototype.depth")
            && output.contains("NestedArrayHandler.prototype.wrap"),
        "Expected depth and wrap methods: {}",
        output
    );
    assert!(
        output.contains("function DeepTransformHandler"),
        "Expected DeepTransformHandler function: {}",
        output
    );
    assert!(
        output.contains("DeepTransformHandler.prototype.makeDeepPartial"),
        "Expected makeDeepPartial method: {}",
        output
    );
}

/// Test: tree structure types
/// Verifies that classes using tree structure types transform correctly to ES5
#[test]
fn test_class_es5_tree_structure_types() {
    let source = r#"
interface TreeNode<T> {
    value: T;
    children: TreeNode<T>[];
}

interface BinaryNode<T> {
    value: T;
    left: BinaryNode<T> | null;
    right: BinaryNode<T> | null;
}

class TreeBuilder<T> {
    createNode(value: T, children: TreeNode<T>[] = []): TreeNode<T> {
        return { value, children };
    }

    addChild(parent: TreeNode<T>, child: TreeNode<T>): void {
        parent.children.push(child);
    }

    traverse(node: TreeNode<T>, callback: (value: T) => void): void {
        callback(node.value);
        for (const child of node.children) {
            this.traverse(child, callback);
        }
    }

    find(node: TreeNode<T>, predicate: (value: T) => boolean): TreeNode<T> | null {
        if (predicate(node.value)) {
            return node;
        }
        for (const child of node.children) {
            const found = this.find(child, predicate);
            if (found) return found;
        }
        return null;
    }
}

class BinaryTreeBuilder<T> {
    createNode(value: T): BinaryNode<T> {
        return { value, left: null, right: null };
    }

    insert(root: BinaryNode<number>, value: number): void {
        if (value < root.value) {
            if (root.left === null) {
                root.left = this.createNode(value) as any;
            } else {
                this.insert(root.left as any, value);
            }
        } else {
            if (root.right === null) {
                root.right = this.createNode(value) as any;
            } else {
                this.insert(root.right as any, value);
            }
        }
    }

    inOrder(node: BinaryNode<T> | null, result: T[] = []): T[] {
        if (node === null) return result;
        this.inOrder(node.left, result);
        result.push(node.value);
        this.inOrder(node.right, result);
        return result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function TreeBuilder"),
        "Expected TreeBuilder function: {}",
        output
    );
    assert!(
        output.contains("TreeBuilder.prototype.createNode")
            && output.contains("TreeBuilder.prototype.addChild"),
        "Expected createNode and addChild methods: {}",
        output
    );
    assert!(
        output.contains("TreeBuilder.prototype.traverse")
            && output.contains("TreeBuilder.prototype.find"),
        "Expected traverse and find methods: {}",
        output
    );
    assert!(
        output.contains("function BinaryTreeBuilder"),
        "Expected BinaryTreeBuilder function: {}",
        output
    );
    assert!(
        output.contains("BinaryTreeBuilder.prototype.insert")
            && output.contains("BinaryTreeBuilder.prototype.inOrder"),
        "Expected insert and inOrder methods: {}",
        output
    );
}

/// Test: linked list types
/// Verifies that classes using linked list types transform correctly to ES5
#[test]
fn test_class_es5_linked_list_types() {
    let source = r#"
interface ListNode<T> {
    value: T;
    next: ListNode<T> | null;
}

interface DoublyLinkedNode<T> {
    value: T;
    prev: DoublyLinkedNode<T> | null;
    next: DoublyLinkedNode<T> | null;
}

class LinkedList<T> {
    private head: ListNode<T> | null = null;
    private tail: ListNode<T> | null = null;

    append(value: T): void {
        const node: ListNode<T> = { value, next: null };
        if (this.tail === null) {
            this.head = node;
            this.tail = node;
        } else {
            this.tail.next = node;
            this.tail = node;
        }
    }

    prepend(value: T): void {
        const node: ListNode<T> = { value, next: this.head };
        this.head = node;
        if (this.tail === null) {
            this.tail = node;
        }
    }

    toArray(): T[] {
        const result: T[] = [];
        let current = this.head;
        while (current !== null) {
            result.push(current.value);
            current = current.next;
        }
        return result;
    }

    find(predicate: (value: T) => boolean): T | undefined {
        let current = this.head;
        while (current !== null) {
            if (predicate(current.value)) {
                return current.value;
            }
            current = current.next;
        }
        return undefined;
    }
}

class DoublyLinkedList<T> {
    private head: DoublyLinkedNode<T> | null = null;
    private tail: DoublyLinkedNode<T> | null = null;

    append(value: T): void {
        const node: DoublyLinkedNode<T> = { value, prev: this.tail, next: null };
        if (this.tail !== null) {
            this.tail.next = node;
        }
        this.tail = node;
        if (this.head === null) {
            this.head = node;
        }
    }

    reverse(): T[] {
        const result: T[] = [];
        let current = this.tail;
        while (current !== null) {
            result.push(current.value);
            current = current.prev;
        }
        return result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function LinkedList"),
        "Expected LinkedList function: {}",
        output
    );
    assert!(
        output.contains("LinkedList.prototype.append")
            && output.contains("LinkedList.prototype.prepend"),
        "Expected append and prepend methods: {}",
        output
    );
    assert!(
        output.contains("LinkedList.prototype.toArray")
            && output.contains("LinkedList.prototype.find"),
        "Expected toArray and find methods: {}",
        output
    );
    assert!(
        output.contains("function DoublyLinkedList"),
        "Expected DoublyLinkedList function: {}",
        output
    );
    assert!(
        output.contains("DoublyLinkedList.prototype.append")
            && output.contains("DoublyLinkedList.prototype.reverse"),
        "Expected DoublyLinkedList methods: {}",
        output
    );
}

/// Test: JSON-like recursive types
/// Verifies that classes using JSON-like recursive types transform correctly to ES5
#[test]
fn test_class_es5_json_recursive_types() {
    let source = r#"
type JSONValue = string | number | boolean | null | JSONObject | JSONArray;
interface JSONObject { [key: string]: JSONValue }
interface JSONArray extends Array<JSONValue> {}

type DeepJSON<T> = T extends object
    ? { [K in keyof T]: DeepJSON<T[K]> }
    : T;

class JSONProcessor {
    stringify(value: JSONValue): string {
        return JSON.stringify(value);
    }

    parse(text: string): JSONValue {
        return JSON.parse(text);
    }

    deepClone(value: JSONValue): JSONValue {
        if (value === null || typeof value !== "object") {
            return value;
        }
        if (Array.isArray(value)) {
            return value.map(item => this.deepClone(item));
        }
        const result: JSONObject = {};
        for (const key of Object.keys(value)) {
            result[key] = this.deepClone(value[key]);
        }
        return result;
    }

    merge(target: JSONObject, source: JSONObject): JSONObject {
        const result: JSONObject = { ...target };
        for (const key of Object.keys(source)) {
            const targetVal = target[key];
            const sourceVal = source[key];
            if (
                targetVal && typeof targetVal === "object" && !Array.isArray(targetVal) &&
                sourceVal && typeof sourceVal === "object" && !Array.isArray(sourceVal)
            ) {
                result[key] = this.merge(targetVal as JSONObject, sourceVal as JSONObject);
            } else {
                result[key] = sourceVal;
            }
        }
        return result;
    }
}

class JSONValidator {
    isValidJSON(value: unknown): value is JSONValue {
        if (value === null) return true;
        const type = typeof value;
        if (type === "string" || type === "number" || type === "boolean") return true;
        if (Array.isArray(value)) {
            return value.every(item => this.isValidJSON(item));
        }
        if (type === "object") {
            return Object.values(value as object).every(v => this.isValidJSON(v));
        }
        return false;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function JSONProcessor"),
        "Expected JSONProcessor function: {}",
        output
    );
    assert!(
        output.contains("JSONProcessor.prototype.stringify")
            && output.contains("JSONProcessor.prototype.parse"),
        "Expected stringify and parse methods: {}",
        output
    );
    assert!(
        output.contains("JSONProcessor.prototype.deepClone")
            && output.contains("JSONProcessor.prototype.merge"),
        "Expected deepClone and merge methods: {}",
        output
    );
    assert!(
        output.contains("function JSONValidator"),
        "Expected JSONValidator function: {}",
        output
    );
    assert!(
        output.contains("JSONValidator.prototype.isValidJSON"),
        "Expected isValidJSON method: {}",
        output
    );
}

/// Test: nested object recursive types
/// Verifies that classes using nested object types transform correctly to ES5
#[test]
fn test_class_es5_nested_object_types() {
    let source = r#"
type NestedRecord<T> = {
    [key: string]: T | NestedRecord<T>;
};

type PathValue<T, P extends string> = P extends `${infer K}.${infer R}`
    ? K extends keyof T
        ? PathValue<T[K], R>
        : never
    : P extends keyof T
        ? T[P]
        : never;

class NestedObjectHandler<T> {
    private data: NestedRecord<T>;

    constructor(data: NestedRecord<T>) {
        this.data = data;
    }

    get(path: string): T | NestedRecord<T> | undefined {
        const parts = path.split(".");
        let current: any = this.data;
        for (const part of parts) {
            if (current === undefined || current === null) return undefined;
            current = current[part];
        }
        return current;
    }

    set(path: string, value: T): void {
        const parts = path.split(".");
        let current: any = this.data;
        for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
                current[part] = {};
            }
            current = current[part];
        }
        current[parts[parts.length - 1]] = value;
    }

    flatten(prefix: string = ""): Record<string, T> {
        const result: Record<string, T> = {};
        const flatten = (obj: NestedRecord<T>, path: string) => {
            for (const key of Object.keys(obj)) {
                const fullPath = path ? path + "." + key : key;
                const value = obj[key];
                if (value && typeof value === "object" && !Array.isArray(value)) {
                    flatten(value as NestedRecord<T>, fullPath);
                } else {
                    result[fullPath] = value as T;
                }
            }
        };
        flatten(this.data, prefix);
        return result;
    }
}

class PathAccessor {
    getPath<T, P extends string>(obj: T, path: P): unknown {
        const parts = (path as string).split(".");
        let current: any = obj;
        for (const part of parts) {
            if (current === undefined) return undefined;
            current = current[part];
        }
        return current;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function NestedObjectHandler"),
        "Expected NestedObjectHandler function: {}",
        output
    );
    assert!(
        output.contains("this.data = data"),
        "Expected constructor assignment: {}",
        output
    );
    assert!(
        output.contains("NestedObjectHandler.prototype.get")
            && output.contains("NestedObjectHandler.prototype.set"),
        "Expected get and set methods: {}",
        output
    );
    assert!(
        output.contains("NestedObjectHandler.prototype.flatten"),
        "Expected flatten method: {}",
        output
    );
    assert!(
        output.contains("function PathAccessor"),
        "Expected PathAccessor function: {}",
        output
    );
    assert!(
        output.contains("PathAccessor.prototype.getPath"),
        "Expected getPath method: {}",
        output
    );
}

/// Test: combined recursive type patterns
/// Verifies that classes using multiple recursive type patterns together transform correctly to ES5
#[test]
fn test_class_es5_combined_recursive_patterns() {
    let source = r#"
interface FileSystemNode {
    name: string;
    type: "file" | "directory";
    children?: FileSystemNode[];
    size?: number;
}

type DeepMutable<T> = {
    -readonly [P in keyof T]: DeepMutable<T[P]>;
};

type Flatten<T> = T extends Array<infer U> ? Flatten<U> : T;

class FileSystem {
    private root: FileSystemNode;

    constructor() {
        this.root = { name: "/", type: "directory", children: [] };
    }

    createFile(path: string, size: number): void {
        const parts = path.split("/").filter(p => p);
        let current = this.root;
        for (let i = 0; i < parts.length - 1; i++) {
            const dir = current.children?.find(c => c.name === parts[i] && c.type === "directory");
            if (!dir) throw new Error("Directory not found");
            current = dir;
        }
        current.children = current.children || [];
        current.children.push({ name: parts[parts.length - 1], type: "file", size });
    }

    createDirectory(path: string): void {
        const parts = path.split("/").filter(p => p);
        let current = this.root;
        for (const part of parts) {
            let dir = current.children?.find(c => c.name === part && c.type === "directory");
            if (!dir) {
                dir = { name: part, type: "directory", children: [] };
                current.children = current.children || [];
                current.children.push(dir);
            }
            current = dir;
        }
    }

    getTotalSize(node: FileSystemNode = this.root): number {
        if (node.type === "file") {
            return node.size || 0;
        }
        return (node.children || []).reduce((sum, child) => sum + this.getTotalSize(child), 0);
    }

    listAll(node: FileSystemNode = this.root, path: string = ""): string[] {
        const currentPath = path + "/" + node.name;
        if (node.type === "file") {
            return [currentPath];
        }
        const files: string[] = [];
        for (const child of node.children || []) {
            files.push(...this.listAll(child, currentPath));
        }
        return files;
    }
}

class RecursiveFlattener {
    flattenDeep<T>(arr: T[]): Flatten<T>[] {
        const result: any[] = [];
        const flatten = (items: any[]) => {
            for (const item of items) {
                if (Array.isArray(item)) {
                    flatten(item);
                } else {
                    result.push(item);
                }
            }
        };
        flatten(arr);
        return result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function FileSystem"),
        "Expected FileSystem function: {}",
        output
    );
    assert!(
        output.contains("FileSystem.prototype.createFile")
            && output.contains("FileSystem.prototype.createDirectory"),
        "Expected createFile and createDirectory methods: {}",
        output
    );
    assert!(
        output.contains("FileSystem.prototype.getTotalSize")
            && output.contains("FileSystem.prototype.listAll"),
        "Expected getTotalSize and listAll methods: {}",
        output
    );
    assert!(
        output.contains("function RecursiveFlattener"),
        "Expected RecursiveFlattener function: {}",
        output
    );
    assert!(
        output.contains("RecursiveFlattener.prototype.flattenDeep"),
        "Expected flattenDeep method: {}",
        output
    );
}

// =============================================================================
// INTERSECTION TYPE PATTERNS - ES5 TRANSFORMATION TESTS
// =============================================================================

/// Test: object intersection types
/// Verifies that classes using object intersection types transform correctly to ES5
#[test]
fn test_class_es5_object_intersection_types() {
    let source = r#"
type Named = { name: string };
type Aged = { age: number };
type Person = Named & Aged;

type Timestamped = { createdAt: Date; updatedAt: Date };
type Identifiable = { id: string };
type Entity = Identifiable & Timestamped;

class PersonFactory {
    create(name: string, age: number): Person {
        return { name, age };
    }

    merge<T extends Named, U extends Aged>(named: T, aged: U): T & U {
        return { ...named, ...aged };
    }

    extend<T extends Person>(person: T, extra: object): T & typeof extra {
        return { ...person, ...extra };
    }
}

class EntityManager {
    private entities: Map<string, Entity> = new Map();

    create(id: string): Entity {
        const now = new Date();
        const entity: Entity = { id, createdAt: now, updatedAt: now };
        this.entities.set(id, entity);
        return entity;
    }

    update(id: string): Entity | undefined {
        const entity = this.entities.get(id);
        if (entity) {
            entity.updatedAt = new Date();
        }
        return entity;
    }

    addMetadata<T extends Entity>(entity: T, metadata: object): T & { metadata: typeof metadata } {
        return { ...entity, metadata };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function PersonFactory"),
        "Expected PersonFactory function: {}",
        output
    );
    assert!(
        output.contains("PersonFactory.prototype.create"),
        "Expected create method: {}",
        output
    );
    assert!(
        output.contains("PersonFactory.prototype.merge")
            && output.contains("PersonFactory.prototype.extend"),
        "Expected merge and extend methods: {}",
        output
    );
    assert!(
        output.contains("function EntityManager"),
        "Expected EntityManager function: {}",
        output
    );
    assert!(
        output.contains("EntityManager.prototype.create")
            && output.contains("EntityManager.prototype.update"),
        "Expected EntityManager create and update methods: {}",
        output
    );
    assert!(
        output.contains("EntityManager.prototype.addMetadata"),
        "Expected addMetadata method: {}",
        output
    );
}

/// Test: interface merging patterns
/// Verifies that classes using interface merging transform correctly to ES5
#[test]
fn test_class_es5_interface_merging() {
    let source = r#"
interface Base {
    id: string;
    name: string;
}

interface WithTimestamp {
    createdAt: Date;
}

interface WithVersion {
    version: number;
}

interface Document extends Base, WithTimestamp, WithVersion {
    content: string;
}

class DocumentBuilder {
    private doc: Partial<Document> = {};

    setId(id: string): this {
        this.doc.id = id;
        return this;
    }

    setName(name: string): this {
        this.doc.name = name;
        return this;
    }

    setContent(content: string): this {
        this.doc.content = content;
        return this;
    }

    setVersion(version: number): this {
        this.doc.version = version;
        return this;
    }

    build(): Document {
        return {
            id: this.doc.id || "",
            name: this.doc.name || "",
            content: this.doc.content || "",
            createdAt: this.doc.createdAt || new Date(),
            version: this.doc.version || 1
        };
    }
}

interface Serializable {
    serialize(): string;
}

interface Deserializable<T> {
    deserialize(data: string): T;
}

class JSONCodec<T> implements Serializable {
    constructor(private data: T) {}

    serialize(): string {
        return JSON.stringify(this.data);
    }

    static deserialize<T>(data: string): T {
        return JSON.parse(data);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function DocumentBuilder"),
        "Expected DocumentBuilder function: {}",
        output
    );
    assert!(
        output.contains("DocumentBuilder.prototype.setId")
            && output.contains("DocumentBuilder.prototype.setName"),
        "Expected setId and setName methods: {}",
        output
    );
    assert!(
        output.contains("DocumentBuilder.prototype.setContent")
            && output.contains("DocumentBuilder.prototype.setVersion"),
        "Expected setContent and setVersion methods: {}",
        output
    );
    assert!(
        output.contains("DocumentBuilder.prototype.build"),
        "Expected build method: {}",
        output
    );
    assert!(
        output.contains("function JSONCodec"),
        "Expected JSONCodec function: {}",
        output
    );
    assert!(
        output.contains("JSONCodec.prototype.serialize"),
        "Expected serialize method: {}",
        output
    );
}

/// Test: conditional intersection types
/// Verifies that classes using conditional intersection types transform correctly to ES5
#[test]
fn test_class_es5_conditional_intersection() {
    let source = r#"
type WithId<T> = T & { id: string };
type WithTimestamps<T> = T & { createdAt: Date; updatedAt: Date };
type Auditable<T> = T extends { id: string } ? T & { auditLog: string[] } : never;

class DataEnhancer {
    addId<T extends object>(data: T, id: string): WithId<T> {
        return { ...data, id };
    }

    addTimestamps<T extends object>(data: T): WithTimestamps<T> {
        const now = new Date();
        return { ...data, createdAt: now, updatedAt: now };
    }

    makeAuditable<T extends { id: string }>(data: T): Auditable<T> {
        return { ...data, auditLog: [] } as Auditable<T>;
    }

    enhance<T extends object>(data: T, id: string): WithId<WithTimestamps<T>> {
        const withTimestamps = this.addTimestamps(data);
        return this.addId(withTimestamps, id);
    }
}

type NonNullableIntersection<T, U> = NonNullable<T> & NonNullable<U>;

class SafeMerger {
    mergeNonNull<T, U>(a: T | null, b: U | null): NonNullableIntersection<T, U> | null {
        if (a === null || b === null) {
            return null;
        }
        return { ...a, ...b } as NonNullableIntersection<T, U>;
    }

    mergeWithDefaults<T extends object, D extends Partial<T>>(data: T, defaults: D): T & Required<D> {
        return { ...defaults, ...data } as T & Required<D>;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function DataEnhancer"),
        "Expected DataEnhancer function: {}",
        output
    );
    assert!(
        output.contains("DataEnhancer.prototype.addId")
            && output.contains("DataEnhancer.prototype.addTimestamps"),
        "Expected addId and addTimestamps methods: {}",
        output
    );
    assert!(
        output.contains("DataEnhancer.prototype.makeAuditable")
            && output.contains("DataEnhancer.prototype.enhance"),
        "Expected makeAuditable and enhance methods: {}",
        output
    );
    assert!(
        output.contains("function SafeMerger"),
        "Expected SafeMerger function: {}",
        output
    );
    assert!(
        output.contains("SafeMerger.prototype.mergeNonNull")
            && output.contains("SafeMerger.prototype.mergeWithDefaults"),
        "Expected SafeMerger methods: {}",
        output
    );
}

/// Test: generic intersection types
/// Verifies that classes using generic intersection types transform correctly to ES5
#[test]
fn test_class_es5_generic_intersection() {
    let source = r#"
type Merge<T, U> = T & U;

class GenericMerger {
    private base: object;

    constructor(base: object) {
        this.base = base;
    }

    merge(other: object): object {
        return Object.assign({}, this.base, other);
    }

    getBase(): object {
        return this.base;
    }
}

type Mixin<T, U> = T & U;

class MixinApplicator {
    apply(target: object, mixin: object): object {
        return Object.assign({}, target, mixin);
    }

    applyTwo(target: object, m1: object, m2: object): object {
        return Object.assign({}, target, m1, m2);
    }

    combine(a: object, b: object): object {
        return Object.assign({}, a, b);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function GenericMerger"),
        "Expected GenericMerger function: {}",
        output
    );
    assert!(
        output.contains("this.base = base"),
        "Expected constructor assignment: {}",
        output
    );
    assert!(
        output.contains("GenericMerger.prototype.merge")
            && output.contains("GenericMerger.prototype.getBase"),
        "Expected merge and getBase methods: {}",
        output
    );
    assert!(
        output.contains("function MixinApplicator"),
        "Expected MixinApplicator function: {}",
        output
    );
    assert!(
        output.contains("MixinApplicator.prototype.apply")
            && output.contains("MixinApplicator.prototype.applyTwo"),
        "Expected MixinApplicator apply methods: {}",
        output
    );
    assert!(
        output.contains("MixinApplicator.prototype.combine"),
        "Expected MixinApplicator combine method: {}",
        output
    );
}

/// Test: mixin patterns with intersection
/// Verifies that classes using mixin patterns with intersection types transform correctly to ES5
#[test]
fn test_class_es5_mixin_intersection_patterns() {
    let source = r#"
type Disposable = {
    dispose(): void;
    isDisposed: boolean;
};

type Activatable = {
    activate(): void;
    deactivate(): void;
    isActive: boolean;
};

type Component = Disposable & Activatable & { name: string };

class ComponentBase implements Component {
    name: string;
    isDisposed: boolean = false;
    isActive: boolean = false;

    constructor(name: string) {
        this.name = name;
    }

    dispose(): void {
        this.isDisposed = true;
        this.isActive = false;
    }

    activate(): void {
        if (!this.isDisposed) {
            this.isActive = true;
        }
    }

    deactivate(): void {
        this.isActive = false;
    }
}

type Logger = { log(message: string): void };
type ErrorHandler = { handleError(error: Error): void };
type Service = Logger & ErrorHandler & { name: string };

class ServiceBase implements Service {
    name: string;
    private logs: string[] = [];

    constructor(name: string) {
        this.name = name;
    }

    log(message: string): void {
        this.logs.push("[" + this.name + "] " + message);
    }

    handleError(error: Error): void {
        this.log("Error: " + error.message);
    }

    getLogs(): string[] {
        return [...this.logs];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ComponentBase"),
        "Expected ComponentBase function: {}",
        output
    );
    assert!(
        output.contains("this.name = name"),
        "Expected constructor assignment: {}",
        output
    );
    assert!(
        output.contains("ComponentBase.prototype.dispose")
            && output.contains("ComponentBase.prototype.activate"),
        "Expected dispose and activate methods: {}",
        output
    );
    assert!(
        output.contains("ComponentBase.prototype.deactivate"),
        "Expected deactivate method: {}",
        output
    );
    assert!(
        output.contains("function ServiceBase"),
        "Expected ServiceBase function: {}",
        output
    );
    assert!(
        output.contains("ServiceBase.prototype.log")
            && output.contains("ServiceBase.prototype.handleError"),
        "Expected log and handleError methods: {}",
        output
    );
}

/// Test: combined intersection type patterns
/// Verifies that classes using multiple intersection type patterns together transform correctly to ES5
#[test]
fn test_class_es5_combined_intersection_patterns() {
    let source = r#"
type HasId = { id: string };
type HasName = { name: string };
type HasCreated = { createdAt: Date };
type HasUpdated = { updatedAt: Date };

type BaseEntity = HasId & HasName;
type TimestampedEntity = BaseEntity & HasCreated & HasUpdated;
type AuditableEntity = TimestampedEntity & { auditLog: string[]; lastModifiedBy: string };

class EntityFactory {
    createBase(id: string, name: string): BaseEntity {
        return { id, name };
    }

    createTimestamped(id: string, name: string): TimestampedEntity {
        const now = new Date();
        return { id, name, createdAt: now, updatedAt: now };
    }

    createAuditable(id: string, name: string, user: string): AuditableEntity {
        const now = new Date();
        return {
            id,
            name,
            createdAt: now,
            updatedAt: now,
            auditLog: ["Created by " + user],
            lastModifiedBy: user
        };
    }

    upgrade<T extends BaseEntity>(entity: T): T & HasCreated & HasUpdated {
        const now = new Date();
        return { ...entity, createdAt: now, updatedAt: now };
    }
}

type Validator<T> = { validate(data: T): boolean };
type Transformer<T, U> = { transform(data: T): U };
type Processor<T, U> = Validator<T> & Transformer<T, U>;

class DataProcessor<T extends object, U extends object> implements Processor<T, U> {
    private validator: (data: T) => boolean;
    private transformer: (data: T) => U;

    constructor(validator: (data: T) => boolean, transformer: (data: T) => U) {
        this.validator = validator;
        this.transformer = transformer;
    }

    validate(data: T): boolean {
        return this.validator(data);
    }

    transform(data: T): U {
        return this.transformer(data);
    }

    process(data: T): U | null {
        if (this.validate(data)) {
            return this.transform(data);
        }
        return null;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function EntityFactory"),
        "Expected EntityFactory function: {}",
        output
    );
    assert!(
        output.contains("EntityFactory.prototype.createBase")
            && output.contains("EntityFactory.prototype.createTimestamped"),
        "Expected createBase and createTimestamped methods: {}",
        output
    );
    assert!(
        output.contains("EntityFactory.prototype.createAuditable")
            && output.contains("EntityFactory.prototype.upgrade"),
        "Expected createAuditable and upgrade methods: {}",
        output
    );
    assert!(
        output.contains("function DataProcessor"),
        "Expected DataProcessor function: {}",
        output
    );
    assert!(
        output.contains("DataProcessor.prototype.validate")
            && output.contains("DataProcessor.prototype.transform"),
        "Expected validate and transform methods: {}",
        output
    );
    assert!(
        output.contains("DataProcessor.prototype.process"),
        "Expected process method: {}",
        output
    );
}

/// Test: discriminated union types
/// Verifies that classes using discriminated union types transform correctly to ES5
#[test]
fn test_class_es5_discriminated_union_types() {
    let source = r#"
type Circle = { kind: "circle"; radius: number };
type Square = { kind: "square"; side: number };
type Rectangle = { kind: "rectangle"; width: number; height: number };
type Shape = Circle | Square | Rectangle;

class ShapeCalculator {
    calculateArea(shape: Shape): number {
        switch (shape.kind) {
            case "circle":
                return Math.PI * shape.radius * shape.radius;
            case "square":
                return shape.side * shape.side;
            case "rectangle":
                return shape.width * shape.height;
        }
    }

    describeShape(shape: Shape): string {
        if (shape.kind === "circle") {
            return "Circle with radius " + shape.radius;
        } else if (shape.kind === "square") {
            return "Square with side " + shape.side;
        } else {
            return "Rectangle " + shape.width + "x" + shape.height;
        }
    }
}

type Success = { status: "success"; data: string };
type Failure = { status: "failure"; error: string };
type Result = Success | Failure;

class ResultHandler {
    handle(result: Result): string {
        if (result.status === "success") {
            return result.data;
        } else {
            return "Error: " + result.error;
        }
    }

    isSuccess(result: Result): boolean {
        return result.status === "success";
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ShapeCalculator"),
        "Expected ShapeCalculator function: {}",
        output
    );
    assert!(
        output.contains("ShapeCalculator.prototype.calculateArea") && output.contains("switch"),
        "Expected calculateArea with switch: {}",
        output
    );
    assert!(
        output.contains("ShapeCalculator.prototype.describeShape"),
        "Expected describeShape method: {}",
        output
    );
    assert!(
        output.contains("function ResultHandler"),
        "Expected ResultHandler function: {}",
        output
    );
    assert!(
        output.contains("ResultHandler.prototype.handle")
            && output.contains("ResultHandler.prototype.isSuccess"),
        "Expected handle and isSuccess methods: {}",
        output
    );
}

/// Test: type narrowing with type guards
/// Verifies that classes using type narrowing patterns transform correctly to ES5
#[test]
fn test_class_es5_type_narrowing() {
    let source = r#"
class TypeChecker {
    processValue(value: string | number): string {
        if (typeof value === "string") {
            return value.toUpperCase();
        } else {
            return value.toString();
        }
    }

    processArray(arr: string[] | string): string[] {
        if (Array.isArray(arr)) {
            return arr;
        } else {
            return [arr];
        }
    }

    processNullable(value: string | null): string {
        if (value === null) {
            return "default";
        }
        return value;
    }
}

class InstanceChecker {
    private items: Array<Date | string>;

    constructor() {
        this.items = [];
    }

    add(item: Date | string): void {
        this.items.push(item);
    }

    formatItem(item: Date | string): string {
        if (item instanceof Date) {
            return item.toISOString();
        }
        return item;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function TypeChecker"),
        "Expected TypeChecker function: {}",
        output
    );
    assert!(
        output.contains("TypeChecker.prototype.processValue") && output.contains("typeof"),
        "Expected processValue with typeof: {}",
        output
    );
    assert!(
        output.contains("TypeChecker.prototype.processArray") && output.contains("Array.isArray"),
        "Expected processArray with Array.isArray: {}",
        output
    );
    assert!(
        output.contains("TypeChecker.prototype.processNullable"),
        "Expected processNullable method: {}",
        output
    );
    assert!(
        output.contains("function InstanceChecker"),
        "Expected InstanceChecker function: {}",
        output
    );
    assert!(
        output.contains("InstanceChecker.prototype.formatItem") && output.contains("instanceof"),
        "Expected formatItem with instanceof: {}",
        output
    );
}

/// Test: string literal unions
/// Verifies that classes using string literal union types transform correctly to ES5
#[test]
fn test_class_es5_string_literal_unions() {
    let source = r#"
type Direction = "north" | "south" | "east" | "west";
type LogLevel = "debug" | "info" | "warn" | "error";

class Navigator {
    private direction: Direction;

    constructor() {
        this.direction = "north";
    }

    move(dir: Direction): void {
        this.direction = dir;
    }

    getOpposite(dir: Direction): Direction {
        if (dir === "north") return "south";
        if (dir === "south") return "north";
        if (dir === "east") return "west";
        return "east";
    }

    getCurrent(): Direction {
        return this.direction;
    }
}

class Logger {
    private level: LogLevel;

    constructor(level: LogLevel) {
        this.level = level;
    }

    log(level: LogLevel, message: string): void {
        console.log("[" + level + "] " + message);
    }

    shouldLog(level: LogLevel): boolean {
        var levels = ["debug", "info", "warn", "error"];
        return levels.indexOf(level) >= levels.indexOf(this.level);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Navigator"),
        "Expected Navigator function: {}",
        output
    );
    assert!(
        output.contains("Navigator.prototype.move")
            && output.contains("Navigator.prototype.getOpposite"),
        "Expected move and getOpposite methods: {}",
        output
    );
    assert!(
        output.contains("Navigator.prototype.getCurrent"),
        "Expected getCurrent method: {}",
        output
    );
    assert!(
        output.contains("function Logger"),
        "Expected Logger function: {}",
        output
    );
    assert!(
        output.contains("Logger.prototype.log") && output.contains("Logger.prototype.shouldLog"),
        "Expected log and shouldLog methods: {}",
        output
    );
}

/// Test: number literal unions
/// Verifies that classes using number literal union types transform correctly to ES5
#[test]
fn test_class_es5_number_literal_unions() {
    let source = r#"
type DiceValue = 1 | 2 | 3 | 4 | 5 | 6;
type HttpStatus = 200 | 201 | 400 | 404 | 500;

class Dice {
    private lastRoll: DiceValue;

    constructor() {
        this.lastRoll = 1;
    }

    roll(): DiceValue {
        var value = Math.floor(Math.random() * 6) + 1;
        this.lastRoll = value as DiceValue;
        return this.lastRoll;
    }

    getLastRoll(): DiceValue {
        return this.lastRoll;
    }

    isMax(value: DiceValue): boolean {
        return value === 6;
    }
}

class HttpResponse {
    private status: HttpStatus;
    private body: string;

    constructor(status: HttpStatus, body: string) {
        this.status = status;
        this.body = body;
    }

    isSuccess(): boolean {
        return this.status === 200 || this.status === 201;
    }

    isError(): boolean {
        return this.status >= 400;
    }

    getStatus(): HttpStatus {
        return this.status;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Dice"),
        "Expected Dice function: {}",
        output
    );
    assert!(
        output.contains("Dice.prototype.roll") && output.contains("Dice.prototype.getLastRoll"),
        "Expected roll and getLastRoll methods: {}",
        output
    );
    assert!(
        output.contains("Dice.prototype.isMax"),
        "Expected isMax method: {}",
        output
    );
    assert!(
        output.contains("function HttpResponse"),
        "Expected HttpResponse function: {}",
        output
    );
    assert!(
        output.contains("HttpResponse.prototype.isSuccess")
            && output.contains("HttpResponse.prototype.isError"),
        "Expected isSuccess and isError methods: {}",
        output
    );
    assert!(
        output.contains("HttpResponse.prototype.getStatus"),
        "Expected getStatus method: {}",
        output
    );
}

/// Test: union with null and undefined
/// Verifies that classes using nullable union types transform correctly to ES5
#[test]
fn test_class_es5_nullable_unions() {
    let source = r#"
class OptionalHandler {
    private value: string | null;
    private data: number | undefined;

    constructor() {
        this.value = null;
        this.data = undefined;
    }

    setValue(val: string | null): void {
        this.value = val;
    }

    getValue(): string | null {
        return this.value;
    }

    getValueOrDefault(def: string): string {
        if (this.value === null) {
            return def;
        }
        return this.value;
    }

    setData(d: number | undefined): void {
        this.data = d;
    }

    hasData(): boolean {
        return this.data !== undefined;
    }
}

class NullableProcessor {
    process(input: string | null | undefined): string {
        if (input === null) {
            return "null input";
        }
        if (input === undefined) {
            return "undefined input";
        }
        return input;
    }

    coalesce(a: string | null, b: string | undefined, def: string): string {
        if (a !== null) return a;
        if (b !== undefined) return b;
        return def;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function OptionalHandler"),
        "Expected OptionalHandler function: {}",
        output
    );
    assert!(
        output.contains("this.value = null") && output.contains("this.data = undefined"),
        "Expected constructor with null/undefined: {}",
        output
    );
    assert!(
        output.contains("OptionalHandler.prototype.setValue")
            && output.contains("OptionalHandler.prototype.getValue"),
        "Expected setValue and getValue methods: {}",
        output
    );
    assert!(
        output.contains("OptionalHandler.prototype.getValueOrDefault")
            && output.contains("OptionalHandler.prototype.hasData"),
        "Expected getValueOrDefault and hasData methods: {}",
        output
    );
    assert!(
        output.contains("function NullableProcessor"),
        "Expected NullableProcessor function: {}",
        output
    );
    assert!(
        output.contains("NullableProcessor.prototype.process")
            && output.contains("NullableProcessor.prototype.coalesce"),
        "Expected process and coalesce methods: {}",
        output
    );
}

/// Test: combined union patterns
/// Verifies that classes using combined union type patterns transform correctly to ES5
#[test]
fn test_class_es5_combined_union_patterns() {
    let source = r#"
type Action =
    | { type: "add"; value: number }
    | { type: "remove"; index: number }
    | { type: "clear" };

type State = { items: number[]; count: number };

class Reducer {
    reduce(state: State, action: Action): State {
        switch (action.type) {
            case "add":
                return { items: state.items.concat([action.value]), count: state.count + 1 };
            case "remove":
                var newItems = state.items.slice();
                newItems.splice(action.index, 1);
                return { items: newItems, count: state.count - 1 };
            case "clear":
                return { items: [], count: 0 };
        }
    }

    getActionType(action: Action): string {
        return action.type;
    }
}

type Primitive = string | number | boolean;
type Container = { value: Primitive };

class PrimitiveHandler {
    wrap(value: Primitive): Container {
        return { value: value };
    }

    unwrap(container: Container): Primitive {
        return container.value;
    }

    stringify(value: Primitive): string {
        if (typeof value === "string") {
            return value;
        } else if (typeof value === "number") {
            return value.toString();
        } else {
            return value ? "true" : "false";
        }
    }

    getType(value: Primitive): string {
        return typeof value;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Reducer"),
        "Expected Reducer function: {}",
        output
    );
    assert!(
        output.contains("Reducer.prototype.reduce") && output.contains("switch"),
        "Expected reduce with switch: {}",
        output
    );
    assert!(
        output.contains("Reducer.prototype.getActionType"),
        "Expected getActionType method: {}",
        output
    );
    assert!(
        output.contains("function PrimitiveHandler"),
        "Expected PrimitiveHandler function: {}",
        output
    );
    assert!(
        output.contains("PrimitiveHandler.prototype.wrap")
            && output.contains("PrimitiveHandler.prototype.unwrap"),
        "Expected wrap and unwrap methods: {}",
        output
    );
    assert!(
        output.contains("PrimitiveHandler.prototype.stringify")
            && output.contains("PrimitiveHandler.prototype.getType"),
        "Expected stringify and getType methods: {}",
        output
    );
}

/// Test: Partial mapped type
/// Verifies that classes using Partial<T> mapped type transform correctly to ES5
#[test]
fn test_class_es5_partial_mapped_type() {
    let source = r#"
interface User {
    name: string;
    email: string;
    age: number;
}

class UserUpdater {
    private user: User;

    constructor(user: User) {
        this.user = user;
    }

    update(changes: Partial<User>): User {
        if (changes.name !== undefined) {
            this.user.name = changes.name;
        }
        if (changes.email !== undefined) {
            this.user.email = changes.email;
        }
        if (changes.age !== undefined) {
            this.user.age = changes.age;
        }
        return this.user;
    }

    patch(field: keyof User, value: string | number): void {
        this.user[field] = value as any;
    }

    getUser(): User {
        return this.user;
    }
}

class PartialBuilder<T> {
    private data: Partial<T>;

    constructor() {
        this.data = {};
    }

    set<K extends keyof T>(key: K, value: T[K]): this {
        this.data[key] = value;
        return this;
    }

    getData(): Partial<T> {
        return this.data;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function UserUpdater"),
        "Expected UserUpdater function: {}",
        output
    );
    assert!(
        output.contains("UserUpdater.prototype.update")
            && output.contains("UserUpdater.prototype.patch"),
        "Expected update and patch methods: {}",
        output
    );
    assert!(
        output.contains("UserUpdater.prototype.getUser"),
        "Expected getUser method: {}",
        output
    );
    assert!(
        output.contains("function PartialBuilder"),
        "Expected PartialBuilder function: {}",
        output
    );
    assert!(
        output.contains("PartialBuilder.prototype.set")
            && output.contains("PartialBuilder.prototype.getData"),
        "Expected set and getData methods: {}",
        output
    );
}

/// Test: Required mapped type
/// Verifies that classes using Required<T> mapped type transform correctly to ES5
#[test]
fn test_class_es5_required_mapped_type() {
    let source = r#"
interface Config {
    host?: string;
    port?: number;
    timeout?: number;
}

class ConfigValidator {
    validate(config: Config): Required<Config> {
        var result = {
            host: config.host || "localhost",
            port: config.port || 8080,
            timeout: config.timeout || 30000
        };
        return result;
    }

    isComplete(config: Config): boolean {
        return config.host !== undefined && config.port !== undefined && config.timeout !== undefined;
    }

    fillDefaults(config: Config): Required<Config> {
        return {
            host: config.host !== undefined ? config.host : "localhost",
            port: config.port !== undefined ? config.port : 8080,
            timeout: config.timeout !== undefined ? config.timeout : 30000
        };
    }
}

class RequiredWrapper<T> {
    private data: Required<T>;

    constructor(data: Required<T>) {
        this.data = data;
    }

    get<K extends keyof T>(key: K): T[K] {
        return this.data[key];
    }

    getData(): Required<T> {
        return this.data;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ConfigValidator"),
        "Expected ConfigValidator function: {}",
        output
    );
    assert!(
        output.contains("ConfigValidator.prototype.validate")
            && output.contains("ConfigValidator.prototype.isComplete"),
        "Expected validate and isComplete methods: {}",
        output
    );
    assert!(
        output.contains("ConfigValidator.prototype.fillDefaults"),
        "Expected fillDefaults method: {}",
        output
    );
    assert!(
        output.contains("function RequiredWrapper"),
        "Expected RequiredWrapper function: {}",
        output
    );
    assert!(
        output.contains("RequiredWrapper.prototype.get")
            && output.contains("RequiredWrapper.prototype.getData"),
        "Expected get and getData methods: {}",
        output
    );
}

/// Test: Readonly mapped type
/// Verifies that classes using Readonly<T> mapped type transform correctly to ES5
#[test]
fn test_class_es5_readonly_mapped_type() {
    let source = r#"
interface State {
    count: number;
    items: string[];
    active: boolean;
}

class StateManager {
    private state: Readonly<State>;

    constructor(initial: State) {
        this.state = initial;
    }

    getState(): Readonly<State> {
        return this.state;
    }

    getCount(): number {
        return this.state.count;
    }

    createSnapshot(): Readonly<State> {
        return {
            count: this.state.count,
            items: this.state.items.slice(),
            active: this.state.active
        };
    }
}

class ImmutableWrapper<T> {
    private data: Readonly<T>;

    constructor(data: T) {
        this.data = data;
    }

    get<K extends keyof T>(key: K): T[K] {
        return this.data[key];
    }

    clone(): Readonly<T> {
        return this.data;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function StateManager"),
        "Expected StateManager function: {}",
        output
    );
    assert!(
        output.contains("StateManager.prototype.getState")
            && output.contains("StateManager.prototype.getCount"),
        "Expected getState and getCount methods: {}",
        output
    );
    assert!(
        output.contains("StateManager.prototype.createSnapshot"),
        "Expected createSnapshot method: {}",
        output
    );
    assert!(
        output.contains("function ImmutableWrapper"),
        "Expected ImmutableWrapper function: {}",
        output
    );
    assert!(
        output.contains("ImmutableWrapper.prototype.get")
            && output.contains("ImmutableWrapper.prototype.clone"),
        "Expected get and clone methods: {}",
        output
    );
}

/// Test: Pick mapped type
/// Verifies that classes using Pick<T, K> mapped type transform correctly to ES5
#[test]
fn test_class_es5_pick_mapped_type() {
    let source = r#"
interface Person {
    id: number;
    name: string;
    email: string;
    phone: string;
    address: string;
}

type ContactInfo = Pick<Person, "email" | "phone">;
type PersonSummary = Pick<Person, "id" | "name">;

class PersonService {
    private people: Person[];

    constructor() {
        this.people = [];
    }

    add(person: Person): void {
        this.people.push(person);
    }

    getContactInfo(id: number): ContactInfo | null {
        var person = this.findById(id);
        if (person === null) return null;
        return { email: person.email, phone: person.phone };
    }

    getSummary(id: number): PersonSummary | null {
        var person = this.findById(id);
        if (person === null) return null;
        return { id: person.id, name: person.name };
    }

    findById(id: number): Person | null {
        for (var i = 0; i < this.people.length; i++) {
            if (this.people[i].id === id) {
                return this.people[i];
            }
        }
        return null;
    }
}

class PickHelper<T, K extends keyof T> {
    private source: T;

    constructor(source: T) {
        this.source = source;
    }

    pick(key: K): T[K] {
        return this.source[key];
    }

    getSource(): T {
        return this.source;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function PersonService"),
        "Expected PersonService function: {}",
        output
    );
    assert!(
        output.contains("PersonService.prototype.add")
            && output.contains("PersonService.prototype.getContactInfo"),
        "Expected add and getContactInfo methods: {}",
        output
    );
    assert!(
        output.contains("PersonService.prototype.getSummary")
            && output.contains("PersonService.prototype.findById"),
        "Expected getSummary and findById methods: {}",
        output
    );
    assert!(
        output.contains("function PickHelper"),
        "Expected PickHelper function: {}",
        output
    );
    assert!(
        output.contains("PickHelper.prototype.pick")
            && output.contains("PickHelper.prototype.getSource"),
        "Expected pick and getSource methods: {}",
        output
    );
}

/// Test: Omit mapped type
/// Verifies that classes using Omit<T, K> mapped type transform correctly to ES5
#[test]
fn test_class_es5_omit_mapped_type() {
    let source = r#"
interface Entity {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    name: string;
    data: object;
}

type CreateEntity = Omit<Entity, "id" | "createdAt" | "updatedAt">;
type PublicEntity = Omit<Entity, "data">;

class EntityFactory {
    private nextId: number;

    constructor() {
        this.nextId = 1;
    }

    create(input: CreateEntity): Entity {
        var now = new Date();
        return {
            id: this.nextId++,
            createdAt: now,
            updatedAt: now,
            name: input.name,
            data: input.data
        };
    }

    toPublic(entity: Entity): PublicEntity {
        return {
            id: entity.id,
            createdAt: entity.createdAt,
            updatedAt: entity.updatedAt,
            name: entity.name
        };
    }

    getNextId(): number {
        return this.nextId;
    }
}

class OmitHelper<T, K extends keyof T> {
    private source: T;
    private excluded: K[];

    constructor(source: T, excluded: K[]) {
        this.source = source;
        this.excluded = excluded;
    }

    isExcluded(key: K): boolean {
        return this.excluded.indexOf(key) >= 0;
    }

    getSource(): T {
        return this.source;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function EntityFactory"),
        "Expected EntityFactory function: {}",
        output
    );
    assert!(
        output.contains("EntityFactory.prototype.create")
            && output.contains("EntityFactory.prototype.toPublic"),
        "Expected create and toPublic methods: {}",
        output
    );
    assert!(
        output.contains("EntityFactory.prototype.getNextId"),
        "Expected getNextId method: {}",
        output
    );
    assert!(
        output.contains("function OmitHelper"),
        "Expected OmitHelper function: {}",
        output
    );
    assert!(
        output.contains("OmitHelper.prototype.isExcluded")
            && output.contains("OmitHelper.prototype.getSource"),
        "Expected isExcluded and getSource methods: {}",
        output
    );
}

/// Test: Record mapped type
/// Verifies that classes using Record<K, V> mapped type transform correctly to ES5
#[test]
fn test_class_es5_record_mapped_type() {
    let source = r#"
type StatusCode = "ok" | "error" | "pending";
type StatusInfo = { message: string; timestamp: number };

class StatusRegistry {
    private statuses: Record<StatusCode, StatusInfo>;

    constructor() {
        var now = Date.now();
        this.statuses = {
            ok: { message: "Success", timestamp: now },
            error: { message: "Failed", timestamp: now },
            pending: { message: "In progress", timestamp: now }
        };
    }

    getStatus(code: StatusCode): StatusInfo {
        return this.statuses[code];
    }

    updateStatus(code: StatusCode, message: string): void {
        this.statuses[code] = { message: message, timestamp: Date.now() };
    }

    getAllStatuses(): Record<StatusCode, StatusInfo> {
        return this.statuses;
    }
}

class RecordStore<K extends string, V> {
    private data: Record<K, V>;

    constructor(initial: Record<K, V>) {
        this.data = initial;
    }

    get(key: K): V {
        return this.data[key];
    }

    set(key: K, value: V): void {
        this.data[key] = value;
    }

    has(key: K): boolean {
        return key in this.data;
    }

    getData(): Record<K, V> {
        return this.data;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function StatusRegistry"),
        "Expected StatusRegistry function: {}",
        output
    );
    assert!(
        output.contains("StatusRegistry.prototype.getStatus")
            && output.contains("StatusRegistry.prototype.updateStatus"),
        "Expected getStatus and updateStatus methods: {}",
        output
    );
    assert!(
        output.contains("StatusRegistry.prototype.getAllStatuses"),
        "Expected getAllStatuses method: {}",
        output
    );
    assert!(
        output.contains("function RecordStore"),
        "Expected RecordStore function: {}",
        output
    );
    assert!(
        output.contains("RecordStore.prototype.get")
            && output.contains("RecordStore.prototype.set"),
        "Expected get and set methods: {}",
        output
    );
    assert!(
        output.contains("RecordStore.prototype.has")
            && output.contains("RecordStore.prototype.getData"),
        "Expected has and getData methods: {}",
        output
    );
}

/// Test: infer keyword with array element type
/// Verifies that classes using infer for array element extraction transform correctly to ES5
#[test]
fn test_class_es5_infer_array_element() {
    let source = r#"
type ElementType<T> = T extends Array<infer E> ? E : never;
type FirstElement<T> = T extends [infer F, ...any[]] ? F : never;

class ArrayProcessor<T extends any[]> {
    private items: T;

    constructor(items: T) {
        this.items = items;
    }

    getFirst(): FirstElement<T> {
        return this.items[0] as FirstElement<T>;
    }

    getLast(): ElementType<T> {
        return this.items[this.items.length - 1] as ElementType<T>;
    }

    map<U>(fn: (item: ElementType<T>) => U): U[] {
        var result = [];
        for (var i = 0; i < this.items.length; i++) {
            result.push(fn(this.items[i]));
        }
        return result;
    }

    getItems(): T {
        return this.items;
    }
}

class TypeExtractor {
    extractElement<T extends any[]>(arr: T): ElementType<T> {
        return arr[0];
    }

    extractFirst<T extends any[]>(arr: T): FirstElement<T> {
        return arr[0] as FirstElement<T>;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ArrayProcessor"),
        "Expected ArrayProcessor function: {}",
        output
    );
    assert!(
        output.contains("ArrayProcessor.prototype.getFirst")
            && output.contains("ArrayProcessor.prototype.getLast"),
        "Expected getFirst and getLast methods: {}",
        output
    );
    assert!(
        output.contains("ArrayProcessor.prototype.map")
            && output.contains("ArrayProcessor.prototype.getItems"),
        "Expected map and getItems methods: {}",
        output
    );
    assert!(
        output.contains("function TypeExtractor"),
        "Expected TypeExtractor function: {}",
        output
    );
    assert!(
        output.contains("TypeExtractor.prototype.extractElement")
            && output.contains("TypeExtractor.prototype.extractFirst"),
        "Expected extractElement and extractFirst methods: {}",
        output
    );
}

/// Test: infer keyword with function return type
/// Verifies that classes using infer for function return type extraction transform correctly to ES5
#[test]
fn test_class_es5_infer_function_return() {
    let source = r#"
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

class FunctionWrapper<T extends (...args: any[]) => any> {
    private fn: T;

    constructor(fn: T) {
        this.fn = fn;
    }

    call(...args: Parameters<T>): ReturnType<T> {
        return this.fn.apply(null, args);
    }

    bind(thisArg: any): T {
        return this.fn.bind(thisArg);
    }

    getFunction(): T {
        return this.fn;
    }
}

class ReturnExtractor {
    getReturnValue<T extends (...args: any[]) => any>(fn: T, args: Parameters<T>): ReturnType<T> {
        return fn.apply(null, args);
    }

    wrapReturn<T extends (...args: any[]) => any>(fn: T): () => ReturnType<T> {
        return function() {
            return fn();
        };
    }

    createCaller<T extends (...args: any[]) => any>(fn: T): (args: Parameters<T>) => ReturnType<T> {
        return function(args) {
            return fn.apply(null, args);
        };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function FunctionWrapper"),
        "Expected FunctionWrapper function: {}",
        output
    );
    assert!(
        output.contains("FunctionWrapper.prototype.call")
            && output.contains("FunctionWrapper.prototype.bind"),
        "Expected call and bind methods: {}",
        output
    );
    assert!(
        output.contains("FunctionWrapper.prototype.getFunction"),
        "Expected getFunction method: {}",
        output
    );
    assert!(
        output.contains("function ReturnExtractor"),
        "Expected ReturnExtractor function: {}",
        output
    );
    assert!(
        output.contains("ReturnExtractor.prototype.getReturnValue")
            && output.contains("ReturnExtractor.prototype.wrapReturn"),
        "Expected getReturnValue and wrapReturn methods: {}",
        output
    );
}

/// Test: infer keyword with Promise unwrap
/// Verifies that classes using infer for Promise unwrapping transform correctly to ES5
#[test]
fn test_class_es5_infer_promise_unwrap() {
    let source = r#"
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;
type PromiseValue<T> = T extends Promise<infer V> ? V : T;

class PromiseHandler<T> {
    private promise: Promise<T>;

    constructor(value: T) {
        this.promise = Promise.resolve(value);
    }

    then<U>(fn: (value: T) => U): PromiseHandler<U> {
        var result = this.promise.then(fn);
        return new PromiseHandler(result as any);
    }

    getPromise(): Promise<T> {
        return this.promise;
    }

    getValue(): Promise<T> {
        return this.promise;
    }
}

class AsyncUnwrapper {
    unwrap<T>(promise: Promise<T>): Promise<PromiseValue<Promise<T>>> {
        return promise;
    }

    unwrapNested<T>(promise: Promise<Promise<T>>): Promise<T> {
        return promise.then(function(inner) { return inner; });
    }

    createResolved<T>(value: T): Promise<T> {
        return Promise.resolve(value);
    }

    createRejected<T>(reason: any): Promise<T> {
        return Promise.reject(reason);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function PromiseHandler"),
        "Expected PromiseHandler function: {}",
        output
    );
    assert!(
        output.contains("PromiseHandler.prototype.then")
            && output.contains("PromiseHandler.prototype.getPromise"),
        "Expected then and getPromise methods: {}",
        output
    );
    assert!(
        output.contains("PromiseHandler.prototype.getValue"),
        "Expected getValue method: {}",
        output
    );
    assert!(
        output.contains("function AsyncUnwrapper"),
        "Expected AsyncUnwrapper function: {}",
        output
    );
    assert!(
        output.contains("AsyncUnwrapper.prototype.unwrap")
            && output.contains("AsyncUnwrapper.prototype.unwrapNested"),
        "Expected unwrap and unwrapNested methods: {}",
        output
    );
}

/// Test: infer keyword with constructor parameters
/// Verifies that classes using infer for constructor parameter extraction transform correctly to ES5
#[test]
fn test_class_es5_infer_constructor_params() {
    let source = r#"
type ConstructorParameters<T> = T extends new (...args: infer P) => any ? P : never;
type InstanceType<T> = T extends new (...args: any[]) => infer R ? R : never;

class FactoryBuilder<T extends new (...args: any[]) => any> {
    private ctor: T;

    constructor(ctor: T) {
        this.ctor = ctor;
    }

    create(...args: ConstructorParameters<T>): InstanceType<T> {
        return new (this.ctor as any)(...args);
    }

    getConstructor(): T {
        return this.ctor;
    }

    createDefault(): InstanceType<T> {
        return new (this.ctor as any)();
    }
}

class InstanceCreator {
    instantiate<T extends new (...args: any[]) => any>(ctor: T, args: ConstructorParameters<T>): InstanceType<T> {
        return new (ctor as any)(...args);
    }

    createEmpty<T extends new () => any>(ctor: T): InstanceType<T> {
        return new ctor();
    }

    getParamCount<T extends new (...args: any[]) => any>(ctor: T): number {
        return ctor.length;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function FactoryBuilder"),
        "Expected FactoryBuilder function: {}",
        output
    );
    assert!(
        output.contains("FactoryBuilder.prototype.create")
            && output.contains("FactoryBuilder.prototype.getConstructor"),
        "Expected create and getConstructor methods: {}",
        output
    );
    assert!(
        output.contains("FactoryBuilder.prototype.createDefault"),
        "Expected createDefault method: {}",
        output
    );
    assert!(
        output.contains("function InstanceCreator"),
        "Expected InstanceCreator function: {}",
        output
    );
    assert!(
        output.contains("InstanceCreator.prototype.instantiate")
            && output.contains("InstanceCreator.prototype.createEmpty"),
        "Expected instantiate and createEmpty methods: {}",
        output
    );
}

/// Test: infer keyword with tuple elements
/// Verifies that classes using infer for tuple element extraction transform correctly to ES5
#[test]
fn test_class_es5_infer_tuple_elements() {
    let source = r#"
type Head<T> = T extends [infer H, ...any[]] ? H : never;
type Tail<T> = T extends [any, ...infer R] ? R : never;
type Last<T> = T extends [...any[], infer L] ? L : never;

class TupleProcessor<T extends any[]> {
    private tuple: T;

    constructor(tuple: T) {
        this.tuple = tuple;
    }

    head(): Head<T> {
        return this.tuple[0] as Head<T>;
    }

    last(): Last<T> {
        return this.tuple[this.tuple.length - 1] as Last<T>;
    }

    length(): number {
        return this.tuple.length;
    }

    getTuple(): T {
        return this.tuple;
    }
}

class TupleExtractor {
    getHead<T extends [any, ...any[]]>(tuple: T): Head<T> {
        return tuple[0];
    }

    getLast<T extends [...any[], any]>(tuple: T): Last<T> {
        return tuple[tuple.length - 1];
    }

    split<T extends [any, ...any[]]>(tuple: T): { head: Head<T>; tail: Tail<T> } {
        var head = tuple[0];
        var tail = tuple.slice(1);
        return { head: head as Head<T>, tail: tail as Tail<T> };
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function TupleProcessor"),
        "Expected TupleProcessor function: {}",
        output
    );
    assert!(
        output.contains("TupleProcessor.prototype.head")
            && output.contains("TupleProcessor.prototype.last"),
        "Expected head and last methods: {}",
        output
    );
    assert!(
        output.contains("TupleProcessor.prototype.length")
            && output.contains("TupleProcessor.prototype.getTuple"),
        "Expected length and getTuple methods: {}",
        output
    );
    assert!(
        output.contains("function TupleExtractor"),
        "Expected TupleExtractor function: {}",
        output
    );
    assert!(
        output.contains("TupleExtractor.prototype.getHead")
            && output.contains("TupleExtractor.prototype.getLast"),
        "Expected getHead and getLast methods: {}",
        output
    );
}

/// Test: combined infer patterns
/// Verifies that classes using combined infer patterns transform correctly to ES5
#[test]
fn test_class_es5_combined_infer_patterns() {
    let source = r#"
type UnpackArray<T> = T extends Array<infer U> ? U : T;
type UnpackPromise<T> = T extends Promise<infer U> ? U : T;
type UnpackFunction<T> = T extends (...args: any[]) => infer R ? R : T;

class TypeUnpacker {
    unpackArrayValue<T extends any[]>(arr: T, index: number): UnpackArray<T> {
        return arr[index];
    }

    wrapInArray<T>(value: T): Array<T> {
        return [value];
    }

    wrapInPromise<T>(value: T): Promise<T> {
        return Promise.resolve(value);
    }

    identity<T>(value: T): T {
        return value;
    }
}

type DeepUnwrap<T> = T extends Promise<infer U>
    ? DeepUnwrap<U>
    : T extends Array<infer E>
    ? DeepUnwrap<E>[]
    : T;

class DeepProcessor {
    processArray<T>(arr: T[]): T[] {
        return arr.slice();
    }

    processPromise<T>(promise: Promise<T>): Promise<T> {
        return promise.then(function(v) { return v; });
    }

    flatten<T>(nested: T[][]): T[] {
        var result = [];
        for (var i = 0; i < nested.length; i++) {
            for (var j = 0; j < nested[i].length; j++) {
                result.push(nested[i][j]);
            }
        }
        return result;
    }

    createPair<A, B>(a: A, b: B): [A, B] {
        return [a, b];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function TypeUnpacker"),
        "Expected TypeUnpacker function: {}",
        output
    );
    assert!(
        output.contains("TypeUnpacker.prototype.unpackArrayValue")
            && output.contains("TypeUnpacker.prototype.wrapInArray"),
        "Expected unpackArrayValue and wrapInArray methods: {}",
        output
    );
    assert!(
        output.contains("TypeUnpacker.prototype.wrapInPromise")
            && output.contains("TypeUnpacker.prototype.identity"),
        "Expected wrapInPromise and identity methods: {}",
        output
    );
    assert!(
        output.contains("function DeepProcessor"),
        "Expected DeepProcessor function: {}",
        output
    );
    assert!(
        output.contains("DeepProcessor.prototype.processArray")
            && output.contains("DeepProcessor.prototype.processPromise"),
        "Expected processArray and processPromise methods: {}",
        output
    );
    assert!(
        output.contains("DeepProcessor.prototype.flatten")
            && output.contains("DeepProcessor.prototype.createPair"),
        "Expected flatten and createPair methods: {}",
        output
    );
}

/// Test ES5 class with const type parameter patterns
#[test]
fn test_class_es5_const_type_parameter_basic() {
    let source = r#"
// Basic const type parameter
class Routes<const T extends readonly string[]> {
    private routes: T;

    constructor(routes: T) {
        this.routes = routes;
    }

    getRoutes(): T {
        return this.routes;
    }

    hasRoute(route: T[number]): boolean {
        return this.routes.includes(route);
    }
}

// Const type parameter with object
class Config<const T extends Record<string, unknown>> {
    private config: T;

    constructor(config: T) {
        this.config = config;
    }

    get<K extends keyof T>(key: K): T[K] {
        return this.config[key];
    }

    getAll(): T {
        return this.config;
    }
}

// Multiple const type parameters
class Mapping<const K extends readonly string[], const V extends readonly number[]> {
    private keys: K;
    private values: V;

    constructor(keys: K, values: V) {
        this.keys = keys;
        this.values = values;
    }

    getKey(index: number): K[number] {
        return this.keys[index];
    }

    getValue(index: number): V[number] {
        return this.values[index];
    }
}

// Usage
const routes = new Routes(["home", "about", "contact"] as const);
const config = new Config({ debug: true, port: 3000 } as const);
const mapping = new Mapping(["a", "b", "c"] as const, [1, 2, 3] as const);
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Routes") && output.contains("Config") && output.contains("Mapping"),
        "Expected const type parameter classes: {}",
        output
    );

    // const keyword in type parameters should be stripped
    assert!(
        !output.contains("const T extends") && !output.contains("const K extends"),
        "Expected const type parameters to be stripped: {}",
        output
    );

    // Methods should be preserved
    assert!(
        output.contains("getRoutes") && output.contains("getAll") && output.contains("getKey"),
        "Expected methods: {}",
        output
    );
}

/// Test ES5 class with readonly inference patterns
#[test]
fn test_class_es5_const_type_parameter_readonly_inference() {
    let source = r#"
// Readonly tuple inference
class TupleStore<const T extends readonly unknown[]> {
    private tuple: T;

    constructor(tuple: T) {
        this.tuple = tuple;
    }

    first(): T[0] {
        return this.tuple[0];
    }

    last(): T[number] {
        return this.tuple[this.tuple.length - 1];
    }

    length(): T["length"] {
        return this.tuple.length;
    }
}

// Readonly object inference
class ObjectStore<const T extends Readonly<Record<string, unknown>>> {
    private data: T;

    constructor(data: T) {
        this.data = data;
    }

    keys(): (keyof T)[] {
        return Object.keys(this.data) as (keyof T)[];
    }

    values(): T[keyof T][] {
        return Object.values(this.data) as T[keyof T][];
    }
}

// Nested readonly inference
class NestedStore<const T extends readonly { readonly name: string; readonly value: number }[]> {
    private items: T;

    constructor(items: T) {
        this.items = items;
    }

    findByName(name: string): T[number] | undefined {
        return this.items.find(item => item.name === name);
    }

    getNames(): string[] {
        return this.items.map(item => item.name);
    }
}

// Usage with inferred readonly types
const tupleStore = new TupleStore([1, "two", true] as const);
const objectStore = new ObjectStore({ x: 1, y: 2, z: 3 } as const);
const nestedStore = new NestedStore([
    { name: "first", value: 1 },
    { name: "second", value: 2 }
] as const);
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("TupleStore")
            && output.contains("ObjectStore")
            && output.contains("NestedStore"),
        "Expected readonly inference classes: {}",
        output
    );

    // const keyword should be stripped
    assert!(
        !output.contains("const T extends"),
        "Expected const to be stripped: {}",
        output
    );

    // Methods should be preserved
    assert!(
        output.contains("first") && output.contains("keys") && output.contains("findByName"),
        "Expected methods: {}",
        output
    );
}

/// Test ES5 class with immutable array patterns
#[test]
fn test_class_es5_const_type_parameter_immutable_arrays() {
    let source = r#"
// Immutable array builder
class ImmutableArrayBuilder<const T extends readonly unknown[]> {
    private items: T;

    constructor(items: T) {
        this.items = items;
    }

    toArray(): T {
        return this.items;
    }

    getLength(): number {
        return this.items.length;
    }

    getFirst(): T[0] {
        return this.items[0];
    }
}

// Immutable set-like collection
class ImmutableSet<const T extends readonly unknown[]> {
    private elements: T;

    constructor(elements: T) {
        this.elements = elements;
    }

    has(element: unknown): boolean {
        return this.elements.includes(element as T[number]);
    }

    size(): number {
        return this.elements.length;
    }
}

// Immutable stack
class ImmutableStack<const T extends readonly unknown[]> {
    private stack: T;

    constructor(stack: T) {
        this.stack = stack;
    }

    peek(): unknown {
        return this.stack[this.stack.length - 1];
    }

    isEmpty(): boolean {
        return this.stack.length === 0;
    }

    getStack(): T {
        return this.stack;
    }
}

// Usage
const builder = new ImmutableArrayBuilder([1, 2, 3] as const);
const set = new ImmutableSet(["a", "b", "c"] as const);
const stack = new ImmutableStack([] as const);
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ImmutableArrayBuilder")
            && output.contains("ImmutableSet")
            && output.contains("ImmutableStack"),
        "Expected immutable array classes: {}",
        output
    );

    // const type parameters should be stripped
    assert!(
        !output.contains("const T extends") && !output.contains("const U extends"),
        "Expected const type parameters to be stripped: {}",
        output
    );

    // Methods should be preserved
    assert!(
        output.contains("toArray")
            && output.contains("has")
            && output.contains("peek")
            && output.contains("isEmpty"),
        "Expected methods: {}",
        output
    );
}

/// Test: keyof object type
/// Verifies that classes using keyof for object key types transform correctly to ES5
#[test]
fn test_class_es5_keyof_object_type() {
    let source = r#"
interface Person {
    name: string;
    age: number;
    email: string;
}

class PropertyAccessor<T> {
    private obj: T;

    constructor(obj: T) {
        this.obj = obj;
    }

    get<K extends keyof T>(key: K): T[K] {
        return this.obj[key];
    }

    set<K extends keyof T>(key: K, value: T[K]): void {
        this.obj[key] = value;
    }

    has(key: keyof T): boolean {
        return key in this.obj;
    }

    getKeys(): Array<keyof T> {
        return Object.keys(this.obj) as Array<keyof T>;
    }
}

class PersonEditor {
    private person: Person;

    constructor(person: Person) {
        this.person = person;
    }

    updateField(field: keyof Person, value: string | number): void {
        this.person[field] = value as any;
    }

    getField(field: keyof Person): string | number {
        return this.person[field];
    }

    getAllFields(): Array<keyof Person> {
        return ["name", "age", "email"];
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function PropertyAccessor"),
        "Expected PropertyAccessor function: {}",
        output
    );
    assert!(
        output.contains("PropertyAccessor.prototype.get")
            && output.contains("PropertyAccessor.prototype.set"),
        "Expected get and set methods: {}",
        output
    );
    assert!(
        output.contains("PropertyAccessor.prototype.has")
            && output.contains("PropertyAccessor.prototype.getKeys"),
        "Expected has and getKeys methods: {}",
        output
    );
    assert!(
        output.contains("function PersonEditor"),
        "Expected PersonEditor function: {}",
        output
    );
    assert!(
        output.contains("PersonEditor.prototype.updateField")
            && output.contains("PersonEditor.prototype.getField"),
        "Expected updateField and getField methods: {}",
        output
    );
}

/// Test: typeof value type
/// Verifies that classes using typeof for value type extraction transform correctly to ES5
#[test]
fn test_class_es5_typeof_value_type() {
    let source = r#"
var defaultConfig = {
    host: "localhost",
    port: 8080,
    debug: false
};

type Config = typeof defaultConfig;

class ConfigManager {
    private config: Config;

    constructor() {
        this.config = {
            host: defaultConfig.host,
            port: defaultConfig.port,
            debug: defaultConfig.debug
        };
    }

    getConfig(): Config {
        return this.config;
    }

    setHost(host: string): void {
        this.config.host = host;
    }

    setPort(port: number): void {
        this.config.port = port;
    }

    setDebug(debug: boolean): void {
        this.config.debug = debug;
    }
}

function createUser(name: string, age: number) {
    return { name: name, age: age, active: true };
}

type User = ReturnType<typeof createUser>;

class UserManager {
    private users: User[];

    constructor() {
        this.users = [];
    }

    add(user: User): void {
        this.users.push(user);
    }

    findByName(name: string): User | undefined {
        for (var i = 0; i < this.users.length; i++) {
            if (this.users[i].name === name) {
                return this.users[i];
            }
        }
        return undefined;
    }

    getAll(): User[] {
        return this.users;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ConfigManager"),
        "Expected ConfigManager function: {}",
        output
    );
    assert!(
        output.contains("ConfigManager.prototype.getConfig")
            && output.contains("ConfigManager.prototype.setHost"),
        "Expected getConfig and setHost methods: {}",
        output
    );
    assert!(
        output.contains("ConfigManager.prototype.setPort")
            && output.contains("ConfigManager.prototype.setDebug"),
        "Expected setPort and setDebug methods: {}",
        output
    );
    assert!(
        output.contains("function UserManager"),
        "Expected UserManager function: {}",
        output
    );
    assert!(
        output.contains("UserManager.prototype.add")
            && output.contains("UserManager.prototype.findByName"),
        "Expected add and findByName methods: {}",
        output
    );
}

/// Test: indexed access types
/// Verifies that classes using indexed access types transform correctly to ES5
#[test]
fn test_class_es5_indexed_access_types() {
    let source = r#"
interface ApiResponse {
    data: {
        users: Array<{ id: number; name: string }>;
        meta: { total: number; page: number };
    };
    status: number;
    message: string;
}

type ResponseData = ApiResponse["data"];
type UserArray = ApiResponse["data"]["users"];
type MetaInfo = ApiResponse["data"]["meta"];

class ResponseHandler {
    private response: ApiResponse;

    constructor(response: ApiResponse) {
        this.response = response;
    }

    getData(): ResponseData {
        return this.response.data;
    }

    getUsers(): UserArray {
        return this.response.data.users;
    }

    getMeta(): MetaInfo {
        return this.response.data.meta;
    }

    getStatus(): ApiResponse["status"] {
        return this.response.status;
    }
}

class IndexedAccessor<T, K extends keyof T> {
    private obj: T;
    private key: K;

    constructor(obj: T, key: K) {
        this.obj = obj;
        this.key = key;
    }

    getValue(): T[K] {
        return this.obj[this.key];
    }

    setValue(value: T[K]): void {
        this.obj[this.key] = value;
    }

    getKey(): K {
        return this.key;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ResponseHandler"),
        "Expected ResponseHandler function: {}",
        output
    );
    assert!(
        output.contains("ResponseHandler.prototype.getData")
            && output.contains("ResponseHandler.prototype.getUsers"),
        "Expected getData and getUsers methods: {}",
        output
    );
    assert!(
        output.contains("ResponseHandler.prototype.getMeta")
            && output.contains("ResponseHandler.prototype.getStatus"),
        "Expected getMeta and getStatus methods: {}",
        output
    );
    assert!(
        output.contains("function IndexedAccessor"),
        "Expected IndexedAccessor function: {}",
        output
    );
    assert!(
        output.contains("IndexedAccessor.prototype.getValue")
            && output.contains("IndexedAccessor.prototype.setValue"),
        "Expected getValue and setValue methods: {}",
        output
    );
}

/// Test: keyof with generics
/// Verifies that classes using keyof with generics transform correctly to ES5
#[test]
fn test_class_es5_keyof_generics() {
    let source = r#"
class ObjectMapper<T extends object> {
    private source: T;

    constructor(source: T) {
        this.source = source;
    }

    pluck<K extends keyof T>(keys: K[]): Pick<T, K> {
        var result = {} as Pick<T, K>;
        for (var i = 0; i < keys.length; i++) {
            result[keys[i]] = this.source[keys[i]];
        }
        return result;
    }

    omit<K extends keyof T>(keys: K[]): Omit<T, K> {
        var result = {} as Omit<T, K>;
        var allKeys = Object.keys(this.source) as Array<keyof T>;
        for (var i = 0; i < allKeys.length; i++) {
            var key = allKeys[i];
            if (keys.indexOf(key as K) === -1) {
                (result as any)[key] = this.source[key];
            }
        }
        return result;
    }

    rename<K extends keyof T>(oldKey: K, newKey: string): object {
        var result = {} as any;
        var allKeys = Object.keys(this.source) as Array<keyof T>;
        for (var i = 0; i < allKeys.length; i++) {
            var key = allKeys[i];
            if (key === oldKey) {
                result[newKey] = this.source[key];
            } else {
                result[key] = this.source[key];
            }
        }
        return result;
    }

    getSource(): T {
        return this.source;
    }
}

class KeyValidator<T extends object> {
    isValidKey(obj: T, key: string): key is keyof T & string {
        return key in obj;
    }

    getValidKeys(obj: T): Array<keyof T> {
        return Object.keys(obj) as Array<keyof T>;
    }

    countKeys(obj: T): number {
        return Object.keys(obj).length;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ObjectMapper"),
        "Expected ObjectMapper function: {}",
        output
    );
    assert!(
        output.contains("ObjectMapper.prototype.pluck")
            && output.contains("ObjectMapper.prototype.omit"),
        "Expected pluck and omit methods: {}",
        output
    );
    assert!(
        output.contains("ObjectMapper.prototype.rename")
            && output.contains("ObjectMapper.prototype.getSource"),
        "Expected rename and getSource methods: {}",
        output
    );
    assert!(
        output.contains("function KeyValidator"),
        "Expected KeyValidator function: {}",
        output
    );
    assert!(
        output.contains("KeyValidator.prototype.isValidKey")
            && output.contains("KeyValidator.prototype.getValidKeys"),
        "Expected isValidKey and getValidKeys methods: {}",
        output
    );
}

/// Test: typeof with const assertions
/// Verifies that classes using typeof with const assertions transform correctly to ES5
#[test]
fn test_class_es5_typeof_const_assertions() {
    let source = r##"
var COLORS = {
    red: "#ff0000",
    green: "#00ff00",
    blue: "#0000ff"
} as const;

type ColorName = keyof typeof COLORS;
type ColorValue = typeof COLORS[ColorName];

class ColorPicker {
    private currentColor: ColorName;

    constructor() {
        this.currentColor = "red";
    }

    setColor(name: ColorName): void {
        this.currentColor = name;
    }

    getColorValue(): ColorValue {
        return COLORS[this.currentColor];
    }

    getCurrentColor(): ColorName {
        return this.currentColor;
    }

    getAllColors(): Array<ColorName> {
        return Object.keys(COLORS) as Array<ColorName>;
    }
}

var STATUS_CODES = [200, 201, 400, 404, 500] as const;

type StatusCode = typeof STATUS_CODES[number];

class StatusHandler {
    private code: StatusCode;

    constructor(code: StatusCode) {
        this.code = code;
    }

    isSuccess(): boolean {
        return this.code === 200 || this.code === 201;
    }

    isClientError(): boolean {
        return this.code === 400 || this.code === 404;
    }

    isServerError(): boolean {
        return this.code === 500;
    }

    getCode(): StatusCode {
        return this.code;
    }
}
"##;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ColorPicker"),
        "Expected ColorPicker function: {}",
        output
    );
    assert!(
        output.contains("ColorPicker.prototype.setColor")
            && output.contains("ColorPicker.prototype.getColorValue"),
        "Expected setColor and getColorValue methods: {}",
        output
    );
    assert!(
        output.contains("ColorPicker.prototype.getCurrentColor")
            && output.contains("ColorPicker.prototype.getAllColors"),
        "Expected getCurrentColor and getAllColors methods: {}",
        output
    );
    assert!(
        output.contains("function StatusHandler"),
        "Expected StatusHandler function: {}",
        output
    );
    assert!(
        output.contains("StatusHandler.prototype.isSuccess")
            && output.contains("StatusHandler.prototype.isClientError"),
        "Expected isSuccess and isClientError methods: {}",
        output
    );
}

/// Test: combined keyof/typeof patterns
/// Verifies that classes using combined keyof/typeof patterns transform correctly to ES5
#[test]
fn test_class_es5_combined_keyof_typeof() {
    let source = r#"
var schema = {
    name: "string",
    age: "number",
    active: "boolean"
};

type Schema = typeof schema;
type SchemaKey = keyof Schema;
type SchemaValue = Schema[SchemaKey];

class SchemaValidator {
    private schema: Schema;

    constructor() {
        this.schema = schema;
    }

    getType(key: SchemaKey): SchemaValue {
        return this.schema[key];
    }

    hasField(key: string): boolean {
        return key in this.schema;
    }

    getFields(): SchemaKey[] {
        return Object.keys(this.schema) as SchemaKey[];
    }

    validateType(key: SchemaKey, value: any): boolean {
        return typeof value === this.schema[key];
    }
}

class DynamicAccessor<T extends object> {
    private data: T;

    constructor(data: T) {
        this.data = data;
    }

    access<K extends keyof T>(key: K): T[K] {
        return this.data[key];
    }

    update<K extends keyof T>(key: K, value: T[K]): void {
        this.data[key] = value;
    }

    keys(): Array<keyof T> {
        return Object.keys(this.data) as Array<keyof T>;
    }

    values(): Array<T[keyof T]> {
        var result = [];
        var keys = Object.keys(this.data) as Array<keyof T>;
        for (var i = 0; i < keys.length; i++) {
            result.push(this.data[keys[i]]);
        }
        return result;
    }

    entries(): Array<[keyof T, T[keyof T]]> {
        var result = [];
        var keys = Object.keys(this.data) as Array<keyof T>;
        for (var i = 0; i < keys.length; i++) {
            result.push([keys[i], this.data[keys[i]]] as [keyof T, T[keyof T]]);
        }
        return result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function SchemaValidator"),
        "Expected SchemaValidator function: {}",
        output
    );
    assert!(
        output.contains("SchemaValidator.prototype.getType")
            && output.contains("SchemaValidator.prototype.hasField"),
        "Expected getType and hasField methods: {}",
        output
    );
    assert!(
        output.contains("SchemaValidator.prototype.getFields")
            && output.contains("SchemaValidator.prototype.validateType"),
        "Expected getFields and validateType methods: {}",
        output
    );
    assert!(
        output.contains("function DynamicAccessor"),
        "Expected DynamicAccessor function: {}",
        output
    );
    assert!(
        output.contains("DynamicAccessor.prototype.access")
            && output.contains("DynamicAccessor.prototype.update"),
        "Expected access and update methods: {}",
        output
    );
    assert!(
        output.contains("DynamicAccessor.prototype.keys")
            && output.contains("DynamicAccessor.prototype.values"),
        "Expected keys and values methods: {}",
        output
    );
    assert!(
        output.contains("DynamicAccessor.prototype.entries"),
        "Expected entries method: {}",
        output
    );
}

/// Test: template string interpolation types
/// Verifies that classes using template string interpolation transform correctly to ES5
#[test]
fn test_class_es5_template_string_interpolation() {
    let source = r#"
type Greeting<T extends string> = `Hello, ${T}!`;
type Farewell<T extends string> = `Goodbye, ${T}!`;

class MessageBuilder {
    private name: string;

    constructor(name: string) {
        this.name = name;
    }

    greet(): string {
        return "Hello, " + this.name + "!";
    }

    farewell(): string {
        return "Goodbye, " + this.name + "!";
    }

    custom(prefix: string, suffix: string): string {
        return prefix + this.name + suffix;
    }

    getName(): string {
        return this.name;
    }
}

type EventName<T extends string> = `on${Capitalize<T>}`;

class EventEmitter {
    private handlers: { [key: string]: Function[] };

    constructor() {
        this.handlers = {};
    }

    on(event: string, handler: Function): void {
        if (!this.handlers[event]) {
            this.handlers[event] = [];
        }
        this.handlers[event].push(handler);
    }

    emit(event: string, data: any): void {
        var handlers = this.handlers[event];
        if (handlers) {
            for (var i = 0; i < handlers.length; i++) {
                handlers[i](data);
            }
        }
    }

    off(event: string, handler: Function): void {
        var handlers = this.handlers[event];
        if (handlers) {
            var index = handlers.indexOf(handler);
            if (index !== -1) {
                handlers.splice(index, 1);
            }
        }
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function MessageBuilder"),
        "Expected MessageBuilder function: {}",
        output
    );
    assert!(
        output.contains("MessageBuilder.prototype.greet")
            && output.contains("MessageBuilder.prototype.farewell"),
        "Expected greet and farewell methods: {}",
        output
    );
    assert!(
        output.contains("MessageBuilder.prototype.custom")
            && output.contains("MessageBuilder.prototype.getName"),
        "Expected custom and getName methods: {}",
        output
    );
    assert!(
        output.contains("function EventEmitter"),
        "Expected EventEmitter function: {}",
        output
    );
    assert!(
        output.contains("EventEmitter.prototype.on")
            && output.contains("EventEmitter.prototype.emit"),
        "Expected on and emit methods: {}",
        output
    );
}

/// Test: template string pattern matching
/// Verifies that classes using template string pattern matching transform correctly to ES5
#[test]
fn test_class_es5_template_pattern_matching() {
    let source = r#"
type PathSegment = `/${string}`;
type QueryParam = `${string}=${string}`;

class UrlParser {
    private url: string;

    constructor(url: string) {
        this.url = url;
    }

    getPath(): string {
        var questionIndex = this.url.indexOf("?");
        if (questionIndex === -1) {
            return this.url;
        }
        return this.url.substring(0, questionIndex);
    }

    getQuery(): string {
        var questionIndex = this.url.indexOf("?");
        if (questionIndex === -1) {
            return "";
        }
        return this.url.substring(questionIndex + 1);
    }

    getSegments(): string[] {
        var path = this.getPath();
        return path.split("/").filter(function(s) { return s.length > 0; });
    }

    getUrl(): string {
        return this.url;
    }
}

type CssUnit = `${number}px` | `${number}em` | `${number}rem`;

class StyleBuilder {
    private styles: { [key: string]: string };

    constructor() {
        this.styles = {};
    }

    set(property: string, value: string): this {
        this.styles[property] = value;
        return this;
    }

    setPx(property: string, value: number): this {
        this.styles[property] = value + "px";
        return this;
    }

    setEm(property: string, value: number): this {
        this.styles[property] = value + "em";
        return this;
    }

    build(): string {
        var result = [];
        for (var key in this.styles) {
            result.push(key + ": " + this.styles[key]);
        }
        return result.join("; ");
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function UrlParser"),
        "Expected UrlParser function: {}",
        output
    );
    assert!(
        output.contains("UrlParser.prototype.getPath")
            && output.contains("UrlParser.prototype.getQuery"),
        "Expected getPath and getQuery methods: {}",
        output
    );
    assert!(
        output.contains("UrlParser.prototype.getSegments")
            && output.contains("UrlParser.prototype.getUrl"),
        "Expected getSegments and getUrl methods: {}",
        output
    );
    assert!(
        output.contains("function StyleBuilder"),
        "Expected StyleBuilder function: {}",
        output
    );
    assert!(
        output.contains("StyleBuilder.prototype.set")
            && output.contains("StyleBuilder.prototype.setPx"),
        "Expected set and setPx methods: {}",
        output
    );
    assert!(
        output.contains("StyleBuilder.prototype.build"),
        "Expected build method: {}",
        output
    );
}

/// Test: template literal key types
/// Verifies that classes using template literal key types transform correctly to ES5
#[test]
fn test_class_es5_template_literal_keys() {
    let source = r#"
type Getters<T> = {
    [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

type Setters<T> = {
    [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void;
};

class PropertyManager<T extends object> {
    private data: T;

    constructor(data: T) {
        this.data = data;
    }

    get<K extends keyof T>(key: K): T[K] {
        return this.data[key];
    }

    set<K extends keyof T>(key: K, value: T[K]): void {
        this.data[key] = value;
    }

    getData(): T {
        return this.data;
    }

    getKeys(): Array<keyof T> {
        return Object.keys(this.data) as Array<keyof T>;
    }
}

type PrefixedKeys<T, P extends string> = {
    [K in keyof T as `${P}${string & K}`]: T[K];
};

class KeyTransformer {
    prefix<T extends object>(obj: T, prefix: string): object {
        var result = {} as any;
        for (var key in obj) {
            result[prefix + key] = (obj as any)[key];
        }
        return result;
    }

    suffix<T extends object>(obj: T, suffix: string): object {
        var result = {} as any;
        for (var key in obj) {
            result[key + suffix] = (obj as any)[key];
        }
        return result;
    }

    transform<T extends object>(obj: T, fn: (key: string) => string): object {
        var result = {} as any;
        for (var key in obj) {
            result[fn(key)] = (obj as any)[key];
        }
        return result;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function PropertyManager"),
        "Expected PropertyManager function: {}",
        output
    );
    assert!(
        output.contains("PropertyManager.prototype.get")
            && output.contains("PropertyManager.prototype.set"),
        "Expected get and set methods: {}",
        output
    );
    assert!(
        output.contains("PropertyManager.prototype.getData")
            && output.contains("PropertyManager.prototype.getKeys"),
        "Expected getData and getKeys methods: {}",
        output
    );
    assert!(
        output.contains("function KeyTransformer"),
        "Expected KeyTransformer function: {}",
        output
    );
    assert!(
        output.contains("KeyTransformer.prototype.prefix")
            && output.contains("KeyTransformer.prototype.suffix"),
        "Expected prefix and suffix methods: {}",
        output
    );
    assert!(
        output.contains("KeyTransformer.prototype.transform"),
        "Expected transform method: {}",
        output
    );
}

/// Test: tagged template literal types
/// Verifies that classes using tagged template literals transform correctly to ES5
#[test]
fn test_class_es5_tagged_template_types() {
    let source = r#"
class SqlBuilder {
    private query: string;
    private params: any[];

    constructor() {
        this.query = "";
        this.params = [];
    }

    select(columns: string[]): this {
        this.query = "SELECT " + columns.join(", ");
        return this;
    }

    from(table: string): this {
        this.query = this.query + " FROM " + table;
        return this;
    }

    where(condition: string, value: any): this {
        this.query = this.query + " WHERE " + condition;
        this.params.push(value);
        return this;
    }

    getQuery(): string {
        return this.query;
    }

    getParams(): any[] {
        return this.params;
    }
}

class HtmlBuilder {
    private content: string;

    constructor() {
        this.content = "";
    }

    tag(name: string, text: string): this {
        this.content = this.content + "<" + name + ">" + text + "</" + name + ">";
        return this;
    }

    div(text: string): this {
        return this.tag("div", text);
    }

    span(text: string): this {
        return this.tag("span", text);
    }

    p(text: string): this {
        return this.tag("p", text);
    }

    build(): string {
        return this.content;
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function SqlBuilder"),
        "Expected SqlBuilder function: {}",
        output
    );
    assert!(
        output.contains("SqlBuilder.prototype.select")
            && output.contains("SqlBuilder.prototype.from"),
        "Expected select and from methods: {}",
        output
    );
    assert!(
        output.contains("SqlBuilder.prototype.where")
            && output.contains("SqlBuilder.prototype.getQuery"),
        "Expected where and getQuery methods: {}",
        output
    );
    assert!(
        output.contains("function HtmlBuilder"),
        "Expected HtmlBuilder function: {}",
        output
    );
    assert!(
        output.contains("HtmlBuilder.prototype.tag")
            && output.contains("HtmlBuilder.prototype.div"),
        "Expected tag and div methods: {}",
        output
    );
    assert!(
        output.contains("HtmlBuilder.prototype.build"),
        "Expected build method: {}",
        output
    );
}

/// Test: string manipulation utility types
/// Verifies that classes using string manipulation utility types transform correctly to ES5
#[test]
fn test_class_es5_string_manipulation_types() {
    let source = r#"
type Upper<T extends string> = Uppercase<T>;
type Lower<T extends string> = Lowercase<T>;
type Cap<T extends string> = Capitalize<T>;
type Uncap<T extends string> = Uncapitalize<T>;

class StringTransformer {
    toUpperCase(str: string): string {
        return str.toUpperCase();
    }

    toLowerCase(str: string): string {
        return str.toLowerCase();
    }

    capitalize(str: string): string {
        if (str.length === 0) return str;
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    uncapitalize(str: string): string {
        if (str.length === 0) return str;
        return str.charAt(0).toLowerCase() + str.slice(1);
    }

    toCamelCase(str: string): string {
        return str.replace(/-([a-z])/g, function(match, letter) {
            return letter.toUpperCase();
        });
    }

    toKebabCase(str: string): string {
        return str.replace(/([A-Z])/g, function(match) {
            return "-" + match.toLowerCase();
        });
    }
}

class NameFormatter {
    private firstName: string;
    private lastName: string;

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    getFullName(): string {
        return this.firstName + " " + this.lastName;
    }

    getInitials(): string {
        return this.firstName.charAt(0).toUpperCase() + this.lastName.charAt(0).toUpperCase();
    }

    getReversed(): string {
        return this.lastName + ", " + this.firstName;
    }

    getUpperCase(): string {
        return this.getFullName().toUpperCase();
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function StringTransformer"),
        "Expected StringTransformer function: {}",
        output
    );
    assert!(
        output.contains("StringTransformer.prototype.toUpperCase")
            && output.contains("StringTransformer.prototype.toLowerCase"),
        "Expected toUpperCase and toLowerCase methods: {}",
        output
    );
    assert!(
        output.contains("StringTransformer.prototype.capitalize")
            && output.contains("StringTransformer.prototype.toCamelCase"),
        "Expected capitalize and toCamelCase methods: {}",
        output
    );
    assert!(
        output.contains("function NameFormatter"),
        "Expected NameFormatter function: {}",
        output
    );
    assert!(
        output.contains("NameFormatter.prototype.getFullName")
            && output.contains("NameFormatter.prototype.getInitials"),
        "Expected getFullName and getInitials methods: {}",
        output
    );
}

/// Test: combined template string patterns
/// Verifies that classes using combined template string patterns transform correctly to ES5
#[test]
fn test_class_es5_combined_template_patterns() {
    let source = r#"
type ApiRoute<T extends string> = `/api/${T}`;
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
type Endpoint<M extends HttpMethod, R extends string> = `${M} ${R}`;

class RouteBuilder {
    private basePath: string;
    private routes: string[];

    constructor(basePath: string) {
        this.basePath = basePath;
        this.routes = [];
    }

    get(path: string): this {
        this.routes.push("GET " + this.basePath + path);
        return this;
    }

    post(path: string): this {
        this.routes.push("POST " + this.basePath + path);
        return this;
    }

    put(path: string): this {
        this.routes.push("PUT " + this.basePath + path);
        return this;
    }

    delete(path: string): this {
        this.routes.push("DELETE " + this.basePath + path);
        return this;
    }

    getRoutes(): string[] {
        return this.routes;
    }
}

type I18nKey<N extends string, K extends string> = `${N}.${K}`;

class I18nManager {
    private translations: { [key: string]: string };
    private namespace: string;

    constructor(namespace: string) {
        this.namespace = namespace;
        this.translations = {};
    }

    set(key: string, value: string): void {
        this.translations[this.namespace + "." + key] = value;
    }

    get(key: string): string {
        var fullKey = this.namespace + "." + key;
        return this.translations[fullKey] || fullKey;
    }

    has(key: string): boolean {
        var fullKey = this.namespace + "." + key;
        return fullKey in this.translations;
    }

    getNamespace(): string {
        return this.namespace;
    }

    getAllKeys(): string[] {
        return Object.keys(this.translations);
    }
}
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function RouteBuilder"),
        "Expected RouteBuilder function: {}",
        output
    );
    assert!(
        output.contains("RouteBuilder.prototype.get")
            && output.contains("RouteBuilder.prototype.post"),
        "Expected get and post methods: {}",
        output
    );
    assert!(
        output.contains("RouteBuilder.prototype.put")
            && output.contains("RouteBuilder.prototype.delete"),
        "Expected put and delete methods: {}",
        output
    );
    assert!(
        output.contains("RouteBuilder.prototype.getRoutes"),
        "Expected getRoutes method: {}",
        output
    );
    assert!(
        output.contains("function I18nManager"),
        "Expected I18nManager function: {}",
        output
    );
    assert!(
        output.contains("I18nManager.prototype.set")
            && output.contains("I18nManager.prototype.get"),
        "Expected set and get methods: {}",
        output
    );
    assert!(
        output.contains("I18nManager.prototype.has")
            && output.contains("I18nManager.prototype.getNamespace"),
        "Expected has and getNamespace methods: {}",
        output
    );
}

// ============================================================================
// CLASS STATIC BLOCK PATTERN TESTS
// ============================================================================

/// Test ES5 class downleveling with static block initialization order
#[test]
fn test_class_es5_static_block_initialization_order() {
    let source = r#"
class Database {
    static connectionString: string;
    static pool: any;
    static initialized: boolean = false;

    static {
        // First static block: set up connection string
        Database.connectionString = "postgres://localhost:5432/db";
        console.log("Connection string configured");
    }

    static maxConnections: number = 10;

    static {
        // Second static block: initialize pool after maxConnections is set
        Database.pool = { size: Database.maxConnections };
        Database.initialized = true;
        console.log("Pool initialized with size:", Database.maxConnections);
    }

    constructor() {
        if (!Database.initialized) {
            throw new Error("Database not initialized");
        }
    }

    query(sql: string): Promise<any[]> {
        return Promise.resolve([]);
    }
}

class Cache {
    static instance: Cache;
    static config: { ttl: number; maxSize: number };

    static {
        Cache.config = { ttl: 3600, maxSize: 1000 };
    }

    static {
        Cache.instance = new Cache();
    }

    private store: Map<string, any> = new Map();

    get(key: string): any {
        return this.store.get(key);
    }

    set(key: string, value: any): void {
        this.store.set(key, value);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Database") && output.contains("Cache"),
        "Expected static block initialization classes: {}",
        output
    );

    // Methods should be preserved
    assert!(
        output.contains("query") && output.contains("get") && output.contains("set"),
        "Expected methods: {}",
        output
    );

    // Static properties should be initialized
    assert!(
        output.contains("connectionString") && output.contains("maxConnections"),
        "Expected static properties: {}",
        output
    );
}

/// Test ES5 class downleveling with multiple static blocks chained
#[test]
fn test_class_es5_static_block_multiple_chained() {
    let source = r#"
class ConfigManager {
    static defaults: Record<string, any>;
    static overrides: Record<string, any>;
    static merged: Record<string, any>;

    static {
        // Block 1: Set defaults
        ConfigManager.defaults = {
            timeout: 5000,
            retries: 3,
            debug: false
        };
    }

    static {
        // Block 2: Set overrides from environment
        ConfigManager.overrides = {
            debug: true
        };
    }

    static {
        // Block 3: Merge configs
        ConfigManager.merged = {
            ...ConfigManager.defaults,
            ...ConfigManager.overrides
        };
    }

    static get(key: string): any {
        return ConfigManager.merged[key];
    }

    static set(key: string, value: any): void {
        ConfigManager.merged[key] = value;
    }
}

class PluginRegistry {
    static plugins: Map<string, Function> = new Map();
    static initialized: boolean = false;

    static {
        // Register core plugins
        PluginRegistry.plugins.set("logger", function() { console.log("logging"); });
    }

    static {
        // Register additional plugins
        PluginRegistry.plugins.set("metrics", function() { console.log("metrics"); });
        PluginRegistry.plugins.set("tracing", function() { console.log("tracing"); });
    }

    static {
        // Mark as initialized
        PluginRegistry.initialized = true;
    }

    static register(name: string, plugin: Function): void {
        PluginRegistry.plugins.set(name, plugin);
    }

    static execute(name: string): void {
        const plugin = PluginRegistry.plugins.get(name);
        if (plugin) plugin();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ConfigManager") && output.contains("PluginRegistry"),
        "Expected multiple static block classes: {}",
        output
    );

    // Static methods should be preserved
    assert!(
        output.contains("register") && output.contains("execute"),
        "Expected PluginRegistry methods: {}",
        output
    );

    // Config properties referenced
    assert!(
        output.contains("defaults") && output.contains("overrides") && output.contains("merged"),
        "Expected config properties: {}",
        output
    );
}

/// Test ES5 class downleveling with static blocks and private static access
#[test]
fn test_class_es5_static_block_private_static_access() {
    let source = r#"
class SecureVault {
    static #encryptionKey: string;
    static #initialized: boolean = false;

    static {
        // Initialize private static fields in static block
        SecureVault.#encryptionKey = "secret-key-12345";
        SecureVault.#initialized = true;
    }

    static encrypt(data: string): string {
        if (!SecureVault.#initialized) {
            throw new Error("Vault not initialized");
        }
        return data + SecureVault.#encryptionKey;
    }

    static decrypt(encrypted: string): string {
        return encrypted.replace(SecureVault.#encryptionKey, "");
    }
}

class Singleton {
    static #instance: Singleton | null = null;

    static {
        // Eagerly create instance in static block
        Singleton.#instance = new Singleton();
    }

    private constructor() {}

    static getInstance(): Singleton {
        return Singleton.#instance!;
    }

    doSomething(): void {
        console.log("Singleton doing something");
    }
}

class LazyLoader {
    static #loaders: Map<string, Function> = new Map();
    static #cache: Map<string, any> = new Map();

    static {
        LazyLoader.#loaders.set("config", () => ({ env: "production" }));
        LazyLoader.#loaders.set("user", () => ({ name: "guest" }));
    }

    static load(key: string): any {
        if (LazyLoader.#cache.has(key)) {
            return LazyLoader.#cache.get(key);
        }
        const loader = LazyLoader.#loaders.get(key);
        if (loader) {
            const value = loader();
            LazyLoader.#cache.set(key, value);
            return value;
        }
        return null;
    }

    static clear(): void {
        LazyLoader.#cache.clear();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("SecureVault")
            && output.contains("Singleton")
            && output.contains("LazyLoader"),
        "Expected static block private access classes: {}",
        output
    );

    // Methods should be preserved
    assert!(
        output.contains("encrypt") && output.contains("decrypt") && output.contains("getInstance"),
        "Expected SecureVault and Singleton methods: {}",
        output
    );

    // LazyLoader methods
    assert!(
        output.contains("load") && output.contains("clear"),
        "Expected LazyLoader methods: {}",
        output
    );
}

// ============================================================================
// ABSTRACT CLASS IMPLEMENTATION PATTERN TESTS
// ============================================================================

/// Test ES5 class downleveling with abstract method implementation patterns
#[test]
fn test_class_es5_abstract_implementation_methods() {
    let source = r#"
abstract class DataSource {
    abstract connect(): Promise<void>;
    abstract disconnect(): Promise<void>;
    abstract query(sql: string): Promise<any[]>;
    abstract execute(sql: string): Promise<number>;

    async transaction<T>(callback: () => Promise<T>): Promise<T> {
        await this.execute("BEGIN");
        try {
            const result = await callback();
            await this.execute("COMMIT");
            return result;
        } catch (error) {
            await this.execute("ROLLBACK");
            throw error;
        }
    }
}

class PostgresDataSource extends DataSource {
    private connectionString: string;
    private connected: boolean = false;

    constructor(connectionString: string) {
        super();
        this.connectionString = connectionString;
    }

    async connect(): Promise<void> {
        console.log("Connecting to:", this.connectionString);
        this.connected = true;
    }

    async disconnect(): Promise<void> {
        this.connected = false;
    }

    async query(sql: string): Promise<any[]> {
        if (!this.connected) throw new Error("Not connected");
        return [];
    }

    async execute(sql: string): Promise<number> {
        if (!this.connected) throw new Error("Not connected");
        return 1;
    }
}

class MySqlDataSource extends DataSource {
    private pool: any;

    constructor(config: { host: string; port: number }) {
        super();
        this.pool = config;
    }

    async connect(): Promise<void> {
        console.log("MySQL connecting");
    }

    async disconnect(): Promise<void> {
        console.log("MySQL disconnecting");
    }

    async query(sql: string): Promise<any[]> {
        return [{ id: 1 }];
    }

    async execute(sql: string): Promise<number> {
        return 0;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("DataSource")
            && output.contains("PostgresDataSource")
            && output.contains("MySqlDataSource"),
        "Expected abstract implementation classes: {}",
        output
    );

    // Implemented methods should be present
    assert!(
        output.contains("connect")
            && output.contains("disconnect")
            && output.contains("query")
            && output.contains("execute"),
        "Expected implemented methods: {}",
        output
    );

    // Base class method should be present
    assert!(
        output.contains("transaction"),
        "Expected base class transaction method: {}",
        output
    );
}

/// Test ES5 class downleveling with abstract property implementation patterns
#[test]
fn test_class_es5_abstract_implementation_properties() {
    let source = r#"
abstract class Component {
    abstract readonly tagName: string;
    abstract template: string;
    abstract styles: string[];

    render(): string {
        return "<" + this.tagName + ">" + this.template + "</" + this.tagName + ">";
    }

    getStyles(): string {
        return this.styles.join("\n");
    }
}

class Button extends Component {
    readonly tagName: string = "button";
    template: string = "<span>Click me</span>";
    styles: string[] = ["button { padding: 10px; }", "button:hover { opacity: 0.8; }"];

    private onClick: Function | null = null;

    setClickHandler(handler: Function): void {
        this.onClick = handler;
    }
}

class Card extends Component {
    readonly tagName: string = "div";
    template: string;
    styles: string[];

    constructor(content: string) {
        super();
        this.template = "<div class='card-body'>" + content + "</div>";
        this.styles = ["div.card { border: 1px solid gray; }", "div.card-body { padding: 16px; }"];
    }

    setContent(content: string): void {
        this.template = "<div class='card-body'>" + content + "</div>";
    }
}

abstract class FormField {
    abstract name: string;
    abstract value: any;
    abstract validate(): boolean;

    abstract get isValid(): boolean;
    abstract set disabled(value: boolean);

    reset(): void {
        this.value = null;
    }
}

class TextField extends FormField {
    name: string;
    value: string = "";
    private _disabled: boolean = false;

    constructor(name: string) {
        super();
        this.name = name;
    }

    validate(): boolean {
        return this.value.length > 0;
    }

    get isValid(): boolean {
        return this.validate();
    }

    set disabled(value: boolean) {
        this._disabled = value;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Component") && output.contains("Button") && output.contains("Card"),
        "Expected abstract property implementation classes: {}",
        output
    );

    // FormField hierarchy
    assert!(
        output.contains("FormField") && output.contains("TextField"),
        "Expected FormField classes: {}",
        output
    );

    // Methods should be preserved
    assert!(
        output.contains("render") && output.contains("getStyles") && output.contains("validate"),
        "Expected methods: {}",
        output
    );

    // Properties should be referenced
    assert!(
        output.contains("tagName") && output.contains("template") && output.contains("styles"),
        "Expected properties: {}",
        output
    );
}

/// Test ES5 class downleveling with abstract generic implementation patterns
#[test]
fn test_class_es5_abstract_implementation_generic() {
    let source = r#"
abstract class Repository<T, ID> {
    abstract findById(id: ID): Promise<T | null>;
    abstract findAll(): Promise<T[]>;
    abstract save(entity: T): Promise<T>;
    abstract delete(id: ID): Promise<boolean>;

    async exists(id: ID): Promise<boolean> {
        const entity = await this.findById(id);
        return entity !== null;
    }
}

interface User {
    id: number;
    name: string;
    email: string;
}

class UserRepository extends Repository<User, number> {
    private users: Map<number, User> = new Map();

    async findById(id: number): Promise<User | null> {
        return this.users.get(id) || null;
    }

    async findAll(): Promise<User[]> {
        return Array.from(this.users.values());
    }

    async save(entity: User): Promise<User> {
        this.users.set(entity.id, entity);
        return entity;
    }

    async delete(id: number): Promise<boolean> {
        return this.users.delete(id);
    }

    async findByEmail(email: string): Promise<User | null> {
        for (const user of this.users.values()) {
            if (user.email === email) return user;
        }
        return null;
    }
}

abstract class Service<T> {
    protected abstract repository: Repository<T, any>;

    abstract validate(entity: T): boolean;

    async create(entity: T): Promise<T> {
        if (!this.validate(entity)) {
            throw new Error("Validation failed");
        }
        return this.repository.save(entity);
    }

    async getAll(): Promise<T[]> {
        return this.repository.findAll();
    }
}

class UserService extends Service<User> {
    protected repository: UserRepository;

    constructor(repository: UserRepository) {
        super();
        this.repository = repository;
    }

    validate(entity: User): boolean {
        return entity.name.length > 0 && entity.email.includes("@");
    }

    async findByEmail(email: string): Promise<User | null> {
        return this.repository.findByEmail(email);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Repository") && output.contains("UserRepository"),
        "Expected Repository classes: {}",
        output
    );

    // Service classes
    assert!(
        output.contains("Service") && output.contains("UserService"),
        "Expected Service classes: {}",
        output
    );

    // Repository methods
    assert!(
        output.contains("findById") && output.contains("findAll") && output.contains("save"),
        "Expected Repository methods: {}",
        output
    );

    // Service methods
    assert!(
        output.contains("validate") && output.contains("create") && output.contains("getAll"),
        "Expected Service methods: {}",
        output
    );
}

// ============================================================================
// INTERFACE IMPLEMENTATION PATTERN TESTS
// ============================================================================

/// Test ES5 class downleveling with implements clause patterns
#[test]
fn test_class_es5_interface_implements_clause() {
    let source = r#"
interface Serializable {
    serialize(): string;
    deserialize(data: string): void;
}

interface Identifiable {
    readonly id: string;
    getId(): string;
}

interface Timestamped {
    createdAt: Date;
    updatedAt: Date;
    touch(): void;
}

class Document implements Serializable, Identifiable, Timestamped {
    readonly id: string;
    createdAt: Date;
    updatedAt: Date;
    private content: string;

    constructor(id: string, content: string) {
        this.id = id;
        this.content = content;
        this.createdAt = new Date();
        this.updatedAt = new Date();
    }

    serialize(): string {
        return JSON.stringify({
            id: this.id,
            content: this.content,
            createdAt: this.createdAt.toISOString(),
            updatedAt: this.updatedAt.toISOString()
        });
    }

    deserialize(data: string): void {
        const parsed = JSON.parse(data);
        this.content = parsed.content;
    }

    getId(): string {
        return this.id;
    }

    touch(): void {
        this.updatedAt = new Date();
    }

    getContent(): string {
        return this.content;
    }
}

class User implements Identifiable {
    readonly id: string;
    name: string;
    email: string;

    constructor(id: string, name: string, email: string) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    getId(): string {
        return this.id;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Document") && output.contains("User"),
        "Expected implements clause classes: {}",
        output
    );

    // Document methods should be preserved
    assert!(
        output.contains("serialize") && output.contains("deserialize") && output.contains("getId"),
        "Expected Document methods: {}",
        output
    );

    // Touch method should be present
    assert!(
        output.contains("touch") && output.contains("getContent"),
        "Expected additional methods: {}",
        output
    );
}

/// Test ES5 class downleveling with multiple interface implementations
#[test]
fn test_class_es5_interface_multiple_implements() {
    let source = r#"
interface Disposable {
    dispose(): void;
    isDisposed: boolean;
}

interface Cloneable<T> {
    clone(): T;
}

interface Comparable<T> {
    compareTo(other: T): number;
    equals(other: T): boolean;
}

interface Hashable {
    hashCode(): number;
}

class Entity implements Disposable, Cloneable<Entity>, Comparable<Entity>, Hashable {
    private _isDisposed: boolean = false;
    readonly value: number;

    constructor(value: number) {
        this.value = value;
    }

    get isDisposed(): boolean {
        return this._isDisposed;
    }

    set isDisposed(value: boolean) {
        this._isDisposed = value;
    }

    dispose(): void {
        this._isDisposed = true;
    }

    clone(): Entity {
        return new Entity(this.value);
    }

    compareTo(other: Entity): number {
        return this.value - other.value;
    }

    equals(other: Entity): boolean {
        return this.value === other.value;
    }

    hashCode(): number {
        return this.value * 31;
    }
}

interface EventEmitter {
    on(event: string, handler: Function): void;
    off(event: string, handler: Function): void;
    emit(event: string, data?: any): void;
}

interface Logger {
    log(message: string): void;
    error(message: string): void;
    warn(message: string): void;
}

class ServiceBase implements EventEmitter, Logger {
    private handlers: Map<string, Function[]> = new Map();

    on(event: string, handler: Function): void {
        const list = this.handlers.get(event) || [];
        list.push(handler);
        this.handlers.set(event, list);
    }

    off(event: string, handler: Function): void {
        const list = this.handlers.get(event) || [];
        const index = list.indexOf(handler);
        if (index >= 0) list.splice(index, 1);
    }

    emit(event: string, data?: any): void {
        const list = this.handlers.get(event) || [];
        list.forEach(h => h(data));
    }

    log(message: string): void {
        console.log("[LOG]", message);
    }

    error(message: string): void {
        console.error("[ERROR]", message);
    }

    warn(message: string): void {
        console.warn("[WARN]", message);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Entity") && output.contains("ServiceBase"),
        "Expected multiple interface classes: {}",
        output
    );

    // Entity methods
    assert!(
        output.contains("dispose") && output.contains("clone") && output.contains("compareTo"),
        "Expected Entity methods: {}",
        output
    );

    // ServiceBase methods
    assert!(
        output.contains("emit") && output.contains("log") && output.contains("error"),
        "Expected ServiceBase methods: {}",
        output
    );
}

/// Test ES5 class downleveling with generic interface implementations
#[test]
fn test_class_es5_interface_generic_implements() {
    let source = r#"
interface Collection<T> {
    add(item: T): void;
    remove(item: T): boolean;
    contains(item: T): boolean;
    size(): number;
    toArray(): T[];
}

interface Iterator<T> {
    next(): { value: T; done: boolean };
    hasNext(): boolean;
    reset(): void;
}

class ArrayList<T> implements Collection<T>, Iterator<T> {
    private items: T[] = [];
    private index: number = 0;

    add(item: T): void {
        this.items.push(item);
    }

    remove(item: T): boolean {
        const idx = this.items.indexOf(item);
        if (idx >= 0) {
            this.items.splice(idx, 1);
            return true;
        }
        return false;
    }

    contains(item: T): boolean {
        return this.items.indexOf(item) >= 0;
    }

    size(): number {
        return this.items.length;
    }

    toArray(): T[] {
        return [...this.items];
    }

    next(): { value: T; done: boolean } {
        if (this.index < this.items.length) {
            return { value: this.items[this.index++], done: false };
        }
        return { value: undefined as any, done: true };
    }

    hasNext(): boolean {
        return this.index < this.items.length;
    }

    reset(): void {
        this.index = 0;
    }
}

interface KeyValueStore<K, V> {
    get(key: K): V | undefined;
    set(key: K, value: V): void;
    delete(key: K): boolean;
    has(key: K): boolean;
    clear(): void;
}

class HashMap<K, V> implements KeyValueStore<K, V> {
    private storage: Map<K, V> = new Map();

    get(key: K): V | undefined {
        return this.storage.get(key);
    }

    set(key: K, value: V): void {
        this.storage.set(key, value);
    }

    delete(key: K): boolean {
        return this.storage.delete(key);
    }

    has(key: K): boolean {
        return this.storage.has(key);
    }

    clear(): void {
        this.storage.clear();
    }

    keys(): K[] {
        return Array.from(this.storage.keys());
    }

    values(): V[] {
        return Array.from(this.storage.values());
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ArrayList") && output.contains("HashMap"),
        "Expected generic interface classes: {}",
        output
    );

    // ArrayList/Collection methods
    assert!(
        output.contains("add") && output.contains("remove") && output.contains("contains"),
        "Expected Collection methods: {}",
        output
    );

    // Iterator methods
    assert!(
        output.contains("next") && output.contains("hasNext") && output.contains("reset"),
        "Expected Iterator methods: {}",
        output
    );

    // HashMap methods
    assert!(
        output.contains("keys") && output.contains("values") && output.contains("clear"),
        "Expected HashMap methods: {}",
        output
    );
}

// ============================================================================
// CONSTRUCTOR SIGNATURE PATTERN TESTS
// ============================================================================

/// Test ES5 class downleveling with constructor optional parameter patterns
#[test]
fn test_class_es5_constructor_signature_optional_params() {
    let source = r#"
class HttpClient {
    private baseUrl: string;
    private timeout: number;
    private headers: Record<string, string>;
    private retries: number;

    constructor(
        baseUrl: string,
        timeout?: number,
        headers?: Record<string, string>,
        retries?: number
    ) {
        this.baseUrl = baseUrl;
        this.timeout = timeout ?? 5000;
        this.headers = headers ?? {};
        this.retries = retries ?? 3;
    }

    get(path: string): Promise<any> {
        return fetch(this.baseUrl + path, {
            headers: this.headers
        }).then(r => r.json());
    }
}

class Logger {
    private level: string;
    private prefix: string;
    private timestamps: boolean;

    constructor(
        level: string = "info",
        prefix: string = "",
        timestamps: boolean = true
    ) {
        this.level = level;
        this.prefix = prefix;
        this.timestamps = timestamps;
    }

    log(message: string): void {
        const ts = this.timestamps ? new Date().toISOString() + " " : "";
        console.log(ts + this.prefix + message);
    }
}

class EventBus {
    private name: string;
    private maxListeners: number;
    private debug: boolean;

    constructor(name?: string, maxListeners?: number, debug?: boolean) {
        this.name = name || "default";
        this.maxListeners = maxListeners || 10;
        this.debug = debug || false;
    }

    emit(event: string, data?: any): void {
        if (this.debug) {
            console.log("[" + this.name + "] Emitting:", event);
        }
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("HttpClient") && output.contains("Logger") && output.contains("EventBus"),
        "Expected constructor optional param classes: {}",
        output
    );

    // Methods should be preserved
    assert!(
        output.contains("get") && output.contains("log") && output.contains("emit"),
        "Expected methods: {}",
        output
    );

    // Properties should be referenced
    assert!(
        output.contains("baseUrl") && output.contains("timeout") && output.contains("headers"),
        "Expected HttpClient properties: {}",
        output
    );
}

/// Test ES5 class downleveling with constructor rest parameter patterns
#[test]
fn test_class_es5_constructor_signature_rest_params() {
    let source = r#"
class Command {
    private name: string;
    private args: string[];

    constructor(name: string, ...args: string[]) {
        this.name = name;
        this.args = args;
    }

    execute(): string {
        return this.name + " " + this.args.join(" ");
    }

    getArgs(): string[] {
        return [...this.args];
    }
}

class Pipeline {
    private stages: Function[];

    constructor(...stages: Function[]) {
        this.stages = stages;
    }

    run(input: any): any {
        return this.stages.reduce((acc, stage) => stage(acc), input);
    }

    addStage(stage: Function): void {
        this.stages.push(stage);
    }
}

class CompositeValidator {
    private validators: ((value: any) => boolean)[];
    private mode: string;

    constructor(mode: string, ...validators: ((value: any) => boolean)[]) {
        this.mode = mode;
        this.validators = validators;
    }

    validate(value: any): boolean {
        if (this.mode === "all") {
            return this.validators.every(v => v(value));
        } else {
            return this.validators.some(v => v(value));
        }
    }

    addValidator(validator: (value: any) => boolean): void {
        this.validators.push(validator);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Command")
            && output.contains("Pipeline")
            && output.contains("CompositeValidator"),
        "Expected constructor rest param classes: {}",
        output
    );

    // Methods should be preserved
    assert!(
        output.contains("execute") && output.contains("run") && output.contains("validate"),
        "Expected methods: {}",
        output
    );

    // Additional methods
    assert!(
        output.contains("getArgs")
            && output.contains("addStage")
            && output.contains("addValidator"),
        "Expected additional methods: {}",
        output
    );
}

/// Test ES5 class downleveling with constructor overload signature patterns
#[test]
fn test_class_es5_constructor_signature_overloads() {
    let source = r#"
class Point {
    x: number;
    y: number;

    constructor();
    constructor(x: number);
    constructor(x: number, y: number);
    constructor(x?: number, y?: number) {
        this.x = x ?? 0;
        this.y = y ?? x ?? 0;
    }

    distanceTo(other: Point): number {
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    static fromArray(arr: [number, number]): Point {
        return new Point(arr[0], arr[1]);
    }
}

class Rectangle {
    width: number;
    height: number;
    x: number;
    y: number;

    constructor(width: number, height: number);
    constructor(width: number, height: number, x: number, y: number);
    constructor(width: number, height: number, x?: number, y?: number) {
        this.width = width;
        this.height = height;
        this.x = x ?? 0;
        this.y = y ?? 0;
    }

    area(): number {
        return this.width * this.height;
    }

    contains(point: Point): boolean {
        return point.x >= this.x && point.x <= this.x + this.width &&
               point.y >= this.y && point.y <= this.y + this.height;
    }
}

class Color {
    r: number;
    g: number;
    b: number;
    a: number;

    constructor(hex: string);
    constructor(r: number, g: number, b: number);
    constructor(r: number, g: number, b: number, a: number);
    constructor(rOrHex: number | string, g?: number, b?: number, a?: number) {
        if (typeof rOrHex === "string") {
            // Parse hex
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 1;
        } else {
            this.r = rOrHex;
            this.g = g ?? 0;
            this.b = b ?? 0;
            this.a = a ?? 1;
        }
    }

    toHex(): string {
        return this.r.toString(16) + this.g.toString(16) + this.b.toString(16);
    }

    withAlpha(alpha: number): Color {
        return new Color(this.r, this.g, this.b, alpha);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Point") && output.contains("Rectangle") && output.contains("Color"),
        "Expected constructor overload classes: {}",
        output
    );

    // Point methods
    assert!(
        output.contains("distanceTo") && output.contains("fromArray"),
        "Expected Point methods: {}",
        output
    );

    // Rectangle methods
    assert!(
        output.contains("area") && output.contains("contains"),
        "Expected Rectangle methods: {}",
        output
    );

    // Color methods
    assert!(
        output.contains("toHex") && output.contains("withAlpha"),
        "Expected Color methods: {}",
        output
    );
}

// ============================================================================
// GENERIC CONSTRAINT PATTERN TESTS
// ============================================================================

/// Test ES5 class downleveling with generic extends constraint patterns
#[test]
fn test_class_es5_generic_constraint_extends() {
    let source = r#"
interface Entity {
    id: string;
    createdAt: Date;
}

interface Nameable {
    name: string;
}

class Repository<T extends Entity> {
    private items: Map<string, T> = new Map();

    save(item: T): T {
        this.items.set(item.id, item);
        return item;
    }

    findById(id: string): T | undefined {
        return this.items.get(id);
    }

    findAll(): T[] {
        return Array.from(this.items.values());
    }

    deleteById(id: string): boolean {
        return this.items.delete(id);
    }
}

class NamedRepository<T extends Entity & Nameable> extends Repository<T> {
    findByName(name: string): T | undefined {
        for (const item of this.findAll()) {
            if (item.name === name) return item;
        }
        return undefined;
    }

    findAllByNamePrefix(prefix: string): T[] {
        return this.findAll().filter(item => item.name.startsWith(prefix));
    }
}

class ComparableCollection<T extends { compareTo(other: T): number }> {
    private items: T[] = [];

    add(item: T): void {
        this.items.push(item);
    }

    sort(): T[] {
        return [...this.items].sort((a, b) => a.compareTo(b));
    }

    min(): T | undefined {
        if (this.items.length === 0) return undefined;
        return this.sort()[0];
    }

    max(): T | undefined {
        if (this.items.length === 0) return undefined;
        const sorted = this.sort();
        return sorted[sorted.length - 1];
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Repository")
            && output.contains("NamedRepository")
            && output.contains("ComparableCollection"),
        "Expected generic extends constraint classes: {}",
        output
    );

    // Repository methods
    assert!(
        output.contains("save") && output.contains("findById") && output.contains("findAll"),
        "Expected Repository methods: {}",
        output
    );

    // NamedRepository methods
    assert!(
        output.contains("findByName") && output.contains("findAllByNamePrefix"),
        "Expected NamedRepository methods: {}",
        output
    );

    // ComparableCollection methods
    assert!(
        output.contains("sort") && output.contains("min") && output.contains("max"),
        "Expected ComparableCollection methods: {}",
        output
    );
}

/// Test ES5 class downleveling with generic keyof constraint patterns
#[test]
fn test_class_es5_generic_constraint_keyof() {
    let source = r#"
class PropertyAccessor<T, K extends keyof T> {
    private obj: T;
    private key: K;

    constructor(obj: T, key: K) {
        this.obj = obj;
        this.key = key;
    }

    get(): T[K] {
        return this.obj[this.key];
    }

    set(value: T[K]): void {
        this.obj[this.key] = value;
    }
}

class ObjectMapper<T extends object> {
    private source: T;

    constructor(source: T) {
        this.source = source;
    }

    pick<K extends keyof T>(...keys: K[]): Pick<T, K> {
        const result = {} as Pick<T, K>;
        for (const key of keys) {
            result[key] = this.source[key];
        }
        return result;
    }

    omit<K extends keyof T>(...keys: K[]): Omit<T, K> {
        const result = { ...this.source } as any;
        for (const key of keys) {
            delete result[key];
        }
        return result;
    }

    getProperty<K extends keyof T>(key: K): T[K] {
        return this.source[key];
    }
}

class FormBuilder<T extends Record<string, any>> {
    private values: Partial<T> = {};
    private errors: Partial<Record<keyof T, string>> = {};

    setValue<K extends keyof T>(key: K, value: T[K]): void {
        this.values[key] = value;
    }

    getValue<K extends keyof T>(key: K): T[K] | undefined {
        return this.values[key];
    }

    setError<K extends keyof T>(key: K, error: string): void {
        this.errors[key] = error;
    }

    getError<K extends keyof T>(key: K): string | undefined {
        return this.errors[key];
    }

    getValues(): Partial<T> {
        return { ...this.values };
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("PropertyAccessor")
            && output.contains("ObjectMapper")
            && output.contains("FormBuilder"),
        "Expected generic keyof constraint classes: {}",
        output
    );

    // PropertyAccessor methods
    assert!(
        output.contains("get") && output.contains("set"),
        "Expected PropertyAccessor methods: {}",
        output
    );

    // ObjectMapper methods
    assert!(
        output.contains("pick") && output.contains("omit") && output.contains("getProperty"),
        "Expected ObjectMapper methods: {}",
        output
    );

    // FormBuilder methods
    assert!(
        output.contains("setValue") && output.contains("getValue") && output.contains("getValues"),
        "Expected FormBuilder methods: {}",
        output
    );
}

/// Test ES5 class downleveling with generic conditional type constraint patterns
#[test]
fn test_class_es5_generic_constraint_conditional() {
    let source = r#"
type IsArray<T> = T extends any[] ? true : false;
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;
type ElementType<T> = T extends (infer E)[] ? E : never;

class TypeChecker<T> {
    private value: T;

    constructor(value: T) {
        this.value = value;
    }

    isArray(): boolean {
        return Array.isArray(this.value);
    }

    getValue(): T {
        return this.value;
    }

    map<U>(fn: (value: T) => U): TypeChecker<U> {
        return new TypeChecker(fn(this.value));
    }
}

class AsyncHandler<T> {
    private promise: Promise<T>;

    constructor(promise: Promise<T>) {
        this.promise = promise;
    }

    async unwrap(): Promise<T> {
        return this.promise;
    }

    map<U>(fn: (value: T) => U): AsyncHandler<U> {
        return new AsyncHandler(this.promise.then(fn));
    }

    flatMap<U>(fn: (value: T) => Promise<U>): AsyncHandler<U> {
        return new AsyncHandler(this.promise.then(fn));
    }
}

class ArrayProcessor<T extends any[]> {
    private array: T;

    constructor(array: T) {
        this.array = array;
    }

    first(): T[number] | undefined {
        return this.array[0];
    }

    last(): T[number] | undefined {
        return this.array[this.array.length - 1];
    }

    map<U>(fn: (item: T[number]) => U): U[] {
        return this.array.map(fn);
    }

    filter(predicate: (item: T[number]) => boolean): T[number][] {
        return this.array.filter(predicate);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("TypeChecker")
            && output.contains("AsyncHandler")
            && output.contains("ArrayProcessor"),
        "Expected generic conditional constraint classes: {}",
        output
    );

    // TypeChecker methods
    assert!(
        output.contains("isArray") && output.contains("getValue"),
        "Expected TypeChecker methods: {}",
        output
    );

    // AsyncHandler methods
    assert!(
        output.contains("unwrap") && output.contains("flatMap"),
        "Expected AsyncHandler methods: {}",
        output
    );

    // ArrayProcessor methods
    assert!(
        output.contains("first") && output.contains("last") && output.contains("filter"),
        "Expected ArrayProcessor methods: {}",
        output
    );
}

// ============================================================================
// TYPE ALIAS PATTERN TESTS
// ============================================================================

/// Test ES5 class downleveling with union type alias patterns
#[test]
fn test_class_es5_type_alias_union() {
    let source = r#"
type StringOrNumber = string | number;
type Primitive = string | number | boolean | null | undefined;
type Result<T> = T | Error;
type AsyncResult<T> = T | Promise<T>;

class ValueHolder<T extends StringOrNumber> {
    private value: T;

    constructor(value: T) {
        this.value = value;
    }

    getValue(): T {
        return this.value;
    }

    isString(): boolean {
        return typeof this.value === "string";
    }

    isNumber(): boolean {
        return typeof this.value === "number";
    }

    toString(): string {
        return String(this.value);
    }
}

class ResultHandler<T> {
    private result: Result<T>;

    constructor(result: Result<T>) {
        this.result = result;
    }

    isError(): boolean {
        return this.result instanceof Error;
    }

    getValue(): T | null {
        if (this.result instanceof Error) {
            return null;
        }
        return this.result;
    }

    getError(): Error | null {
        if (this.result instanceof Error) {
            return this.result;
        }
        return null;
    }

    map<U>(fn: (value: T) => U): ResultHandler<U> {
        if (this.result instanceof Error) {
            return new ResultHandler<U>(this.result);
        }
        return new ResultHandler<U>(fn(this.result));
    }
}

class PrimitiveParser {
    parse(value: Primitive): string {
        if (value === null) return "null";
        if (value === undefined) return "undefined";
        return String(value);
    }

    parseAll(values: Primitive[]): string[] {
        return values.map(v => this.parse(v));
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ValueHolder")
            && output.contains("ResultHandler")
            && output.contains("PrimitiveParser"),
        "Expected union type alias classes: {}",
        output
    );

    // ValueHolder methods
    assert!(
        output.contains("getValue") && output.contains("isString") && output.contains("isNumber"),
        "Expected ValueHolder methods: {}",
        output
    );

    // ResultHandler methods
    assert!(
        output.contains("isError") && output.contains("getError"),
        "Expected ResultHandler methods: {}",
        output
    );

    // PrimitiveParser methods
    assert!(
        output.contains("parse") && output.contains("parseAll"),
        "Expected PrimitiveParser methods: {}",
        output
    );
}

/// Test ES5 class downleveling with intersection type alias patterns
#[test]
fn test_class_es5_type_alias_intersection() {
    let source = r#"
type Named = { name: string };
type Aged = { age: number };
type Identified = { id: string };

type Person = Named & Aged;
type IdentifiedPerson = Person & Identified;
type Timestamped = { createdAt: Date; updatedAt: Date };
type Entity = Identified & Timestamped;

class PersonBuilder {
    private data: Partial<IdentifiedPerson> = {};

    setId(id: string): this {
        this.data.id = id;
        return this;
    }

    setName(name: string): this {
        this.data.name = name;
        return this;
    }

    setAge(age: number): this {
        this.data.age = age;
        return this;
    }

    build(): IdentifiedPerson {
        return this.data as IdentifiedPerson;
    }

    reset(): void {
        this.data = {};
    }
}

class EntityManager<T extends Entity> {
    private entities: Map<string, T> = new Map();

    add(entity: T): void {
        this.entities.set(entity.id, entity);
    }

    get(id: string): T | undefined {
        return this.entities.get(id);
    }

    getAll(): T[] {
        return Array.from(this.entities.values());
    }

    findByDateRange(start: Date, end: Date): T[] {
        return this.getAll().filter(
            e => e.createdAt >= start && e.createdAt <= end
        );
    }
}

class MixinApplier<T extends object> {
    private base: T;

    constructor(base: T) {
        this.base = base;
    }

    with<U extends object>(mixin: U): T & U {
        return { ...this.base, ...mixin };
    }

    withAll<U extends object[]>(...mixins: U): T {
        return Object.assign({}, this.base, ...mixins);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("PersonBuilder")
            && output.contains("EntityManager")
            && output.contains("MixinApplier"),
        "Expected intersection type alias classes: {}",
        output
    );

    // PersonBuilder methods
    assert!(
        output.contains("setId")
            && output.contains("setName")
            && output.contains("setAge")
            && output.contains("build"),
        "Expected PersonBuilder methods: {}",
        output
    );

    // EntityManager methods
    assert!(
        output.contains("add") && output.contains("getAll") && output.contains("findByDateRange"),
        "Expected EntityManager methods: {}",
        output
    );

    // MixinApplier methods
    assert!(
        output.contains("withAll"),
        "Expected MixinApplier methods: {}",
        output
    );
}

/// Test ES5 class downleveling with conditional type alias patterns
#[test]
fn test_class_es5_type_alias_conditional() {
    let source = r#"
type NonNullable<T> = T extends null | undefined ? never : T;
type ExtractArray<T> = T extends (infer U)[] ? U : T;
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;
type PromiseValue<T> = T extends Promise<infer V> ? V : T;

class NullableHandler<T> {
    private value: T | null | undefined;

    constructor(value: T | null | undefined) {
        this.value = value;
    }

    isNull(): boolean {
        return this.value === null;
    }

    isUndefined(): boolean {
        return this.value === undefined;
    }

    isDefined(): boolean {
        return this.value !== null && this.value !== undefined;
    }

    getOrDefault(defaultValue: T): T {
        if (this.value === null || this.value === undefined) {
            return defaultValue;
        }
        return this.value;
    }

    map<U>(fn: (value: T) => U): NullableHandler<U> {
        if (this.value === null || this.value === undefined) {
            return new NullableHandler<U>(null);
        }
        return new NullableHandler<U>(fn(this.value));
    }
}

class ArrayExtractor<T> {
    private array: T[];

    constructor(array: T[]) {
        this.array = array;
    }

    extract(): T[] {
        return [...this.array];
    }

    head(): T | undefined {
        return this.array[0];
    }

    tail(): T[] {
        return this.array.slice(1);
    }

    flatten<U>(this: ArrayExtractor<U[]>): U[] {
        return this.array.flat();
    }
}

class FunctionAnalyzer<T extends (...args: any[]) => any> {
    private fn: T;

    constructor(fn: T) {
        this.fn = fn;
    }

    call(...args: Parameters<T>): ReturnType<T> {
        return this.fn(...args);
    }

    bind<U>(thisArg: U): (...args: Parameters<T>) => ReturnType<T> {
        return this.fn.bind(thisArg);
    }

    getArity(): number {
        return this.fn.length;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("NullableHandler")
            && output.contains("ArrayExtractor")
            && output.contains("FunctionAnalyzer"),
        "Expected conditional type alias classes: {}",
        output
    );

    // NullableHandler methods
    assert!(
        output.contains("isNull")
            && output.contains("isUndefined")
            && output.contains("isDefined")
            && output.contains("getOrDefault"),
        "Expected NullableHandler methods: {}",
        output
    );

    // ArrayExtractor methods
    assert!(
        output.contains("extract") && output.contains("head") && output.contains("tail"),
        "Expected ArrayExtractor methods: {}",
        output
    );

    // FunctionAnalyzer methods
    assert!(
        output.contains("call") && output.contains("bind") && output.contains("getArity"),
        "Expected FunctionAnalyzer methods: {}",
        output
    );
}

// ============================================================================
// ENUM PATTERN TESTS
// ============================================================================

/// Test enum patterns: const enum (inlined values)
#[test]
fn test_class_es5_enum_const() {
    let source = r#"
const enum Direction {
    Up = 0,
    Down = 1,
    Left = 2,
    Right = 3
}

const enum HttpStatus {
    OK = 200,
    Created = 201,
    BadRequest = 400,
    NotFound = 404,
    InternalError = 500
}

class DirectionHandler {
    private direction: number;

    constructor() {
        this.direction = 0;
    }

    setDirection(dir: Direction): void {
        this.direction = dir;
    }

    getDirection(): number {
        return this.direction;
    }

    isHorizontal(): boolean {
        return this.direction === Direction.Left || this.direction === Direction.Right;
    }

    isVertical(): boolean {
        return this.direction === Direction.Up || this.direction === Direction.Down;
    }
}

class HttpStatusChecker {
    isSuccess(status: HttpStatus): boolean {
        return status >= 200 && status < 300;
    }

    isClientError(status: HttpStatus): boolean {
        return status >= 400 && status < 500;
    }

    isServerError(status: HttpStatus): boolean {
        return status >= 500;
    }

    getStatusText(status: HttpStatus): string {
        switch (status) {
            case HttpStatus.OK: return "OK";
            case HttpStatus.Created: return "Created";
            case HttpStatus.BadRequest: return "Bad Request";
            case HttpStatus.NotFound: return "Not Found";
            case HttpStatus.InternalError: return "Internal Server Error";
            default: return "Unknown";
        }
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted to ES5
    assert!(
        output.contains("function DirectionHandler")
            && output.contains("function HttpStatusChecker"),
        "Expected ES5 class constructors: {}",
        output
    );

    // Methods should be on prototype
    assert!(
        output.contains("DirectionHandler.prototype.setDirection")
            && output.contains("HttpStatusChecker.prototype.isSuccess"),
        "Expected methods on prototype: {}",
        output
    );

    // Direction check methods
    assert!(
        output.contains("isHorizontal") && output.contains("isVertical"),
        "Expected direction methods: {}",
        output
    );
}

/// Test enum patterns: string enum
#[test]
fn test_class_es5_enum_string() {
    let source = r#"
enum Color {
    Red = "RED",
    Green = "GREEN",
    Blue = "BLUE",
    Yellow = "YELLOW"
}

enum LogLevel {
    Debug = "debug",
    Info = "info",
    Warning = "warning",
    Error = "error"
}

class ColorPicker {
    private currentColor: Color;

    constructor() {
        this.currentColor = Color.Red;
    }

    setColor(color: Color): void {
        this.currentColor = color;
    }

    getColor(): Color {
        return this.currentColor;
    }

    getColorName(): string {
        return this.currentColor;
    }

    isPrimary(): boolean {
        return this.currentColor === Color.Red ||
               this.currentColor === Color.Green ||
               this.currentColor === Color.Blue;
    }
}

class Logger {
    private level: LogLevel;
    private messages: string[] = [];

    constructor(level: LogLevel) {
        this.level = level;
    }

    log(level: LogLevel, message: string): void {
        if (this.shouldLog(level)) {
            this.messages.push("[" + level + "] " + message);
        }
    }

    private shouldLog(level: LogLevel): boolean {
        const levels = [LogLevel.Debug, LogLevel.Info, LogLevel.Warning, LogLevel.Error];
        return levels.indexOf(level) >= levels.indexOf(this.level);
    }

    getMessages(): string[] {
        return this.messages.slice();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("function ColorPicker") && output.contains("function Logger"),
        "Expected ES5 class constructors: {}",
        output
    );

    // Enum should be emitted
    assert!(
        output.contains("Color") && output.contains("LogLevel"),
        "Expected enum declarations: {}",
        output
    );

    // Methods preserved
    assert!(
        output.contains("setColor") && output.contains("isPrimary"),
        "Expected ColorPicker methods: {}",
        output
    );
}

/// Test enum patterns: numeric enum
#[test]
fn test_class_es5_enum_numeric() {
    let source = r#"
enum Priority {
    Low,
    Medium,
    High,
    Critical
}

enum Weekday {
    Monday = 1,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
}

class TaskPrioritizer {
    private priority: Priority;

    constructor() {
        this.priority = Priority.Medium;
    }

    setPriority(priority: Priority): void {
        this.priority = priority;
    }

    getPriority(): Priority {
        return this.priority;
    }

    isUrgent(): boolean {
        return this.priority >= Priority.High;
    }

    compare(other: Priority): number {
        return this.priority - other;
    }
}

class WeekdayScheduler {
    private workdays: Set<Weekday> = new Set();

    addWorkday(day: Weekday): void {
        this.workdays.add(day);
    }

    isWorkday(day: Weekday): boolean {
        return this.workdays.has(day);
    }

    isWeekend(day: Weekday): boolean {
        return day === Weekday.Saturday || day === Weekday.Sunday;
    }

    getWorkdayCount(): number {
        return this.workdays.size;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("function TaskPrioritizer") && output.contains("function WeekdayScheduler"),
        "Expected ES5 class constructors: {}",
        output
    );

    // Enum should be emitted
    assert!(
        output.contains("Priority") && output.contains("Weekday"),
        "Expected enum declarations: {}",
        output
    );

    // Methods preserved
    assert!(
        output.contains("isUrgent") && output.contains("isWeekend"),
        "Expected methods: {}",
        output
    );
}

/// Test enum patterns: computed enum values
#[test]
fn test_class_es5_enum_computed() {
    let source = r#"
enum FileSize {
    Kilobyte = 1024,
    Megabyte = 1024 * 1024,
    Gigabyte = 1024 * 1024 * 1024
}

enum Permission {
    None = 0,
    Read = 1 << 0,
    Write = 1 << 1,
    Execute = 1 << 2,
    All = Read | Write | Execute
}

class FileSizeFormatter {
    format(bytes: number): string {
        if (bytes >= FileSize.Gigabyte) {
            return (bytes / FileSize.Gigabyte).toFixed(2) + " GB";
        } else if (bytes >= FileSize.Megabyte) {
            return (bytes / FileSize.Megabyte).toFixed(2) + " MB";
        } else if (bytes >= FileSize.Kilobyte) {
            return (bytes / FileSize.Kilobyte).toFixed(2) + " KB";
        }
        return bytes + " B";
    }

    parse(size: string): number {
        const value = parseFloat(size);
        if (size.includes("GB")) return value * FileSize.Gigabyte;
        if (size.includes("MB")) return value * FileSize.Megabyte;
        if (size.includes("KB")) return value * FileSize.Kilobyte;
        return value;
    }
}

class PermissionManager {
    private permissions: Permission;

    constructor() {
        this.permissions = Permission.None;
    }

    grant(permission: Permission): void {
        this.permissions = this.permissions | permission;
    }

    revoke(permission: Permission): void {
        this.permissions = this.permissions & ~permission;
    }

    has(permission: Permission): boolean {
        return (this.permissions & permission) === permission;
    }

    canRead(): boolean {
        return this.has(Permission.Read);
    }

    canWrite(): boolean {
        return this.has(Permission.Write);
    }

    canExecute(): boolean {
        return this.has(Permission.Execute);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("function FileSizeFormatter")
            && output.contains("function PermissionManager"),
        "Expected ES5 class constructors: {}",
        output
    );

    // Enums should be emitted
    assert!(
        output.contains("FileSize") && output.contains("Permission"),
        "Expected enum declarations: {}",
        output
    );

    // Methods preserved
    assert!(
        output.contains("format") && output.contains("parse"),
        "Expected FileSizeFormatter methods: {}",
        output
    );

    // Permission methods
    assert!(
        output.contains("grant") && output.contains("revoke") && output.contains("has"),
        "Expected PermissionManager methods: {}",
        output
    );
}

/// Test enum patterns: enum as class property type
#[test]
fn test_class_es5_enum_class_property() {
    let source = r#"
enum Status {
    Pending = "pending",
    Active = "active",
    Completed = "completed",
    Cancelled = "cancelled"
}

enum UserRole {
    Guest,
    User,
    Moderator,
    Admin
}

class Order {
    private id: string;
    private status: Status;
    private items: string[];

    constructor(id: string) {
        this.id = id;
        this.status = Status.Pending;
        this.items = [];
    }

    addItem(item: string): void {
        this.items.push(item);
    }

    activate(): void {
        if (this.status === Status.Pending) {
            this.status = Status.Active;
        }
    }

    complete(): void {
        if (this.status === Status.Active) {
            this.status = Status.Completed;
        }
    }

    cancel(): void {
        if (this.status !== Status.Completed) {
            this.status = Status.Cancelled;
        }
    }

    getStatus(): Status {
        return this.status;
    }
}

class User {
    private id: string;
    private name: string;
    private role: UserRole;

    constructor(id: string, name: string, role: UserRole = UserRole.User) {
        this.id = id;
        this.name = name;
        this.role = role;
    }

    promote(): void {
        if (this.role < UserRole.Admin) {
            this.role++;
        }
    }

    demote(): void {
        if (this.role > UserRole.Guest) {
            this.role--;
        }
    }

    isAdmin(): boolean {
        return this.role === UserRole.Admin;
    }

    hasModeratorAccess(): boolean {
        return this.role >= UserRole.Moderator;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("function Order") && output.contains("function User"),
        "Expected ES5 class constructors: {}",
        output
    );

    // Enums should be emitted
    assert!(
        output.contains("Status") && output.contains("UserRole"),
        "Expected enum declarations: {}",
        output
    );

    // Order methods
    assert!(
        output.contains("activate") && output.contains("complete") && output.contains("cancel"),
        "Expected Order methods: {}",
        output
    );

    // User methods
    assert!(
        output.contains("promote") && output.contains("demote") && output.contains("isAdmin"),
        "Expected User methods: {}",
        output
    );
}

/// Test enum patterns: combined enum patterns
#[test]
fn test_class_es5_enum_combined_patterns() {
    let source = r#"
const enum MessageType {
    Text = 0,
    Image = 1,
    Video = 2,
    Audio = 3
}

enum DeliveryStatus {
    Sent = "sent",
    Delivered = "delivered",
    Read = "read",
    Failed = "failed"
}

enum Priority {
    Low = 1,
    Normal = 2,
    High = 3,
    Urgent = 4
}

class Message {
    private type: MessageType;
    private content: string;
    private status: DeliveryStatus;
    private priority: Priority;

    constructor(type: MessageType, content: string) {
        this.type = type;
        this.content = content;
        this.status = DeliveryStatus.Sent;
        this.priority = Priority.Normal;
    }

    getType(): number {
        return this.type;
    }

    isMedia(): boolean {
        return this.type === MessageType.Image ||
               this.type === MessageType.Video ||
               this.type === MessageType.Audio;
    }

    markDelivered(): void {
        this.status = DeliveryStatus.Delivered;
    }

    markRead(): void {
        this.status = DeliveryStatus.Read;
    }

    markFailed(): void {
        this.status = DeliveryStatus.Failed;
    }

    setPriority(priority: Priority): void {
        this.priority = priority;
    }

    isHighPriority(): boolean {
        return this.priority >= Priority.High;
    }
}

class MessageQueue {
    private messages: Message[] = [];

    add(message: Message): void {
        this.messages.push(message);
    }

    getByStatus(status: DeliveryStatus): Message[] {
        return this.messages.filter(m => {
            return true;
        });
    }

    getHighPriority(): Message[] {
        return this.messages.filter(m => m.isHighPriority());
    }

    countByType(type: MessageType): number {
        return this.messages.filter(m => m.getType() === type).length;
    }

    clear(): void {
        this.messages = [];
    }
}

class NotificationManager {
    private queue: MessageQueue;

    constructor() {
        this.queue = new MessageQueue();
    }

    sendText(content: string, priority: Priority = Priority.Normal): void {
        const message = new Message(MessageType.Text, content);
        message.setPriority(priority);
        this.queue.add(message);
    }

    sendImage(url: string): void {
        this.queue.add(new Message(MessageType.Image, url));
    }

    sendVideo(url: string): void {
        this.queue.add(new Message(MessageType.Video, url));
    }

    getQueue(): MessageQueue {
        return this.queue;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // All classes should be converted
    assert!(
        output.contains("function Message")
            && output.contains("function MessageQueue")
            && output.contains("function NotificationManager"),
        "Expected ES5 class constructors: {}",
        output
    );

    // Enums should be present
    assert!(
        output.contains("DeliveryStatus") && output.contains("Priority"),
        "Expected enum declarations: {}",
        output
    );

    // Message methods
    assert!(
        output.contains("isMedia")
            && output.contains("markDelivered")
            && output.contains("markRead"),
        "Expected Message methods: {}",
        output
    );

    // MessageQueue methods
    assert!(
        output.contains("getByStatus")
            && output.contains("getHighPriority")
            && output.contains("countByType"),
        "Expected MessageQueue methods: {}",
        output
    );

    // NotificationManager methods
    assert!(
        output.contains("sendText") && output.contains("sendImage") && output.contains("sendVideo"),
        "Expected NotificationManager methods: {}",
        output
    );
}

// ============================================================================
// NAMESPACE PATTERN TESTS
// ============================================================================

/// Test namespace merged with class (declaration merging)
#[test]
fn test_class_es5_namespace_merged() {
    let source = r#"
class Validator {
    private rules: string[] = [];

    addRule(rule: string): void {
        this.rules.push(rule);
    }

    validate(value: string): boolean {
        return this.rules.every(rule => value.includes(rule));
    }
}

namespace Validator {
    export const VERSION = "1.0.0";
    export function isEmail(value: string): boolean {
        return value.includes("@");
    }
    export function isUrl(value: string): boolean {
        return value.startsWith("http");
    }
}

class FormValidator {
    private validator: Validator;

    constructor() {
        this.validator = new Validator();
    }

    checkEmail(email: string): boolean {
        return Validator.isEmail(email);
    }

    getVersion(): string {
        return Validator.VERSION;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be ES5 constructor
    assert!(
        output.contains("function Validator"),
        "Expected ES5 Validator class: {}",
        output
    );

    // FormValidator should be ES5 constructor
    assert!(
        output.contains("function FormValidator"),
        "Expected ES5 FormValidator class: {}",
        output
    );

    // Namespace functions should be emitted
    assert!(
        output.contains("isEmail") && output.contains("isUrl"),
        "Expected namespace functions: {}",
        output
    );
}

/// Test exported namespace with classes inside
#[test]
fn test_class_es5_namespace_exported() {
    let source = r#"
export namespace Geometry {
    export class Point {
        constructor(public x: number, public y: number) {}

        distanceTo(other: Point): number {
            const dx = this.x - other.x;
            const dy = this.y - other.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
    }

    export class Rectangle {
        constructor(
            public topLeft: Point,
            public width: number,
            public height: number
        ) {}

        area(): number {
            return this.width * this.height;
        }

        contains(point: Point): boolean {
            return point.x >= this.topLeft.x &&
                   point.x <= this.topLeft.x + this.width &&
                   point.y >= this.topLeft.y &&
                   point.y <= this.topLeft.y + this.height;
        }
    }

    export function createPoint(x: number, y: number): Point {
        return new Point(x, y);
    }
}

class Canvas {
    private shapes: Geometry.Rectangle[] = [];

    addRectangle(rect: Geometry.Rectangle): void {
        this.shapes.push(rect);
    }

    getTotalArea(): number {
        return this.shapes.reduce((sum, rect) => sum + rect.area(), 0);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Geometry namespace should exist
    assert!(
        output.contains("Geometry"),
        "Expected Geometry namespace: {}",
        output
    );

    // Canvas class should be ES5 constructor
    assert!(
        output.contains("function Canvas"),
        "Expected ES5 Canvas class: {}",
        output
    );

    // Methods should be on prototype
    assert!(
        output.contains("addRectangle") && output.contains("getTotalArea"),
        "Expected Canvas methods: {}",
        output
    );
}

/// Test nested namespaces
#[test]
fn test_class_es5_namespace_nested() {
    let source = r#"
namespace Company {
    export namespace Departments {
        export namespace Engineering {
            export class Developer {
                private name: string;
                private level: number;

                constructor(name: string, level: number) {
                    this.name = name;
                    this.level = level;
                }

                getName(): string {
                    return this.name;
                }

                getLevel(): number {
                    return this.level;
                }

                promote(): void {
                    this.level++;
                }
            }

            export class Team {
                private members: Developer[] = [];

                addMember(dev: Developer): void {
                    this.members.push(dev);
                }

                getSize(): number {
                    return this.members.length;
                }
            }
        }

        export namespace HR {
            export class Employee {
                constructor(public id: string, public department: string) {}

                getInfo(): string {
                    return this.id + " - " + this.department;
                }
            }
        }
    }
}

class HRManager {
    private employees: Company.Departments.HR.Employee[] = [];

    hire(id: string, dept: string): void {
        this.employees.push(new Company.Departments.HR.Employee(id, dept));
    }

    getCount(): number {
        return this.employees.length;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Nested namespace structure
    assert!(
        output.contains("Company"),
        "Expected Company namespace: {}",
        output
    );

    // HRManager class should be ES5 constructor
    assert!(
        output.contains("function HRManager"),
        "Expected ES5 HRManager class: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("hire") && output.contains("getCount"),
        "Expected HRManager methods: {}",
        output
    );
}

/// Test namespace with repository pattern (interface and classes)
#[test]
fn test_class_es5_namespace_repository_pattern() {
    let source = r#"
namespace DataAccess {
    export interface Repository<T> {
        find(id: string): T | null;
        save(item: T): void;
        delete(id: string): boolean;
    }

    export class InMemoryRepository<T extends { id: string }> implements Repository<T> {
        private items: Map<string, T> = new Map();

        find(id: string): T | null {
            return this.items.get(id) || null;
        }

        save(item: T): void {
            this.items.set(item.id, item);
        }

        delete(id: string): boolean {
            return this.items.delete(id);
        }

        getAll(): T[] {
            return Array.from(this.items.values());
        }
    }

    export class CachedRepository<T extends { id: string }> implements Repository<T> {
        private cache: Map<string, T> = new Map();
        private inner: Repository<T>;

        constructor(inner: Repository<T>) {
            this.inner = inner;
        }

        find(id: string): T | null {
            if (this.cache.has(id)) {
                return this.cache.get(id)!;
            }
            const item = this.inner.find(id);
            if (item) {
                this.cache.set(id, item);
            }
            return item;
        }

        save(item: T): void {
            this.cache.set(item.id, item);
            this.inner.save(item);
        }

        delete(id: string): boolean {
            this.cache.delete(id);
            return this.inner.delete(id);
        }

        clearCache(): void {
            this.cache.clear();
        }
    }
}

class UserService {
    private repo: DataAccess.Repository<{ id: string; name: string }>;

    constructor() {
        this.repo = new DataAccess.InMemoryRepository();
    }

    getUser(id: string): { id: string; name: string } | null {
        return this.repo.find(id);
    }

    createUser(id: string, name: string): void {
        this.repo.save({ id, name });
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // DataAccess namespace should exist
    assert!(
        output.contains("DataAccess"),
        "Expected DataAccess namespace: {}",
        output
    );

    // UserService class should be ES5 constructor
    assert!(
        output.contains("function UserService"),
        "Expected ES5 UserService class: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getUser") && output.contains("createUser"),
        "Expected UserService methods: {}",
        output
    );
}

/// Test namespace with constants and utility functions
#[test]
fn test_class_es5_namespace_utilities() {
    let source = r#"
namespace StringUtils {
    export const EMPTY = "";
    export const SPACE = " ";

    export function isEmpty(str: string): boolean {
        return str.length === 0;
    }

    export function trim(str: string): string {
        return str.trim();
    }

    export function capitalize(str: string): string {
        if (isEmpty(str)) return str;
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    export function split(str: string, delimiter: string): string[] {
        return str.split(delimiter);
    }

    export class StringBuilder {
        private parts: string[] = [];

        append(str: string): StringBuilder {
            this.parts.push(str);
            return this;
        }

        appendLine(str: string): StringBuilder {
            this.parts.push(str + "\n");
            return this;
        }

        toString(): string {
            return this.parts.join(EMPTY);
        }

        clear(): void {
            this.parts = [];
        }
    }
}

class TextProcessor {
    private builder: StringUtils.StringBuilder;

    constructor() {
        this.builder = new StringUtils.StringBuilder();
    }

    process(text: string): string {
        const words = StringUtils.split(text, StringUtils.SPACE);
        for (const word of words) {
            const capitalized = StringUtils.capitalize(word);
            this.builder.append(capitalized).append(StringUtils.SPACE);
        }
        return StringUtils.trim(this.builder.toString());
    }

    reset(): void {
        this.builder.clear();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // StringUtils namespace should exist
    assert!(
        output.contains("StringUtils"),
        "Expected StringUtils namespace: {}",
        output
    );

    // TextProcessor class should be ES5 constructor
    assert!(
        output.contains("function TextProcessor"),
        "Expected ES5 TextProcessor class: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("process") && output.contains("reset"),
        "Expected TextProcessor methods: {}",
        output
    );
}

/// Test combined namespace patterns with multiple features
#[test]
fn test_class_es5_namespace_combined() {
    let source = r#"
namespace App {
    export const VERSION = "2.0.0";

    export namespace Models {
        export interface Entity {
            id: string;
            createdAt: Date;
        }

        export class User implements Entity {
            id: string;
            createdAt: Date;
            name: string;

            constructor(id: string, name: string) {
                this.id = id;
                this.name = name;
                this.createdAt = new Date();
            }

            toString(): string {
                return this.name + " (" + this.id + ")";
            }
        }

        export class Product implements Entity {
            id: string;
            createdAt: Date;
            title: string;
            price: number;

            constructor(id: string, title: string, price: number) {
                this.id = id;
                this.title = title;
                this.price = price;
                this.createdAt = new Date();
            }

            getFormattedPrice(): string {
                return "$" + this.price.toFixed(2);
            }
        }
    }

    export namespace Services {
        export class UserService {
            private users: Models.User[] = [];

            add(user: Models.User): void {
                this.users.push(user);
            }

            findById(id: string): Models.User | undefined {
                return this.users.find(u => u.id === id);
            }

            getAll(): Models.User[] {
                return [...this.users];
            }
        }

        export class ProductService {
            private products: Models.Product[] = [];

            add(product: Models.Product): void {
                this.products.push(product);
            }

            findByPriceRange(min: number, max: number): Models.Product[] {
                return this.products.filter(p => p.price >= min && p.price <= max);
            }

            getTotalValue(): number {
                return this.products.reduce((sum, p) => sum + p.price, 0);
            }
        }
    }

    export namespace Utils {
        export function generateId(): string {
            return Math.random().toString(36).substr(2, 9);
        }

        export function formatDate(date: Date): string {
            return date.toISOString();
        }
    }
}

class Application {
    private userService: App.Services.UserService;
    private productService: App.Services.ProductService;

    constructor() {
        this.userService = new App.Services.UserService();
        this.productService = new App.Services.ProductService();
    }

    createUser(name: string): App.Models.User {
        const user = new App.Models.User(App.Utils.generateId(), name);
        this.userService.add(user);
        return user;
    }

    createProduct(title: string, price: number): App.Models.Product {
        const product = new App.Models.Product(App.Utils.generateId(), title, price);
        this.productService.add(product);
        return product;
    }

    getVersion(): string {
        return App.VERSION;
    }

    getUserCount(): number {
        return this.userService.getAll().length;
    }

    getProductValue(): number {
        return this.productService.getTotalValue();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // App namespace should exist
    assert!(output.contains("App"), "Expected App namespace: {}", output);

    // Application class should be ES5 constructor
    assert!(
        output.contains("function Application"),
        "Expected ES5 Application class: {}",
        output
    );

    // All Application methods should exist
    assert!(
        output.contains("createUser")
            && output.contains("createProduct")
            && output.contains("getVersion")
            && output.contains("getUserCount")
            && output.contains("getProductValue"),
        "Expected Application methods: {}",
        output
    );
}

// =============================================================================
// TEMPLATE LITERAL TYPE PATTERN TESTS - Uppercase, Lowercase, Capitalize
// =============================================================================

#[test]
fn test_class_es5_template_literal_type_uppercase() {
    let source = r#"
// Uppercase template literal type pattern
type EventName = "click" | "focus" | "blur";
type UpperEventName = Uppercase<EventName>;

type HttpMethod = "get" | "post" | "put" | "delete";
type UpperHttpMethod = Uppercase<HttpMethod>;

class EventRegistry<T extends string> {
    private events: Map<T, Function[]> = new Map();

    register(event: T, handler: Function): void {
        if (!this.events.has(event)) {
            this.events.set(event, []);
        }
        this.events.get(event)!.push(handler);
    }

    unregister(event: T, handler: Function): void {
        const handlers = this.events.get(event);
        if (handlers) {
            const index = handlers.indexOf(handler);
            if (index >= 0) {
                handlers.splice(index, 1);
            }
        }
    }

    trigger(event: T, data?: unknown): void {
        const handlers = this.events.get(event);
        if (handlers) {
            handlers.forEach(h => h(data));
        }
    }

    getEventNames(): T[] {
        return Array.from(this.events.keys());
    }
}

class UppercaseEventRegistry extends EventRegistry<UpperEventName> {
    registerClick(handler: Function): void {
        this.register("CLICK", handler);
    }

    registerFocus(handler: Function): void {
        this.register("FOCUS", handler);
    }

    registerBlur(handler: Function): void {
        this.register("BLUR", handler);
    }
}

class HttpClient<M extends string> {
    protected baseUrl: string;

    constructor(baseUrl: string) {
        this.baseUrl = baseUrl;
    }

    request(method: M, path: string): Promise<Response> {
        return fetch(this.baseUrl + path, { method: method as string });
    }

    getBaseUrl(): string {
        return this.baseUrl;
    }
}

class UppercaseHttpClient extends HttpClient<UpperHttpMethod> {
    get(path: string): Promise<Response> {
        return this.request("GET", path);
    }

    post(path: string): Promise<Response> {
        return this.request("POST", path);
    }

    put(path: string): Promise<Response> {
        return this.request("PUT", path);
    }

    delete(path: string): Promise<Response> {
        return this.request("DELETE", path);
    }
}

type StatusLevel = "info" | "warn" | "error";
type UpperStatusLevel = Uppercase<StatusLevel>;

class Logger<L extends string> {
    private level: L;

    constructor(level: L) {
        this.level = level;
    }

    log(message: string): void {
        console.log("[" + this.level + "]", message);
    }

    getLevel(): L {
        return this.level;
    }
}

class UppercaseLogger extends Logger<UpperStatusLevel> {
    info(message: string): void {
        console.log("[INFO]", message);
    }

    warn(message: string): void {
        console.log("[WARN]", message);
    }

    error(message: string): void {
        console.log("[ERROR]", message);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("EventRegistry") && output.contains("UppercaseEventRegistry"),
        "Expected Uppercase template literal type classes: {}",
        output
    );

    // EventRegistry methods
    assert!(
        output.contains("register") && output.contains("unregister") && output.contains("trigger"),
        "Expected EventRegistry methods: {}",
        output
    );

    // UppercaseEventRegistry methods
    assert!(
        output.contains("registerClick")
            && output.contains("registerFocus")
            && output.contains("registerBlur"),
        "Expected UppercaseEventRegistry methods: {}",
        output
    );

    // HttpClient classes
    assert!(
        output.contains("HttpClient") && output.contains("UppercaseHttpClient"),
        "Expected HttpClient classes: {}",
        output
    );

    // Logger classes
    assert!(
        output.contains("Logger") && output.contains("UppercaseLogger"),
        "Expected Logger classes: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type EventName")
            && !output.contains("type UpperEventName")
            && !output.contains("type HttpMethod"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_template_literal_type_lowercase() {
    let source = r#"
// Lowercase template literal type pattern
type Command = "START" | "STOP" | "PAUSE" | "RESUME";
type LowerCommand = Lowercase<Command>;

type Priority = "HIGH" | "MEDIUM" | "LOW";
type LowerPriority = Lowercase<Priority>;

class CommandProcessor<C extends string> {
    private commands: Map<C, () => void> = new Map();

    addCommand(name: C, action: () => void): void {
        this.commands.set(name, action);
    }

    execute(name: C): void {
        const action = this.commands.get(name);
        if (action) {
            action();
        }
    }

    hasCommand(name: C): boolean {
        return this.commands.has(name);
    }

    getCommands(): C[] {
        return Array.from(this.commands.keys());
    }
}

class LowercaseCommandProcessor extends CommandProcessor<LowerCommand> {
    start(): void {
        this.execute("start");
    }

    stop(): void {
        this.execute("stop");
    }

    pause(): void {
        this.execute("pause");
    }

    resume(): void {
        this.execute("resume");
    }
}

class TaskQueue<P extends string> {
    private tasks: Array<{ priority: P; task: () => void }> = [];

    add(priority: P, task: () => void): void {
        this.tasks.push({ priority, task });
    }

    process(): void {
        this.tasks.forEach(t => t.task());
        this.tasks = [];
    }

    getCount(): number {
        return this.tasks.length;
    }

    clear(): void {
        this.tasks = [];
    }
}

class LowercasePriorityQueue extends TaskQueue<LowerPriority> {
    addHighPriority(task: () => void): void {
        this.add("high", task);
    }

    addMediumPriority(task: () => void): void {
        this.add("medium", task);
    }

    addLowPriority(task: () => void): void {
        this.add("low", task);
    }
}

type DatabaseAction = "SELECT" | "INSERT" | "UPDATE" | "DELETE";
type LowerDatabaseAction = Lowercase<DatabaseAction>;

class QueryBuilder<A extends string> {
    protected action: A;
    protected table: string = "";

    constructor(action: A) {
        this.action = action;
    }

    from(table: string): this {
        this.table = table;
        return this;
    }

    build(): string {
        return this.action + " FROM " + this.table;
    }

    getAction(): A {
        return this.action;
    }
}

class LowercaseQueryBuilder extends QueryBuilder<LowerDatabaseAction> {
    select(table: string): this {
        this.table = table;
        return this;
    }

    insert(table: string): this {
        this.table = table;
        return this;
    }

    update(table: string): this {
        this.table = table;
        return this;
    }

    deleteFrom(table: string): this {
        this.table = table;
        return this;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("CommandProcessor") && output.contains("LowercaseCommandProcessor"),
        "Expected Lowercase template literal type classes: {}",
        output
    );

    // CommandProcessor methods
    assert!(
        output.contains("addCommand")
            && output.contains("execute")
            && output.contains("hasCommand"),
        "Expected CommandProcessor methods: {}",
        output
    );

    // LowercaseCommandProcessor methods
    assert!(
        output.contains("start")
            && output.contains("stop")
            && output.contains("pause")
            && output.contains("resume"),
        "Expected LowercaseCommandProcessor methods: {}",
        output
    );

    // TaskQueue classes
    assert!(
        output.contains("TaskQueue") && output.contains("LowercasePriorityQueue"),
        "Expected TaskQueue classes: {}",
        output
    );

    // LowercasePriorityQueue methods
    assert!(
        output.contains("addHighPriority")
            && output.contains("addMediumPriority")
            && output.contains("addLowPriority"),
        "Expected LowercasePriorityQueue methods: {}",
        output
    );

    // QueryBuilder classes
    assert!(
        output.contains("QueryBuilder") && output.contains("LowercaseQueryBuilder"),
        "Expected QueryBuilder classes: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type Command")
            && !output.contains("type LowerCommand")
            && !output.contains("type Priority"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_template_literal_type_capitalize() {
    let source = r#"
// Capitalize template literal type pattern
type FieldName = "name" | "email" | "address" | "phone";
type CapitalizedField = Capitalize<FieldName>;

type ComponentType = "button" | "input" | "select" | "textarea";
type CapitalizedComponent = Capitalize<ComponentType>;

class FormFieldGenerator<F extends string> {
    private fields: Map<F, HTMLElement> = new Map();

    createField(name: F): HTMLElement {
        const input = document.createElement("input");
        input.name = name;
        this.fields.set(name, input);
        return input;
    }

    getField(name: F): HTMLElement | undefined {
        return this.fields.get(name);
    }

    hasField(name: F): boolean {
        return this.fields.has(name);
    }

    removeField(name: F): void {
        this.fields.delete(name);
    }

    getAllFieldNames(): F[] {
        return Array.from(this.fields.keys());
    }
}

class CapitalizedFieldGenerator extends FormFieldGenerator<CapitalizedField> {
    createNameField(): HTMLElement {
        return this.createField("Name");
    }

    createEmailField(): HTMLElement {
        return this.createField("Email");
    }

    createAddressField(): HTMLElement {
        return this.createField("Address");
    }

    createPhoneField(): HTMLElement {
        return this.createField("Phone");
    }
}

class ComponentFactory<C extends string> {
    protected registry: Map<C, () => HTMLElement> = new Map();

    register(type: C, factory: () => HTMLElement): void {
        this.registry.set(type, factory);
    }

    create(type: C): HTMLElement | null {
        const factory = this.registry.get(type);
        return factory ? factory() : null;
    }

    isRegistered(type: C): boolean {
        return this.registry.has(type);
    }

    getTypes(): C[] {
        return Array.from(this.registry.keys());
    }
}

class CapitalizedComponentFactory extends ComponentFactory<CapitalizedComponent> {
    createButton(): HTMLElement | null {
        return this.create("Button");
    }

    createInput(): HTMLElement | null {
        return this.create("Input");
    }

    createSelect(): HTMLElement | null {
        return this.create("Select");
    }

    createTextarea(): HTMLElement | null {
        return this.create("Textarea");
    }
}

type ApiEndpoint = "users" | "posts" | "comments" | "likes";
type CapitalizedEndpoint = Capitalize<ApiEndpoint>;

class ApiRouter<E extends string> {
    private baseUrl: string;
    private routes: Map<E, string> = new Map();

    constructor(baseUrl: string) {
        this.baseUrl = baseUrl;
    }

    addRoute(endpoint: E, path: string): void {
        this.routes.set(endpoint, path);
    }

    getUrl(endpoint: E): string {
        const path = this.routes.get(endpoint) || endpoint;
        return this.baseUrl + "/" + path;
    }

    hasRoute(endpoint: E): boolean {
        return this.routes.has(endpoint);
    }

    getBaseUrl(): string {
        return this.baseUrl;
    }
}

class CapitalizedApiRouter extends ApiRouter<CapitalizedEndpoint> {
    getUsersUrl(): string {
        return this.getUrl("Users");
    }

    getPostsUrl(): string {
        return this.getUrl("Posts");
    }

    getCommentsUrl(): string {
        return this.getUrl("Comments");
    }

    getLikesUrl(): string {
        return this.getUrl("Likes");
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("FormFieldGenerator") && output.contains("CapitalizedFieldGenerator"),
        "Expected Capitalize template literal type classes: {}",
        output
    );

    // FormFieldGenerator methods
    assert!(
        output.contains("createField")
            && output.contains("getField")
            && output.contains("hasField"),
        "Expected FormFieldGenerator methods: {}",
        output
    );

    // CapitalizedFieldGenerator methods
    assert!(
        output.contains("createNameField")
            && output.contains("createEmailField")
            && output.contains("createAddressField"),
        "Expected CapitalizedFieldGenerator methods: {}",
        output
    );

    // ComponentFactory classes
    assert!(
        output.contains("ComponentFactory") && output.contains("CapitalizedComponentFactory"),
        "Expected ComponentFactory classes: {}",
        output
    );

    // CapitalizedComponentFactory methods
    assert!(
        output.contains("createButton")
            && output.contains("createInput")
            && output.contains("createSelect"),
        "Expected CapitalizedComponentFactory methods: {}",
        output
    );

    // ApiRouter classes
    assert!(
        output.contains("ApiRouter") && output.contains("CapitalizedApiRouter"),
        "Expected ApiRouter classes: {}",
        output
    );

    // CapitalizedApiRouter methods
    assert!(
        output.contains("getUsersUrl")
            && output.contains("getPostsUrl")
            && output.contains("getCommentsUrl"),
        "Expected CapitalizedApiRouter methods: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type FieldName")
            && !output.contains("type CapitalizedField")
            && !output.contains("type ComponentType"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

// =============================================================================
// INFER KEYWORD PATTERN TESTS - array element, function return, promise unwrap
// =============================================================================

#[test]
fn test_class_es5_infer_keyword_array_element() {
    let source = r#"
// Infer array element type pattern
type ArrayElement<T> = T extends (infer U)[] ? U : never;
type FirstElement<T extends unknown[]> = T extends [infer F, ...unknown[]] ? F : never;
type LastElement<T extends unknown[]> = T extends [...unknown[], infer L] ? L : never;

class ArrayProcessor<T extends unknown[]> {
    private items: T;

    constructor(items: T) {
        this.items = items;
    }

    getFirst(): FirstElement<T> {
        return this.items[0] as FirstElement<T>;
    }

    getLast(): LastElement<T> {
        return this.items[this.items.length - 1] as LastElement<T>;
    }

    getAll(): T {
        return this.items;
    }

    getLength(): number {
        return this.items.length;
    }
}

class NumberArrayProcessor extends ArrayProcessor<number[]> {
    sum(): number {
        return this.getAll().reduce((a, b) => a + b, 0);
    }

    average(): number {
        const all = this.getAll();
        return all.length > 0 ? this.sum() / all.length : 0;
    }

    max(): number {
        return Math.max(...this.getAll());
    }

    min(): number {
        return Math.min(...this.getAll());
    }
}

class StringArrayProcessor extends ArrayProcessor<string[]> {
    join(separator: string): string {
        return this.getAll().join(separator);
    }

    toUpperCase(): string[] {
        return this.getAll().map(s => s.toUpperCase());
    }

    toLowerCase(): string[] {
        return this.getAll().map(s => s.toLowerCase());
    }

    filter(predicate: (s: string) => boolean): string[] {
        return this.getAll().filter(predicate);
    }
}

type Flatten<T> = T extends (infer U)[] ? Flatten<U> : T;

class DeepArrayFlattener<T> {
    private data: T;

    constructor(data: T) {
        this.data = data;
    }

    getData(): T {
        return this.data;
    }

    isArray(): boolean {
        return Array.isArray(this.data);
    }

    flatten(): Flatten<T>[] {
        const result: Flatten<T>[] = [];
        const flattenHelper = (arr: unknown): void => {
            if (Array.isArray(arr)) {
                arr.forEach(item => flattenHelper(item));
            } else {
                result.push(arr as Flatten<T>);
            }
        };
        flattenHelper(this.data);
        return result;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ArrayProcessor")
            && output.contains("NumberArrayProcessor")
            && output.contains("StringArrayProcessor"),
        "Expected infer array element type classes: {}",
        output
    );

    // ArrayProcessor methods
    assert!(
        output.contains("getFirst") && output.contains("getLast") && output.contains("getAll"),
        "Expected ArrayProcessor methods: {}",
        output
    );

    // NumberArrayProcessor methods
    assert!(
        output.contains("sum")
            && output.contains("average")
            && output.contains("max")
            && output.contains("min"),
        "Expected NumberArrayProcessor methods: {}",
        output
    );

    // StringArrayProcessor methods
    assert!(
        output.contains("join") && output.contains("toUpperCase") && output.contains("toLowerCase"),
        "Expected StringArrayProcessor methods: {}",
        output
    );

    // DeepArrayFlattener class
    assert!(
        output.contains("DeepArrayFlattener")
            && output.contains("flatten")
            && output.contains("isArray"),
        "Expected DeepArrayFlattener class: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type ArrayElement")
            && !output.contains("type FirstElement")
            && !output.contains("type Flatten"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_infer_keyword_function_return() {
    let source = r#"
// Infer function return type pattern
type ReturnType<T> = T extends (...args: unknown[]) => infer R ? R : never;
type Parameters<T> = T extends (...args: infer P) => unknown ? P : never;
type ConstructorParameters<T> = T extends new (...args: infer P) => unknown ? P : never;

class FunctionWrapper<F extends (...args: unknown[]) => unknown> {
    private fn: F;

    constructor(fn: F) {
        this.fn = fn;
    }

    call(...args: Parameters<F>): ReturnType<F> {
        return this.fn(...args) as ReturnType<F>;
    }

    bind<T>(thisArg: T): FunctionWrapper<F> {
        return new FunctionWrapper(this.fn.bind(thisArg) as F);
    }

    getFunction(): F {
        return this.fn;
    }
}

class MemoizedFunction<F extends (...args: unknown[]) => unknown> {
    private fn: F;
    private cache: Map<string, ReturnType<F>> = new Map();

    constructor(fn: F) {
        this.fn = fn;
    }

    call(...args: Parameters<F>): ReturnType<F> {
        const key = JSON.stringify(args);
        if (this.cache.has(key)) {
            return this.cache.get(key)!;
        }
        const result = this.fn(...args) as ReturnType<F>;
        this.cache.set(key, result);
        return result;
    }

    clearCache(): void {
        this.cache.clear();
    }

    getCacheSize(): number {
        return this.cache.size;
    }

    hasCache(args: Parameters<F>): boolean {
        return this.cache.has(JSON.stringify(args));
    }
}

class DebouncedFunction<F extends (...args: unknown[]) => unknown> {
    private fn: F;
    private delay: number;
    private timeoutId: ReturnType<typeof setTimeout> | null = null;

    constructor(fn: F, delay: number) {
        this.fn = fn;
        this.delay = delay;
    }

    call(...args: Parameters<F>): void {
        if (this.timeoutId !== null) {
            clearTimeout(this.timeoutId);
        }
        this.timeoutId = setTimeout(() => {
            this.fn(...args);
            this.timeoutId = null;
        }, this.delay);
    }

    cancel(): void {
        if (this.timeoutId !== null) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
    }

    isPending(): boolean {
        return this.timeoutId !== null;
    }

    getDelay(): number {
        return this.delay;
    }
}

class ThrottledFunction<F extends (...args: unknown[]) => unknown> {
    private fn: F;
    private limit: number;
    private lastCall: number = 0;

    constructor(fn: F, limit: number) {
        this.fn = fn;
        this.limit = limit;
    }

    call(...args: Parameters<F>): ReturnType<F> | undefined {
        const now = Date.now();
        if (now - this.lastCall >= this.limit) {
            this.lastCall = now;
            return this.fn(...args) as ReturnType<F>;
        }
        return undefined;
    }

    reset(): void {
        this.lastCall = 0;
    }

    getLimit(): number {
        return this.limit;
    }

    getTimeSinceLastCall(): number {
        return Date.now() - this.lastCall;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("FunctionWrapper") && output.contains("MemoizedFunction"),
        "Expected infer function return type classes: {}",
        output
    );

    // FunctionWrapper methods
    assert!(
        output.contains("call") && output.contains("bind") && output.contains("getFunction"),
        "Expected FunctionWrapper methods: {}",
        output
    );

    // MemoizedFunction methods
    assert!(
        output.contains("clearCache")
            && output.contains("getCacheSize")
            && output.contains("hasCache"),
        "Expected MemoizedFunction methods: {}",
        output
    );

    // DebouncedFunction class
    assert!(
        output.contains("DebouncedFunction")
            && output.contains("cancel")
            && output.contains("isPending"),
        "Expected DebouncedFunction class: {}",
        output
    );

    // ThrottledFunction class
    assert!(
        output.contains("ThrottledFunction")
            && output.contains("reset")
            && output.contains("getLimit"),
        "Expected ThrottledFunction class: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type ReturnType")
            && !output.contains("type Parameters")
            && !output.contains("type ConstructorParameters"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_infer_keyword_promise_unwrap() {
    let source = r#"
// Infer promise unwrap type pattern
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;
type PromiseType<T> = T extends Promise<infer U> ? U : never;
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;

class AsyncWrapper<T> {
    private promise: Promise<T>;

    constructor(promise: Promise<T>) {
        this.promise = promise;
    }

    then<U>(callback: (value: T) => U | Promise<U>): AsyncWrapper<U> {
        return new AsyncWrapper(this.promise.then(callback));
    }

    catch<U>(callback: (error: unknown) => U | Promise<U>): AsyncWrapper<T | U> {
        return new AsyncWrapper(this.promise.catch(callback));
    }

    finally(callback: () => void): AsyncWrapper<T> {
        return new AsyncWrapper(this.promise.finally(callback));
    }

    getPromise(): Promise<T> {
        return this.promise;
    }
}

class AsyncResult<T> {
    private valuePromise: Promise<T>;

    constructor(valuePromise: Promise<T>) {
        this.valuePromise = valuePromise;
    }

    async getValue(): Promise<T> {
        return this.valuePromise;
    }

    async map<U>(fn: (value: T) => U): Promise<U> {
        const value = await this.valuePromise;
        return fn(value);
    }

    async flatMap<U>(fn: (value: T) => Promise<U>): Promise<U> {
        const value = await this.valuePromise;
        return fn(value);
    }

    async filter(predicate: (value: T) => boolean): Promise<T | null> {
        const value = await this.valuePromise;
        return predicate(value) ? value : null;
    }
}

class PromiseQueue<T> {
    private queue: Promise<T>[] = [];

    add(promise: Promise<T>): void {
        this.queue.push(promise);
    }

    async all(): Promise<T[]> {
        return Promise.all(this.queue);
    }

    async race(): Promise<T> {
        return Promise.race(this.queue);
    }

    async allSettled(): Promise<PromiseSettledResult<T>[]> {
        return Promise.allSettled(this.queue);
    }

    clear(): void {
        this.queue = [];
    }

    getCount(): number {
        return this.queue.length;
    }
}

class RetryablePromise<T> {
    private factory: () => Promise<T>;
    private maxRetries: number;
    private delay: number;

    constructor(factory: () => Promise<T>, maxRetries: number, delay: number) {
        this.factory = factory;
        this.maxRetries = maxRetries;
        this.delay = delay;
    }

    async execute(): Promise<T> {
        let lastError: unknown;
        for (let i = 0; i <= this.maxRetries; i++) {
            try {
                return await this.factory();
            } catch (error) {
                lastError = error;
                if (i < this.maxRetries) {
                    await this.sleep(this.delay);
                }
            }
        }
        throw lastError;
    }

    private sleep(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    getMaxRetries(): number {
        return this.maxRetries;
    }

    getDelay(): number {
        return this.delay;
    }
}

class TimeoutPromise<T> {
    private promise: Promise<T>;
    private timeout: number;

    constructor(promise: Promise<T>, timeout: number) {
        this.promise = promise;
        this.timeout = timeout;
    }

    async execute(): Promise<T> {
        return Promise.race([
            this.promise,
            new Promise<never>((_, reject) =>
                setTimeout(() => reject(new Error("Timeout")), this.timeout)
            )
        ]);
    }

    getTimeout(): number {
        return this.timeout;
    }

    getPromise(): Promise<T> {
        return this.promise;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("AsyncWrapper")
            && output.contains("AsyncResult")
            && output.contains("PromiseQueue"),
        "Expected infer promise unwrap type classes: {}",
        output
    );

    // AsyncWrapper methods
    assert!(
        output.contains("then") && output.contains("catch") && output.contains("finally"),
        "Expected AsyncWrapper methods: {}",
        output
    );

    // AsyncResult methods
    assert!(
        output.contains("getValue") && output.contains("map") && output.contains("flatMap"),
        "Expected AsyncResult methods: {}",
        output
    );

    // PromiseQueue methods
    assert!(
        output.contains("all") && output.contains("race") && output.contains("allSettled"),
        "Expected PromiseQueue methods: {}",
        output
    );

    // RetryablePromise class
    assert!(
        output.contains("RetryablePromise")
            && output.contains("execute")
            && output.contains("getMaxRetries"),
        "Expected RetryablePromise class: {}",
        output
    );

    // TimeoutPromise class
    assert!(
        output.contains("TimeoutPromise") && output.contains("getTimeout"),
        "Expected TimeoutPromise class: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type Awaited")
            && !output.contains("type PromiseType")
            && !output.contains("type UnwrapPromise"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

// =============================================================================
// RECURSIVE TYPE PATTERN TESTS - tree, linked list, JSON
// =============================================================================

#[test]
fn test_class_es5_recursive_type_tree() {
    let source = r#"
// Recursive tree type pattern
interface TreeNode<T> {
    value: T;
    children: TreeNode<T>[];
}

type BinaryTreeNode<T> = {
    value: T;
    left: BinaryTreeNode<T> | null;
    right: BinaryTreeNode<T> | null;
};

class Tree<T> {
    private root: TreeNode<T> | null = null;

    constructor(rootValue?: T) {
        if (rootValue !== undefined) {
            this.root = { value: rootValue, children: [] };
        }
    }

    getRoot(): TreeNode<T> | null {
        return this.root;
    }

    setRoot(node: TreeNode<T>): void {
        this.root = node;
    }

    addChild(parent: TreeNode<T>, value: T): TreeNode<T> {
        const child: TreeNode<T> = { value, children: [] };
        parent.children.push(child);
        return child;
    }

    traverse(callback: (node: TreeNode<T>) => void): void {
        if (this.root) {
            this.traverseNode(this.root, callback);
        }
    }

    private traverseNode(node: TreeNode<T>, callback: (node: TreeNode<T>) => void): void {
        callback(node);
        node.children.forEach(child => this.traverseNode(child, callback));
    }

    getDepth(): number {
        if (!this.root) return 0;
        return this.calculateDepth(this.root);
    }

    private calculateDepth(node: TreeNode<T>): number {
        if (node.children.length === 0) return 1;
        return 1 + Math.max(...node.children.map(c => this.calculateDepth(c)));
    }
}

class BinaryTree<T> {
    private root: BinaryTreeNode<T> | null = null;

    constructor(rootValue?: T) {
        if (rootValue !== undefined) {
            this.root = { value: rootValue, left: null, right: null };
        }
    }

    getRoot(): BinaryTreeNode<T> | null {
        return this.root;
    }

    insert(value: T, compareFn: (a: T, b: T) => number): void {
        const newNode: BinaryTreeNode<T> = { value, left: null, right: null };
        if (!this.root) {
            this.root = newNode;
            return;
        }
        this.insertNode(this.root, newNode, compareFn);
    }

    private insertNode(node: BinaryTreeNode<T>, newNode: BinaryTreeNode<T>, compareFn: (a: T, b: T) => number): void {
        if (compareFn(newNode.value, node.value) < 0) {
            if (node.left === null) {
                node.left = newNode;
            } else {
                this.insertNode(node.left, newNode, compareFn);
            }
        } else {
            if (node.right === null) {
                node.right = newNode;
            } else {
                this.insertNode(node.right, newNode, compareFn);
            }
        }
    }

    inorderTraversal(callback: (value: T) => void): void {
        if (this.root) {
            this.inorder(this.root, callback);
        }
    }

    private inorder(node: BinaryTreeNode<T>, callback: (value: T) => void): void {
        if (node.left) this.inorder(node.left, callback);
        callback(node.value);
        if (node.right) this.inorder(node.right, callback);
    }
}

class FileSystemTree {
    private root: TreeNode<string>;

    constructor(rootName: string) {
        this.root = { value: rootName, children: [] };
    }

    getRoot(): TreeNode<string> {
        return this.root;
    }

    addFolder(parent: TreeNode<string>, name: string): TreeNode<string> {
        const folder: TreeNode<string> = { value: name, children: [] };
        parent.children.push(folder);
        return folder;
    }

    addFile(parent: TreeNode<string>, name: string): TreeNode<string> {
        const file: TreeNode<string> = { value: name, children: [] };
        parent.children.push(file);
        return file;
    }

    findNode(name: string): TreeNode<string> | null {
        return this.findInNode(this.root, name);
    }

    private findInNode(node: TreeNode<string>, name: string): TreeNode<string> | null {
        if (node.value === name) return node;
        for (const child of node.children) {
            const found = this.findInNode(child, name);
            if (found) return found;
        }
        return null;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Tree")
            && output.contains("BinaryTree")
            && output.contains("FileSystemTree"),
        "Expected recursive tree type classes: {}",
        output
    );

    // Tree methods
    assert!(
        output.contains("getRoot")
            && output.contains("setRoot")
            && output.contains("addChild")
            && output.contains("traverse"),
        "Expected Tree methods: {}",
        output
    );

    // BinaryTree methods
    assert!(
        output.contains("insert") && output.contains("inorderTraversal"),
        "Expected BinaryTree methods: {}",
        output
    );

    // FileSystemTree methods
    assert!(
        output.contains("addFolder") && output.contains("addFile") && output.contains("findNode"),
        "Expected FileSystemTree methods: {}",
        output
    );

    // Interface and type aliases should be stripped
    assert!(
        !output.contains("interface TreeNode") && !output.contains("type BinaryTreeNode"),
        "Expected interface and type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_recursive_type_linked_list() {
    let source = r#"
// Recursive linked list type pattern
interface ListNode<T> {
    value: T;
    next: ListNode<T> | null;
}

type DoublyLinkedNode<T> = {
    value: T;
    prev: DoublyLinkedNode<T> | null;
    next: DoublyLinkedNode<T> | null;
};

class LinkedList<T> {
    private head: ListNode<T> | null = null;
    private tail: ListNode<T> | null = null;
    private length: number = 0;

    getHead(): ListNode<T> | null {
        return this.head;
    }

    getTail(): ListNode<T> | null {
        return this.tail;
    }

    getLength(): number {
        return this.length;
    }

    append(value: T): void {
        const node: ListNode<T> = { value, next: null };
        if (!this.tail) {
            this.head = this.tail = node;
        } else {
            this.tail.next = node;
            this.tail = node;
        }
        this.length++;
    }

    prepend(value: T): void {
        const node: ListNode<T> = { value, next: this.head };
        this.head = node;
        if (!this.tail) {
            this.tail = node;
        }
        this.length++;
    }

    removeFirst(): T | null {
        if (!this.head) return null;
        const value = this.head.value;
        this.head = this.head.next;
        if (!this.head) {
            this.tail = null;
        }
        this.length--;
        return value;
    }

    find(predicate: (value: T) => boolean): T | null {
        let current = this.head;
        while (current) {
            if (predicate(current.value)) {
                return current.value;
            }
            current = current.next;
        }
        return null;
    }

    toArray(): T[] {
        const result: T[] = [];
        let current = this.head;
        while (current) {
            result.push(current.value);
            current = current.next;
        }
        return result;
    }
}

class DoublyLinkedList<T> {
    private head: DoublyLinkedNode<T> | null = null;
    private tail: DoublyLinkedNode<T> | null = null;
    private length: number = 0;

    getHead(): DoublyLinkedNode<T> | null {
        return this.head;
    }

    getTail(): DoublyLinkedNode<T> | null {
        return this.tail;
    }

    getLength(): number {
        return this.length;
    }

    append(value: T): void {
        const node: DoublyLinkedNode<T> = { value, prev: this.tail, next: null };
        if (!this.tail) {
            this.head = this.tail = node;
        } else {
            this.tail.next = node;
            this.tail = node;
        }
        this.length++;
    }

    prepend(value: T): void {
        const node: DoublyLinkedNode<T> = { value, prev: null, next: this.head };
        if (!this.head) {
            this.head = this.tail = node;
        } else {
            this.head.prev = node;
            this.head = node;
        }
        this.length++;
    }

    removeLast(): T | null {
        if (!this.tail) return null;
        const value = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
            this.tail.next = null;
        } else {
            this.head = null;
        }
        this.length--;
        return value;
    }

    reverse(): void {
        let current = this.head;
        let temp: DoublyLinkedNode<T> | null = null;
        while (current) {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }
        temp = this.head;
        this.head = this.tail;
        this.tail = temp;
    }
}

class CircularLinkedList<T> {
    private head: ListNode<T> | null = null;
    private length: number = 0;

    getHead(): ListNode<T> | null {
        return this.head;
    }

    getLength(): number {
        return this.length;
    }

    append(value: T): void {
        const node: ListNode<T> = { value, next: null };
        if (!this.head) {
            this.head = node;
            node.next = node;
        } else {
            let current = this.head;
            while (current.next !== this.head) {
                current = current.next!;
            }
            current.next = node;
            node.next = this.head;
        }
        this.length++;
    }

    rotate(): void {
        if (this.head && this.head.next) {
            this.head = this.head.next;
        }
    }

    toArray(): T[] {
        const result: T[] = [];
        if (!this.head) return result;
        let current = this.head;
        do {
            result.push(current.value);
            current = current.next!;
        } while (current !== this.head);
        return result;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("LinkedList")
            && output.contains("DoublyLinkedList")
            && output.contains("CircularLinkedList"),
        "Expected recursive linked list type classes: {}",
        output
    );

    // LinkedList methods
    assert!(
        output.contains("append")
            && output.contains("prepend")
            && output.contains("removeFirst")
            && output.contains("find"),
        "Expected LinkedList methods: {}",
        output
    );

    // DoublyLinkedList methods
    assert!(
        output.contains("removeLast") && output.contains("reverse"),
        "Expected DoublyLinkedList methods: {}",
        output
    );

    // CircularLinkedList methods
    assert!(
        output.contains("rotate") && output.contains("toArray"),
        "Expected CircularLinkedList methods: {}",
        output
    );

    // Interface and type aliases should be stripped
    assert!(
        !output.contains("interface ListNode") && !output.contains("type DoublyLinkedNode"),
        "Expected interface and type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_recursive_type_json() {
    let source = r#"
// Recursive JSON type pattern
type JSONPrimitive = string | number | boolean | null;
type JSONArray = JSONValue[];
type JSONObject = { [key: string]: JSONValue };
type JSONValue = JSONPrimitive | JSONArray | JSONObject;

class JSONParser {
    parse(input: string): JSONValue {
        return JSON.parse(input);
    }

    stringify(value: JSONValue, indent?: number): string {
        return JSON.stringify(value, null, indent);
    }

    isObject(value: JSONValue): value is JSONObject {
        return typeof value === "object" && value !== null && !Array.isArray(value);
    }

    isArray(value: JSONValue): value is JSONArray {
        return Array.isArray(value);
    }

    isPrimitive(value: JSONValue): value is JSONPrimitive {
        return !this.isObject(value) && !this.isArray(value);
    }
}

class JSONTransformer {
    private value: JSONValue;

    constructor(value: JSONValue) {
        this.value = value;
    }

    getValue(): JSONValue {
        return this.value;
    }

    mapStrings(fn: (s: string) => string): JSONTransformer {
        return new JSONTransformer(this.transformStrings(this.value, fn));
    }

    private transformStrings(value: JSONValue, fn: (s: string) => string): JSONValue {
        if (typeof value === "string") {
            return fn(value);
        }
        if (Array.isArray(value)) {
            return value.map(item => this.transformStrings(item, fn));
        }
        if (typeof value === "object" && value !== null) {
            const result: JSONObject = {};
            for (const key in value) {
                result[key] = this.transformStrings(value[key], fn);
            }
            return result;
        }
        return value;
    }

    filterNulls(): JSONTransformer {
        return new JSONTransformer(this.removeNulls(this.value));
    }

    private removeNulls(value: JSONValue): JSONValue {
        if (value === null) {
            return null;
        }
        if (Array.isArray(value)) {
            return value.filter(item => item !== null).map(item => this.removeNulls(item));
        }
        if (typeof value === "object" && value !== null) {
            const result: JSONObject = {};
            for (const key in value) {
                if (value[key] !== null) {
                    result[key] = this.removeNulls(value[key]);
                }
            }
            return result;
        }
        return value;
    }

    getDepth(): number {
        return this.calculateDepth(this.value);
    }

    private calculateDepth(value: JSONValue): number {
        if (value === null || typeof value !== "object") {
            return 0;
        }
        if (Array.isArray(value)) {
            if (value.length === 0) return 1;
            return 1 + Math.max(...value.map(item => this.calculateDepth(item)));
        }
        const keys = Object.keys(value);
        if (keys.length === 0) return 1;
        return 1 + Math.max(...keys.map(key => this.calculateDepth(value[key])));
    }
}

class JSONPathQuery {
    private root: JSONValue;

    constructor(root: JSONValue) {
        this.root = root;
    }

    getRoot(): JSONValue {
        return this.root;
    }

    get(path: string): JSONValue | undefined {
        const parts = path.split(".").filter(p => p.length > 0);
        let current: JSONValue = this.root;
        for (const part of parts) {
            if (typeof current !== "object" || current === null) {
                return undefined;
            }
            if (Array.isArray(current)) {
                const index = parseInt(part, 10);
                if (isNaN(index)) return undefined;
                current = current[index];
            } else {
                current = (current as JSONObject)[part];
            }
            if (current === undefined) return undefined;
        }
        return current;
    }

    set(path: string, value: JSONValue): void {
        const parts = path.split(".").filter(p => p.length > 0);
        if (parts.length === 0) return;
        let current: JSONValue = this.root;
        for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (typeof current !== "object" || current === null || Array.isArray(current)) {
                return;
            }
            current = (current as JSONObject)[part];
        }
        if (typeof current === "object" && current !== null && !Array.isArray(current)) {
            (current as JSONObject)[parts[parts.length - 1]] = value;
        }
    }

    has(path: string): boolean {
        return this.get(path) !== undefined;
    }

    keys(): string[] {
        if (typeof this.root === "object" && this.root !== null && !Array.isArray(this.root)) {
            return Object.keys(this.root);
        }
        return [];
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("JSONParser")
            && output.contains("JSONTransformer")
            && output.contains("JSONPathQuery"),
        "Expected recursive JSON type classes: {}",
        output
    );

    // JSONParser methods
    assert!(
        output.contains("parse")
            && output.contains("stringify")
            && output.contains("isObject")
            && output.contains("isArray"),
        "Expected JSONParser methods: {}",
        output
    );

    // JSONTransformer methods
    assert!(
        output.contains("mapStrings")
            && output.contains("filterNulls")
            && output.contains("getDepth"),
        "Expected JSONTransformer methods: {}",
        output
    );

    // JSONPathQuery methods
    assert!(
        output.contains("get")
            && output.contains("set")
            && output.contains("has")
            && output.contains("keys"),
        "Expected JSONPathQuery methods: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type JSONPrimitive")
            && !output.contains("type JSONArray")
            && !output.contains("type JSONValue"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

// =============================================================================
// VARIADIC TUPLE PATTERN TESTS - spread, labeled, optional
// =============================================================================

#[test]
fn test_class_es5_variadic_tuple_spread() {
    let source = r#"
// Variadic tuple spread pattern
type Prepend<T, U extends unknown[]> = [T, ...U];
type Append<T extends unknown[], U> = [...T, U];
type Concat<T extends unknown[], U extends unknown[]> = [...T, ...U];

class TupleBuilder<T extends unknown[]> {
    private items: T;

    constructor(...items: T) {
        this.items = items;
    }

    getItems(): T {
        return this.items;
    }

    prepend<U>(item: U): TupleBuilder<[U, ...T]> {
        return new TupleBuilder(item, ...this.items) as TupleBuilder<[U, ...T]>;
    }

    append<U>(item: U): TupleBuilder<[...T, U]> {
        return new TupleBuilder(...this.items, item) as TupleBuilder<[...T, U]>;
    }

    concat<U extends unknown[]>(other: TupleBuilder<U>): TupleBuilder<[...T, ...U]> {
        return new TupleBuilder(...this.items, ...other.getItems()) as TupleBuilder<[...T, ...U]>;
    }

    getLength(): number {
        return this.items.length;
    }
}

class SpreadOperations<T extends unknown[]> {
    private data: T;

    constructor(data: T) {
        this.data = data;
    }

    getData(): T {
        return this.data;
    }

    first(): T[0] {
        return this.data[0];
    }

    rest(): T extends [unknown, ...infer R] ? R : never {
        return this.data.slice(1) as T extends [unknown, ...infer R] ? R : never;
    }

    last(): T extends [...unknown[], infer L] ? L : never {
        return this.data[this.data.length - 1] as T extends [...unknown[], infer L] ? L : never;
    }

    init(): T extends [...infer I, unknown] ? I : never {
        return this.data.slice(0, -1) as T extends [...infer I, unknown] ? I : never;
    }
}

class FunctionComposer {
    compose<A, B, C>(f: (a: A) => B, g: (b: B) => C): (a: A) => C {
        return (a: A) => g(f(a));
    }

    pipe<T extends unknown[], R>(
        ...fns: [...{ [K in keyof T]: (arg: K extends 0 ? T[0] : unknown) => unknown }, (arg: unknown) => R]
    ): (arg: T[0]) => R {
        return (arg: T[0]) => fns.reduce((acc, fn) => (fn as Function)(acc), arg) as R;
    }

    identity<T>(value: T): T {
        return value;
    }

    constant<T>(value: T): () => T {
        return () => value;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("TupleBuilder")
            && output.contains("SpreadOperations")
            && output.contains("FunctionComposer"),
        "Expected variadic tuple spread classes: {}",
        output
    );

    // TupleBuilder methods
    assert!(
        output.contains("getItems")
            && output.contains("prepend")
            && output.contains("append")
            && output.contains("concat"),
        "Expected TupleBuilder methods: {}",
        output
    );

    // SpreadOperations methods
    assert!(
        output.contains("first")
            && output.contains("rest")
            && output.contains("last")
            && output.contains("init"),
        "Expected SpreadOperations methods: {}",
        output
    );

    // FunctionComposer methods
    assert!(
        output.contains("compose") && output.contains("pipe") && output.contains("identity"),
        "Expected FunctionComposer methods: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type Prepend")
            && !output.contains("type Append")
            && !output.contains("type Concat"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_variadic_tuple_labeled() {
    let source = r#"
// Variadic tuple labeled pattern
type Point2D = [x: number, y: number];
type Point3D = [x: number, y: number, z: number];
type RGB = [red: number, green: number, blue: number];
type RGBA = [red: number, green: number, blue: number, alpha: number];

class Point2DHandler {
    private point: Point2D;

    constructor(x: number, y: number) {
        this.point = [x, y];
    }

    getX(): number {
        return this.point[0];
    }

    getY(): number {
        return this.point[1];
    }

    getPoint(): Point2D {
        return this.point;
    }

    distanceFromOrigin(): number {
        return Math.sqrt(this.point[0] ** 2 + this.point[1] ** 2);
    }

    add(other: Point2D): Point2DHandler {
        return new Point2DHandler(this.point[0] + other[0], this.point[1] + other[1]);
    }
}

class Point3DHandler {
    private point: Point3D;

    constructor(x: number, y: number, z: number) {
        this.point = [x, y, z];
    }

    getX(): number {
        return this.point[0];
    }

    getY(): number {
        return this.point[1];
    }

    getZ(): number {
        return this.point[2];
    }

    getPoint(): Point3D {
        return this.point;
    }

    distanceFromOrigin(): number {
        return Math.sqrt(this.point[0] ** 2 + this.point[1] ** 2 + this.point[2] ** 2);
    }

    toPoint2D(): Point2DHandler {
        return new Point2DHandler(this.point[0], this.point[1]);
    }
}

class ColorHandler {
    private color: RGB | RGBA;

    constructor(red: number, green: number, blue: number, alpha?: number) {
        if (alpha !== undefined) {
            this.color = [red, green, blue, alpha];
        } else {
            this.color = [red, green, blue];
        }
    }

    getRed(): number {
        return this.color[0];
    }

    getGreen(): number {
        return this.color[1];
    }

    getBlue(): number {
        return this.color[2];
    }

    getAlpha(): number | undefined {
        return this.color.length === 4 ? this.color[3] : undefined;
    }

    hasAlpha(): boolean {
        return this.color.length === 4;
    }

    toHexString(): string {
        const r = this.color[0].toString(16).padStart(2, "0");
        const g = this.color[1].toString(16).padStart(2, "0");
        const b = this.color[2].toString(16).padStart(2, "0");
        return r + g + b;
    }

    toRGBString(): string {
        return "rgb(" + this.color[0] + ", " + this.color[1] + ", " + this.color[2] + ")";
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Point2DHandler")
            && output.contains("Point3DHandler")
            && output.contains("ColorHandler"),
        "Expected variadic tuple labeled classes: {}",
        output
    );

    // Point2DHandler methods
    assert!(
        output.contains("getX")
            && output.contains("getY")
            && output.contains("distanceFromOrigin")
            && output.contains("add"),
        "Expected Point2DHandler methods: {}",
        output
    );

    // Point3DHandler methods
    assert!(
        output.contains("getZ") && output.contains("toPoint2D"),
        "Expected Point3DHandler methods: {}",
        output
    );

    // ColorHandler methods
    assert!(
        output.contains("getRed")
            && output.contains("getGreen")
            && output.contains("getBlue")
            && output.contains("getAlpha"),
        "Expected ColorHandler methods: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type Point2D")
            && !output.contains("type Point3D")
            && !output.contains("type RGB"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

#[test]
#[ignore = "Test times out/hangs - needs performance investigation"]
fn test_class_es5_variadic_tuple_optional() {
    let source = r#"
// Variadic tuple optional pattern
type OptionalTail<T, U?, V?> = [T, U?, V?];
type ConfigTuple = [host: string, port?: number, secure?: boolean];
type CallbackTuple = [success: () => void, error?: (err: Error) => void, complete?: () => void];

class ConfigManager {
    private config: ConfigTuple;

    constructor(host: string, port?: number, secure?: boolean) {
        this.config = [host, port, secure];
    }

    getHost(): string {
        return this.config[0];
    }

    getPort(): number | undefined {
        return this.config[1];
    }

    getSecure(): boolean | undefined {
        return this.config[2];
    }

    getPortOrDefault(defaultPort: number): number {
        return this.config[1] ?? defaultPort;
    }

    isSecure(): boolean {
        return this.config[2] ?? false;
    }

    getUrl(): string {
        const protocol = this.isSecure() ? "https" : "http";
        const port = this.getPort();
        if (port) {
            return protocol + "://" + this.getHost() + ":" + port;
        }
        return protocol + "://" + this.getHost();
    }
}

class CallbackManager {
    private callbacks: CallbackTuple;

    constructor(success: () => void, error?: (err: Error) => void, complete?: () => void) {
        this.callbacks = [success, error, complete];
    }

    getSuccess(): () => void {
        return this.callbacks[0];
    }

    getError(): ((err: Error) => void) | undefined {
        return this.callbacks[1];
    }

    getComplete(): (() => void) | undefined {
        return this.callbacks[2];
    }

    execute(): void {
        try {
            this.callbacks[0]();
        } catch (err) {
            if (this.callbacks[1]) {
                this.callbacks[1](err as Error);
            }
        } finally {
            if (this.callbacks[2]) {
                this.callbacks[2]();
            }
        }
    }

    hasErrorHandler(): boolean {
        return this.callbacks[1] !== undefined;
    }

    hasCompleteHandler(): boolean {
        return this.callbacks[2] !== undefined;
    }
}

class OptionalArgsHandler<T extends unknown[]> {
    private args: T;

    constructor(...args: T) {
        this.args = args;
    }

    getArgs(): T {
        return this.args;
    }

    getArg<K extends keyof T>(index: K): T[K] {
        return this.args[index];
    }

    hasArg(index: number): boolean {
        return index < this.args.length && this.args[index] !== undefined;
    }

    getArgCount(): number {
        return this.args.filter(arg => arg !== undefined).length;
    }

    getTotalSlots(): number {
        return this.args.length;
    }

    mapArgs<U>(fn: (arg: T[number]) => U): U[] {
        return this.args.map(fn);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ConfigManager")
            && output.contains("CallbackManager")
            && output.contains("OptionalArgsHandler"),
        "Expected variadic tuple optional classes: {}",
        output
    );

    // ConfigManager methods
    assert!(
        output.contains("getHost")
            && output.contains("getPort")
            && output.contains("getSecure")
            && output.contains("getUrl"),
        "Expected ConfigManager methods: {}",
        output
    );

    // CallbackManager methods
    assert!(
        output.contains("getSuccess") && output.contains("getError") && output.contains("execute"),
        "Expected CallbackManager methods: {}",
        output
    );

    // OptionalArgsHandler methods
    assert!(
        output.contains("getArgs")
            && output.contains("getArg")
            && output.contains("hasArg")
            && output.contains("getArgCount"),
        "Expected OptionalArgsHandler methods: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type OptionalTail")
            && !output.contains("type ConfigTuple")
            && !output.contains("type CallbackTuple"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

// =============================================================================
// KEY REMAPPING PATTERN TESTS - as clause, template literals
// =============================================================================

#[test]
fn test_class_es5_key_remapping_basic_as_clause() {
    let source = r#"
// Basic as clause in mapped types
type Getters<T> = {
    [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

type Setters<T> = {
    [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void;
};

interface Person {
    name: string;
    age: number;
    email: string;
}

class PersonAccessors {
    private data: Person;

    constructor(name: string, age: number, email: string) {
        this.data = { name, age, email };
    }

    getName(): string {
        return this.data.name;
    }

    setName(value: string): void {
        this.data.name = value;
    }

    getAge(): number {
        return this.data.age;
    }

    setAge(value: number): void {
        this.data.age = value;
    }

    getEmail(): string {
        return this.data.email;
    }

    setEmail(value: string): void {
        this.data.email = value;
    }

    getData(): Person {
        return { ...this.data };
    }
}

class PropertyMapper<T extends object> {
    private source: T;

    constructor(source: T) {
        this.source = source;
    }

    getSource(): T {
        return this.source;
    }

    get<K extends keyof T>(key: K): T[K] {
        return this.source[key];
    }

    set<K extends keyof T>(key: K, value: T[K]): void {
        this.source[key] = value;
    }

    keys(): (keyof T)[] {
        return Object.keys(this.source) as (keyof T)[];
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("PersonAccessors") && output.contains("PropertyMapper"),
        "Expected basic as clause classes: {}",
        output
    );

    // PersonAccessors methods
    assert!(
        output.contains("getName")
            && output.contains("setName")
            && output.contains("getAge")
            && output.contains("setAge"),
        "Expected PersonAccessors methods: {}",
        output
    );

    // PropertyMapper methods
    assert!(
        output.contains("getSource")
            && output.contains("get")
            && output.contains("set")
            && output.contains("keys"),
        "Expected PropertyMapper methods: {}",
        output
    );

    // Type aliases and interface should be stripped
    assert!(
        !output.contains("type Getters")
            && !output.contains("type Setters")
            && !output.contains("interface Person"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_key_remapping_template_literal() {
    let source = r#"
// Template literal key remapping
type EventHandlers<T> = {
    [K in keyof T as `on${Capitalize<string & K>}Change`]: (newValue: T[K], oldValue: T[K]) => void;
};

type PrefixedKeys<T, P extends string> = {
    [K in keyof T as `${P}_${string & K}`]: T[K];
};

type SuffixedKeys<T, S extends string> = {
    [K in keyof T as `${string & K}_${S}`]: T[K];
};

class EventEmitter<T extends object> {
    private state: T;
    private handlers: Map<string, Function[]> = new Map();

    constructor(initialState: T) {
        this.state = initialState;
    }

    getState(): T {
        return { ...this.state };
    }

    on(event: string, handler: Function): void {
        if (!this.handlers.has(event)) {
            this.handlers.set(event, []);
        }
        this.handlers.get(event)!.push(handler);
    }

    off(event: string, handler: Function): void {
        const handlers = this.handlers.get(event);
        if (handlers) {
            const index = handlers.indexOf(handler);
            if (index >= 0) {
                handlers.splice(index, 1);
            }
        }
    }

    emit(event: string, ...args: unknown[]): void {
        const handlers = this.handlers.get(event);
        if (handlers) {
            handlers.forEach(h => h(...args));
        }
    }

    update<K extends keyof T>(key: K, value: T[K]): void {
        const oldValue = this.state[key];
        this.state[key] = value;
        this.emit("on" + String(key) + "Change", value, oldValue);
    }
}

class PrefixedStorage<T extends object> {
    private prefix: string;
    private data: Map<string, unknown> = new Map();

    constructor(prefix: string) {
        this.prefix = prefix;
    }

    getPrefix(): string {
        return this.prefix;
    }

    set<K extends keyof T>(key: K, value: T[K]): void {
        this.data.set(this.prefix + "_" + String(key), value);
    }

    get<K extends keyof T>(key: K): T[K] | undefined {
        return this.data.get(this.prefix + "_" + String(key)) as T[K] | undefined;
    }

    has<K extends keyof T>(key: K): boolean {
        return this.data.has(this.prefix + "_" + String(key));
    }

    delete<K extends keyof T>(key: K): boolean {
        return this.data.delete(this.prefix + "_" + String(key));
    }

    clear(): void {
        this.data.clear();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("EventEmitter") && output.contains("PrefixedStorage"),
        "Expected template literal key remapping classes: {}",
        output
    );

    // EventEmitter methods
    assert!(
        output.contains("getState")
            && output.contains("on")
            && output.contains("off")
            && output.contains("emit")
            && output.contains("update"),
        "Expected EventEmitter methods: {}",
        output
    );

    // PrefixedStorage methods
    assert!(
        output.contains("getPrefix")
            && output.contains("set")
            && output.contains("get")
            && output.contains("has")
            && output.contains("delete"),
        "Expected PrefixedStorage methods: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type EventHandlers")
            && !output.contains("type PrefixedKeys")
            && !output.contains("type SuffixedKeys"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_key_remapping_conditional_as() {
    let source = r#"
// Conditional as clause
type OnlyStrings<T> = {
    [K in keyof T as T[K] extends string ? K : never]: T[K];
};

type OnlyNumbers<T> = {
    [K in keyof T as T[K] extends number ? K : never]: T[K];
};

type OnlyFunctions<T> = {
    [K in keyof T as T[K] extends Function ? K : never]: T[K];
};

interface MixedData {
    name: string;
    age: number;
    active: boolean;
    greet: () => string;
    calculate: (x: number) => number;
}

class StringFieldsHandler<T extends object> {
    private data: T;

    constructor(data: T) {
        this.data = data;
    }

    getData(): T {
        return this.data;
    }

    getStringFields(): string[] {
        return Object.entries(this.data)
            .filter(([_, value]) => typeof value === "string")
            .map(([key, _]) => key);
    }

    getStringValue(key: string): string | undefined {
        const value = (this.data as Record<string, unknown>)[key];
        return typeof value === "string" ? value : undefined;
    }

    setStringValue(key: string, value: string): void {
        if (typeof (this.data as Record<string, unknown>)[key] === "string") {
            (this.data as Record<string, unknown>)[key] = value;
        }
    }
}

class NumberFieldsHandler<T extends object> {
    private data: T;

    constructor(data: T) {
        this.data = data;
    }

    getData(): T {
        return this.data;
    }

    getNumberFields(): string[] {
        return Object.entries(this.data)
            .filter(([_, value]) => typeof value === "number")
            .map(([key, _]) => key);
    }

    sum(): number {
        return Object.values(this.data)
            .filter((value): value is number => typeof value === "number")
            .reduce((acc, val) => acc + val, 0);
    }

    average(): number {
        const numbers = Object.values(this.data).filter((value): value is number => typeof value === "number");
        return numbers.length > 0 ? numbers.reduce((acc, val) => acc + val, 0) / numbers.length : 0;
    }
}

class FunctionFieldsHandler<T extends object> {
    private data: T;

    constructor(data: T) {
        this.data = data;
    }

    getData(): T {
        return this.data;
    }

    getFunctionFields(): string[] {
        return Object.entries(this.data)
            .filter(([_, value]) => typeof value === "function")
            .map(([key, _]) => key);
    }

    invoke(key: string, ...args: unknown[]): unknown {
        const fn = (this.data as Record<string, unknown>)[key];
        if (typeof fn === "function") {
            return fn(...args);
        }
        return undefined;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("StringFieldsHandler")
            && output.contains("NumberFieldsHandler")
            && output.contains("FunctionFieldsHandler"),
        "Expected conditional as clause classes: {}",
        output
    );

    // StringFieldsHandler methods
    assert!(
        output.contains("getStringFields")
            && output.contains("getStringValue")
            && output.contains("setStringValue"),
        "Expected StringFieldsHandler methods: {}",
        output
    );

    // NumberFieldsHandler methods
    assert!(
        output.contains("getNumberFields") && output.contains("sum") && output.contains("average"),
        "Expected NumberFieldsHandler methods: {}",
        output
    );

    // FunctionFieldsHandler methods
    assert!(
        output.contains("getFunctionFields") && output.contains("invoke"),
        "Expected FunctionFieldsHandler methods: {}",
        output
    );

    // Type aliases and interface should be stripped
    assert!(
        !output.contains("type OnlyStrings")
            && !output.contains("type OnlyNumbers")
            && !output.contains("interface MixedData"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_key_remapping_nested() {
    let source = r#"
// Nested key remapping
type DeepGetters<T> = {
    [K in keyof T as `get${Capitalize<string & K>}`]: T[K] extends object
        ? () => DeepGetters<T[K]>
        : () => T[K];
};

type NestedKeys<T, Prefix extends string = ""> = {
    [K in keyof T as `${Prefix}${Prefix extends "" ? "" : "."}${string & K}`]: T[K] extends object
        ? NestedKeys<T[K], `${Prefix}${Prefix extends "" ? "" : "."}${string & K}`>
        : T[K];
};

interface NestedConfig {
    database: {
        host: string;
        port: number;
    };
    server: {
        host: string;
        port: number;
    };
}

class NestedConfigHandler {
    private config: NestedConfig;

    constructor(config: NestedConfig) {
        this.config = config;
    }

    getConfig(): NestedConfig {
        return this.config;
    }

    getDatabaseHost(): string {
        return this.config.database.host;
    }

    getDatabasePort(): number {
        return this.config.database.port;
    }

    getServerHost(): string {
        return this.config.server.host;
    }

    getServerPort(): number {
        return this.config.server.port;
    }

    setDatabaseHost(host: string): void {
        this.config.database.host = host;
    }

    setDatabasePort(port: number): void {
        this.config.database.port = port;
    }

    setServerHost(host: string): void {
        this.config.server.host = host;
    }

    setServerPort(port: number): void {
        this.config.server.port = port;
    }
}

class DeepPropertyAccessor<T extends object> {
    private data: T;

    constructor(data: T) {
        this.data = data;
    }

    getData(): T {
        return this.data;
    }

    getByPath(path: string): unknown {
        const keys = path.split(".");
        let current: unknown = this.data;
        for (const key of keys) {
            if (current === null || current === undefined) {
                return undefined;
            }
            current = (current as Record<string, unknown>)[key];
        }
        return current;
    }

    setByPath(path: string, value: unknown): void {
        const keys = path.split(".");
        let current: unknown = this.data;
        for (let i = 0; i < keys.length - 1; i++) {
            if (current === null || current === undefined) {
                return;
            }
            current = (current as Record<string, unknown>)[keys[i]];
        }
        if (current !== null && current !== undefined) {
            (current as Record<string, unknown>)[keys[keys.length - 1]] = value;
        }
    }

    hasPath(path: string): boolean {
        return this.getByPath(path) !== undefined;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("NestedConfigHandler") && output.contains("DeepPropertyAccessor"),
        "Expected nested key remapping classes: {}",
        output
    );

    // NestedConfigHandler methods
    assert!(
        output.contains("getDatabaseHost")
            && output.contains("getDatabasePort")
            && output.contains("getServerHost")
            && output.contains("getServerPort"),
        "Expected NestedConfigHandler methods: {}",
        output
    );

    // DeepPropertyAccessor methods
    assert!(
        output.contains("getByPath") && output.contains("setByPath") && output.contains("hasPath"),
        "Expected DeepPropertyAccessor methods: {}",
        output
    );

    // Type aliases and interface should be stripped
    assert!(
        !output.contains("type DeepGetters")
            && !output.contains("type NestedKeys")
            && !output.contains("interface NestedConfig"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_key_remapping_filtering() {
    let source = r#"
// Key filtering with as
type ExcludeKeys<T, K extends keyof T> = {
    [P in keyof T as P extends K ? never : P]: T[P];
};

type IncludeKeys<T, K extends keyof T> = {
    [P in keyof T as P extends K ? P : never]: T[P];
};

type OmitByType<T, U> = {
    [K in keyof T as T[K] extends U ? never : K]: T[K];
};

type PickByType<T, U> = {
    [K in keyof T as T[K] extends U ? K : never]: T[K];
};

interface FullUser {
    id: number;
    name: string;
    email: string;
    password: string;
    createdAt: Date;
    updatedAt: Date;
}

class PublicUserView {
    private user: FullUser;

    constructor(user: FullUser) {
        this.user = user;
    }

    getId(): number {
        return this.user.id;
    }

    getName(): string {
        return this.user.name;
    }

    getEmail(): string {
        return this.user.email;
    }

    getCreatedAt(): Date {
        return this.user.createdAt;
    }

    toJSON(): object {
        return {
            id: this.user.id,
            name: this.user.name,
            email: this.user.email,
            createdAt: this.user.createdAt
        };
    }
}

class FilteredDataHandler<T extends object> {
    private data: T;
    private excludedKeys: Set<string>;

    constructor(data: T, excludedKeys: string[] = []) {
        this.data = data;
        this.excludedKeys = new Set(excludedKeys);
    }

    getData(): T {
        return this.data;
    }

    getFiltered(): Partial<T> {
        const result: Partial<T> = {};
        for (const key of Object.keys(this.data) as (keyof T)[]) {
            if (!this.excludedKeys.has(key as string)) {
                result[key] = this.data[key];
            }
        }
        return result;
    }

    exclude(key: string): void {
        this.excludedKeys.add(key);
    }

    include(key: string): void {
        this.excludedKeys.delete(key);
    }

    isExcluded(key: string): boolean {
        return this.excludedKeys.has(key);
    }

    getExcludedKeys(): string[] {
        return Array.from(this.excludedKeys);
    }
}

class TypeFilteredHandler<T extends object> {
    private data: T;

    constructor(data: T) {
        this.data = data;
    }

    getData(): T {
        return this.data;
    }

    pickByType<U>(typeChecker: (value: unknown) => value is U): Record<string, U> {
        const result: Record<string, U> = {};
        for (const [key, value] of Object.entries(this.data)) {
            if (typeChecker(value)) {
                result[key] = value;
            }
        }
        return result;
    }

    omitByType<U>(typeChecker: (value: unknown) => value is U): Record<string, unknown> {
        const result: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(this.data)) {
            if (!typeChecker(value)) {
                result[key] = value;
            }
        }
        return result;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("PublicUserView")
            && output.contains("FilteredDataHandler")
            && output.contains("TypeFilteredHandler"),
        "Expected key filtering classes: {}",
        output
    );

    // PublicUserView methods
    assert!(
        output.contains("getId")
            && output.contains("getName")
            && output.contains("getEmail")
            && output.contains("toJSON"),
        "Expected PublicUserView methods: {}",
        output
    );

    // FilteredDataHandler methods
    assert!(
        output.contains("getFiltered")
            && output.contains("exclude")
            && output.contains("include")
            && output.contains("isExcluded"),
        "Expected FilteredDataHandler methods: {}",
        output
    );

    // TypeFilteredHandler methods
    assert!(
        output.contains("pickByType") && output.contains("omitByType"),
        "Expected TypeFilteredHandler methods: {}",
        output
    );

    // Type aliases and interface should be stripped
    assert!(
        !output.contains("type ExcludeKeys")
            && !output.contains("type PickByType")
            && !output.contains("interface FullUser"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

#[test]
fn test_class_es5_key_remapping_combined() {
    let source = r#"
// Combined key remapping patterns
type AsyncMethods<T> = {
    [K in keyof T as T[K] extends (...args: infer A) => infer R
        ? `${string & K}Async`
        : never]: T[K] extends (...args: infer A) => infer R
        ? (...args: A) => Promise<R>
        : never;
};

type ObservableProps<T> = {
    [K in keyof T as T[K] extends Function ? never : `${string & K}$`]: {
        subscribe: (callback: (value: T[K]) => void) => () => void;
        getValue: () => T[K];
    };
};

type ValidatedFields<T> = {
    [K in keyof T as `validate${Capitalize<string & K>}`]: (value: T[K]) => boolean;
} & {
    [K in keyof T as `${string & K}Error`]: string | null;
};

class AsyncWrapper<T extends object> {
    private target: T;

    constructor(target: T) {
        this.target = target;
    }

    getTarget(): T {
        return this.target;
    }

    async callAsync<K extends keyof T>(
        method: K,
        ...args: T[K] extends (...args: infer A) => unknown ? A : never[]
    ): Promise<T[K] extends (...args: unknown[]) => infer R ? R : never> {
        const fn = this.target[method];
        if (typeof fn === "function") {
            return Promise.resolve(fn.apply(this.target, args));
        }
        throw new Error("Not a function: " + String(method));
    }

    wrapMethod<K extends keyof T>(method: K): (...args: unknown[]) => Promise<unknown> {
        return async (...args: unknown[]) => {
            const fn = this.target[method];
            if (typeof fn === "function") {
                return fn.apply(this.target, args);
            }
            throw new Error("Not a function: " + String(method));
        };
    }
}

class ObservableState<T extends object> {
    private state: T;
    private subscribers: Map<keyof T, Set<(value: unknown) => void>> = new Map();

    constructor(initialState: T) {
        this.state = initialState;
    }

    getState(): T {
        return { ...this.state };
    }

    getValue<K extends keyof T>(key: K): T[K] {
        return this.state[key];
    }

    setValue<K extends keyof T>(key: K, value: T[K]): void {
        this.state[key] = value;
        this.notify(key, value);
    }

    subscribe<K extends keyof T>(key: K, callback: (value: T[K]) => void): () => void {
        if (!this.subscribers.has(key)) {
            this.subscribers.set(key, new Set());
        }
        this.subscribers.get(key)!.add(callback as (value: unknown) => void);
        return () => {
            this.subscribers.get(key)?.delete(callback as (value: unknown) => void);
        };
    }

    private notify<K extends keyof T>(key: K, value: T[K]): void {
        const callbacks = this.subscribers.get(key);
        if (callbacks) {
            callbacks.forEach(cb => cb(value));
        }
    }
}

class FormValidator<T extends object> {
    private data: T;
    private errors: Map<keyof T, string | null> = new Map();
    private validators: Map<keyof T, (value: unknown) => boolean> = new Map();

    constructor(data: T) {
        this.data = data;
    }

    getData(): T {
        return this.data;
    }

    addValidator<K extends keyof T>(field: K, validator: (value: T[K]) => boolean): void {
        this.validators.set(field, validator as (value: unknown) => boolean);
    }

    validate<K extends keyof T>(field: K): boolean {
        const validator = this.validators.get(field);
        if (validator) {
            const isValid = validator(this.data[field]);
            this.errors.set(field, isValid ? null : "Validation failed for " + String(field));
            return isValid;
        }
        return true;
    }

    validateAll(): boolean {
        let allValid = true;
        for (const field of Object.keys(this.data) as (keyof T)[]) {
            if (!this.validate(field)) {
                allValid = false;
            }
        }
        return allValid;
    }

    getError<K extends keyof T>(field: K): string | null {
        return this.errors.get(field) ?? null;
    }

    getAllErrors(): Record<string, string | null> {
        const result: Record<string, string | null> = {};
        for (const [key, value] of this.errors) {
            result[key as string] = value;
        }
        return result;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("AsyncWrapper")
            && output.contains("ObservableState")
            && output.contains("FormValidator"),
        "Expected combined key remapping classes: {}",
        output
    );

    // AsyncWrapper methods
    assert!(
        output.contains("getTarget")
            && output.contains("callAsync")
            && output.contains("wrapMethod"),
        "Expected AsyncWrapper methods: {}",
        output
    );

    // ObservableState methods
    assert!(
        output.contains("getState")
            && output.contains("getValue")
            && output.contains("setValue")
            && output.contains("subscribe"),
        "Expected ObservableState methods: {}",
        output
    );

    // FormValidator methods
    assert!(
        output.contains("addValidator")
            && output.contains("validate")
            && output.contains("validateAll")
            && output.contains("getError"),
        "Expected FormValidator methods: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type AsyncMethods")
            && !output.contains("type ObservableProps")
            && !output.contains("type ValidatedFields"),
        "Expected type aliases to be stripped: {}",
        output
    );
}

// =============================================================================
// NESTED ARROW THIS CAPTURE PATTERN TESTS
// =============================================================================

/// Test ES5 class with arrow in arrow in method pattern
#[test]
fn test_class_es5_arrow_in_arrow_in_method() {
    let source = r#"
class DataProcessor {
    private data: number[] = [];

    processWithCallback(): void {
        const outer = () => {
            const inner = () => {
                this.data.push(1);
                return this.data.length;
            };
            return inner();
        };
        outer();
    }

    transformData(): number[] {
        const mapper = () => {
            const doubler = () => {
                return this.data.map(x => x * 2);
            };
            return doubler();
        };
        return mapper();
    }

    chainedArrows(): void {
        const first = () => {
            const second = () => {
                const third = () => {
                    this.data = this.data.filter(x => x > 0);
                };
                third();
            };
            second();
        };
        first();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("DataProcessor"),
        "Expected DataProcessor class: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("processWithCallback")
            && output.contains("transformData")
            && output.contains("chainedArrows"),
        "Expected methods: {}",
        output
    );

    // Type annotation should be stripped
    assert!(
        !output.contains("private data: number[]"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with arrow in async in arrow pattern
#[test]
fn test_class_es5_arrow_in_async_in_arrow() {
    let source = r#"
class AsyncHandler {
    private value: string = "";

    handleAsync(): void {
        const outer = () => {
            const asyncMiddle = async () => {
                const inner = () => {
                    return this.value;
                };
                await Promise.resolve();
                this.value = inner();
            };
            asyncMiddle();
        };
        outer();
    }

    fetchWithArrows(): void {
        const setup = () => {
            const doFetch = async () => {
                const processResult = () => {
                    this.value = "fetched";
                };
                await fetch("/api");
                processResult();
            };
            doFetch();
        };
        setup();
    }

    nestedAsyncArrows(): void {
        const wrapper = async () => {
            const inner = async () => {
                const callback = () => {
                    return this.value.toUpperCase();
                };
                await Promise.resolve();
                this.value = callback();
            };
            await inner();
        };
        wrapper();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("AsyncHandler"),
        "Expected AsyncHandler class: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("handleAsync")
            && output.contains("fetchWithArrows")
            && output.contains("nestedAsyncArrows"),
        "Expected methods: {}",
        output
    );

    // Type annotation should be stripped
    assert!(
        !output.contains("private value: string"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with arrow callback in constructor pattern
#[test]
fn test_class_es5_arrow_callback_in_constructor() {
    let source = r#"
class EventEmitter {
    private handlers: (() => void)[] = [];

    constructor() {
        const setup = () => {
            this.handlers.push(() => {
                console.log("Handler 1");
            });
        };
        setup();

        [1, 2, 3].forEach(n => {
            this.handlers.push(() => {
                console.log("Handler " + n);
            });
        });

        setTimeout(() => {
            const nestedSetup = () => {
                this.handlers.forEach(h => h());
            };
            nestedSetup();
        }, 0);
    }
}

class ServiceInitializer {
    private services: Map<string, any> = new Map();

    constructor(config: Record<string, any>) {
        Object.keys(config).forEach(key => {
            const init = () => {
                this.services.set(key, config[key]);
            };
            init();
        });

        const finalize = () => {
            const validate = () => {
                return this.services.size > 0;
            };
            if (!validate()) {
                throw new Error("No services");
            }
        };
        finalize();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("EventEmitter") && output.contains("ServiceInitializer"),
        "Expected classes: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private handlers:") && !output.contains("private services:"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with nested arrow in getter/setter pattern
#[test]
fn test_class_es5_nested_arrow_in_getter_setter() {
    let source = r#"
class ComputedProperty {
    private _value: number = 0;
    private transformers: ((n: number) => number)[] = [];

    get value(): number {
        const compute = () => {
            const applyTransforms = () => {
                return this.transformers.reduce((acc, fn) => fn(acc), this._value);
            };
            return applyTransforms();
        };
        return compute();
    }

    set value(n: number) {
        const validate = () => {
            const isValid = () => {
                return n >= 0 && n <= 100;
            };
            if (isValid()) {
                this._value = n;
            }
        };
        validate();
    }

    addTransformer(fn: (n: number) => number): void {
        this.transformers.push(fn);
    }
}

class CachedGetter {
    private cache: Map<string, any> = new Map();

    get computedValue(): string {
        const getOrCompute = () => {
            const key = "computed";
            const compute = () => {
                const result = "computed_" + Date.now();
                this.cache.set(key, result);
                return result;
            };
            return this.cache.get(key) ?? compute();
        };
        return getOrCompute();
    }

    set computedValue(val: string) {
        const updateCache = () => {
            const key = "computed";
            const validate = () => val.startsWith("computed_");
            if (validate()) {
                this.cache.set(key, val);
            }
        };
        updateCache();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ComputedProperty") && output.contains("CachedGetter"),
        "Expected classes: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private _value: number") && !output.contains("private cache: Map"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with arrow in static block pattern
#[test]
fn test_class_es5_arrow_in_static_block() {
    let source = r#"
class StaticInitializer {
    static instances: StaticInitializer[] = [];
    static config: Record<string, any> = {};

    static {
        const setup = () => {
            const initConfig = () => {
                StaticInitializer.config = { initialized: true };
            };
            initConfig();
        };
        setup();

        [1, 2, 3].forEach(n => {
            const create = () => {
                StaticInitializer.instances.push(new StaticInitializer());
            };
            create();
        });
    }

    private id: number;

    constructor() {
        this.id = StaticInitializer.instances.length;
    }
}

class RegistryInitializer {
    static registry: Map<string, Function> = new Map();

    static {
        const registerDefaults = () => {
            const addEntry = (name: string, fn: Function) => {
                RegistryInitializer.registry.set(name, fn);
            };

            ["a", "b", "c"].forEach(name => {
                addEntry(name, () => console.log(name));
            });
        };
        registerDefaults();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("StaticInitializer") && output.contains("RegistryInitializer"),
        "Expected classes: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("static instances: StaticInitializer[]")
            && !output.contains("static registry: Map"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with combined nested arrow this patterns
#[test]
fn test_class_es5_combined_nested_arrow_this_patterns() {
    let source = r#"
class ComplexThisCapture {
    private state: any = {};
    private listeners: ((state: any) => void)[] = [];

    constructor() {
        const init = () => {
            this.state = { ready: false };
            const setupListeners = () => {
                this.listeners.push(state => {
                    console.log("State changed:", state);
                });
            };
            setupListeners();
        };
        init();
    }

    get currentState(): any {
        const getState = () => {
            const clone = () => ({ ...this.state });
            return clone();
        };
        return getState();
    }

    set currentState(newState: any) {
        const update = () => {
            const notify = () => {
                this.listeners.forEach(listener => {
                    listener(newState);
                });
            };
            this.state = newState;
            notify();
        };
        update();
    }

    async processAsync(): Promise<void> {
        const outer = () => {
            const middle = async () => {
                const inner = () => {
                    this.state.processing = true;
                };
                inner();
                await Promise.resolve();
                const finalize = () => {
                    this.state.processing = false;
                };
                finalize();
            };
            return middle();
        };
        await outer();
    }

    static instances: ComplexThisCapture[] = [];

    static {
        const registerFactory = () => {
            const createInstance = () => {
                const instance = new ComplexThisCapture();
                ComplexThisCapture.instances.push(instance);
                return instance;
            };
            createInstance();
        };
        registerFactory();
    }
}

class EventBus<T> {
    private handlers: Map<string, ((data: T) => void)[]> = new Map();

    on(event: string, handler: (data: T) => void): void {
        const addHandler = () => {
            const handlers = this.handlers.get(event) ?? [];
            const wrappedHandler = (data: T) => {
                const process = () => handler(data);
                process();
            };
            handlers.push(wrappedHandler);
            this.handlers.set(event, handlers);
        };
        addHandler();
    }

    emit(event: string, data: T): void {
        const dispatch = () => {
            const handlers = this.handlers.get(event) ?? [];
            const notifyAll = () => {
                handlers.forEach(handler => {
                    const invoke = () => handler(data);
                    invoke();
                });
            };
            notifyAll();
        };
        dispatch();
    }

    async emitAsync(event: string, data: T): Promise<void> {
        const asyncDispatch = async () => {
            const handlers = this.handlers.get(event) ?? [];
            for (const handler of handlers) {
                const invokeAsync = async () => {
                    await Promise.resolve();
                    handler(data);
                };
                await invokeAsync();
            }
        };
        await asyncDispatch();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ComplexThisCapture") && output.contains("EventBus"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("processAsync")
            && output.contains("on")
            && output.contains("emit")
            && output.contains("emitAsync"),
        "Expected methods: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private state: any") && !output.contains("private handlers: Map"),
        "Expected type annotations to be stripped: {}",
        output
    );

    // Generic parameter should be stripped
    assert!(
        !output.contains("EventBus<T>"),
        "Expected generic parameter to be stripped: {}",
        output
    );
}

// =============================================================================
// ASYNC METHOD SUPER CALL PATTERN TESTS
// =============================================================================

/// Test ES5 class with async method calling super.method()
#[test]
fn test_class_es5_async_method_calling_super_method() {
    let source = r#"
class BaseService {
    protected async fetchData(): Promise<string> {
        return "base data";
    }

    protected async processItem(item: string): Promise<string> {
        return item.toUpperCase();
    }

    protected getData(): string {
        return "sync data";
    }
}

class DerivedService extends BaseService {
    async fetchData(): Promise<string> {
        const baseResult = await super.fetchData();
        return baseResult + " extended";
    }

    async processItem(item: string): Promise<string> {
        const processed = await super.processItem(item);
        return "derived: " + processed;
    }

    async combinedOperation(): Promise<string> {
        const data = await super.fetchData();
        const processed = await super.processItem(data);
        return processed;
    }
}

class GrandchildService extends DerivedService {
    async fetchData(): Promise<string> {
        const parentResult = await super.fetchData();
        return parentResult + " grandchild";
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("BaseService")
            && output.contains("DerivedService")
            && output.contains("GrandchildService"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("fetchData")
            && output.contains("processItem")
            && output.contains("combinedOperation"),
        "Expected methods: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("Promise<string>") && !output.contains("protected async"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with async method with await before super call
#[test]
fn test_class_es5_async_method_await_before_super() {
    let source = r#"
class BaseProcessor {
    process(data: string): string {
        return data.trim();
    }

    validate(input: string): boolean {
        return input.length > 0;
    }
}

class AsyncProcessor extends BaseProcessor {
    private config: any;

    async processAsync(data: string): Promise<string> {
        const config = await this.loadConfig();
        this.config = config;
        return super.process(data);
    }

    async validateAsync(input: string): Promise<boolean> {
        await this.initialize();
        const trimmed = input.trim();
        return super.validate(trimmed);
    }

    async complexFlow(data: string): Promise<string> {
        const step1 = await Promise.resolve(data);
        const step2 = await this.transform(step1);
        await this.log("before super");
        return super.process(step2);
    }

    private async loadConfig(): Promise<any> {
        return { enabled: true };
    }

    private async initialize(): Promise<void> {
        await Promise.resolve();
    }

    private async transform(data: string): Promise<string> {
        return data.toLowerCase();
    }

    private async log(message: string): Promise<void> {
        console.log(message);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("BaseProcessor") && output.contains("AsyncProcessor"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("processAsync")
            && output.contains("validateAsync")
            && output.contains("complexFlow"),
        "Expected methods: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private config: any") && !output.contains("Promise<string>"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with async method with await after super call
#[test]
fn test_class_es5_async_method_await_after_super() {
    let source = r#"
class BaseLogger {
    log(message: string): string {
        return "[LOG] " + message;
    }

    format(data: any): string {
        return JSON.stringify(data);
    }
}

class AsyncLogger extends BaseLogger {
    async logAndNotify(message: string): Promise<void> {
        const formatted = super.log(message);
        await this.sendNotification(formatted);
    }

    async formatAndStore(data: any): Promise<string> {
        const formatted = super.format(data);
        await this.storeInDatabase(formatted);
        await this.updateCache(formatted);
        return formatted;
    }

    async logWithRetry(message: string): Promise<string> {
        const result = super.log(message);
        for (let i = 0; i < 3; i++) {
            try {
                await this.sendToServer(result);
                break;
            } catch {
                await this.delay(1000);
            }
        }
        return result;
    }

    private async sendNotification(msg: string): Promise<void> {
        await fetch("/notify", { method: "POST", body: msg });
    }

    private async storeInDatabase(data: string): Promise<void> {
        await Promise.resolve();
    }

    private async updateCache(data: string): Promise<void> {
        await Promise.resolve();
    }

    private async sendToServer(data: string): Promise<void> {
        await fetch("/log", { method: "POST", body: data });
    }

    private async delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("BaseLogger") && output.contains("AsyncLogger"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("logAndNotify")
            && output.contains("formatAndStore")
            && output.contains("logWithRetry"),
        "Expected methods: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("Promise<void>") && !output.contains("Promise<string>"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with async static method with super property
#[test]
fn test_class_es5_async_static_method_super_property() {
    let source = r#"
class BaseFactory {
    static defaultConfig = { timeout: 5000 };

    static create(): BaseFactory {
        return new BaseFactory();
    }

    static getVersion(): string {
        return "1.0.0";
    }
}

class AsyncFactory extends BaseFactory {
    static async createAsync(): Promise<AsyncFactory> {
        await this.initialize();
        const instance = super.create() as AsyncFactory;
        return instance;
    }

    static async getVersionAsync(): Promise<string> {
        await Promise.resolve();
        const baseVersion = super.getVersion();
        return baseVersion + "-async";
    }

    static async createWithConfig(config: any): Promise<AsyncFactory> {
        const merged = { ...super.defaultConfig, ...config };
        await this.applyConfig(merged);
        return new AsyncFactory();
    }

    private static async initialize(): Promise<void> {
        await Promise.resolve();
    }

    private static async applyConfig(config: any): Promise<void> {
        await Promise.resolve();
    }
}

class ExtendedFactory extends AsyncFactory {
    static async createAsync(): Promise<ExtendedFactory> {
        await Promise.resolve();
        const base = await super.createAsync();
        return base as ExtendedFactory;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("BaseFactory")
            && output.contains("AsyncFactory")
            && output.contains("ExtendedFactory"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("createAsync")
            && output.contains("getVersionAsync")
            && output.contains("createWithConfig"),
        "Expected methods: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("Promise<AsyncFactory>") && !output.contains("Promise<string>"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with async method with super in try/catch
#[test]
fn test_class_es5_async_method_super_in_try_catch() {
    let source = r#"
class BaseHandler {
    handle(request: any): any {
        return { success: true, data: request };
    }

    handleError(error: Error): any {
        return { success: false, error: error.message };
    }

    cleanup(): void {
        console.log("cleanup");
    }
}

class SafeHandler extends BaseHandler {
    async safeHandle(request: any): Promise<any> {
        try {
            const result = super.handle(request);
            await this.logSuccess(result);
            return result;
        } catch (error) {
            return super.handleError(error as Error);
        }
    }

    async handleWithFinally(request: any): Promise<any> {
        try {
            await this.preProcess(request);
            return super.handle(request);
        } catch (error) {
            const errorResult = super.handleError(error as Error);
            await this.logError(error);
            return errorResult;
        } finally {
            super.cleanup();
            await this.postProcess();
        }
    }

    async nestedTryCatch(request: any): Promise<any> {
        try {
            try {
                await this.validate(request);
                return super.handle(request);
            } catch (validationError) {
                await this.handleValidationError(validationError);
                throw validationError;
            }
        } catch (error) {
            return super.handleError(error as Error);
        }
    }

    private async logSuccess(result: any): Promise<void> {
        await Promise.resolve();
    }

    private async logError(error: any): Promise<void> {
        await Promise.resolve();
    }

    private async preProcess(request: any): Promise<void> {
        await Promise.resolve();
    }

    private async postProcess(): Promise<void> {
        await Promise.resolve();
    }

    private async validate(request: any): Promise<void> {
        if (!request) throw new Error("Invalid request");
    }

    private async handleValidationError(error: any): Promise<void> {
        await Promise.resolve();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("BaseHandler") && output.contains("SafeHandler"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("safeHandle")
            && output.contains("handleWithFinally")
            && output.contains("nestedTryCatch"),
        "Expected methods: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("Promise<any>") && !output.contains("request: any"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with combined async super call patterns
#[test]
fn test_class_es5_combined_async_super_patterns() {
    let source = r#"
class BaseRepository<T> {
    protected items: T[] = [];

    save(item: T): T {
        this.items.push(item);
        return item;
    }

    findAll(): T[] {
        return [...this.items];
    }

    delete(index: number): boolean {
        if (index >= 0 && index < this.items.length) {
            this.items.splice(index, 1);
            return true;
        }
        return false;
    }

    static getRepositoryName(): string {
        return "BaseRepository";
    }
}

class AsyncRepository<T> extends BaseRepository<T> {
    private eventHandlers: ((event: string, data: any) => void)[] = [];

    async saveAsync(item: T): Promise<T> {
        await this.beforeSave(item);
        try {
            const saved = super.save(item);
            await this.afterSave(saved);
            await this.notifyHandlers("save", saved);
            return saved;
        } catch (error) {
            await this.handleError("save", error);
            throw error;
        }
    }

    async findAllAsync(): Promise<T[]> {
        await this.ensureConnection();
        const items = super.findAll();
        await this.logAccess("findAll", items.length);
        return items;
    }

    async deleteAsync(index: number): Promise<boolean> {
        const item = this.items[index];
        await this.beforeDelete(item);
        try {
            const result = super.delete(index);
            if (result) {
                await this.afterDelete(item);
                await this.notifyHandlers("delete", { index, item });
            }
            return result;
        } finally {
            await this.cleanup();
        }
    }

    static async getRepositoryNameAsync(): Promise<string> {
        await Promise.resolve();
        const baseName = super.getRepositoryName();
        return baseName + "Async";
    }

    async batchSave(items: T[]): Promise<T[]> {
        const results: T[] = [];
        for (const item of items) {
            await this.delay(10);
            const saved = super.save(item);
            results.push(saved);
        }
        await this.notifyHandlers("batchSave", results);
        return results;
    }

    private async beforeSave(item: T): Promise<void> {
        await Promise.resolve();
    }

    private async afterSave(item: T): Promise<void> {
        await Promise.resolve();
    }

    private async beforeDelete(item: T): Promise<void> {
        await Promise.resolve();
    }

    private async afterDelete(item: T): Promise<void> {
        await Promise.resolve();
    }

    private async ensureConnection(): Promise<void> {
        await Promise.resolve();
    }

    private async logAccess(operation: string, count: number): Promise<void> {
        await Promise.resolve();
    }

    private async handleError(operation: string, error: any): Promise<void> {
        await Promise.resolve();
    }

    private async cleanup(): Promise<void> {
        await Promise.resolve();
    }

    private async delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    private async notifyHandlers(event: string, data: any): Promise<void> {
        for (const handler of this.eventHandlers) {
            await Promise.resolve();
            handler(event, data);
        }
    }
}

class CachedRepository<T> extends AsyncRepository<T> {
    private cache: Map<string, T[]> = new Map();

    async findAllAsync(): Promise<T[]> {
        const cached = this.cache.get("all");
        if (cached) {
            return cached;
        }
        const items = await super.findAllAsync();
        this.cache.set("all", items);
        return items;
    }

    async saveAsync(item: T): Promise<T> {
        this.cache.delete("all");
        return super.saveAsync(item);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("BaseRepository")
            && output.contains("AsyncRepository")
            && output.contains("CachedRepository"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("saveAsync")
            && output.contains("findAllAsync")
            && output.contains("deleteAsync")
            && output.contains("batchSave"),
        "Expected methods: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("protected items: T[]") && !output.contains("private cache: Map"),
        "Expected type annotations to be stripped: {}",
        output
    );

    // Generic parameters should be stripped
    assert!(
        !output.contains("BaseRepository<T>") && !output.contains("AsyncRepository<T>"),
        "Expected generic parameters to be stripped: {}",
        output
    );
}

// =============================================================================
// GETTER/SETTER THIS BINDING PATTERN TESTS
// =============================================================================

/// Test ES5 class with getter with arrow function returning this
#[test]
fn test_class_es5_getter_arrow_returning_this() {
    let source = r#"
class FluentBuilder {
    private _name: string = "";
    private _value: number = 0;

    get self(): this {
        return this;
    }

    get nameGetter(): () => this {
        return () => this;
    }

    get valueAccessor(): { get: () => number; set: (v: number) => this } {
        return {
            get: () => this._value,
            set: (v: number) => {
                this._value = v;
                return this;
            }
        };
    }

    setName(name: string): this {
        this._name = name;
        return this;
    }
}

class ChainedAccessor<T> {
    private _data: T | null = null;

    get accessor(): { value: () => T | null; chain: () => this } {
        return {
            value: () => this._data,
            chain: () => this
        };
    }

    get lazyThis(): () => this {
        const capturedThis = this;
        return () => capturedThis;
    }

    set data(value: T) {
        this._data = value;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("FluentBuilder") && output.contains("ChainedAccessor"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(output.contains("setName"), "Expected methods: {}", output);

    // Type annotations should be stripped
    assert!(
        !output.contains("private _name: string") && !output.contains("private _data: T"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with setter with nested arrow this
#[test]
fn test_class_es5_setter_nested_arrow_this() {
    let source = r#"
class FormField {
    private _value: string = "";
    private _validators: ((value: string) => boolean)[] = [];
    private _onChange: ((value: string) => void)[] = [];

    get value(): string {
        return this._value;
    }

    set value(newValue: string) {
        const validate = () => {
            const isValid = () => {
                return this._validators.every(v => v(newValue));
            };
            return isValid();
        };

        if (validate()) {
            this._value = newValue;
            const notify = () => {
                this._onChange.forEach(handler => {
                    const safeCall = () => handler(this._value);
                    safeCall();
                });
            };
            notify();
        }
    }

    addValidator(validator: (value: string) => boolean): void {
        this._validators.push(validator);
    }

    onChange(handler: (value: string) => void): void {
        this._onChange.push(handler);
    }
}

class ReactiveProperty<T> {
    private _value: T;
    private _subscriptions: Set<(value: T) => void> = new Set();

    constructor(initial: T) {
        this._value = initial;
    }

    get current(): T {
        return this._value;
    }

    set current(newValue: T) {
        const oldValue = this._value;
        this._value = newValue;

        const broadcast = () => {
            const notify = (subscriber: (value: T) => void) => {
                const dispatch = () => subscriber(this._value);
                dispatch();
            };
            this._subscriptions.forEach(notify);
        };

        if (oldValue !== newValue) {
            broadcast();
        }
    }

    subscribe(callback: (value: T) => void): () => void {
        this._subscriptions.add(callback);
        return () => this._subscriptions.delete(callback);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("FormField") && output.contains("ReactiveProperty"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("addValidator")
            && output.contains("onChange")
            && output.contains("subscribe"),
        "Expected methods: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private _value: string")
            && !output.contains("private _subscriptions: Set"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with computed getter with this access
#[test]
fn test_class_es5_computed_getter_this_access() {
    let source = r#"
const propName = "dynamicValue";
const PREFIX = "computed_";

class ComputedAccessors {
    private data: Record<string, any> = {};

    get [propName](): any {
        return this.data[propName];
    }

    set [propName](value: any) {
        this.data[propName] = value;
    }

    get [PREFIX + "name"](): string {
        return this.data.name ?? "";
    }

    set [PREFIX + "name"](value: string) {
        const process = () => {
            this.data.name = value.trim();
        };
        process();
    }

    get ["get" + "Value"](): () => any {
        return () => this.data;
    }
}

class SymbolAccessors {
    private storage: Map<symbol, any> = new Map();
    static readonly KEY = Symbol("key");

    get [Symbol.toStringTag](): string {
        return "SymbolAccessors";
    }

    get [SymbolAccessors.KEY](): any {
        const retrieve = () => this.storage.get(SymbolAccessors.KEY);
        return retrieve();
    }

    set [SymbolAccessors.KEY](value: any) {
        const store = () => {
            this.storage.set(SymbolAccessors.KEY, value);
        };
        store();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("ComputedAccessors") && output.contains("SymbolAccessors"),
        "Expected classes: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private data: Record") && !output.contains("private storage: Map"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with static getter/setter with this
#[test]
fn test_class_es5_static_getter_setter_this() {
    let source = r#"
class Singleton {
    private static _instance: Singleton | null = null;
    private static _config: Record<string, any> = {};

    static get instance(): Singleton {
        if (!this._instance) {
            this._instance = new Singleton();
        }
        return this._instance;
    }

    static get config(): Record<string, any> {
        const clone = () => ({ ...this._config });
        return clone();
    }

    static set config(newConfig: Record<string, any>) {
        const merge = () => {
            this._config = { ...this._config, ...newConfig };
        };
        merge();
    }

    static get configKeys(): string[] {
        return Object.keys(this._config);
    }
}

class Registry<T> {
    private static _entries: Map<string, any> = new Map();

    static get size(): number {
        return this._entries.size;
    }

    static get all(): [string, any][] {
        const entries: [string, any][] = [];
        const collect = () => {
            this._entries.forEach((value, key) => {
                entries.push([key, value]);
            });
        };
        collect();
        return entries;
    }

    static set entry(pair: [string, any]) {
        const [key, value] = pair;
        const store = () => {
            this._entries.set(key, value);
        };
        store();
    }

    static register(key: string, value: any): void {
        this._entries.set(key, value);
    }

    static get(key: string): any {
        return this._entries.get(key);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Singleton") && output.contains("Registry"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(output.contains("register"), "Expected methods: {}", output);

    // Type annotations should be stripped
    assert!(
        !output.contains("private static _instance: Singleton")
            && !output.contains("private static _entries: Map"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with accessor decorator with this
#[test]
fn test_class_es5_accessor_decorator_this() {
    let source = r#"
function logged(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalGet = descriptor.get;
    const originalSet = descriptor.set;

    if (originalGet) {
        descriptor.get = function(this: any) {
            console.log("Getting " + propertyKey);
            return originalGet.call(this);
        };
    }

    if (originalSet) {
        descriptor.set = function(this: any, value: any) {
            console.log("Setting " + propertyKey + " to " + value);
            originalSet.call(this, value);
        };
    }

    return descriptor;
}

function cached(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalGet = descriptor.get!;
    let cachedValue: any;
    let hasCached = false;

    descriptor.get = function(this: any) {
        if (!hasCached) {
            cachedValue = originalGet.call(this);
            hasCached = true;
        }
        return cachedValue;
    };

    return descriptor;
}

class DecoratedAccessors {
    private _name: string = "";
    private _items: string[] = [];

    @logged
    get name(): string {
        return this._name;
    }

    @logged
    set name(value: string) {
        this._name = value;
    }

    @cached
    get expensiveComputation(): number {
        const compute = () => {
            return this._items.reduce((acc, item) => acc + item.length, 0);
        };
        return compute();
    }

    addItem(item: string): void {
        this._items.push(item);
    }
}

class ValidationAccessors {
    private _value: number = 0;
    private _min: number = 0;
    private _max: number = 100;

    get value(): number {
        const getValue = () => this._value;
        return getValue();
    }

    set value(newValue: number) {
        const clamp = () => {
            const validate = () => {
                if (newValue < this._min) return this._min;
                if (newValue > this._max) return this._max;
                return newValue;
            };
            this._value = validate();
        };
        clamp();
    }

    setBounds(min: number, max: number): void {
        this._min = min;
        this._max = max;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("DecoratedAccessors") && output.contains("ValidationAccessors"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("addItem") && output.contains("setBounds"),
        "Expected methods: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("logged") && output.contains("cached"),
        "Expected decorator functions: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private _name: string") && !output.contains("private _value: number"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with combined getter/setter this patterns
#[test]
fn test_class_es5_combined_getter_setter_this_patterns() {
    let source = r#"
class StateManager<T extends object> {
    private _state: T;
    private _history: T[] = [];
    private _subscribers: Set<(state: T) => void> = new Set();

    constructor(initialState: T) {
        this._state = initialState;
    }

    get state(): T {
        const clone = () => ({ ...this._state });
        return clone();
    }

    set state(newState: T) {
        const commit = () => {
            this._history.push({ ...this._state });
            this._state = { ...newState };
            const notify = () => {
                this._subscribers.forEach(sub => {
                    const dispatch = () => sub(this._state);
                    dispatch();
                });
            };
            notify();
        };
        commit();
    }

    get history(): T[] {
        return [...this._history];
    }

    get canUndo(): boolean {
        return this._history.length > 0;
    }

    get stateAccessor(): { get: () => T; set: (s: T) => void } {
        return {
            get: () => this._state,
            set: (s: T) => { this.state = s; }
        };
    }

    subscribe(callback: (state: T) => void): () => void {
        this._subscribers.add(callback);
        return () => {
            const unsubscribe = () => this._subscribers.delete(callback);
            unsubscribe();
        };
    }

    undo(): boolean {
        if (this.canUndo) {
            const restore = () => {
                this._state = this._history.pop()!;
            };
            restore();
            return true;
        }
        return false;
    }
}

class ComputedStore {
    private _firstName: string = "";
    private _lastName: string = "";
    private _cache: Map<string, any> = new Map();

    get firstName(): string {
        return this._firstName;
    }

    set firstName(value: string) {
        const update = () => {
            this._firstName = value;
            this._cache.delete("fullName");
        };
        update();
    }

    get lastName(): string {
        return this._lastName;
    }

    set lastName(value: string) {
        const update = () => {
            this._lastName = value;
            this._cache.delete("fullName");
        };
        update();
    }

    get fullName(): string {
        const compute = () => {
            if (this._cache.has("fullName")) {
                return this._cache.get("fullName");
            }
            const result = () => {
                const format = () => this._firstName + " " + this._lastName;
                return format().trim();
            };
            const computed = result();
            this._cache.set("fullName", computed);
            return computed;
        };
        return compute();
    }

    static _instances: ComputedStore[] = [];

    static get instances(): ComputedStore[] {
        return [...this._instances];
    }

    static set register(store: ComputedStore) {
        const add = () => {
            this._instances.push(store);
        };
        add();
    }

    static get instanceCount(): number {
        return this._instances.length;
    }
}

class AsyncAccessorPattern {
    private _loading: boolean = false;
    private _data: any = null;
    private _error: Error | null = null;

    get loading(): boolean {
        return this._loading;
    }

    set loading(value: boolean) {
        const update = () => {
            this._loading = value;
            if (value) {
                this._error = null;
            }
        };
        update();
    }

    get data(): any {
        const retrieve = () => this._data;
        return retrieve();
    }

    set data(value: any) {
        const store = () => {
            this._data = value;
            this._loading = false;
        };
        store();
    }

    get error(): Error | null {
        return this._error;
    }

    set error(err: Error | null) {
        const handle = () => {
            this._error = err;
            this._loading = false;
            if (err) {
                this._data = null;
            }
        };
        handle();
    }

    get status(): { loading: boolean; hasData: boolean; hasError: boolean } {
        const compute = () => ({
            loading: this._loading,
            hasData: this._data !== null,
            hasError: this._error !== null
        });
        return compute();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("StateManager")
            && output.contains("ComputedStore")
            && output.contains("AsyncAccessorPattern"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("subscribe") && output.contains("undo"),
        "Expected methods: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private _state: T") && !output.contains("private _cache: Map"),
        "Expected type annotations to be stripped: {}",
        output
    );

    // Generic parameters should be stripped
    assert!(
        !output.contains("StateManager<T"),
        "Expected generic parameters to be stripped: {}",
        output
    );
}

// =============================================================================
// METHOD DECORATOR THIS BINDING PATTERN TESTS
// =============================================================================

/// Test ES5 class with decorated method with this access
#[test]
fn test_class_es5_decorated_method_this_access() {
    let source = r#"
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(this: any, ...args: any[]) {
        console.log("Calling " + propertyKey);
        return original.apply(this, args);
    };
    return descriptor;
}

function bind(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    return {
        configurable: true,
        get(this: any) {
            const bound = original.bind(this);
            Object.defineProperty(this, propertyKey, {
                value: bound,
                configurable: true,
                writable: true
            });
            return bound;
        }
    };
}

class UserService {
    private users: Map<string, any> = new Map();

    @log
    getUser(id: string): any {
        return this.users.get(id);
    }

    @bind
    handleClick(): void {
        const process = () => {
            console.log("Users count:", this.users.size);
        };
        process();
    }

    @log
    addUser(id: string, data: any): void {
        this.users.set(id, data);
    }
}

class DataManager {
    private data: any[] = [];

    @log
    getData(): any[] {
        const retrieve = () => [...this.data];
        return retrieve();
    }

    @log
    setData(items: any[]): void {
        const store = () => {
            this.data = items;
        };
        store();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("UserService") && output.contains("DataManager"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getUser") && output.contains("handleClick") && output.contains("addUser"),
        "Expected methods: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("log") && output.contains("bind"),
        "Expected decorator functions: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private users: Map") && !output.contains("private data: any[]"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with multiple decorators with this
#[test]
fn test_class_es5_multiple_decorators_this() {
    let source = r#"
function first(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(this: any, ...args: any[]) {
        console.log("First decorator - this:", this.constructor.name);
        return original.apply(this, args);
    };
    return descriptor;
}

function second(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(this: any, ...args: any[]) {
        console.log("Second decorator - this:", this.constructor.name);
        return original.apply(this, args);
    };
    return descriptor;
}

function third(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(this: any, ...args: any[]) {
        console.log("Third decorator - this:", this.constructor.name);
        return original.apply(this, args);
    };
    return descriptor;
}

class MultiDecorated {
    private value: number = 0;

    @first
    @second
    @third
    process(): number {
        const compute = () => this.value * 2;
        return compute();
    }

    @first
    @second
    setValue(val: number): void {
        const update = () => {
            this.value = val;
        };
        update();
    }

    @third
    getValue(): number {
        return this.value;
    }
}

class ChainedDecorators {
    private items: string[] = [];

    @first
    @second
    @third
    transform(): string[] {
        const process = () => {
            return this.items.map(item => item.toUpperCase());
        };
        return process();
    }

    addItem(item: string): void {
        this.items.push(item);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("MultiDecorated") && output.contains("ChainedDecorators"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("process")
            && output.contains("setValue")
            && output.contains("getValue")
            && output.contains("transform"),
        "Expected methods: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("first") && output.contains("second") && output.contains("third"),
        "Expected decorator functions: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private value: number") && !output.contains("private items: string[]"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with decorator factory with this binding
#[test]
fn test_class_es5_decorator_factory_this_binding() {
    let source = r#"
function logWithPrefix(prefix: string) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = function(this: any, ...args: any[]) {
            console.log(prefix + " - Calling " + propertyKey + " on " + this.constructor.name);
            return original.apply(this, args);
        };
        return descriptor;
    };
}

function debounce(delay: number) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        let timeout: any;
        descriptor.value = function(this: any, ...args: any[]) {
            clearTimeout(timeout);
            timeout = setTimeout(() => original.apply(this, args), delay);
        };
        return descriptor;
    };
}

function memoize(maxSize: number = 100) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        const cache = new Map<string, any>();
        descriptor.value = function(this: any, ...args: any[]) {
            const key = JSON.stringify(args);
            if (cache.has(key)) {
                return cache.get(key);
            }
            const result = original.apply(this, args);
            if (cache.size >= maxSize) {
                const firstKey = cache.keys().next().value;
                cache.delete(firstKey);
            }
            cache.set(key, result);
            return result;
        };
        return descriptor;
    };
}

class CacheService {
    private store: Map<string, any> = new Map();

    @logWithPrefix("[CACHE]")
    get(key: string): any {
        const retrieve = () => this.store.get(key);
        return retrieve();
    }

    @logWithPrefix("[CACHE]")
    @debounce(100)
    set(key: string, value: any): void {
        const store = () => {
            this.store.set(key, value);
        };
        store();
    }

    @memoize(50)
    compute(input: string): string {
        const process = () => {
            return input.split("").reverse().join("");
        };
        return process();
    }
}

class ApiClient {
    private baseUrl: string;

    constructor(baseUrl: string) {
        this.baseUrl = baseUrl;
    }

    @logWithPrefix("[API]")
    @memoize(10)
    fetch(endpoint: string): string {
        return this.baseUrl + endpoint;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("CacheService") && output.contains("ApiClient"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("compute") && output.contains("fetch"),
        "Expected methods: {}",
        output
    );

    // Decorator factory functions should be present
    assert!(
        output.contains("logWithPrefix")
            && output.contains("debounce")
            && output.contains("memoize"),
        "Expected decorator factory functions: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private store: Map") && !output.contains("private baseUrl: string"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with decorated async method this
#[test]
fn test_class_es5_decorated_async_method_this() {
    let source = r#"
function asyncLog(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = async function(this: any, ...args: any[]) {
        console.log("Before async " + propertyKey);
        const result = await original.apply(this, args);
        console.log("After async " + propertyKey);
        return result;
    };
    return descriptor;
}

function retry(attempts: number) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const original = descriptor.value;
        descriptor.value = async function(this: any, ...args: any[]) {
            for (let i = 0; i < attempts; i++) {
                try {
                    return await original.apply(this, args);
                } catch (error) {
                    if (i === attempts - 1) throw error;
                    await new Promise(r => setTimeout(r, 100));
                }
            }
        };
        return descriptor;
    };
}

class AsyncService {
    private cache: Map<string, any> = new Map();

    @asyncLog
    async fetchData(url: string): Promise<any> {
        const retrieve = async () => {
            if (this.cache.has(url)) {
                return this.cache.get(url);
            }
            const response = await fetch(url);
            const data = await response.json();
            this.cache.set(url, data);
            return data;
        };
        return retrieve();
    }

    @asyncLog
    @retry(3)
    async saveData(key: string, data: any): Promise<void> {
        const store = async () => {
            await Promise.resolve();
            this.cache.set(key, data);
        };
        await store();
    }

    @retry(5)
    async deleteData(key: string): Promise<boolean> {
        const remove = async () => {
            await Promise.resolve();
            return this.cache.delete(key);
        };
        return remove();
    }
}

class DataProcessor {
    private results: any[] = [];

    @asyncLog
    async process(items: any[]): Promise<any[]> {
        const transform = async () => {
            for (const item of items) {
                await Promise.resolve();
                this.results.push(item);
            }
            return this.results;
        };
        return transform();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("AsyncService") && output.contains("DataProcessor"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("fetchData")
            && output.contains("saveData")
            && output.contains("deleteData")
            && output.contains("process"),
        "Expected methods: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("asyncLog") && output.contains("retry"),
        "Expected decorator functions: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private cache: Map") && !output.contains("private results: any[]"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with decorated static method this
#[test]
fn test_class_es5_decorated_static_method_this() {
    let source = r#"
function staticLog(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(this: any, ...args: any[]) {
        console.log("Static method " + propertyKey + " called on " + this.name);
        return original.apply(this, args);
    };
    return descriptor;
}

function singleton(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    let instance: any = null;
    descriptor.value = function(this: any, ...args: any[]) {
        if (!instance) {
            instance = original.apply(this, args);
        }
        return instance;
    };
    return descriptor;
}

class Factory {
    private static _registry: Map<string, any> = new Map();
    private static _count: number = 0;

    @staticLog
    static create(type: string): any {
        const build = () => {
            this._count++;
            return { type, id: this._count };
        };
        return build();
    }

    @staticLog
    static register(name: string, factory: () => any): void {
        const add = () => {
            this._registry.set(name, factory);
        };
        add();
    }

    @singleton
    static getInstance(): Factory {
        return new Factory();
    }

    @staticLog
    static getCount(): number {
        return this._count;
    }
}

class ConfigManager {
    private static _config: Record<string, any> = {};

    @staticLog
    static get(key: string): any {
        const retrieve = () => this._config[key];
        return retrieve();
    }

    @staticLog
    static set(key: string, value: any): void {
        const store = () => {
            this._config[key] = value;
        };
        store();
    }

    @staticLog
    static getAll(): Record<string, any> {
        return { ...this._config };
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Factory") && output.contains("ConfigManager"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("create") && output.contains("register") && output.contains("getInstance"),
        "Expected methods: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("staticLog") && output.contains("singleton"),
        "Expected decorator functions: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private static _registry: Map")
            && !output.contains("private static _config: Record"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with combined decorator this patterns
#[test]
fn test_class_es5_combined_decorator_this_patterns() {
    let source = r#"
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(this: any, ...args: any[]) {
        console.log("Calling " + propertyKey);
        return original.apply(this, args);
    };
    return descriptor;
}

function validate(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(this: any, ...args: any[]) {
        if (args.some(arg => arg === undefined || arg === null)) {
            throw new Error("Invalid arguments");
        }
        return original.apply(this, args);
    };
    return descriptor;
}

function measure(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function(this: any, ...args: any[]) {
        const start = Date.now();
        const result = original.apply(this, args);
        const end = Date.now();
        console.log(propertyKey + " took " + (end - start) + "ms");
        return result;
    };
    return descriptor;
}

function asyncMeasure(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = async function(this: any, ...args: any[]) {
        const start = Date.now();
        const result = await original.apply(this, args);
        const end = Date.now();
        console.log(propertyKey + " took " + (end - start) + "ms");
        return result;
    };
    return descriptor;
}

class CompleteService<T> {
    private items: T[] = [];
    private cache: Map<string, T> = new Map();
    private static _instances: CompleteService<any>[] = [];

    @log
    @validate
    add(item: T): void {
        const insert = () => {
            this.items.push(item);
        };
        insert();
    }

    @log
    @measure
    findAll(): T[] {
        const retrieve = () => {
            return [...this.items];
        };
        return retrieve();
    }

    @log
    @validate
    @measure
    findById(id: string): T | undefined {
        const search = () => {
            if (this.cache.has(id)) {
                return this.cache.get(id);
            }
            return this.items.find((item: any) => item.id === id);
        };
        return search();
    }

    @asyncMeasure
    async fetchRemote(url: string): Promise<T[]> {
        const fetch = async () => {
            await Promise.resolve();
            return this.items;
        };
        return fetch();
    }

    @log
    static register(instance: CompleteService<any>): void {
        const add = () => {
            this._instances.push(instance);
        };
        add();
    }

    @log
    @measure
    static getAll(): CompleteService<any>[] {
        return [...this._instances];
    }
}

class EventEmitter {
    private handlers: Map<string, ((data: any) => void)[]> = new Map();

    @log
    on(event: string, handler: (data: any) => void): void {
        const subscribe = () => {
            const handlers = this.handlers.get(event) ?? [];
            handlers.push(handler);
            this.handlers.set(event, handlers);
        };
        subscribe();
    }

    @log
    @validate
    emit(event: string, data: any): void {
        const dispatch = () => {
            const handlers = this.handlers.get(event) ?? [];
            handlers.forEach(h => {
                const call = () => h(data);
                call();
            });
        };
        dispatch();
    }

    @asyncMeasure
    async emitAsync(event: string, data: any): Promise<void> {
        const asyncDispatch = async () => {
            const handlers = this.handlers.get(event) ?? [];
            for (const h of handlers) {
                await Promise.resolve();
                h(data);
            }
        };
        await asyncDispatch();
    }

    @log
    off(event: string, handler: (data: any) => void): void {
        const unsubscribe = () => {
            const handlers = this.handlers.get(event) ?? [];
            const index = handlers.indexOf(handler);
            if (index !== -1) {
                handlers.splice(index, 1);
            }
        };
        unsubscribe();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("CompleteService") && output.contains("EventEmitter"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("add")
            && output.contains("findAll")
            && output.contains("findById")
            && output.contains("fetchRemote"),
        "Expected methods: {}",
        output
    );

    // Decorator functions should be present
    assert!(
        output.contains("log")
            && output.contains("validate")
            && output.contains("measure")
            && output.contains("asyncMeasure"),
        "Expected decorator functions: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains("private items: T[]") && !output.contains("private handlers: Map"),
        "Expected type annotations to be stripped: {}",
        output
    );

    // Generic parameters should be stripped
    assert!(
        !output.contains("CompleteService<T>"),
        "Expected generic parameters to be stripped: {}",
        output
    );
}

// =============================================================================
// AUTO-ACCESSOR DECORATOR PATTERNS
// =============================================================================

/// Test basic auto-accessor with decorator
#[test]
fn test_class_es5_auto_accessor_basic_decorator() {
    let source = r#"
function logged(target: any, context: ClassAccessorDecoratorContext) {
    return {
        get() {
            console.log("Getting value");
            return target.get.call(this);
        },
        set(value: any) {
            console.log("Setting value:", value);
            target.set.call(this, value);
        }
    };
}

class Counter {
    @logged
    accessor count: number = 0;

    increment(): void {
        this.count++;
    }

    decrement(): void {
        this.count--;
    }

    getCount(): number {
        return this.count;
    }
}

class Temperature {
    @logged
    accessor celsius: number = 0;

    setFahrenheit(f: number): void {
        this.celsius = (f - 32) * 5 / 9;
    }

    getFahrenheit(): number {
        return this.celsius * 9 / 5 + 32;
    }

    getKelvin(): number {
        return this.celsius + 273.15;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Counter class should be ES5 constructor
    assert!(
        output.contains("function Counter") || output.contains("Counter"),
        "Expected Counter class: {}",
        output
    );

    // Temperature class should be ES5 constructor
    assert!(
        output.contains("function Temperature") || output.contains("Temperature"),
        "Expected Temperature class: {}",
        output
    );

    // Decorator function should be present
    assert!(
        output.contains("function logged") || output.contains("logged"),
        "Expected logged decorator: {}",
        output
    );

    // Methods should be present
    assert!(
        output.contains("increment") && output.contains("decrement") && output.contains("getCount"),
        "Expected Counter methods: {}",
        output
    );

    // Temperature methods
    assert!(
        output.contains("setFahrenheit")
            && output.contains("getFahrenheit")
            && output.contains("getKelvin"),
        "Expected Temperature methods: {}",
        output
    );
}

/// Test static auto-accessor with decorator
#[test]
fn test_class_es5_auto_accessor_static_decorator() {
    let source = r#"
function cached(target: any, context: ClassAccessorDecoratorContext) {
    let cachedValue: any = undefined;
    return {
        get() {
            if (cachedValue === undefined) {
                cachedValue = target.get.call(this);
            }
            return cachedValue;
        },
        set(value: any) {
            cachedValue = value;
            target.set.call(this, value);
        }
    };
}

class Configuration {
    @cached
    static accessor apiUrl: string = "https://api.example.com";

    @cached
    static accessor timeout: number = 5000;

    static getApiUrl(): string {
        return Configuration.apiUrl;
    }

    static getTimeout(): number {
        return Configuration.timeout;
    }

    static setApiUrl(url: string): void {
        Configuration.apiUrl = url;
    }

    static setTimeout(ms: number): void {
        Configuration.timeout = ms;
    }
}

class AppState {
    @cached
    static accessor initialized: boolean = false;

    @cached
    static accessor version: string = "1.0.0";

    static initialize(): void {
        AppState.initialized = true;
    }

    static isInitialized(): boolean {
        return AppState.initialized;
    }

    static getVersion(): string {
        return AppState.version;
    }

    static setVersion(v: string): void {
        AppState.version = v;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Configuration class
    assert!(
        output.contains("Configuration"),
        "Expected Configuration class: {}",
        output
    );

    // AppState class
    assert!(
        output.contains("AppState"),
        "Expected AppState class: {}",
        output
    );

    // Cached decorator function
    assert!(
        output.contains("function cached") || output.contains("cached"),
        "Expected cached decorator: {}",
        output
    );

    // Static methods should be present
    assert!(
        output.contains("getApiUrl")
            && output.contains("getTimeout")
            && output.contains("setApiUrl"),
        "Expected Configuration static methods: {}",
        output
    );

    // AppState methods
    assert!(
        output.contains("initialize")
            && output.contains("isInitialized")
            && output.contains("getVersion"),
        "Expected AppState static methods: {}",
        output
    );
}

/// Test auto-accessor with multiple decorators
#[test]
fn test_class_es5_auto_accessor_multiple_decorators() {
    let source = r#"
function validate(min: number, max: number) {
    return function(target: any, context: ClassAccessorDecoratorContext) {
        return {
            get() {
                return target.get.call(this);
            },
            set(value: number) {
                if (value < min || value > max) {
                    throw new Error("Value out of range");
                }
                target.set.call(this, value);
            }
        };
    };
}

function round(target: any, context: ClassAccessorDecoratorContext) {
    return {
        get() {
            return Math.round(target.get.call(this));
        },
        set(value: number) {
            target.set.call(this, value);
        }
    };
}

function clamp(min: number, max: number) {
    return function(target: any, context: ClassAccessorDecoratorContext) {
        return {
            get() {
                return target.get.call(this);
            },
            set(value: number) {
                target.set.call(this, Math.max(min, Math.min(max, value)));
            }
        };
    };
}

class NumberBox {
    @validate(0, 100)
    @round
    accessor value: number = 0;

    getValue(): number {
        return this.value;
    }

    setValue(v: number): void {
        this.value = v;
    }
}

class Slider {
    @clamp(0, 100)
    @round
    accessor position: number = 50;

    getPosition(): number {
        return this.position;
    }

    setPosition(p: number): void {
        this.position = p;
    }

    increment(step: number = 1): void {
        this.position += step;
    }

    decrement(step: number = 1): void {
        this.position -= step;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // NumberBox class
    assert!(
        output.contains("NumberBox"),
        "Expected NumberBox class: {}",
        output
    );

    // Slider class
    assert!(
        output.contains("Slider"),
        "Expected Slider class: {}",
        output
    );

    // Decorator functions
    assert!(
        output.contains("validate") && output.contains("round") && output.contains("clamp"),
        "Expected decorator functions: {}",
        output
    );

    // NumberBox methods
    assert!(
        output.contains("getValue") && output.contains("setValue"),
        "Expected NumberBox methods: {}",
        output
    );

    // Slider methods
    assert!(
        output.contains("getPosition")
            && output.contains("setPosition")
            && output.contains("increment"),
        "Expected Slider methods: {}",
        output
    );
}

/// Test auto-accessor in derived class
#[test]
fn test_class_es5_auto_accessor_derived_class() {
    let source = r#"
function observable(target: any, context: ClassAccessorDecoratorContext) {
    const listeners: Array<(value: any) => void> = [];
    return {
        get() {
            return target.get.call(this);
        },
        set(value: any) {
            target.set.call(this, value);
            listeners.forEach(fn => fn(value));
        }
    };
}

class BaseEntity {
    protected id: string;

    constructor(id: string) {
        this.id = id;
    }

    getId(): string {
        return this.id;
    }
}

class User extends BaseEntity {
    @observable
    accessor name: string = "";

    @observable
    accessor email: string = "";

    constructor(id: string, name: string, email: string) {
        super(id);
        this.name = name;
        this.email = email;
    }

    getName(): string {
        return this.name;
    }

    getEmail(): string {
        return this.email;
    }

    setName(name: string): void {
        this.name = name;
    }

    setEmail(email: string): void {
        this.email = email;
    }
}

class Admin extends User {
    @observable
    accessor role: string = "admin";

    @observable
    accessor permissions: string[] = [];

    constructor(id: string, name: string, email: string) {
        super(id, name, email);
    }

    getRole(): string {
        return this.role;
    }

    getPermissions(): string[] {
        return this.permissions;
    }

    addPermission(perm: string): void {
        this.permissions = [...this.permissions, perm];
    }

    setRole(role: string): void {
        this.role = role;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // BaseEntity should be ES5 constructor
    assert!(
        output.contains("function BaseEntity"),
        "Expected ES5 BaseEntity class: {}",
        output
    );

    // User class
    assert!(output.contains("User"), "Expected User class: {}", output);

    // Admin class
    assert!(output.contains("Admin"), "Expected Admin class: {}", output);

    // Observable decorator
    assert!(
        output.contains("function observable") || output.contains("observable"),
        "Expected observable decorator: {}",
        output
    );

    // Should have __extends pattern
    assert!(
        output.contains("__extends") || output.contains("extendStatics"),
        "Expected __extends helper: {}",
        output
    );

    // User methods
    assert!(
        output.contains("getName") && output.contains("getEmail") && output.contains("setName"),
        "Expected User methods: {}",
        output
    );

    // Admin methods
    assert!(
        output.contains("getRole")
            && output.contains("getPermissions")
            && output.contains("addPermission"),
        "Expected Admin methods: {}",
        output
    );
}

/// Test auto-accessor with initializer
#[test]
fn test_class_es5_auto_accessor_with_initializer() {
    let source = r#"
function lazy(target: any, context: ClassAccessorDecoratorContext) {
    let initialized = false;
    let value: any;
    return {
        get() {
            if (!initialized) {
                value = target.get.call(this);
                initialized = true;
            }
            return value;
        },
        set(newValue: any) {
            value = newValue;
            initialized = true;
            target.set.call(this, newValue);
        }
    };
}

class Settings {
    @lazy
    accessor theme: string = "light";

    @lazy
    accessor fontSize: number = 14;

    @lazy
    accessor notifications: boolean = true;

    getTheme(): string {
        return this.theme;
    }

    getFontSize(): number {
        return this.fontSize;
    }

    areNotificationsEnabled(): boolean {
        return this.notifications;
    }

    setTheme(theme: string): void {
        this.theme = theme;
    }

    setFontSize(size: number): void {
        this.fontSize = size;
    }

    toggleNotifications(): void {
        this.notifications = !this.notifications;
    }
}

class Cache {
    @lazy
    accessor data: Map<string, any> = new Map();

    @lazy
    accessor maxSize: number = 1000;

    @lazy
    accessor ttl: number = 60000;

    get(key: string): any {
        return this.data.get(key);
    }

    set(key: string, value: any): void {
        this.data.set(key, value);
    }

    has(key: string): boolean {
        return this.data.has(key);
    }

    clear(): void {
        this.data.clear();
    }

    getMaxSize(): number {
        return this.maxSize;
    }

    getTtl(): number {
        return this.ttl;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Settings class
    assert!(
        output.contains("Settings"),
        "Expected Settings class: {}",
        output
    );

    // Cache class
    assert!(output.contains("Cache"), "Expected Cache class: {}", output);

    // Lazy decorator
    assert!(
        output.contains("function lazy") || output.contains("lazy"),
        "Expected lazy decorator: {}",
        output
    );

    // Settings methods
    assert!(
        output.contains("getTheme")
            && output.contains("getFontSize")
            && output.contains("toggleNotifications"),
        "Expected Settings methods: {}",
        output
    );

    // Cache methods
    assert!(
        output.contains("get")
            && output.contains("set")
            && output.contains("has")
            && output.contains("clear"),
        "Expected Cache methods: {}",
        output
    );

    // Initializer values should be present
    assert!(
        output.contains("\"light\"") || output.contains("14") || output.contains("1000"),
        "Expected initializer values: {}",
        output
    );
}

/// Test combined auto-accessor patterns
#[test]
fn test_class_es5_auto_accessor_combined_patterns() {
    let source = r#"
function track(name: string) {
    return function(target: any, context: ClassAccessorDecoratorContext) {
        return {
            get() {
                console.log("Read:", name);
                return target.get.call(this);
            },
            set(value: any) {
                console.log("Write:", name, value);
                target.set.call(this, value);
            }
        };
    };
}

function readonly(target: any, context: ClassAccessorDecoratorContext) {
    let value: any;
    let initialized = false;
    return {
        get() {
            return value ?? target.get.call(this);
        },
        set(newValue: any) {
            if (!initialized) {
                value = newValue;
                initialized = true;
            }
        }
    };
}

function memoize(target: any, context: ClassAccessorDecoratorContext) {
    const cache = new WeakMap();
    return {
        get() {
            if (!cache.has(this)) {
                cache.set(this, target.get.call(this));
            }
            return cache.get(this);
        },
        set(value: any) {
            cache.set(this, value);
            target.set.call(this, value);
        }
    };
}

class Document {
    @readonly
    accessor id: string = "";

    @track("title")
    accessor title: string = "Untitled";

    @track("content")
    @memoize
    accessor content: string = "";

    @track("version")
    static accessor version: string = "1.0";

    constructor(id: string) {
        this.id = id;
    }

    getId(): string {
        return this.id;
    }

    getTitle(): string {
        return this.title;
    }

    getContent(): string {
        return this.content;
    }

    setTitle(title: string): void {
        this.title = title;
    }

    setContent(content: string): void {
        this.content = content;
    }

    static getVersion(): string {
        return Document.version;
    }
}

class Store<T> {
    @track("state")
    accessor state: T;

    @track("subscribers")
    accessor subscribers: Array<(state: T) => void> = [];

    constructor(initialState: T) {
        this.state = initialState;
    }

    getState(): T {
        return this.state;
    }

    setState(newState: T): void {
        this.state = newState;
        this.notify();
    }

    subscribe(fn: (state: T) => void): void {
        this.subscribers = [...this.subscribers, fn];
    }

    private notify(): void {
        this.subscribers.forEach(fn => fn(this.state));
    }

    getSubscriberCount(): number {
        return this.subscribers.length;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Document class
    assert!(
        output.contains("Document"),
        "Expected Document class: {}",
        output
    );

    // Store class
    assert!(output.contains("Store"), "Expected Store class: {}", output);

    // Decorator functions
    assert!(
        output.contains("track") && output.contains("readonly") && output.contains("memoize"),
        "Expected decorator functions: {}",
        output
    );

    // Document methods
    assert!(
        output.contains("getId")
            && output.contains("getTitle")
            && output.contains("getContent")
            && output.contains("setTitle"),
        "Expected Document methods: {}",
        output
    );

    // Store methods
    assert!(
        output.contains("getState")
            && output.contains("setState")
            && output.contains("subscribe")
            && output.contains("getSubscriberCount"),
        "Expected Store methods: {}",
        output
    );

    // Static method
    assert!(
        output.contains("getVersion"),
        "Expected Document.getVersion static method: {}",
        output
    );

    // Initializer strings
    assert!(
        output.contains("\"Untitled\"") || output.contains("\"1.0\""),
        "Expected initializer strings: {}",
        output
    );
}

// =============================================================================
// MIXIN PATTERN VARIATION TESTS
// =============================================================================

/// Test ES5 class with basic mixin function
#[test]
fn test_class_es5_basic_mixin_function() {
    let source = r#"
type Constructor<T = {}> = new (...args: any[]) => T;

function Timestamped<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        timestamp = Date.now();

        getTimestamp(): number {
            return this.timestamp;
        }
    };
}

function Named<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        name: string = "";

        setName(name: string): void {
            this.name = name;
        }

        getName(): string {
            return this.name;
        }
    };
}

class BaseEntity {
    id: string;

    constructor(id: string) {
        this.id = id;
    }

    getId(): string {
        return this.id;
    }
}

const TimestampedEntity = Timestamped(BaseEntity);
const NamedEntity = Named(BaseEntity);

class User extends Timestamped(Named(BaseEntity)) {
    email: string;

    constructor(id: string, email: string) {
        super(id);
        this.email = email;
    }

    getEmail(): string {
        return this.email;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("BaseEntity") && output.contains("User"),
        "Expected classes: {}",
        output
    );

    // Mixin functions should exist
    assert!(
        output.contains("Timestamped") && output.contains("Named"),
        "Expected mixin functions: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getId") && output.contains("getEmail"),
        "Expected methods: {}",
        output
    );

    // Type alias should be stripped
    assert!(
        !output.contains("type Constructor"),
        "Expected type alias to be stripped: {}",
        output
    );
}

/// Test ES5 class with mixin with static members
#[test]
fn test_class_es5_mixin_static_members() {
    let source = r#"
type Constructor<T = {}> = new (...args: any[]) => T;

function WithRegistry<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        static registry: Map<string, any> = new Map();
        static instanceCount: number = 0;

        static register(key: string, instance: any): void {
            this.registry.set(key, instance);
            this.instanceCount++;
        }

        static get(key: string): any {
            return this.registry.get(key);
        }

        static getCount(): number {
            return this.instanceCount;
        }
    };
}

function WithFactory<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        static instances: any[] = [];

        static create(...args: any[]): any {
            const instance = new this(...args);
            this.instances.push(instance);
            return instance;
        }

        static getAll(): any[] {
            return [...this.instances];
        }

        static clear(): void {
            this.instances = [];
        }
    };
}

class Service {
    name: string;

    constructor(name: string) {
        this.name = name;
    }

    getName(): string {
        return this.name;
    }
}

class RegisteredService extends WithRegistry(Service) {
    constructor(name: string) {
        super(name);
    }
}

class FactoryService extends WithFactory(WithRegistry(Service)) {
    constructor(name: string) {
        super(name);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Service")
            && output.contains("RegisteredService")
            && output.contains("FactoryService"),
        "Expected classes: {}",
        output
    );

    // Mixin functions should exist
    assert!(
        output.contains("WithRegistry") && output.contains("WithFactory"),
        "Expected mixin functions: {}",
        output
    );

    // Methods should exist
    assert!(output.contains("getName"), "Expected methods: {}", output);
}

/// Test ES5 class with multiple mixins composition
#[test]
fn test_class_es5_multiple_mixins_composition() {
    let source = r#"
type Constructor<T = {}> = new (...args: any[]) => T;

function Serializable<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        serialize(): string {
            return JSON.stringify(this);
        }

        static deserialize(json: string): any {
            return JSON.parse(json);
        }
    };
}

function Validatable<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        errors: string[] = [];

        validate(): boolean {
            this.errors = [];
            return this.errors.length === 0;
        }

        addError(error: string): void {
            this.errors.push(error);
        }

        getErrors(): string[] {
            return [...this.errors];
        }
    };
}

function Observable<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        observers: ((data: any) => void)[] = [];

        subscribe(observer: (data: any) => void): () => void {
            this.observers.push(observer);
            return () => {
                const index = this.observers.indexOf(observer);
                if (index !== -1) {
                    this.observers.splice(index, 1);
                }
            };
        }

        notify(data: any): void {
            this.observers.forEach(obs => obs(data));
        }
    };
}

class DataModel {
    data: Record<string, any> = {};

    get(key: string): any {
        return this.data[key];
    }

    set(key: string, value: any): void {
        this.data[key] = value;
    }
}

class EnhancedModel extends Observable(Validatable(Serializable(DataModel))) {
    setAndNotify(key: string, value: any): void {
        this.set(key, value);
        this.notify({ key, value });
    }
}

class FormModel extends Validatable(Observable(DataModel)) {
    submit(): boolean {
        if (this.validate()) {
            this.notify({ type: "submit", data: this.data });
            return true;
        }
        return false;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("DataModel")
            && output.contains("EnhancedModel")
            && output.contains("FormModel"),
        "Expected classes: {}",
        output
    );

    // Mixin functions should exist
    assert!(
        output.contains("Serializable")
            && output.contains("Validatable")
            && output.contains("Observable"),
        "Expected mixin functions: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("setAndNotify") && output.contains("submit"),
        "Expected methods: {}",
        output
    );
}

/// Test ES5 class with generic mixin constraints
#[test]
fn test_class_es5_generic_mixin_constraints() {
    let source = r#"
type Constructor<T = {}> = new (...args: any[]) => T;

interface Identifiable {
    id: string;
}

interface Nameable {
    name: string;
}

function WithId<TBase extends Constructor<Identifiable>>(Base: TBase) {
    return class extends Base {
        getShortId(): string {
            return this.id.substring(0, 8);
        }

        matchesId(otherId: string): boolean {
            return this.id === otherId;
        }
    };
}

function WithDisplayName<TBase extends Constructor<Nameable>>(Base: TBase) {
    return class extends Base {
        getDisplayName(): string {
            return this.name.toUpperCase();
        }

        hasName(): boolean {
            return this.name.length > 0;
        }
    };
}

function WithFullInfo<TBase extends Constructor<Identifiable & Nameable>>(Base: TBase) {
    return class extends Base {
        getFullInfo(): string {
            return this.id + ": " + this.name;
        }

        toJSON(): object {
            return { id: this.id, name: this.name };
        }
    };
}

class Entity implements Identifiable, Nameable {
    id: string;
    name: string;

    constructor(id: string, name: string) {
        this.id = id;
        this.name = name;
    }
}

class EnhancedEntity extends WithFullInfo(WithDisplayName(WithId(Entity))) {
    description: string = "";

    setDescription(desc: string): void {
        this.description = desc;
    }

    getDescription(): string {
        return this.description;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Entity") && output.contains("EnhancedEntity"),
        "Expected classes: {}",
        output
    );

    // Mixin functions should exist
    assert!(
        output.contains("WithId")
            && output.contains("WithDisplayName")
            && output.contains("WithFullInfo"),
        "Expected mixin functions: {}",
        output
    );

    // Interfaces should be stripped
    assert!(
        !output.contains("interface Identifiable") && !output.contains("interface Nameable"),
        "Expected interfaces to be stripped: {}",
        output
    );
}

/// Test ES5 class with mixin with private fields
#[test]
fn test_class_es5_mixin_private_fields() {
    let source = r#"
type Constructor<T = {}> = new (...args: any[]) => T;

function WithCache<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        private _cache: Map<string, any> = new Map();

        protected getCached(key: string): any {
            return this._cache.get(key);
        }

        protected setCached(key: string, value: any): void {
            this._cache.set(key, value);
        }

        protected hasCached(key: string): boolean {
            return this._cache.has(key);
        }

        clearCache(): void {
            this._cache.clear();
        }
    };
}

function WithLogger<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        private _logs: string[] = [];
        private _logLevel: string = "info";

        protected log(message: string): void {
            this._logs.push("[" + this._logLevel + "] " + message);
        }

        setLogLevel(level: string): void {
            this._logLevel = level;
        }

        getLogs(): string[] {
            return [...this._logs];
        }

        clearLogs(): void {
            this._logs = [];
        }
    };
}

function WithState<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        private _state: Record<string, any> = {};
        private _history: Record<string, any>[] = [];

        protected getState(): Record<string, any> {
            return { ...this._state };
        }

        protected setState(newState: Record<string, any>): void {
            this._history.push({ ...this._state });
            this._state = { ...this._state, ...newState };
        }

        undo(): boolean {
            if (this._history.length > 0) {
                this._state = this._history.pop()!;
                return true;
            }
            return false;
        }

        getHistoryLength(): number {
            return this._history.length;
        }
    };
}

class Component {
    element: string;

    constructor(element: string) {
        this.element = element;
    }

    getElement(): string {
        return this.element;
    }
}

class StatefulComponent extends WithState(WithLogger(WithCache(Component))) {
    render(): void {
        const state = this.getState();
        this.log("Rendering with state: " + JSON.stringify(state));
    }

    update(data: Record<string, any>): void {
        if (!this.hasCached("lastUpdate")) {
            this.setCached("lastUpdate", Date.now());
        }
        this.setState(data);
        this.log("Updated state");
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Component") && output.contains("StatefulComponent"),
        "Expected classes: {}",
        output
    );

    // Mixin functions should exist
    assert!(
        output.contains("WithCache")
            && output.contains("WithLogger")
            && output.contains("WithState"),
        "Expected mixin functions: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("render") && output.contains("update") && output.contains("undo"),
        "Expected methods: {}",
        output
    );

    // Private field declarations should be stripped
    assert!(
        !output.contains("private _cache:") && !output.contains("private _logs:"),
        "Expected private field declarations to be stripped: {}",
        output
    );
}

/// Test ES5 class with combined mixin patterns
#[test]
fn test_class_es5_combined_mixin_patterns() {
    let source = r#"
type Constructor<T = {}> = new (...args: any[]) => T;

interface Disposable {
    dispose(): void;
}

function Activatable<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        isActive: boolean = false;

        activate(): void {
            const process = () => {
                this.isActive = true;
            };
            process();
        }

        deactivate(): void {
            const process = () => {
                this.isActive = false;
            };
            process();
        }

        toggle(): void {
            this.isActive = !this.isActive;
        }
    };
}

function Lockable<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        private locked: boolean = false;

        lock(): void {
            this.locked = true;
        }

        unlock(): void {
            this.locked = false;
        }

        isLocked(): boolean {
            return this.locked;
        }

        withLock<T>(fn: () => T): T {
            this.lock();
            try {
                return fn();
            } finally {
                this.unlock();
            }
        }
    };
}

function Taggable<TBase extends Constructor>(Base: TBase) {
    return class extends Base {
        private tags: Set<string> = new Set();

        addTag(tag: string): void {
            this.tags.add(tag);
        }

        removeTag(tag: string): boolean {
            return this.tags.delete(tag);
        }

        hasTag(tag: string): boolean {
            return this.tags.has(tag);
        }

        getTags(): string[] {
            return Array.from(this.tags);
        }

        clearTags(): void {
            this.tags.clear();
        }
    };
}

function DisposableMixin<TBase extends Constructor>(Base: TBase) {
    return class extends Base implements Disposable {
        private disposed: boolean = false;
        private disposables: (() => void)[] = [];

        registerDisposable(fn: () => void): void {
            this.disposables.push(fn);
        }

        dispose(): void {
            if (!this.disposed) {
                this.disposables.forEach(d => d());
                this.disposables = [];
                this.disposed = true;
            }
        }

        isDisposed(): boolean {
            return this.disposed;
        }
    };
}

class Resource {
    name: string;
    private data: any;

    constructor(name: string) {
        this.name = name;
        this.data = {};
    }

    getName(): string {
        return this.name;
    }

    getData(): any {
        return this.data;
    }

    setData(data: any): void {
        this.data = data;
    }
}

class ManagedResource extends DisposableMixin(Taggable(Lockable(Activatable(Resource)))) {
    private connections: any[] = [];

    constructor(name: string) {
        super(name);
        this.registerDisposable(() => {
            this.connections = [];
            this.deactivate();
        });
    }

    connect(target: any): void {
        const process = () => {
            if (!this.isLocked()) {
                this.connections.push(target);
                this.addTag("connected");
            }
        };
        process();
    }

    disconnect(): void {
        this.withLock(() => {
            this.connections = [];
            this.removeTag("connected");
        });
    }

    getConnectionCount(): number {
        return this.connections.length;
    }
}

class SecureResource extends Lockable(DisposableMixin(Resource)) {
    secureData: string = "";

    setSecureData(data: string): void {
        this.withLock(() => {
            this.secureData = data;
        });
    }

    getSecureData(): string {
        if (this.isLocked()) {
            return "";
        }
        return this.secureData;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Resource")
            && output.contains("ManagedResource")
            && output.contains("SecureResource"),
        "Expected classes: {}",
        output
    );

    // Mixin functions should exist
    assert!(
        output.contains("Activatable")
            && output.contains("Lockable")
            && output.contains("Taggable")
            && output.contains("DisposableMixin"),
        "Expected mixin functions: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("connect") && output.contains("disconnect") && output.contains("dispose"),
        "Expected methods: {}",
        output
    );

    // Interface should be stripped
    assert!(
        !output.contains("interface Disposable"),
        "Expected interface to be stripped: {}",
        output
    );

    // Type alias should be stripped
    assert!(
        !output.contains("type Constructor"),
        "Expected type alias to be stripped: {}",
        output
    );
}

// =============================================================================
// NEW.TARGET META-PROPERTY PATTERN TESTS
// =============================================================================

/// Test ES5 class with basic new.target in constructor
#[test]
fn test_class_es5_basic_new_target_constructor() {
    let source = r#"
class Shape {
    name: string;

    constructor() {
        if (new.target === Shape) {
            throw new Error("Shape is abstract");
        }
        this.name = new.target.name;
    }

    getName(): string {
        return this.name;
    }
}

class Circle extends Shape {
    radius: number;

    constructor(radius: number) {
        super();
        this.radius = radius;
    }

    getArea(): number {
        return Math.PI * this.radius * this.radius;
    }
}

class Rectangle extends Shape {
    width: number;
    height: number;

    constructor(width: number, height: number) {
        super();
        this.width = width;
        this.height = height;
    }

    getArea(): number {
        return this.width * this.height;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Shape") && output.contains("Circle") && output.contains("Rectangle"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getName") && output.contains("getArea"),
        "Expected methods: {}",
        output
    );
}

/// Test ES5 class with new.target in derived class
#[test]
fn test_class_es5_new_target_derived_class() {
    let source = r#"
class BaseComponent {
    componentName: string;
    isBase: boolean;

    constructor() {
        this.componentName = new.target.name;
        this.isBase = new.target === BaseComponent;
    }

    getInfo(): string {
        return this.componentName + (this.isBase ? " (base)" : " (derived)");
    }
}

class Button extends BaseComponent {
    label: string;

    constructor(label: string) {
        super();
        this.label = label;
    }

    render(): string {
        return "<button>" + this.label + "</button>";
    }
}

class IconButton extends Button {
    icon: string;

    constructor(label: string, icon: string) {
        super(label);
        this.icon = icon;
    }

    render(): string {
        return "<button>" + this.icon + " " + this.label + "</button>";
    }
}

class Input extends BaseComponent {
    type: string;
    value: string;

    constructor(type: string) {
        super();
        this.type = type;
        this.value = "";
    }

    render(): string {
        return "<input type=\"" + this.type + "\" />";
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("BaseComponent")
            && output.contains("Button")
            && output.contains("IconButton")
            && output.contains("Input"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getInfo") && output.contains("render"),
        "Expected methods: {}",
        output
    );
}

/// Test ES5 class with new.target with abstract pattern
#[test]
fn test_class_es5_new_target_abstract_service_pattern() {
    let source = r#"
class AbstractService {
    serviceName: string;
    private initialized: boolean = false;

    constructor() {
        if (new.target === AbstractService) {
            throw new TypeError("Cannot instantiate abstract class AbstractService");
        }
        this.serviceName = new.target.name;
    }

    protected init(): void {
        if (this.initialized) {
            throw new Error("Already initialized");
        }
        this.initialized = true;
    }

    isInitialized(): boolean {
        return this.initialized;
    }

    abstract process(data: any): any;
}

class DataService extends AbstractService {
    private data: any[] = [];

    constructor() {
        super();
        this.init();
    }

    process(data: any): any {
        this.data.push(data);
        return data;
    }

    getAll(): any[] {
        return [...this.data];
    }
}

class CacheService extends AbstractService {
    private cache: Map<string, any> = new Map();

    constructor() {
        super();
        this.init();
    }

    process(data: any): any {
        const key = JSON.stringify(data);
        if (!this.cache.has(key)) {
            this.cache.set(key, data);
        }
        return this.cache.get(key);
    }

    clear(): void {
        this.cache.clear();
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("AbstractService")
            && output.contains("DataService")
            && output.contains("CacheService"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("process") && output.contains("isInitialized"),
        "Expected methods: {}",
        output
    );

    // Abstract keyword should be stripped
    assert!(
        !output.contains("abstract process"),
        "Expected abstract keyword to be stripped: {}",
        output
    );
}

/// Test ES5 class with new.target in factory function
#[test]
fn test_class_es5_new_target_factory_function() {
    let source = r#"
class Entity {
    id: string;
    createdBy: string;

    constructor(id: string) {
        this.id = id;
        this.createdBy = new.target ? new.target.name : "factory";
    }

    static create(id: string): Entity {
        return new Entity(id);
    }

    getCreator(): string {
        return this.createdBy;
    }
}

class User extends Entity {
    name: string;

    constructor(id: string, name: string) {
        super(id);
        this.name = name;
    }

    static createUser(id: string, name: string): User {
        return new User(id, name);
    }
}

class Product extends Entity {
    title: string;
    price: number;

    constructor(id: string, title: string, price: number) {
        super(id);
        this.title = title;
        this.price = price;
    }

    static createProduct(id: string, title: string, price: number): Product {
        return new Product(id, title, price);
    }

    getInfo(): string {
        return this.title + " - $" + this.price;
    }
}

function createEntity(id: string): Entity {
    return new Entity(id);
}

function createTypedEntity<T extends Entity>(
    Ctor: new (id: string) => T,
    id: string
): T {
    return new Ctor(id);
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Entity") && output.contains("User") && output.contains("Product"),
        "Expected classes: {}",
        output
    );

    // Factory functions should exist
    assert!(
        output.contains("createEntity") && output.contains("createTypedEntity"),
        "Expected factory functions: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getCreator") && output.contains("getInfo"),
        "Expected methods: {}",
        output
    );
}

/// Test ES5 class with new.target with instanceof check
#[test]
fn test_class_es5_new_target_instanceof_check() {
    let source = r#"
class Singleton {
    private static instance: Singleton | null = null;
    name: string;

    constructor() {
        if (new.target === Singleton) {
            if (Singleton.instance) {
                return Singleton.instance;
            }
            Singleton.instance = this;
        }
        this.name = new.target.name;
    }

    static getInstance(): Singleton {
        if (!Singleton.instance) {
            new Singleton();
        }
        return Singleton.instance!;
    }

    getName(): string {
        return this.name;
    }
}

class ExtendedSingleton extends Singleton {
    value: number;

    constructor(value: number) {
        super();
        this.value = value;
    }

    getValue(): number {
        return this.value;
    }
}

class TypeChecker {
    targetName: string;
    isDirectInstantiation: boolean;

    constructor() {
        this.targetName = new.target.name;
        this.isDirectInstantiation = new.target === TypeChecker;
    }

    checkType(): string {
        if (this.isDirectInstantiation) {
            return "Direct TypeChecker instance";
        }
        return "Instance of " + this.targetName;
    }
}

class DerivedChecker extends TypeChecker {
    category: string;

    constructor(category: string) {
        super();
        this.category = category;
    }

    getCategory(): string {
        return this.category;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Singleton")
            && output.contains("ExtendedSingleton")
            && output.contains("TypeChecker")
            && output.contains("DerivedChecker"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getInstance")
            && output.contains("getName")
            && output.contains("checkType"),
        "Expected methods: {}",
        output
    );
}

/// Test ES5 class with combined new.target patterns
#[test]
fn test_class_es5_combined_new_target_patterns() {
    let source = r#"
class AbstractFactory<T> {
    factoryName: string;
    productType: string;

    constructor() {
        if (new.target === AbstractFactory) {
            throw new Error("AbstractFactory cannot be instantiated directly");
        }
        this.factoryName = new.target.name;
        this.productType = "";
    }

    abstract create(...args: any[]): T;

    getFactoryInfo(): string {
        return this.factoryName + " produces " + this.productType;
    }
}

interface Vehicle {
    brand: string;
    model: string;
    start(): void;
}

class Car implements Vehicle {
    brand: string;
    model: string;

    constructor(brand: string, model: string) {
        this.brand = brand;
        this.model = model;
    }

    start(): void {
        console.log("Starting car: " + this.brand + " " + this.model);
    }
}

class CarFactory extends AbstractFactory<Car> {
    constructor() {
        super();
        this.productType = "Car";
    }

    create(brand: string, model: string): Car {
        return new Car(brand, model);
    }
}

class Motorcycle implements Vehicle {
    brand: string;
    model: string;
    cc: number;

    constructor(brand: string, model: string, cc: number) {
        this.brand = brand;
        this.model = model;
        this.cc = cc;
    }

    start(): void {
        console.log("Starting motorcycle: " + this.brand + " " + this.model);
    }
}

class MotorcycleFactory extends AbstractFactory<Motorcycle> {
    constructor() {
        super();
        this.productType = "Motorcycle";
    }

    create(brand: string, model: string, cc: number): Motorcycle {
        return new Motorcycle(brand, model, cc);
    }
}

class ServiceRegistry {
    private static services: Map<string, any> = new Map();
    serviceName: string;
    registeredAt: number;

    constructor() {
        this.serviceName = new.target.name;
        this.registeredAt = Date.now();

        const existing = ServiceRegistry.services.get(this.serviceName);
        if (existing && new.target === existing.constructor) {
            return existing;
        }

        ServiceRegistry.services.set(this.serviceName, this);
    }

    static getService<T extends ServiceRegistry>(name: string): T | undefined {
        return ServiceRegistry.services.get(name) as T | undefined;
    }

    static clearAll(): void {
        ServiceRegistry.services.clear();
    }

    getRegistrationTime(): number {
        return this.registeredAt;
    }
}

class AuthService extends ServiceRegistry {
    private token: string | null = null;

    login(username: string, password: string): boolean {
        this.token = "token_" + username;
        return true;
    }

    logout(): void {
        this.token = null;
    }

    isAuthenticated(): boolean {
        return this.token !== null;
    }
}

class DataService extends ServiceRegistry {
    private data: any[] = [];

    add(item: any): void {
        this.data.push(item);
    }

    getAll(): any[] {
        return [...this.data];
    }

    clear(): void {
        this.data = [];
    }
}

class Logger {
    level: string;
    prefix: string;
    createdViaNew: boolean;

    constructor(level: string = "info") {
        this.level = level;
        this.prefix = new.target ? "[" + new.target.name + "]" : "[Logger]";
        this.createdViaNew = !!new.target;
    }

    log(message: string): void {
        console.log(this.prefix + " [" + this.level + "] " + message);
    }

    static create(level: string): Logger {
        return new Logger(level);
    }
}

class DebugLogger extends Logger {
    debugInfo: boolean = true;

    constructor() {
        super("debug");
    }

    debug(message: string): void {
        if (this.debugInfo) {
            this.log("[DEBUG] " + message);
        }
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("AbstractFactory")
            && output.contains("CarFactory")
            && output.contains("MotorcycleFactory"),
        "Expected factory classes: {}",
        output
    );

    assert!(
        output.contains("ServiceRegistry")
            && output.contains("AuthService")
            && output.contains("DataService"),
        "Expected service classes: {}",
        output
    );

    assert!(
        output.contains("Logger") && output.contains("DebugLogger"),
        "Expected logger classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("create")
            && output.contains("getFactoryInfo")
            && output.contains("getService"),
        "Expected methods: {}",
        output
    );

    // Interface should be stripped
    assert!(
        !output.contains("interface Vehicle"),
        "Expected interface to be stripped: {}",
        output
    );

    // Generic parameter should be stripped
    assert!(
        !output.contains("AbstractFactory<T>"),
        "Expected generic parameter to be stripped: {}",
        output
    );
}

/// Test ES5 class with private field via WeakMap pattern
#[test]
fn test_class_es5_weakmap_private_field_pattern() {
    let source = r#"
class SecureContainer {
    #secret: string;
    #counter: number = 0;

    constructor(secret: string) {
        this.#secret = secret;
    }

    getSecret(): string {
        this.#counter++;
        return this.#secret;
    }

    getAccessCount(): number {
        return this.#counter;
    }

    updateSecret(newSecret: string): void {
        this.#secret = newSecret;
        this.#counter = 0;
    }
}

class TokenVault {
    #tokens: Map<string, string> = new Map();
    #lastAccess: Date | null = null;

    addToken(key: string, token: string): void {
        this.#tokens.set(key, token);
        this.#lastAccess = new Date();
    }

    getToken(key: string): string | undefined {
        this.#lastAccess = new Date();
        return this.#tokens.get(key);
    }

    hasToken(key: string): boolean {
        return this.#tokens.has(key);
    }

    getLastAccess(): Date | null {
        return this.#lastAccess;
    }
}

const container = new SecureContainer("mySecret");
const vault = new TokenVault();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("SecureContainer") && output.contains("TokenVault"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getSecret")
            && output.contains("getAccessCount")
            && output.contains("updateSecret"),
        "Expected SecureContainer methods: {}",
        output
    );

    assert!(
        output.contains("addToken") && output.contains("getToken") && output.contains("hasToken"),
        "Expected TokenVault methods: {}",
        output
    );

    // Private field syntax should be transformed
    assert!(
        !output.contains("#secret") && !output.contains("#counter") && !output.contains("#tokens"),
        "Expected private fields to be transformed: {}",
        output
    );
}

/// Test ES5 class with static private via WeakMap pattern
#[test]
fn test_class_es5_weakmap_static_private_pattern() {
    let source = r#"
class Configuration {
    static #instance: Configuration | null = null;
    static #settings: Map<string, any> = new Map();

    #localSettings: Map<string, any> = new Map();

    private constructor() {}

    static getInstance(): Configuration {
        if (Configuration.#instance === null) {
            Configuration.#instance = new Configuration();
        }
        return Configuration.#instance;
    }

    static setSetting(key: string, value: any): void {
        Configuration.#settings.set(key, value);
    }

    static getSetting(key: string): any {
        return Configuration.#settings.get(key);
    }

    setLocalSetting(key: string, value: any): void {
        this.#localSettings.set(key, value);
    }

    getLocalSetting(key: string): any {
        return this.#localSettings.get(key);
    }
}

class ConnectionPool {
    static #pool: any[] = [];
    static #maxSize: number = 10;

    static acquire(): any | null {
        if (ConnectionPool.#pool.length > 0) {
            return ConnectionPool.#pool.pop();
        }
        return null;
    }

    static release(connection: any): void {
        if (ConnectionPool.#pool.length < ConnectionPool.#maxSize) {
            ConnectionPool.#pool.push(connection);
        }
    }

    static getPoolSize(): number {
        return ConnectionPool.#pool.length;
    }
}

const config = Configuration.getInstance();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Configuration") && output.contains("ConnectionPool"),
        "Expected classes: {}",
        output
    );

    // Static methods should exist
    assert!(
        output.contains("getInstance")
            && output.contains("setSetting")
            && output.contains("getSetting"),
        "Expected Configuration static methods: {}",
        output
    );

    assert!(
        output.contains("acquire") && output.contains("release") && output.contains("getPoolSize"),
        "Expected ConnectionPool static methods: {}",
        output
    );

    // Instance private field should be transformed to WeakMap
    assert!(
        output.contains("_Configuration_localSettings") || output.contains("localSettings"),
        "Expected instance private field to be handled: {}",
        output
    );
}

/// Test ES5 class with private method via WeakMap pattern
#[test]
fn test_class_es5_weakmap_private_method_pattern() {
    let source = r#"
class Validator {
    #rules: Map<string, (value: any) => boolean> = new Map();

    #validateRequired(value: any): boolean {
        return value !== null && value !== undefined;
    }

    #validateString(value: any): boolean {
        return typeof value === 'string';
    }

    #validateNumber(value: any): boolean {
        return typeof value === 'number' && !isNaN(value);
    }

    addRule(name: string, rule: (value: any) => boolean): void {
        this.#rules.set(name, rule);
    }

    validate(value: any, ruleName: string): boolean {
        switch (ruleName) {
            case 'required':
                return this.#validateRequired(value);
            case 'string':
                return this.#validateString(value);
            case 'number':
                return this.#validateNumber(value);
            default:
                const rule = this.#rules.get(ruleName);
                return rule ? rule(value) : false;
        }
    }
}

class Encryptor {
    #key: string;

    constructor(key: string) {
        this.#key = key;
    }

    #encrypt(data: string): string {
        return btoa(data + this.#key);
    }

    #decrypt(encrypted: string): string {
        const decoded = atob(encrypted);
        return decoded.slice(0, -this.#key.length);
    }

    encryptData(data: string): string {
        return this.#encrypt(data);
    }

    decryptData(encrypted: string): string {
        return this.#decrypt(encrypted);
    }
}

const validator = new Validator();
const encryptor = new Encryptor("secret-key");
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Validator") && output.contains("Encryptor"),
        "Expected classes: {}",
        output
    );

    // Public methods should exist
    assert!(
        output.contains("addRule") && output.contains("validate"),
        "Expected Validator methods: {}",
        output
    );

    assert!(
        output.contains("encryptData") && output.contains("decryptData"),
        "Expected Encryptor methods: {}",
        output
    );

    // Private method syntax should be transformed
    assert!(
        !output.contains("#validateRequired") && !output.contains("#encrypt"),
        "Expected private methods to be transformed: {}",
        output
    );
}

/// Test ES5 class with WeakSet membership check pattern
#[test]
fn test_class_es5_weakset_membership_check_pattern() {
    let source = r#"
class PermissionManager {
    #authorizedUsers: WeakSet<object> = new WeakSet();
    #admins: WeakSet<object> = new WeakSet();

    authorize(user: object): void {
        this.#authorizedUsers.add(user);
    }

    revokeAuthorization(user: object): void {
        this.#authorizedUsers.delete(user);
    }

    isAuthorized(user: object): boolean {
        return this.#authorizedUsers.has(user);
    }

    promoteToAdmin(user: object): void {
        if (this.isAuthorized(user)) {
            this.#admins.add(user);
        }
    }

    isAdmin(user: object): boolean {
        return this.#admins.has(user);
    }
}

class VisitedTracker {
    #visited: WeakSet<object> = new WeakSet();
    #visitCount: WeakMap<object, number> = new WeakMap();

    visit(item: object): void {
        this.#visited.add(item);
        const count = this.#visitCount.get(item) || 0;
        this.#visitCount.set(item, count + 1);
    }

    hasVisited(item: object): boolean {
        return this.#visited.has(item);
    }

    getVisitCount(item: object): number {
        return this.#visitCount.get(item) || 0;
    }

    reset(item: object): void {
        this.#visited.delete(item);
        this.#visitCount.delete(item);
    }
}

const permissions = new PermissionManager();
const tracker = new VisitedTracker();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("PermissionManager") && output.contains("VisitedTracker"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("authorize")
            && output.contains("isAuthorized")
            && output.contains("promoteToAdmin"),
        "Expected PermissionManager methods: {}",
        output
    );

    assert!(
        output.contains("visit")
            && output.contains("hasVisited")
            && output.contains("getVisitCount"),
        "Expected VisitedTracker methods: {}",
        output
    );

    // Private field syntax should be transformed
    assert!(
        !output.contains("#authorizedUsers")
            && !output.contains("#admins")
            && !output.contains("#visited"),
        "Expected private fields to be transformed: {}",
        output
    );
}

/// Test ES5 class with WeakRef advanced cache pattern
#[test]
fn test_class_es5_weakref_advanced_cache_pattern() {
    let source = r#"
class SmartCache<T extends object> {
    #cache: Map<string, WeakRef<T>> = new Map();
    #finalizationRegistry: FinalizationRegistry<string>;

    constructor() {
        this.#finalizationRegistry = new FinalizationRegistry((key: string) => {
            this.#cache.delete(key);
        });
    }

    set(key: string, value: T): void {
        const ref = new WeakRef(value);
        this.#cache.set(key, ref);
        this.#finalizationRegistry.register(value, key);
    }

    get(key: string): T | undefined {
        const ref = this.#cache.get(key);
        if (ref) {
            return ref.deref();
        }
        return undefined;
    }

    has(key: string): boolean {
        const ref = this.#cache.get(key);
        return ref !== undefined && ref.deref() !== undefined;
    }

    delete(key: string): boolean {
        return this.#cache.delete(key);
    }
}

class ObjectPool<T extends object> {
    #available: WeakRef<T>[] = [];
    #inUse: WeakSet<T> = new WeakSet();
    #factory: () => T;

    constructor(factory: () => T) {
        this.#factory = factory;
    }

    acquire(): T {
        while (this.#available.length > 0) {
            const ref = this.#available.pop()!;
            const obj = ref.deref();
            if (obj && !this.#inUse.has(obj)) {
                this.#inUse.add(obj);
                return obj;
            }
        }
        const newObj = this.#factory();
        this.#inUse.add(newObj);
        return newObj;
    }

    release(obj: T): void {
        this.#inUse.delete(obj);
        this.#available.push(new WeakRef(obj));
    }

    getAvailableCount(): number {
        return this.#available.filter(ref => ref.deref() !== undefined).length;
    }
}

const cache = new SmartCache<object>();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("SmartCache") && output.contains("ObjectPool"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("set") && output.contains("get") && output.contains("has"),
        "Expected SmartCache methods: {}",
        output
    );

    assert!(
        output.contains("acquire")
            && output.contains("release")
            && output.contains("getAvailableCount"),
        "Expected ObjectPool methods: {}",
        output
    );

    // Generic parameter should be stripped
    assert!(
        !output.contains("SmartCache<T") && !output.contains("ObjectPool<T"),
        "Expected generic parameters to be stripped: {}",
        output
    );
}

/// Test ES5 class with combined WeakMap/WeakSet patterns
#[test]
fn test_class_es5_weakmap_weakset_combined_pattern() {
    let source = r#"
class DependencyInjector {
    static #instances: WeakMap<Function, object> = new WeakMap();
    static #initialized: WeakSet<object> = new WeakSet();
    static #dependencies: Map<Function, Function[]> = new Map();

    #localInstances: WeakMap<Function, object> = new WeakMap();
    #scope: string;

    constructor(scope: string) {
        this.#scope = scope;
    }

    static register(token: Function, deps: Function[] = []): void {
        DependencyInjector.#dependencies.set(token, deps);
    }

    static resolve<T>(token: Function): T {
        if (DependencyInjector.#instances.has(token)) {
            return DependencyInjector.#instances.get(token) as T;
        }

        const deps = DependencyInjector.#dependencies.get(token) || [];
        const resolvedDeps = deps.map(dep => DependencyInjector.resolve(dep));
        const instance = Reflect.construct(token, resolvedDeps);

        DependencyInjector.#instances.set(token, instance);
        DependencyInjector.#initialized.add(instance);

        return instance as T;
    }

    static isInitialized(instance: object): boolean {
        return DependencyInjector.#initialized.has(instance);
    }

    resolveScoped<T>(token: Function): T {
        if (this.#localInstances.has(token)) {
            return this.#localInstances.get(token) as T;
        }

        const instance = DependencyInjector.resolve<T>(token);
        this.#localInstances.set(token, instance as object);
        return instance;
    }

    getScope(): string {
        return this.#scope;
    }
}

class EventEmitter {
    #listeners: WeakMap<Function, Set<Function>> = new WeakMap();
    #onceListeners: WeakSet<Function> = new WeakSet();
    #eventCounts: Map<string, number> = new Map();

    on(event: Function, listener: Function): void {
        if (!this.#listeners.has(event)) {
            this.#listeners.set(event, new Set());
        }
        this.#listeners.get(event)!.add(listener);
    }

    once(event: Function, listener: Function): void {
        this.on(event, listener);
        this.#onceListeners.add(listener);
    }

    emit(event: Function, ...args: any[]): void {
        const listeners = this.#listeners.get(event);
        if (listeners) {
            const count = this.#eventCounts.get(event.name) || 0;
            this.#eventCounts.set(event.name, count + 1);

            for (const listener of listeners) {
                listener(...args);
                if (this.#onceListeners.has(listener)) {
                    listeners.delete(listener);
                    this.#onceListeners.delete(listener);
                }
            }
        }
    }

    getEventCount(eventName: string): number {
        return this.#eventCounts.get(eventName) || 0;
    }
}

class CacheManager {
    #strongCache: Map<string, object> = new Map();
    #weakCache: WeakMap<object, string> = new WeakMap();
    #trackedKeys: WeakSet<object> = new WeakSet();
    #refs: Map<string, WeakRef<object>> = new Map();

    store(key: string, value: object): void {
        this.#strongCache.set(key, value);
        this.#weakCache.set(value, key);
        this.#trackedKeys.add(value);
        this.#refs.set(key, new WeakRef(value));
    }

    retrieve(key: string): object | undefined {
        const ref = this.#refs.get(key);
        if (ref) {
            const value = ref.deref();
            if (value && this.#trackedKeys.has(value)) {
                return value;
            }
        }
        return this.#strongCache.get(key);
    }

    getKeyForValue(value: object): string | undefined {
        return this.#weakCache.get(value);
    }

    isTracked(value: object): boolean {
        return this.#trackedKeys.has(value);
    }

    clear(): void {
        this.#strongCache.clear();
        this.#refs.clear();
    }
}

const injector = new DependencyInjector("root");
const emitter = new EventEmitter();
const cacheManager = new CacheManager();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("DependencyInjector")
            && output.contains("EventEmitter")
            && output.contains("CacheManager"),
        "Expected classes: {}",
        output
    );

    // DependencyInjector methods
    assert!(
        output.contains("register")
            && output.contains("resolve")
            && output.contains("isInitialized"),
        "Expected DependencyInjector methods: {}",
        output
    );

    // EventEmitter methods
    assert!(
        output.contains("on") && output.contains("once") && output.contains("emit"),
        "Expected EventEmitter methods: {}",
        output
    );

    // CacheManager methods
    assert!(
        output.contains("store") && output.contains("retrieve") && output.contains("isTracked"),
        "Expected CacheManager methods: {}",
        output
    );

    // Instance private fields should be transformed to WeakMap pattern
    assert!(
        output.contains("_EventEmitter_listeners") || output.contains("_CacheManager_strongCache"),
        "Expected instance private fields to be handled: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains(": WeakMap<")
            && !output.contains(": WeakSet<")
            && !output.contains(": WeakRef<"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test BigInt class property
#[test]
fn test_class_es5_bigint_class_property() {
    let source = r#"
class LargeCounter {
    private count: bigint;
    private maxValue: bigint;

    constructor(initialCount: bigint = 0n) {
        this.count = initialCount;
        this.maxValue = 9007199254740991n;
    }

    getCount(): bigint {
        return this.count;
    }

    increment(): void {
        if (this.count < this.maxValue) {
            this.count = this.count + 1n;
        }
    }

    decrement(): void {
        if (this.count > 0n) {
            this.count = this.count - 1n;
        }
    }

    reset(): void {
        this.count = 0n;
    }
}

class TransactionId {
    private id: bigint;
    private timestamp: bigint;

    constructor(id: bigint) {
        this.id = id;
        this.timestamp = BigInt(Date.now());
    }

    getId(): bigint {
        return this.id;
    }

    getTimestamp(): bigint {
        return this.timestamp;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();
    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);
    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);
    let output = printer.get_output().to_string();

    // Should have ES5 class structure
    assert!(
        output.contains("LargeCounter") && output.contains("TransactionId"),
        "Expected class names: {}",
        output
    );

    // Should have BigInt literals
    assert!(
        output.contains("0n") || output.contains("BigInt"),
        "Expected BigInt usage: {}",
        output
    );
}

/// Test BigInt arithmetic in methods
#[test]
fn test_class_es5_bigint_arithmetic_methods() {
    let source = r#"
class BigIntCalculator {
    private precision: bigint;

    constructor(precision: bigint = 10n) {
        this.precision = precision;
    }

    add(a: bigint, b: bigint): bigint {
        return a + b;
    }

    subtract(a: bigint, b: bigint): bigint {
        return a - b;
    }

    multiply(a: bigint, b: bigint): bigint {
        return a * b;
    }

    divide(a: bigint, b: bigint): bigint {
        if (b === 0n) {
            throw new Error('Division by zero');
        }
        return a / b;
    }

    modulo(a: bigint, b: bigint): bigint {
        return a % b;
    }

    power(base: bigint, exponent: bigint): bigint {
        return base ** exponent;
    }

    factorial(n: bigint): bigint {
        if (n <= 1n) {
            return 1n;
        }
        return n * this.factorial(n - 1n);
    }
}

class FibonacciBigInt {
    private cache: Map<bigint, bigint>;

    constructor() {
        this.cache = new Map();
        this.cache.set(0n, 0n);
        this.cache.set(1n, 1n);
    }

    calculate(n: bigint): bigint {
        if (this.cache.has(n)) {
            return this.cache.get(n)!;
        }
        const result = this.calculate(n - 1n) + this.calculate(n - 2n);
        this.cache.set(n, result);
        return result;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();
    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);
    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);
    let output = printer.get_output().to_string();

    // Should have ES5 class structure
    assert!(
        output.contains("BigIntCalculator") && output.contains("FibonacciBigInt"),
        "Expected class names: {}",
        output
    );

    // Should have arithmetic methods
    assert!(
        output.contains("add") && output.contains("multiply") && output.contains("factorial"),
        "Expected arithmetic methods: {}",
        output
    );
}

/// Test BigInt comparison operations
#[test]
fn test_class_es5_bigint_comparison_operations() {
    let source = r#"
class BigIntRange {
    private min: bigint;
    private max: bigint;

    constructor(min: bigint, max: bigint) {
        this.min = min;
        this.max = max;
    }

    contains(value: bigint): boolean {
        return value >= this.min && value <= this.max;
    }

    isBelow(value: bigint): boolean {
        return value < this.min;
    }

    isAbove(value: bigint): boolean {
        return value > this.max;
    }

    equals(other: BigIntRange): boolean {
        return this.min === other.min && this.max === other.max;
    }

    notEquals(other: BigIntRange): boolean {
        return this.min !== other.min || this.max !== other.max;
    }
}

class BigIntComparator {
    compare(a: bigint, b: bigint): number {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
    }

    max(...values: bigint[]): bigint {
        return values.reduce((max, val) => val > max ? val : max);
    }

    min(...values: bigint[]): bigint {
        return values.reduce((min, val) => val < min ? val : min);
    }

    clamp(value: bigint, min: bigint, max: bigint): bigint {
        if (value < min) return min;
        if (value > max) return max;
        return value;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();
    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);
    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);
    let output = printer.get_output().to_string();

    // Should have ES5 class structure
    assert!(
        output.contains("BigIntRange") && output.contains("BigIntComparator"),
        "Expected class names: {}",
        output
    );

    // Should have comparison methods
    assert!(
        output.contains("contains") && output.contains("compare") && output.contains("clamp"),
        "Expected comparison methods: {}",
        output
    );
}

/// Test BigInt constructor parameter
#[test]
fn test_class_es5_bigint_constructor_parameter() {
    let source = r#"
class Account {
    private readonly id: bigint;
    private balance: bigint;
    private readonly createdAt: bigint;

    constructor(id: bigint, initialBalance: bigint = 0n) {
        this.id = id;
        this.balance = initialBalance;
        this.createdAt = BigInt(Date.now());
    }

    getId(): bigint {
        return this.id;
    }

    getBalance(): bigint {
        return this.balance;
    }

    deposit(amount: bigint): void {
        if (amount > 0n) {
            this.balance = this.balance + amount;
        }
    }

    withdraw(amount: bigint): boolean {
        if (amount > 0n && amount <= this.balance) {
            this.balance = this.balance - amount;
            return true;
        }
        return false;
    }
}

class BlockchainAddress {
    private readonly address: bigint;
    private readonly checksum: bigint;

    constructor(address: bigint, checksum: bigint) {
        this.address = address;
        this.checksum = checksum;
    }

    getAddress(): bigint {
        return this.address;
    }

    verify(): boolean {
        return this.computeChecksum() === this.checksum;
    }

    private computeChecksum(): bigint {
        return this.address % 256n;
    }

    toHex(): string {
        return '0x' + this.address.toString(16);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();
    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);
    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);
    let output = printer.get_output().to_string();

    // Should have ES5 class structure
    assert!(
        output.contains("Account") && output.contains("BlockchainAddress"),
        "Expected class names: {}",
        output
    );

    // Should have methods with BigInt operations
    assert!(
        output.contains("deposit") && output.contains("withdraw") && output.contains("toHex"),
        "Expected methods: {}",
        output
    );
}

/// Test BigInt static field
#[test]
fn test_class_es5_bigint_static_field() {
    let source = r#"
class BigIntConstants {
    static readonly MAX_SAFE_INTEGER: bigint = 9007199254740991n;
    static readonly MIN_SAFE_INTEGER: bigint = -9007199254740991n;
    static readonly ZERO: bigint = 0n;
    static readonly ONE: bigint = 1n;
    static readonly NEGATIVE_ONE: bigint = -1n;

    static isPositive(value: bigint): boolean {
        return value > BigIntConstants.ZERO;
    }

    static isNegative(value: bigint): boolean {
        return value < BigIntConstants.ZERO;
    }

    static abs(value: bigint): bigint {
        return value < BigIntConstants.ZERO ? -value : value;
    }

    static sign(value: bigint): bigint {
        if (value > BigIntConstants.ZERO) return BigIntConstants.ONE;
        if (value < BigIntConstants.ZERO) return BigIntConstants.NEGATIVE_ONE;
        return BigIntConstants.ZERO;
    }
}

class CryptoConstants {
    static readonly MODULUS: bigint = 2n ** 256n - 1n;
    static readonly GENERATOR: bigint = 2n;
    static readonly ORDER: bigint = 2n ** 128n;

    private value: bigint;

    constructor(value: bigint) {
        this.value = value % CryptoConstants.MODULUS;
    }

    getValue(): bigint {
        return this.value;
    }

    modPow(exponent: bigint): bigint {
        let result = 1n;
        let base = this.value;
        let exp = exponent;
        while (exp > 0n) {
            if (exp % 2n === 1n) {
                result = (result * base) % CryptoConstants.MODULUS;
            }
            base = (base * base) % CryptoConstants.MODULUS;
            exp = exp / 2n;
        }
        return result;
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();
    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);
    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);
    let output = printer.get_output().to_string();

    // Should have ES5 class structure
    assert!(
        output.contains("BigIntConstants") && output.contains("CryptoConstants"),
        "Expected class names: {}",
        output
    );

    // Should have static methods
    assert!(
        output.contains("isPositive") && output.contains("abs") && output.contains("modPow"),
        "Expected static methods: {}",
        output
    );
}

/// Test combined BigInt patterns
#[test]
fn test_class_es5_bigint_combined_patterns() {
    let source = r#"
interface Currency {
    code: string;
    decimals: number;
}

class Money {
    private amount: bigint;
    private currency: Currency;

    constructor(amount: bigint, currency: Currency) {
        this.amount = amount;
        this.currency = currency;
    }

    static fromNumber(value: number, currency: Currency): Money {
        const multiplier = 10n ** BigInt(currency.decimals);
        const amount = BigInt(Math.round(value * Number(multiplier)));
        return new Money(amount, currency);
    }

    getAmount(): bigint {
        return this.amount;
    }

    getCurrency(): Currency {
        return this.currency;
    }

    add(other: Money): Money {
        this.ensureSameCurrency(other);
        return new Money(this.amount + other.amount, this.currency);
    }

    subtract(other: Money): Money {
        this.ensureSameCurrency(other);
        return new Money(this.amount - other.amount, this.currency);
    }

    multiply(factor: bigint): Money {
        return new Money(this.amount * factor, this.currency);
    }

    divide(divisor: bigint): Money {
        return new Money(this.amount / divisor, this.currency);
    }

    isGreaterThan(other: Money): boolean {
        this.ensureSameCurrency(other);
        return this.amount > other.amount;
    }

    isLessThan(other: Money): boolean {
        this.ensureSameCurrency(other);
        return this.amount < other.amount;
    }

    equals(other: Money): boolean {
        return this.amount === other.amount && this.currency.code === other.currency.code;
    }

    private ensureSameCurrency(other: Money): void {
        if (this.currency.code !== other.currency.code) {
            throw new Error('Currency mismatch');
        }
    }

    toNumber(): number {
        const multiplier = 10n ** BigInt(this.currency.decimals);
        return Number(this.amount) / Number(multiplier);
    }

    toString(): string {
        return `${this.toNumber().toFixed(this.currency.decimals)} ${this.currency.code}`;
    }
}

class Ledger {
    private entries: Map<bigint, Money>;
    private nextId: bigint;

    constructor() {
        this.entries = new Map();
        this.nextId = 1n;
    }

    addEntry(amount: Money): bigint {
        const id = this.nextId++;
        this.entries.set(id, amount);
        return id;
    }

    getEntry(id: bigint): Money | undefined {
        return this.entries.get(id);
    }

    getTotal(currency: Currency): Money {
        let total = new Money(0n, currency);
        for (const entry of this.entries.values()) {
            if (entry.getCurrency().code === currency.code) {
                total = total.add(entry);
            }
        }
        return total;
    }

    getEntryCount(): bigint {
        return BigInt(this.entries.size);
    }
}
"#;

    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();
    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);
    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);
    let output = printer.get_output().to_string();

    // Should have ES5 class structure
    assert!(
        output.contains("Money") && output.contains("Ledger"),
        "Expected class names: {}",
        output
    );

    // Should have various methods
    assert!(
        output.contains("add") && output.contains("subtract") && output.contains("getTotal"),
        "Expected methods: {}",
        output
    );

    // Interface should be stripped
    assert!(
        !output.contains("interface Currency"),
        "Expected interface to be stripped: {}",
        output
    );

    // Should have BigInt usage
    assert!(
        output.contains("0n") || output.contains("1n") || output.contains("BigInt"),
        "Expected BigInt usage: {}",
        output
    );
}

/// Test ES5 class with basic Symbol.iterator implementation pattern
#[test]
fn test_class_es5_symbol_iterator_basic_pattern() {
    let source = r#"
class NumberRange {
    private start: number;
    private end: number;
    private step: number;

    constructor(start: number, end: number, step: number = 1) {
        this.start = start;
        this.end = end;
        this.step = step;
    }

    [Symbol.iterator](): Iterator<number> {
        let current = this.start;
        const end = this.end;
        const step = this.step;

        return {
            next(): IteratorResult<number> {
                if (current <= end) {
                    const value = current;
                    current += step;
                    return { value, done: false };
                }
                return { value: undefined, done: true };
            }
        };
    }

    toArray(): number[] {
        return [...this];
    }
}

class StringCharIterator {
    private str: string;

    constructor(str: string) {
        this.str = str;
    }

    [Symbol.iterator](): Iterator<string> {
        let index = 0;
        const str = this.str;

        return {
            next(): IteratorResult<string> {
                if (index < str.length) {
                    return { value: str[index++], done: false };
                }
                return { value: undefined, done: true };
            }
        };
    }

    getLength(): number {
        return this.str.length;
    }
}

const range = new NumberRange(1, 10, 2);
const chars = new StringCharIterator("hello");
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("NumberRange") && output.contains("StringCharIterator"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("toArray") && output.contains("getLength"),
        "Expected methods: {}",
        output
    );

    // Symbol.iterator should be present
    assert!(
        output.contains("Symbol.iterator"),
        "Expected Symbol.iterator: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains(": Iterator<") && !output.contains(": IteratorResult<"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with Symbol.asyncIterator implementation pattern
#[test]
fn test_class_es5_symbol_async_iterator_pattern() {
    let source = r#"
class AsyncDataStream {
    private data: string[];
    private delay: number;

    constructor(data: string[], delay: number = 100) {
        this.data = data;
        this.delay = delay;
    }

    [Symbol.asyncIterator](): AsyncIterator<string> {
        let index = 0;
        const data = this.data;
        const delay = this.delay;

        return {
            async next(): Promise<IteratorResult<string>> {
                await new Promise(resolve => setTimeout(resolve, delay));
                if (index < data.length) {
                    return { value: data[index++], done: false };
                }
                return { value: undefined, done: true };
            }
        };
    }

    getCount(): number {
        return this.data.length;
    }
}

class AsyncNumberGenerator {
    private max: number;

    constructor(max: number) {
        this.max = max;
    }

    [Symbol.asyncIterator](): AsyncIterator<number> {
        let current = 0;
        const max = this.max;

        return {
            async next(): Promise<IteratorResult<number>> {
                if (current < max) {
                    return { value: current++, done: false };
                }
                return { value: undefined, done: true };
            }
        };
    }

    getMax(): number {
        return this.max;
    }
}

const stream = new AsyncDataStream(["a", "b", "c"]);
const generator = new AsyncNumberGenerator(5);
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("AsyncDataStream") && output.contains("AsyncNumberGenerator"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getCount") && output.contains("getMax"),
        "Expected methods: {}",
        output
    );

    // Symbol.asyncIterator should be present
    assert!(
        output.contains("Symbol.asyncIterator"),
        "Expected Symbol.asyncIterator: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains(": AsyncIterator<") && !output.contains(": Promise<IteratorResult"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with iterable class pattern
#[test]
fn test_class_es5_iterable_class_pattern() {
    let source = r#"
class Collection<T> implements Iterable<T> {
    private items: T[] = [];

    add(item: T): void {
        this.items.push(item);
    }

    remove(item: T): boolean {
        const index = this.items.indexOf(item);
        if (index !== -1) {
            this.items.splice(index, 1);
            return true;
        }
        return false;
    }

    [Symbol.iterator](): Iterator<T> {
        let index = 0;
        const items = this.items;

        return {
            next(): IteratorResult<T> {
                if (index < items.length) {
                    return { value: items[index++], done: false };
                }
                return { value: undefined as any, done: true };
            }
        };
    }

    size(): number {
        return this.items.length;
    }

    toArray(): T[] {
        return [...this];
    }
}

class Queue<T> implements Iterable<T> {
    private elements: T[] = [];

    enqueue(item: T): void {
        this.elements.push(item);
    }

    dequeue(): T | undefined {
        return this.elements.shift();
    }

    peek(): T | undefined {
        return this.elements[0];
    }

    [Symbol.iterator](): Iterator<T> {
        return this.elements[Symbol.iterator]();
    }

    isEmpty(): boolean {
        return this.elements.length === 0;
    }
}

const collection = new Collection<number>();
const queue = new Queue<string>();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Collection") && output.contains("Queue"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("add") && output.contains("remove") && output.contains("size"),
        "Expected Collection methods: {}",
        output
    );

    assert!(
        output.contains("enqueue") && output.contains("dequeue") && output.contains("peek"),
        "Expected Queue methods: {}",
        output
    );

    // Generic type parameter should be stripped
    assert!(
        !output.contains("Collection<T>") && !output.contains("Queue<T>"),
        "Expected generic parameters to be stripped: {}",
        output
    );

    // implements clause should be stripped
    assert!(
        !output.contains("implements Iterable"),
        "Expected implements clause to be stripped: {}",
        output
    );
}

/// Test ES5 class with generator-based iterator pattern
#[test]
fn test_class_es5_generator_iterator_pattern() {
    let source = r#"
class TreeNode<T> {
    value: T;
    left: TreeNode<T> | null = null;
    right: TreeNode<T> | null = null;

    constructor(value: T) {
        this.value = value;
    }

    *inOrder(): Generator<T> {
        if (this.left) {
            yield* this.left.inOrder();
        }
        yield this.value;
        if (this.right) {
            yield* this.right.inOrder();
        }
    }

    *preOrder(): Generator<T> {
        yield this.value;
        if (this.left) {
            yield* this.left.preOrder();
        }
        if (this.right) {
            yield* this.right.preOrder();
        }
    }

    *postOrder(): Generator<T> {
        if (this.left) {
            yield* this.left.postOrder();
        }
        if (this.right) {
            yield* this.right.postOrder();
        }
        yield this.value;
    }

    [Symbol.iterator](): Generator<T> {
        return this.inOrder();
    }
}

class Fibonacci {
    private max: number;

    constructor(max: number) {
        this.max = max;
    }

    *[Symbol.iterator](): Generator<number> {
        let a = 0, b = 1;
        while (a <= this.max) {
            yield a;
            [a, b] = [b, a + b];
        }
    }

    getMax(): number {
        return this.max;
    }
}

const tree = new TreeNode<number>(1);
const fib = new Fibonacci(100);
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("TreeNode") && output.contains("Fibonacci"),
        "Expected classes: {}",
        output
    );

    // Generator methods should exist
    assert!(
        output.contains("inOrder") && output.contains("preOrder") && output.contains("postOrder"),
        "Expected TreeNode generator methods: {}",
        output
    );

    assert!(
        output.contains("getMax"),
        "Expected Fibonacci methods: {}",
        output
    );

    // Generic type parameter should be stripped
    assert!(
        !output.contains("TreeNode<T>") && !output.contains(": Generator<"),
        "Expected generic/type parameters to be stripped: {}",
        output
    );
}

/// Test ES5 class with async iterator for-await-of pattern
#[test]
fn test_class_es5_async_iterator_for_await_pattern() {
    let source = r#"
class AsyncFileReader {
    private lines: string[];

    constructor(lines: string[]) {
        this.lines = lines;
    }

    async *readLines(): AsyncGenerator<string> {
        for (const line of this.lines) {
            await new Promise(resolve => setTimeout(resolve, 10));
            yield line;
        }
    }

    [Symbol.asyncIterator](): AsyncGenerator<string> {
        return this.readLines();
    }

    getLineCount(): number {
        return this.lines.length;
    }
}

class AsyncBatchProcessor<T> {
    private items: T[];
    private batchSize: number;

    constructor(items: T[], batchSize: number = 10) {
        this.items = items;
        this.batchSize = batchSize;
    }

    async *processBatches(): AsyncGenerator<T[]> {
        for (let i = 0; i < this.items.length; i += this.batchSize) {
            await new Promise(resolve => setTimeout(resolve, 5));
            yield this.items.slice(i, i + this.batchSize);
        }
    }

    [Symbol.asyncIterator](): AsyncGenerator<T[]> {
        return this.processBatches();
    }

    getTotalItems(): number {
        return this.items.length;
    }

    getBatchSize(): number {
        return this.batchSize;
    }
}

async function consumeReader(reader: AsyncFileReader): Promise<string[]> {
    const results: string[] = [];
    for await (const line of reader) {
        results.push(line);
    }
    return results;
}

const reader = new AsyncFileReader(["line1", "line2", "line3"]);
const processor = new AsyncBatchProcessor<number>([1, 2, 3, 4, 5], 2);
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("AsyncFileReader") && output.contains("AsyncBatchProcessor"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("readLines") && output.contains("getLineCount"),
        "Expected AsyncFileReader methods: {}",
        output
    );

    assert!(
        output.contains("processBatches")
            && output.contains("getTotalItems")
            && output.contains("getBatchSize"),
        "Expected AsyncBatchProcessor methods: {}",
        output
    );

    // Function should exist
    assert!(
        output.contains("consumeReader"),
        "Expected consumeReader function: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains(": AsyncGenerator<") && !output.contains(": Promise<string[]>"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with combined iterator patterns
#[test]
fn test_class_es5_combined_iterator_patterns() {
    let source = r#"
class DataPipeline<T> implements Iterable<T>, AsyncIterable<T> {
    private data: T[];
    private transformers: ((item: T) => T)[] = [];

    constructor(data: T[]) {
        this.data = data;
    }

    addTransformer(fn: (item: T) => T): this {
        this.transformers.push(fn);
        return this;
    }

    private applyTransformers(item: T): T {
        return this.transformers.reduce((acc, fn) => fn(acc), item);
    }

    [Symbol.iterator](): Iterator<T> {
        let index = 0;
        const data = this.data;
        const apply = this.applyTransformers.bind(this);

        return {
            next(): IteratorResult<T> {
                if (index < data.length) {
                    return { value: apply(data[index++]), done: false };
                }
                return { value: undefined as any, done: true };
            }
        };
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<T> {
        for (const item of this.data) {
            await new Promise(resolve => setTimeout(resolve, 1));
            yield this.applyTransformers(item);
        }
    }

    *reversed(): Generator<T> {
        for (let i = this.data.length - 1; i >= 0; i--) {
            yield this.applyTransformers(this.data[i]);
        }
    }

    async *filteredAsync(predicate: (item: T) => boolean): AsyncGenerator<T> {
        for await (const item of this) {
            if (predicate(item)) {
                yield item;
            }
        }
    }

    toArray(): T[] {
        return [...this];
    }

    getLength(): number {
        return this.data.length;
    }
}

class BidirectionalIterator<T> {
    private items: T[];
    private currentIndex: number = 0;

    constructor(items: T[]) {
        this.items = items;
    }

    [Symbol.iterator](): Iterator<T> {
        this.currentIndex = 0;
        return this.forwardIterator();
    }

    private forwardIterator(): Iterator<T> {
        const self = this;
        return {
            next(): IteratorResult<T> {
                if (self.currentIndex < self.items.length) {
                    return { value: self.items[self.currentIndex++], done: false };
                }
                return { value: undefined as any, done: true };
            }
        };
    }

    *reverseIterator(): Generator<T> {
        for (let i = this.items.length - 1; i >= 0; i--) {
            yield this.items[i];
        }
    }

    *rangeIterator(start: number, end: number): Generator<T> {
        const actualStart = Math.max(0, start);
        const actualEnd = Math.min(this.items.length, end);
        for (let i = actualStart; i < actualEnd; i++) {
            yield this.items[i];
        }
    }

    getCurrentIndex(): number {
        return this.currentIndex;
    }

    reset(): void {
        this.currentIndex = 0;
    }
}

class EventStream<T> {
    private events: T[] = [];
    private listeners: Set<(event: T) => void> = new Set();

    emit(event: T): void {
        this.events.push(event);
        for (const listener of this.listeners) {
            listener(event);
        }
    }

    subscribe(listener: (event: T) => void): () => void {
        this.listeners.add(listener);
        return () => this.listeners.delete(listener);
    }

    [Symbol.iterator](): Iterator<T> {
        return this.events[Symbol.iterator]();
    }

    async *watch(): AsyncGenerator<T> {
        let index = 0;
        while (true) {
            if (index < this.events.length) {
                yield this.events[index++];
            } else {
                await new Promise(resolve => setTimeout(resolve, 10));
            }
        }
    }

    getEventCount(): number {
        return this.events.length;
    }
}

const pipeline = new DataPipeline<number>([1, 2, 3, 4, 5]);
const biIterator = new BidirectionalIterator<string>(["a", "b", "c"]);
const eventStream = new EventStream<string>();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("DataPipeline")
            && output.contains("BidirectionalIterator")
            && output.contains("EventStream"),
        "Expected classes: {}",
        output
    );

    // DataPipeline methods
    assert!(
        output.contains("addTransformer")
            && output.contains("reversed")
            && output.contains("filteredAsync"),
        "Expected DataPipeline methods: {}",
        output
    );

    // BidirectionalIterator methods
    assert!(
        output.contains("reverseIterator")
            && output.contains("rangeIterator")
            && output.contains("reset"),
        "Expected BidirectionalIterator methods: {}",
        output
    );

    // EventStream methods
    assert!(
        output.contains("emit") && output.contains("subscribe") && output.contains("watch"),
        "Expected EventStream methods: {}",
        output
    );

    // Symbol methods should be present
    assert!(
        output.contains("Symbol.iterator") && output.contains("Symbol.asyncIterator"),
        "Expected Symbol.iterator and Symbol.asyncIterator: {}",
        output
    );

    // implements clause should be stripped
    assert!(
        !output.contains("implements Iterable") && !output.contains("implements AsyncIterable"),
        "Expected implements clauses to be stripped: {}",
        output
    );

    // Generic type parameters should be stripped
    assert!(
        !output.contains("DataPipeline<T>") && !output.contains("BidirectionalIterator<T>"),
        "Expected generic parameters to be stripped: {}",
        output
    );
}

/// Test ES5 class with basic Reflect.metadata decorator pattern
#[test]
fn test_class_es5_reflect_metadata_basic_pattern() {
    let source = r#"
function metadata(key: string, value: any): ClassDecorator & MethodDecorator & PropertyDecorator {
    return function(target: any, propertyKey?: string | symbol, descriptor?: PropertyDescriptor) {
        if (propertyKey) {
            Reflect.defineMetadata(key, value, target, propertyKey);
        } else {
            Reflect.defineMetadata(key, value, target);
        }
    };
}

@metadata("role", "admin")
@metadata("version", "1.0.0")
class UserService {
    @metadata("cache", true)
    private users: Map<string, any> = new Map();

    @metadata("log", true)
    @metadata("async", false)
    getUser(id: string): any {
        return this.users.get(id);
    }

    @metadata("validate", true)
    setUser(id: string, user: any): void {
        this.users.set(id, user);
    }
}

@metadata("singleton", true)
class ConfigService {
    private config: Record<string, any> = {};

    @metadata("readonly", true)
    get(key: string): any {
        return this.config[key];
    }

    @metadata("writeonly", false)
    set(key: string, value: any): void {
        this.config[key] = value;
    }
}

const userService = new UserService();
const configService = new ConfigService();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("UserService") && output.contains("ConfigService"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getUser") && output.contains("setUser"),
        "Expected UserService methods: {}",
        output
    );

    assert!(
        output.contains("get") && output.contains("set"),
        "Expected ConfigService methods: {}",
        output
    );

    // Decorator function should exist
    assert!(
        output.contains("metadata"),
        "Expected metadata function: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains(": ClassDecorator") && !output.contains(": MethodDecorator"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with design type metadata pattern
#[test]
fn test_class_es5_reflect_metadata_design_type_pattern() {
    let source = r#"
function Type(type: Function): PropertyDecorator {
    return function(target: Object, propertyKey: string | symbol) {
        Reflect.defineMetadata("design:type", type, target, propertyKey);
    };
}

function Injectable(): ClassDecorator {
    return function(target: Function) {
        const paramTypes = Reflect.getMetadata("design:paramtypes", target) || [];
        Reflect.defineMetadata("injectable:params", paramTypes, target);
    };
}

class Logger {
    log(message: string): void {
        console.log(message);
    }
}

class Database {
    query(sql: string): any[] {
        return [];
    }
}

@Injectable()
class Repository {
    @Type(Database)
    private db: Database;

    @Type(Logger)
    private logger: Logger;

    constructor(db: Database, logger: Logger) {
        this.db = db;
        this.logger = logger;
    }

    findAll(): any[] {
        this.logger.log("Finding all");
        return this.db.query("SELECT * FROM table");
    }

    findById(id: string): any {
        this.logger.log("Finding by id: " + id);
        return this.db.query("SELECT * FROM table WHERE id = " + id)[0];
    }
}

@Injectable()
class Service {
    @Type(Repository)
    private repo: Repository;

    constructor(repo: Repository) {
        this.repo = repo;
    }

    getAll(): any[] {
        return this.repo.findAll();
    }
}

const repo = new Repository(new Database(), new Logger());
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Logger")
            && output.contains("Database")
            && output.contains("Repository")
            && output.contains("Service"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("findAll") && output.contains("findById"),
        "Expected Repository methods: {}",
        output
    );

    // Decorator functions should exist
    assert!(
        output.contains("Type") && output.contains("Injectable"),
        "Expected decorator functions: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains(": PropertyDecorator") && !output.contains(": ClassDecorator"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with parameter type metadata pattern
#[test]
fn test_class_es5_reflect_metadata_param_type_pattern() {
    let source = r#"
function Inject(token: string): ParameterDecorator {
    return function(target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const existingParams = Reflect.getMetadata("inject:params", target) || [];
        existingParams[parameterIndex] = token;
        Reflect.defineMetadata("inject:params", existingParams, target);
    };
}

function Optional(): ParameterDecorator {
    return function(target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const optionalParams = Reflect.getMetadata("optional:params", target) || [];
        optionalParams[parameterIndex] = true;
        Reflect.defineMetadata("optional:params", optionalParams, target);
    };
}

function Validate(validator: (value: any) => boolean): ParameterDecorator {
    return function(target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const validators = Reflect.getMetadata("validators", target, propertyKey!) || [];
        validators[parameterIndex] = validator;
        Reflect.defineMetadata("validators", validators, target, propertyKey!);
    };
}

class AuthService {
    authenticate(
        @Inject("username") username: string,
        @Inject("password") password: string,
        @Optional() @Inject("rememberMe") rememberMe?: boolean
    ): boolean {
        return username.length > 0 && password.length > 0;
    }

    validateToken(
        @Validate((v) => typeof v === "string") token: string
    ): boolean {
        return token.length > 0;
    }
}

class UserController {
    constructor(
        @Inject("AuthService") private authService: AuthService,
        @Inject("Logger") @Optional() private logger?: any
    ) {}

    login(
        @Validate((v) => v.length >= 3) username: string,
        @Validate((v) => v.length >= 8) password: string
    ): boolean {
        return this.authService.authenticate(username, password);
    }
}

const authService = new AuthService();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("AuthService") && output.contains("UserController"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("authenticate") && output.contains("validateToken"),
        "Expected AuthService methods: {}",
        output
    );

    assert!(
        output.contains("login"),
        "Expected UserController methods: {}",
        output
    );

    // Decorator functions should exist
    assert!(
        output.contains("Inject") && output.contains("Optional") && output.contains("Validate"),
        "Expected decorator functions: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains(": ParameterDecorator"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with return type metadata pattern
#[test]
fn test_class_es5_reflect_metadata_return_type_pattern() {
    let source = r#"
function ReturnType(type: Function): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        Reflect.defineMetadata("design:returntype", type, target, propertyKey);
        return descriptor;
    };
}

function AsyncReturn(type: Function): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        Reflect.defineMetadata("async:returntype", type, target, propertyKey);
        Reflect.defineMetadata("is:async", true, target, propertyKey);
        return descriptor;
    };
}

function Cacheable(ttl: number): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        const returnType = Reflect.getMetadata("design:returntype", target, propertyKey);
        Reflect.defineMetadata("cache:ttl", ttl, target, propertyKey);
        Reflect.defineMetadata("cache:type", returnType, target, propertyKey);
        return descriptor;
    };
}

class User {
    id: string;
    name: string;

    constructor(id: string, name: string) {
        this.id = id;
        this.name = name;
    }
}

class UserRepository {
    private users: Map<string, User> = new Map();

    @ReturnType(User)
    @Cacheable(300)
    findById(id: string): User | undefined {
        return this.users.get(id);
    }

    @ReturnType(Array)
    @Cacheable(600)
    findAll(): User[] {
        return Array.from(this.users.values());
    }

    @AsyncReturn(User)
    async findByIdAsync(id: string): Promise<User | undefined> {
        return this.users.get(id);
    }

    @ReturnType(Boolean)
    save(user: User): boolean {
        this.users.set(user.id, user);
        return true;
    }
}

const repo = new UserRepository();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("User") && output.contains("UserRepository"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("findById")
            && output.contains("findAll")
            && output.contains("findByIdAsync")
            && output.contains("save"),
        "Expected UserRepository methods: {}",
        output
    );

    // Decorator functions should exist
    assert!(
        output.contains("ReturnType")
            && output.contains("AsyncReturn")
            && output.contains("Cacheable"),
        "Expected decorator functions: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains(": MethodDecorator") && !output.contains(": PropertyDescriptor"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with custom metadata keys pattern
#[test]
fn test_class_es5_reflect_metadata_custom_keys_pattern() {
    let source = r#"
const ROUTE_METADATA = Symbol("route");
const METHOD_METADATA = Symbol("method");
const MIDDLEWARE_METADATA = Symbol("middleware");
const GUARD_METADATA = Symbol("guard");

function Controller(path: string): ClassDecorator {
    return function(target: Function) {
        Reflect.defineMetadata(ROUTE_METADATA, path, target);
    };
}

function Get(path: string): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        Reflect.defineMetadata(ROUTE_METADATA, path, target, propertyKey);
        Reflect.defineMetadata(METHOD_METADATA, "GET", target, propertyKey);
        return descriptor;
    };
}

function Post(path: string): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        Reflect.defineMetadata(ROUTE_METADATA, path, target, propertyKey);
        Reflect.defineMetadata(METHOD_METADATA, "POST", target, propertyKey);
        return descriptor;
    };
}

function UseMiddleware(...middlewares: Function[]): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        Reflect.defineMetadata(MIDDLEWARE_METADATA, middlewares, target, propertyKey);
        return descriptor;
    };
}

function UseGuard(guard: Function): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        const guards = Reflect.getMetadata(GUARD_METADATA, target, propertyKey) || [];
        guards.push(guard);
        Reflect.defineMetadata(GUARD_METADATA, guards, target, propertyKey);
        return descriptor;
    };
}

function authMiddleware(req: any, res: any, next: Function) {
    next();
}

function logMiddleware(req: any, res: any, next: Function) {
    console.log(req.url);
    next();
}

function AdminGuard(req: any): boolean {
    return req.user?.role === "admin";
}

@Controller("/users")
class UserController {
    @Get("/")
    @UseMiddleware(logMiddleware)
    getAll(): any[] {
        return [];
    }

    @Get("/:id")
    @UseMiddleware(authMiddleware, logMiddleware)
    @UseGuard(AdminGuard)
    getById(id: string): any {
        return { id };
    }

    @Post("/")
    @UseMiddleware(authMiddleware)
    @UseGuard(AdminGuard)
    create(data: any): any {
        return data;
    }
}

const controller = new UserController();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Class should be converted
    assert!(
        output.contains("UserController"),
        "Expected UserController class: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getAll") && output.contains("getById") && output.contains("create"),
        "Expected UserController methods: {}",
        output
    );

    // Decorator functions should exist
    assert!(
        output.contains("Controller") && output.contains("Get") && output.contains("Post"),
        "Expected route decorator functions: {}",
        output
    );

    assert!(
        output.contains("UseMiddleware") && output.contains("UseGuard"),
        "Expected middleware decorator functions: {}",
        output
    );

    // Symbol constants should exist
    assert!(
        output.contains("ROUTE_METADATA") && output.contains("METHOD_METADATA"),
        "Expected metadata symbol constants: {}",
        output
    );

    // Type annotations should be stripped
    assert!(
        !output.contains(": ClassDecorator") && !output.contains(": MethodDecorator"),
        "Expected type annotations to be stripped: {}",
        output
    );
}

/// Test ES5 class with combined reflect-metadata patterns
#[test]
fn test_class_es5_reflect_metadata_combined_pattern() {
    let source = r#"
const INJECTABLE = Symbol("injectable");
const DEPENDENCIES = Symbol("dependencies");
const SCOPE = Symbol("scope");

type Scope = "singleton" | "transient" | "request";

function Injectable(options?: { scope?: Scope }): ClassDecorator {
    return function(target: Function) {
        Reflect.defineMetadata(INJECTABLE, true, target);
        Reflect.defineMetadata(SCOPE, options?.scope || "singleton", target);

        const paramTypes = Reflect.getMetadata("design:paramtypes", target) || [];
        Reflect.defineMetadata(DEPENDENCIES, paramTypes, target);
    };
}

function Inject(token: string | symbol): ParameterDecorator {
    return function(target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) {
        const injections = Reflect.getMetadata("custom:inject", target) || [];
        injections[parameterIndex] = token;
        Reflect.defineMetadata("custom:inject", injections, target);
    };
}

function Property(options?: { required?: boolean; default?: any }): PropertyDecorator {
    return function(target: Object, propertyKey: string | symbol) {
        const type = Reflect.getMetadata("design:type", target, propertyKey);
        Reflect.defineMetadata("property:type", type, target, propertyKey);
        Reflect.defineMetadata("property:options", options || {}, target, propertyKey);
    };
}

function Method(options?: { async?: boolean; cacheable?: boolean }): MethodDecorator {
    return function(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
        const returnType = Reflect.getMetadata("design:returntype", target, propertyKey);
        const paramTypes = Reflect.getMetadata("design:paramtypes", target, propertyKey);

        Reflect.defineMetadata("method:returntype", returnType, target, propertyKey);
        Reflect.defineMetadata("method:paramtypes", paramTypes, target, propertyKey);
        Reflect.defineMetadata("method:options", options || {}, target, propertyKey);

        return descriptor;
    };
}

interface ILogger {
    log(message: string): void;
    error(message: string): void;
}

interface IDatabase {
    query(sql: string): Promise<any[]>;
    execute(sql: string): Promise<void>;
}

@Injectable({ scope: "singleton" })
class Logger implements ILogger {
    @Property({ required: false, default: "INFO" })
    level: string = "INFO";

    @Method({ async: false })
    log(message: string): void {
        console.log(`[${this.level}] ${message}`);
    }

    @Method({ async: false })
    error(message: string): void {
        console.error(`[ERROR] ${message}`);
    }
}

@Injectable({ scope: "singleton" })
class Database implements IDatabase {
    @Property({ required: true })
    connectionString: string;

    constructor(@Inject("CONNECTION_STRING") connectionString: string) {
        this.connectionString = connectionString;
    }

    @Method({ async: true, cacheable: false })
    async query(sql: string): Promise<any[]> {
        return [];
    }

    @Method({ async: true })
    async execute(sql: string): Promise<void> {
        // Execute SQL
    }
}

@Injectable({ scope: "transient" })
class UserService {
    @Property()
    private logger: Logger;

    @Property()
    private db: Database;

    constructor(
        @Inject("Logger") logger: Logger,
        @Inject("Database") db: Database
    ) {
        this.logger = logger;
        this.db = db;
    }

    @Method({ async: true, cacheable: true })
    async findAll(): Promise<any[]> {
        this.logger.log("Finding all users");
        return this.db.query("SELECT * FROM users");
    }

    @Method({ async: true })
    async findById(id: string): Promise<any> {
        this.logger.log("Finding user by id: " + id);
        const results = await this.db.query("SELECT * FROM users WHERE id = " + id);
        return results[0];
    }

    @Method({ async: true })
    async create(data: any): Promise<any> {
        this.logger.log("Creating user");
        await this.db.execute("INSERT INTO users ...");
        return data;
    }
}

class Container {
    private instances: Map<string | symbol, any> = new Map();
    private factories: Map<string | symbol, Function> = new Map();

    register<T>(token: string | symbol, factory: () => T): void {
        this.factories.set(token, factory);
    }

    resolve<T>(token: string | symbol): T {
        if (this.instances.has(token)) {
            return this.instances.get(token);
        }

        const factory = this.factories.get(token);
        if (!factory) {
            throw new Error("No factory registered for token");
        }

        const instance = factory();
        this.instances.set(token, instance);
        return instance as T;
    }

    getMetadata(target: Function): any {
        return {
            injectable: Reflect.getMetadata(INJECTABLE, target),
            scope: Reflect.getMetadata(SCOPE, target),
            dependencies: Reflect.getMetadata(DEPENDENCIES, target)
        };
    }
}

const container = new Container();
const logger = new Logger();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Logger")
            && output.contains("Database")
            && output.contains("UserService")
            && output.contains("Container"),
        "Expected classes: {}",
        output
    );

    // Logger methods
    assert!(
        output.contains("log") && output.contains("error"),
        "Expected Logger methods: {}",
        output
    );

    // Database methods
    assert!(
        output.contains("query") && output.contains("execute"),
        "Expected Database methods: {}",
        output
    );

    // UserService methods
    assert!(
        output.contains("findAll") && output.contains("findById") && output.contains("create"),
        "Expected UserService methods: {}",
        output
    );

    // Container methods
    assert!(
        output.contains("register") && output.contains("resolve") && output.contains("getMetadata"),
        "Expected Container methods: {}",
        output
    );

    // Decorator functions should exist
    assert!(
        output.contains("Injectable")
            && output.contains("Inject")
            && output.contains("Property")
            && output.contains("Method"),
        "Expected decorator functions: {}",
        output
    );

    // Symbol constants should exist
    assert!(
        output.contains("INJECTABLE")
            && output.contains("DEPENDENCIES")
            && output.contains("SCOPE"),
        "Expected metadata symbol constants: {}",
        output
    );

    // Interfaces should be stripped
    assert!(
        !output.contains("interface ILogger") && !output.contains("interface IDatabase"),
        "Expected interfaces to be stripped: {}",
        output
    );

    // Type alias should be stripped
    assert!(
        !output.contains("type Scope"),
        "Expected type alias to be stripped: {}",
        output
    );
}

/// Test ES5 class with revealing module pattern
#[test]
fn test_class_es5_revealing_module_pattern() {
    let source = r#"
const CounterModule = (function() {
    let count = 0;

    class Counter {
        private _value: number;

        constructor(initial: number = 0) {
            this._value = initial;
        }

        increment(): number {
            this._value++;
            count++;
            return this._value;
        }

        decrement(): number {
            this._value--;
            return this._value;
        }

        getValue(): number {
            return this._value;
        }
    }

    function createCounter(initial?: number): Counter {
        return new Counter(initial);
    }

    function getTotalOperations(): number {
        return count;
    }

    return {
        Counter,
        createCounter,
        getTotalOperations
    };
})();

const LoggerModule = (function() {
    const logs: string[] = [];

    class Logger {
        private prefix: string;

        constructor(prefix: string = "") {
            this.prefix = prefix;
        }

        log(message: string): void {
            const entry = this.prefix ? `[${this.prefix}] ${message}` : message;
            logs.push(entry);
            console.log(entry);
        }

        warn(message: string): void {
            this.log(`WARN: ${message}`);
        }

        error(message: string): void {
            this.log(`ERROR: ${message}`);
        }
    }

    function getLogs(): string[] {
        return [...logs];
    }

    function clearLogs(): void {
        logs.length = 0;
    }

    return {
        Logger,
        getLogs,
        clearLogs
    };
})();

const counter = CounterModule.createCounter(10);
const logger = new LoggerModule.Logger("App");
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Module names should exist
    assert!(
        output.contains("CounterModule") && output.contains("LoggerModule"),
        "Expected module names: {}",
        output
    );

    // Classes should be converted
    assert!(
        output.contains("Counter") && output.contains("Logger"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("increment") && output.contains("decrement") && output.contains("getValue"),
        "Expected Counter methods: {}",
        output
    );

    assert!(
        output.contains("log") && output.contains("warn") && output.contains("error"),
        "Expected Logger methods: {}",
        output
    );

    // Module functions should exist
    assert!(
        output.contains("createCounter") && output.contains("getTotalOperations"),
        "Expected CounterModule functions: {}",
        output
    );

    assert!(
        output.contains("getLogs") && output.contains("clearLogs"),
        "Expected LoggerModule functions: {}",
        output
    );
}

/// Test ES5 class with namespace module pattern
#[test]
fn test_class_es5_namespace_module_pattern() {
    let source = r#"
namespace DataAccess {
    export interface Repository<T> {
        findAll(): T[];
        findById(id: string): T | undefined;
        save(entity: T): void;
        delete(id: string): boolean;
    }

    export class BaseEntity {
        id: string;
        createdAt: Date;
        updatedAt: Date;

        constructor(id: string) {
            this.id = id;
            this.createdAt = new Date();
            this.updatedAt = new Date();
        }

        touch(): void {
            this.updatedAt = new Date();
        }
    }

    export class InMemoryRepository<T extends BaseEntity> implements Repository<T> {
        protected entities: Map<string, T> = new Map();

        findAll(): T[] {
            return Array.from(this.entities.values());
        }

        findById(id: string): T | undefined {
            return this.entities.get(id);
        }

        save(entity: T): void {
            entity.touch();
            this.entities.set(entity.id, entity);
        }

        delete(id: string): boolean {
            return this.entities.delete(id);
        }
    }
}

namespace Services {
    export class UserService {
        private repo: DataAccess.Repository<DataAccess.BaseEntity>;

        constructor(repo: DataAccess.Repository<DataAccess.BaseEntity>) {
            this.repo = repo;
        }

        getAllUsers(): DataAccess.BaseEntity[] {
            return this.repo.findAll();
        }

        getUserById(id: string): DataAccess.BaseEntity | undefined {
            return this.repo.findById(id);
        }
    }
}

const repo = new DataAccess.InMemoryRepository<DataAccess.BaseEntity>();
const service = new Services.UserService(repo);
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Namespaces should exist
    assert!(
        output.contains("DataAccess") && output.contains("Services"),
        "Expected namespaces: {}",
        output
    );

    // Classes should be converted
    assert!(
        output.contains("BaseEntity")
            && output.contains("InMemoryRepository")
            && output.contains("UserService"),
        "Expected classes: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("findAll") && output.contains("findById") && output.contains("save"),
        "Expected Repository methods: {}",
        output
    );

    // Interface should be stripped
    assert!(
        !output.contains("interface Repository"),
        "Expected interface to be stripped: {}",
        output
    );
}

/// Test ES5 class with import/export class patterns
#[test]
fn test_class_es5_import_export_class_pattern() {
    let source = r#"
export interface Serializable {
    serialize(): string;
    deserialize(data: string): void;
}

export abstract class Model implements Serializable {
    abstract id: string;

    abstract serialize(): string;
    abstract deserialize(data: string): void;

    clone(): this {
        const data = this.serialize();
        const clone = Object.create(Object.getPrototypeOf(this));
        clone.deserialize(data);
        return clone;
    }
}

export class User extends Model {
    id: string;
    name: string;
    email: string;

    constructor(id: string, name: string, email: string) {
        super();
        this.id = id;
        this.name = name;
        this.email = email;
    }

    serialize(): string {
        return JSON.stringify({ id: this.id, name: this.name, email: this.email });
    }

    deserialize(data: string): void {
        const obj = JSON.parse(data);
        this.id = obj.id;
        this.name = obj.name;
        this.email = obj.email;
    }
}

export class Product extends Model {
    id: string;
    title: string;
    price: number;

    constructor(id: string, title: string, price: number) {
        super();
        this.id = id;
        this.title = title;
        this.price = price;
    }

    serialize(): string {
        return JSON.stringify({ id: this.id, title: this.title, price: this.price });
    }

    deserialize(data: string): void {
        const obj = JSON.parse(data);
        this.id = obj.id;
        this.title = obj.title;
        this.price = obj.price;
    }
}

export default class DefaultExportClass {
    value: string;

    constructor(value: string) {
        this.value = value;
    }

    getValue(): string {
        return this.value;
    }
}

const user = new User("1", "John", "john@example.com");
const product = new Product("1", "Widget", 9.99);
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("Model") && output.contains("User") && output.contains("Product"),
        "Expected classes: {}",
        output
    );

    assert!(
        output.contains("DefaultExportClass"),
        "Expected default export class: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("serialize") && output.contains("deserialize") && output.contains("clone"),
        "Expected Model methods: {}",
        output
    );

    // Interface should be stripped
    assert!(
        !output.contains("interface Serializable"),
        "Expected interface to be stripped: {}",
        output
    );
}

/// Test ES5 class with barrel export variation pattern
#[test]
fn test_class_es5_barrel_export_variation_pattern() {
    let source = r#"
// models/user.ts style
class UserModel {
    id: string;
    username: string;

    constructor(id: string, username: string) {
        this.id = id;
        this.username = username;
    }

    toJSON(): object {
        return { id: this.id, username: this.username };
    }
}

// models/product.ts style
class ProductModel {
    id: string;
    name: string;
    price: number;

    constructor(id: string, name: string, price: number) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    toJSON(): object {
        return { id: this.id, name: this.name, price: this.price };
    }
}

// models/order.ts style
class OrderModel {
    id: string;
    userId: string;
    products: ProductModel[];

    constructor(id: string, userId: string, products: ProductModel[] = []) {
        this.id = id;
        this.userId = userId;
        this.products = products;
    }

    addProduct(product: ProductModel): void {
        this.products.push(product);
    }

    getTotal(): number {
        return this.products.reduce((sum, p) => sum + p.price, 0);
    }

    toJSON(): object {
        return {
            id: this.id,
            userId: this.userId,
            products: this.products.map(p => p.toJSON())
        };
    }
}

// models/index.ts barrel export style
const Models = {
    User: UserModel,
    Product: ProductModel,
    Order: OrderModel
};

// Export types for convenience
type User = UserModel;
type Product = ProductModel;
type Order = OrderModel;

// Factory functions
function createUser(id: string, username: string): UserModel {
    return new UserModel(id, username);
}

function createProduct(id: string, name: string, price: number): ProductModel {
    return new ProductModel(id, name, price);
}

function createOrder(id: string, userId: string): OrderModel {
    return new OrderModel(id, userId);
}

const Factories = {
    createUser,
    createProduct,
    createOrder
};

const user = Factories.createUser("1", "john");
const product = Factories.createProduct("1", "Widget", 9.99);
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Classes should be converted
    assert!(
        output.contains("UserModel")
            && output.contains("ProductModel")
            && output.contains("OrderModel"),
        "Expected model classes: {}",
        output
    );

    // Barrel export object should exist
    assert!(
        output.contains("Models"),
        "Expected Models barrel export: {}",
        output
    );

    // Factory functions should exist
    assert!(
        output.contains("createUser")
            && output.contains("createProduct")
            && output.contains("createOrder"),
        "Expected factory functions: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("toJSON") && output.contains("addProduct") && output.contains("getTotal"),
        "Expected model methods: {}",
        output
    );

    // Type aliases should be stripped
    assert!(
        !output.contains("type User =") && !output.contains("type Product ="),
        "Expected type aliases to be stripped: {}",
        output
    );
}

/// Test ES5 class with re-export variation pattern
#[test]
fn test_class_es5_re_export_variation_pattern() {
    let source = r#"
// core/base.ts
abstract class BaseService {
    protected name: string;

    constructor(name: string) {
        this.name = name;
    }

    getName(): string {
        return this.name;
    }

    abstract execute(): void;
}

// core/logger.ts
class LogService extends BaseService {
    private logs: string[] = [];

    constructor() {
        super("LogService");
    }

    execute(): void {
        console.log("LogService executing...");
    }

    log(message: string): void {
        this.logs.push(message);
    }

    getLogs(): string[] {
        return [...this.logs];
    }
}

// core/cache.ts
class CacheService extends BaseService {
    private cache: Map<string, any> = new Map();

    constructor() {
        super("CacheService");
    }

    execute(): void {
        console.log("CacheService executing...");
    }

    set(key: string, value: any): void {
        this.cache.set(key, value);
    }

    get(key: string): any {
        return this.cache.get(key);
    }

    clear(): void {
        this.cache.clear();
    }
}

// core/index.ts re-export pattern
const CoreServices = {
    BaseService,
    LogService,
    CacheService
};

// features/auth.ts
class AuthService extends BaseService {
    private logService: LogService;

    constructor(logService: LogService) {
        super("AuthService");
        this.logService = logService;
    }

    execute(): void {
        this.logService.log("AuthService executing...");
    }

    authenticate(username: string, password: string): boolean {
        this.logService.log(`Authenticating user: ${username}`);
        return username.length > 0 && password.length > 0;
    }
}

// features/data.ts
class DataService extends BaseService {
    private cacheService: CacheService;
    private logService: LogService;

    constructor(cacheService: CacheService, logService: LogService) {
        super("DataService");
        this.cacheService = cacheService;
        this.logService = logService;
    }

    execute(): void {
        this.logService.log("DataService executing...");
    }

    fetch(key: string): any {
        const cached = this.cacheService.get(key);
        if (cached) {
            this.logService.log(`Cache hit for: ${key}`);
            return cached;
        }
        this.logService.log(`Cache miss for: ${key}`);
        return null;
    }

    store(key: string, value: any): void {
        this.cacheService.set(key, value);
        this.logService.log(`Stored: ${key}`);
    }
}

// features/index.ts re-export pattern
const FeatureServices = {
    AuthService,
    DataService
};

// main index.ts - aggregate exports
const AllServices = {
    ...CoreServices,
    ...FeatureServices
};

const logService = new LogService();
const cacheService = new CacheService();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Base class should be converted
    assert!(
        output.contains("BaseService"),
        "Expected BaseService class: {}",
        output
    );

    // Core services should exist
    assert!(
        output.contains("LogService") && output.contains("CacheService"),
        "Expected core service classes: {}",
        output
    );

    // Feature services should exist
    assert!(
        output.contains("AuthService") && output.contains("DataService"),
        "Expected feature service classes: {}",
        output
    );

    // Re-export objects should exist
    assert!(
        output.contains("CoreServices")
            && output.contains("FeatureServices")
            && output.contains("AllServices"),
        "Expected re-export objects: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("getName") && output.contains("execute"),
        "Expected BaseService methods: {}",
        output
    );

    assert!(
        output.contains("authenticate") && output.contains("fetch") && output.contains("store"),
        "Expected feature service methods: {}",
        output
    );
}

/// Test ES5 class with combined module patterns
#[test]
fn test_class_es5_combined_module_patterns() {
    let source = r#"
// Types module
namespace Types {
    export interface Entity {
        id: string;
        createdAt: Date;
    }

    export interface Persistable {
        save(): Promise<void>;
        load(id: string): Promise<void>;
    }

    export type EntityId = string | number;
}

// Base module with revealing pattern
const BaseModule = (function() {
    abstract class AbstractEntity implements Types.Entity {
        id: string;
        createdAt: Date;

        constructor(id: string) {
            this.id = id;
            this.createdAt = new Date();
        }

        abstract validate(): boolean;
    }

    class EntityFactory {
        private static instances: Map<string, AbstractEntity> = new Map();

        static register(id: string, entity: AbstractEntity): void {
            this.instances.set(id, entity);
        }

        static get(id: string): AbstractEntity | undefined {
            return this.instances.get(id);
        }

        static clear(): void {
            this.instances.clear();
        }
    }

    return {
        AbstractEntity,
        EntityFactory
    };
})();

// Domain module using namespace
namespace Domain {
    export class User extends (BaseModule.AbstractEntity as any) {
        name: string;
        email: string;

        constructor(id: string, name: string, email: string) {
            super(id);
            this.name = name;
            this.email = email;
        }

        validate(): boolean {
            return this.name.length > 0 && this.email.includes("@");
        }

        getDisplayName(): string {
            return `${this.name} <${this.email}>`;
        }
    }

    export class Order extends (BaseModule.AbstractEntity as any) {
        userId: string;
        total: number;
        items: string[];

        constructor(id: string, userId: string) {
            super(id);
            this.userId = userId;
            this.total = 0;
            this.items = [];
        }

        validate(): boolean {
            return this.userId.length > 0 && this.items.length > 0;
        }

        addItem(item: string, price: number): void {
            this.items.push(item);
            this.total += price;
        }

        getItemCount(): number {
            return this.items.length;
        }
    }
}

// Services module
namespace Services {
    export class UserService {
        private users: Map<string, Domain.User> = new Map();

        create(id: string, name: string, email: string): Domain.User {
            const user = new Domain.User(id, name, email);
            if (user.validate()) {
                this.users.set(id, user);
                BaseModule.EntityFactory.register(id, user as any);
            }
            return user;
        }

        findById(id: string): Domain.User | undefined {
            return this.users.get(id);
        }

        findAll(): Domain.User[] {
            return Array.from(this.users.values());
        }
    }

    export class OrderService {
        private orders: Map<string, Domain.Order> = new Map();

        create(id: string, userId: string): Domain.Order {
            const order = new Domain.Order(id, userId);
            this.orders.set(id, order);
            return order;
        }

        findByUserId(userId: string): Domain.Order[] {
            return Array.from(this.orders.values()).filter(o => o.userId === userId);
        }

        getOrderTotal(orderId: string): number {
            const order = this.orders.get(orderId);
            return order ? order.total : 0;
        }
    }
}

// Application facade
class Application {
    private userService: Services.UserService;
    private orderService: Services.OrderService;

    constructor() {
        this.userService = new Services.UserService();
        this.orderService = new Services.OrderService();
    }

    getUserService(): Services.UserService {
        return this.userService;
    }

    getOrderService(): Services.OrderService {
        return this.orderService;
    }

    initialize(): void {
        console.log("Application initialized");
    }
}

// Export aggregation
const Modules = {
    Types,
    BaseModule,
    Domain,
    Services,
    Application
};

const app = new Application();
app.initialize();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Namespaces should exist
    assert!(
        output.contains("Types") && output.contains("Domain") && output.contains("Services"),
        "Expected namespaces: {}",
        output
    );

    // Revealing module should exist
    assert!(
        output.contains("BaseModule"),
        "Expected BaseModule: {}",
        output
    );

    // Domain classes should exist
    assert!(
        output.contains("User") && output.contains("Order"),
        "Expected domain classes: {}",
        output
    );

    // Service classes should exist
    assert!(
        output.contains("UserService") && output.contains("OrderService"),
        "Expected service classes: {}",
        output
    );

    // Application class should exist
    assert!(
        output.contains("Application"),
        "Expected Application class: {}",
        output
    );

    // Methods should exist
    assert!(
        output.contains("validate") && output.contains("getDisplayName"),
        "Expected User methods: {}",
        output
    );

    assert!(
        output.contains("create") && output.contains("findById") && output.contains("findAll"),
        "Expected UserService methods: {}",
        output
    );

    // Aggregate export should exist
    assert!(
        output.contains("Modules"),
        "Expected Modules aggregate export: {}",
        output
    );

    // Interfaces should be stripped
    assert!(
        !output.contains("interface Entity") && !output.contains("interface Persistable"),
        "Expected interfaces to be stripped: {}",
        output
    );

    // Type alias should be stripped
    assert!(
        !output.contains("type EntityId"),
        "Expected type alias to be stripped: {}",
        output
    );
}

// =============================================================================
// Dependency Injection Pattern Tests
// =============================================================================

#[test]
fn test_class_es5_di_basic_constructor_injection() {
    // Test basic constructor injection pattern
    let source = r#"
interface Logger {
    log(message: string): void;
}

class ConsoleLogger implements Logger {
    log(message: string): void {
        console.log(message);
    }
}

class UserService {
    private logger: Logger;

    constructor(logger: Logger) {
        this.logger = logger;
    }

    createUser(name: string): void {
        this.logger.log(`Creating user: ${name}`);
    }
}

const logger = new ConsoleLogger();
const userService = new UserService(logger);
userService.createUser("Alice");
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ConsoleLogger"),
        "Expected ConsoleLogger function: {}",
        output
    );
    assert!(
        output.contains("function UserService"),
        "Expected UserService function: {}",
        output
    );
    assert!(
        output.contains("this.logger = logger"),
        "Expected logger assignment in constructor: {}",
        output
    );
    assert!(
        output.contains("UserService.prototype.createUser"),
        "Expected createUser method: {}",
        output
    );
}

#[test]
fn test_class_es5_di_property_injection() {
    // Test property injection pattern
    let source = r#"
interface Database {
    query(sql: string): any[];
}

class MySQLDatabase implements Database {
    query(sql: string): any[] {
        return [];
    }
}

class Repository {
    public database!: Database;

    findAll(): any[] {
        return this.database.query("SELECT * FROM items");
    }

    findById(id: number): any {
        return this.database.query(`SELECT * FROM items WHERE id = ${id}`)[0];
    }
}

const repo = new Repository();
repo.database = new MySQLDatabase();
repo.findAll();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function MySQLDatabase"),
        "Expected MySQLDatabase function: {}",
        output
    );
    assert!(
        output.contains("function Repository"),
        "Expected Repository function: {}",
        output
    );
    assert!(
        output.contains("Repository.prototype.findAll"),
        "Expected findAll method: {}",
        output
    );
    assert!(
        output.contains("Repository.prototype.findById"),
        "Expected findById method: {}",
        output
    );
    assert!(
        output.contains("repo.database ="),
        "Expected property injection: {}",
        output
    );
}

#[test]
fn test_class_es5_di_factory_pattern() {
    // Test factory pattern for dependency injection
    let source = r#"
interface HttpClient {
    get(url: string): Promise<any>;
    post(url: string, data: any): Promise<any>;
}

class FetchClient implements HttpClient {
    async get(url: string): Promise<any> {
        const response = await fetch(url);
        return response.json();
    }

    async post(url: string, data: any): Promise<any> {
        const response = await fetch(url, {
            method: "POST",
            body: JSON.stringify(data)
        });
        return response.json();
    }
}

class HttpClientFactory {
    private static instance: HttpClient | null = null;

    static create(): HttpClient {
        if (!HttpClientFactory.instance) {
            HttpClientFactory.instance = new FetchClient();
        }
        return HttpClientFactory.instance;
    }

    static reset(): void {
        HttpClientFactory.instance = null;
    }
}

class ApiService {
    private client: HttpClient;

    constructor() {
        this.client = HttpClientFactory.create();
    }

    fetchData(endpoint: string): Promise<any> {
        return this.client.get(endpoint);
    }
}

const apiService = new ApiService();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function FetchClient"),
        "Expected FetchClient function: {}",
        output
    );
    assert!(
        output.contains("function HttpClientFactory"),
        "Expected HttpClientFactory function: {}",
        output
    );
    assert!(
        output.contains("HttpClientFactory.create"),
        "Expected static create method: {}",
        output
    );
    assert!(
        output.contains("HttpClientFactory.reset"),
        "Expected static reset method: {}",
        output
    );
    assert!(
        output.contains("function ApiService"),
        "Expected ApiService function: {}",
        output
    );
}

#[test]
fn test_class_es5_di_singleton_pattern() {
    // Test singleton pattern for dependency injection
    let source = r#"
class ConfigService {
    private static instance: ConfigService;
    private config: Map<string, any> = new Map();

    private constructor() {}

    static getInstance(): ConfigService {
        if (!ConfigService.instance) {
            ConfigService.instance = new ConfigService();
        }
        return ConfigService.instance;
    }

    set(key: string, value: any): void {
        this.config.set(key, value);
    }

    get<T>(key: string): T | undefined {
        return this.config.get(key);
    }

    has(key: string): boolean {
        return this.config.has(key);
    }
}

class AppComponent {
    private config: ConfigService;

    constructor() {
        this.config = ConfigService.getInstance();
    }

    initialize(): void {
        const apiUrl = this.config.get<string>("apiUrl");
        console.log(`Connecting to: ${apiUrl}`);
    }
}

const app = new AppComponent();
app.initialize();
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function ConfigService"),
        "Expected ConfigService function: {}",
        output
    );
    assert!(
        output.contains("ConfigService.getInstance"),
        "Expected static getInstance method: {}",
        output
    );
    assert!(
        output.contains("ConfigService.prototype.set"),
        "Expected set method: {}",
        output
    );
    assert!(
        output.contains("ConfigService.prototype.get"),
        "Expected get method: {}",
        output
    );
    assert!(
        output.contains("function AppComponent"),
        "Expected AppComponent function: {}",
        output
    );
}

#[test]
fn test_class_es5_di_scoped_injection() {
    // Test scoped injection pattern with container
    let source = r#"
type ServiceFactory<T> = () => T;

class Container {
    private services: Map<string, ServiceFactory<any>> = new Map();
    private singletons: Map<string, any> = new Map();

    register<T>(key: string, factory: ServiceFactory<T>): void {
        this.services.set(key, factory);
    }

    registerSingleton<T>(key: string, factory: ServiceFactory<T>): void {
        this.services.set(key, () => {
            if (!this.singletons.has(key)) {
                this.singletons.set(key, factory());
            }
            return this.singletons.get(key);
        });
    }

    resolve<T>(key: string): T {
        const factory = this.services.get(key);
        if (!factory) {
            throw new Error(`Service not found: ${key}`);
        }
        return factory();
    }
}

class EmailService {
    send(to: string, message: string): void {
        console.log(`Email to ${to}: ${message}`);
    }
}

class NotificationService {
    private emailService: EmailService;

    constructor(emailService: EmailService) {
        this.emailService = emailService;
    }

    notify(user: string, message: string): void {
        this.emailService.send(user, message);
    }
}

const container = new Container();
container.registerSingleton("email", () => new EmailService());
container.register("notification", () => new NotificationService(container.resolve("email")));

const notificationService = container.resolve<NotificationService>("notification");
notificationService.notify("user@example.com", "Hello!");
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    assert!(
        output.contains("function Container"),
        "Expected Container function: {}",
        output
    );
    assert!(
        output.contains("Container.prototype.register"),
        "Expected register method: {}",
        output
    );
    assert!(
        output.contains("Container.prototype.registerSingleton"),
        "Expected registerSingleton method: {}",
        output
    );
    assert!(
        output.contains("Container.prototype.resolve"),
        "Expected resolve method: {}",
        output
    );
    assert!(
        output.contains("function EmailService"),
        "Expected EmailService function: {}",
        output
    );
    assert!(
        output.contains("function NotificationService"),
        "Expected NotificationService function: {}",
        output
    );
}

#[test]
fn test_class_es5_di_combined_patterns() {
    // Test combined dependency injection patterns
    let source = r#"
// Interfaces
interface ILogger {
    debug(msg: string): void;
    info(msg: string): void;
    error(msg: string): void;
}

interface ICache<T> {
    get(key: string): T | undefined;
    set(key: string, value: T, ttl?: number): void;
    delete(key: string): void;
}

interface IRepository<T> {
    findById(id: string): Promise<T | null>;
    save(entity: T): Promise<void>;
    delete(id: string): Promise<void>;
}

// Implementations
class ConsoleLogger implements ILogger {
    private prefix: string;

    constructor(prefix: string = "") {
        this.prefix = prefix;
    }

    debug(msg: string): void {
        console.debug(`${this.prefix}[DEBUG] ${msg}`);
    }

    info(msg: string): void {
        console.info(`${this.prefix}[INFO] ${msg}`);
    }

    error(msg: string): void {
        console.error(`${this.prefix}[ERROR] ${msg}`);
    }
}

class MemoryCache<T> implements ICache<T> {
    private cache: Map<string, { value: T; expires: number }> = new Map();

    get(key: string): T | undefined {
        const entry = this.cache.get(key);
        if (!entry) return undefined;
        if (entry.expires < Date.now()) {
            this.cache.delete(key);
            return undefined;
        }
        return entry.value;
    }

    set(key: string, value: T, ttl: number = 60000): void {
        this.cache.set(key, { value, expires: Date.now() + ttl });
    }

    delete(key: string): void {
        this.cache.delete(key);
    }
}

// Base repository with DI
class BaseRepository<T extends { id: string }> implements IRepository<T> {
    protected logger: ILogger;
    protected cache: ICache<T>;

    constructor(logger: ILogger, cache: ICache<T>) {
        this.logger = logger;
        this.cache = cache;
    }

    async findById(id: string): Promise<T | null> {
        this.logger.debug(`Finding entity by id: ${id}`);
        const cached = this.cache.get(id);
        if (cached) {
            this.logger.debug(`Cache hit for id: ${id}`);
            return cached;
        }
        return null;
    }

    async save(entity: T): Promise<void> {
        this.logger.info(`Saving entity: ${entity.id}`);
        this.cache.set(entity.id, entity);
    }

    async delete(id: string): Promise<void> {
        this.logger.info(`Deleting entity: ${id}`);
        this.cache.delete(id);
    }
}

// DI Container
class DIContainer {
    private static instance: DIContainer;
    private factories: Map<string, () => any> = new Map();
    private instances: Map<string, any> = new Map();

    private constructor() {}

    static getInstance(): DIContainer {
        if (!DIContainer.instance) {
            DIContainer.instance = new DIContainer();
        }
        return DIContainer.instance;
    }

    bind<T>(key: string, factory: () => T, singleton: boolean = false): void {
        if (singleton) {
            this.factories.set(key, () => {
                if (!this.instances.has(key)) {
                    this.instances.set(key, factory());
                }
                return this.instances.get(key);
            });
        } else {
            this.factories.set(key, factory);
        }
    }

    get<T>(key: string): T {
        const factory = this.factories.get(key);
        if (!factory) throw new Error(`No binding found for: ${key}`);
        return factory();
    }
}

// Setup container
const container = DIContainer.getInstance();
container.bind<ILogger>("logger", () => new ConsoleLogger("[App] "), true);
container.bind<ICache<any>>("cache", () => new MemoryCache<any>(), true);

// User entity and repository
interface User {
    id: string;
    name: string;
    email: string;
}

class UserRepository extends BaseRepository<User> {
    constructor() {
        super(
            DIContainer.getInstance().get<ILogger>("logger"),
            DIContainer.getInstance().get<ICache<User>>("cache")
        );
    }

    async findByEmail(email: string): Promise<User | null> {
        this.logger.debug(`Finding user by email: ${email}`);
        return null;
    }
}

// Usage
const userRepo = new UserRepository();
userRepo.save({ id: "1", name: "Alice", email: "alice@example.com" });
"#;
    let mut parser = ParserState::new("test.ts".to_string(), source.to_string());
    let root = parser.parse_source_file();

    let mut options = PrinterOptions::default();
    options.target = ScriptTarget::ES5;
    let ctx = EmitContext::with_options(options.clone());
    let transforms = LoweringPass::new(&parser.arena, &ctx).run(root);

    let mut printer = Printer::with_transforms_and_options(&parser.arena, transforms, options);
    printer.set_target_es5(ctx.target_es5);
    printer.set_source_text(source);
    printer.emit(root);

    let output = printer.get_output().to_string();

    // Check implementations
    assert!(
        output.contains("function ConsoleLogger"),
        "Expected ConsoleLogger function: {}",
        output
    );
    assert!(
        output.contains("function MemoryCache"),
        "Expected MemoryCache function: {}",
        output
    );
    assert!(
        output.contains("function BaseRepository"),
        "Expected BaseRepository function: {}",
        output
    );
    assert!(
        output.contains("function DIContainer"),
        "Expected DIContainer function: {}",
        output
    );
    assert!(
        output.contains("function UserRepository"),
        "Expected UserRepository function: {}",
        output
    );

    // Check methods
    assert!(
        output.contains("ConsoleLogger.prototype.debug")
            && output.contains("ConsoleLogger.prototype.info")
            && output.contains("ConsoleLogger.prototype.error"),
        "Expected logger methods: {}",
        output
    );
    assert!(
        output.contains("MemoryCache.prototype.get")
            && output.contains("MemoryCache.prototype.set")
            && output.contains("MemoryCache.prototype.delete"),
        "Expected cache methods: {}",
        output
    );
    assert!(
        output.contains("BaseRepository.prototype.findById")
            && output.contains("BaseRepository.prototype.save")
            && output.contains("BaseRepository.prototype.delete"),
        "Expected repository methods: {}",
        output
    );
    assert!(
        output.contains("DIContainer.getInstance")
            && output.contains("DIContainer.prototype.bind")
            && output.contains("DIContainer.prototype.get"),
        "Expected container methods: {}",
        output
    );

    // Interfaces should be stripped
    assert!(
        !output.contains("interface ILogger")
            && !output.contains("interface ICache")
            && !output.contains("interface IRepository"),
        "Expected interfaces to be stripped: {}",
        output
    );
}
